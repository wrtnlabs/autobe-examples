[{"id":"0199e33b-c418-77bd-ac91-f0afe42d7bf8","type":"userMessage","contents":[{"type":"text","text":"I want to create an e-commerce shopping mall platform.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit.\r\n\r\nHere are the key features I want:\r\n- User registration and login with address management\r\n- Product catalog with categories and search\r\n- Product variants (SKU) with different colors, sizes, options\r\n- Shopping cart and wishlist\r\n- Order placement and payment processing\r\n- Order tracking and shipping status updates\r\n- Product reviews and ratings\r\n- Seller accounts to manage their products\r\n- Inventory management per SKU\r\n- Order history and cancellation/refund requests\r\n- Admin dashboard for order and product management"}],"created_at":"2025-10-14T14:59:28.920Z"},{"type":"analyze","id":"0199e341-b957-720d-af8c-2a75dc801570","instruction":"Focus on e-commerce features with emphasis on inventory management and order processing. User wants simple checkout flow.","prefix":"shoppingMall","roles":[{"name":"guest","description":"Unauthenticated users who can browse products and add items to cart.","kind":"guest"},{"name":"member","description":"Authenticated users who can place orders, manage their profile, and view order history.","kind":"member"},{"name":"seller","description":"Users who can manage their products, inventory, and view sales reports.","kind":"member"},{"name":"admin","description":"System administrators who can manage all users, products, orders, and system settings.","kind":"admin"}],"files":[{"reason":"To provide an overview of the e-commerce platform, including its purpose, target audience, and key features.","filename":"00-toc.md","documentType":"service-overview","outline":["Service Vision","Problem Statement","Target Audience","Core Features","Success Metrics","Implementation Timeline"],"audience":"general","keyQuestions":["What problem does this service solve?","Who are the primary and secondary users?","What are the main competitive advantages?","How will we measure success?","What are the potential risks and mitigation strategies?"],"detailLevel":"high-level overview","relatedDocuments":[],"constraints":["Must include cost-benefit analysis","Focus on mobile-first user experience","Include measurable KPIs and success metrics","Address data privacy and security concerns","Consider scalability for 1M+ users","Include timeline and milestone recommendations"],"content":"# Service Overview for E-commerce Shopping Mall Platform\n\n## Business Model\n\n### Business Justification\nThe e-commerce shopping mall platform aims to provide a seamless and user-friendly online shopping experience. The platform will cater to a wide range of customers, including those looking for everyday essentials, fashion, electronics, and more. The business model is designed to be scalable and adaptable to meet the evolving needs of the market.\n\n### Revenue Strategy\nThe platform will generate revenue through a combination of transaction fees, subscription models, and advertising. Transaction fees will be charged on each successful order, with rates varying based on the product category and seller tier. Subscription models will offer premium features such as advanced analytics, priority customer support, and exclusive promotions. Advertising revenue will be generated through sponsored listings and banner ads.\n\n### Growth Plan\nThe growth plan focuses on acquiring and retaining customers through targeted marketing campaigns, partnerships with influencers and brands, and continuous improvement of the platform's user experience. The platform will also invest in marketing and advertising to drive traffic and increase sales.\n\n### Success Metrics\nThe success of the platform will be measured using key performance indicators (KPIs) such as:\n\n- **Customer Acquisition Cost (CAC)**: The cost of acquiring a new customer.\n- **Customer Lifetime Value (LTV)**: The total revenue generated from a customer over their lifetime.\n- **Conversion Rate**: The percentage of visitors who complete a purchase.\n- **Average Order Value (AOV)**: The average amount spent per order.\n- **Net Promoter Score (NPS)**: A measure of customer loyalty and satisfaction.\n\n## User Roles\n\n### Guest\nUnauthenticated users who can browse products and add items to cart.\n\n### Member\nAuthenticated users who can place orders, manage their profile, and view order history.\n\n### Seller\nUsers who can manage their products, inventory, and view sales reports.\n\n### Admin\nSystem administrators who can manage all users, products, orders, and system settings.\n\n## Core Features\n\n### User Registration and Login\n- Users can register with email and password.\n- Users can log in to access their account.\n- Users can log out to end their session.\n- System maintains user sessions securely.\n- Users can verify their email address.\n- Users can reset forgotten passwords.\n- Users can change their password.\n- Users can revoke access from all devices.\n\n### Product Catalog and Search\n- Products are organized into categories.\n- Users can search for products by name, category, and keywords.\n- Search results are displayed with product images, names, prices, and ratings.\n- Users can filter search results by price, rating, and availability.\n\n### Product Variants\n- Products can have multiple variants based on color, size, and options.\n- Each variant has a unique SKU and inventory level.\n- Users can select variants before adding to cart.\n\n### Shopping Cart and Wishlist\n- Users can add products to their shopping cart.\n- Users can view and edit their shopping cart.\n- Users can save items to their wishlist for future purchase.\n- Users can move items from their wishlist to their shopping cart.\n\n### Order Placement and Payment\n- Users can review their order before placing it.\n- Users can select a shipping address and payment method.\n- System processes payment securely.\n- Users receive an order confirmation email.\n\n### Order Tracking and Shipping\n- Users can track their order status.\n- Users receive shipping updates via email and SMS.\n- Users can view shipping details, including carrier and tracking number.\n\n### Product Reviews and Ratings\n- Users can leave reviews and ratings for products they have purchased.\n- Reviews are displayed on the product page.\n- Users can report inappropriate reviews.\n\n### Seller Account Management\n- Sellers can manage their product listings.\n- Sellers can update inventory levels.\n- Sellers can view sales reports and analytics.\n\n### Inventory Management\n- Sellers can track inventory levels for each SKU.\n- System alerts sellers when inventory is low.\n- Sellers can receive restocking recommendations.\n\n### Order History and Refunds\n- Users can view their order history.\n- Users can request order cancellations or refunds.\n- System processes refund requests and updates order status.\n\n### Admin Dashboard\n- Admins can manage all users, products, orders, and system settings.\n- Admins can view analytics and reports.\n- Admins can resolve customer support issues.\n\n## Success Criteria\n\n### User Satisfaction\n- Achieve a Net Promoter Score (NPS) of 50 or higher.\n- Maintain a customer satisfaction rating of 4.5 stars or higher.\n- Reduce customer support inquiries by 30% within the first year.\n\n### Order Fulfillment\n- Achieve a 99% order fulfillment rate.\n- Reduce order processing time to 24 hours or less.\n- Maintain a 95% on-time delivery rate.\n\n### System Performance\n- Achieve a 99.9% uptime for the platform.\n- Ensure the platform can handle 10,000 concurrent users.\n- Reduce page load times to 2 seconds or less.\n\n### Security and Compliance\n- Achieve a PCI DSS compliance level of 3.2.1.\n- Implement two-factor authentication for all user accounts.\n- Regularly update and patch the platform to address security vulnerabilities.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the core features and user needs for the e-commerce platform before moving on to detailed user flow documentation.","filename":"01-service-overview.md","documentType":"requirement","outline":["Business Model","User Roles","Core Features","Success Criteria"],"audience":"development team","keyQuestions":["What are the primary user roles and their permissions?","What are the core features of the platform?","What are the success criteria for each feature?","How will user data be protected and secured?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must include user authentication and authorization requirements","Must define data models and relationships","Must specify API endpoints and request/response formats","Must include error handling and recovery procedures","Must address performance and scalability requirements"],"content":"# Service Overview for E-commerce Shopping Mall Platform\n\n## Business Model\n\n### Business Justification\nThe e-commerce shopping mall platform aims to provide a seamless and user-friendly online shopping experience. The platform will cater to a wide range of customers, including those looking for everyday essentials, fashion, electronics, and more. The business model is designed to be scalable and adaptable to meet the evolving needs of the market.\n\n### Revenue Strategy\nThe platform will generate revenue through a combination of transaction fees, subscription models, and advertising. Transaction fees will be charged on each successful order, with rates varying based on the product category and seller tier. Subscription models will offer premium features such as advanced analytics, priority customer support, and exclusive promotions. Advertising revenue will be generated through sponsored listings and banner ads.\n\n### Growth Plan\nThe growth plan focuses on acquiring and retaining customers through targeted marketing campaigns, partnerships with influencers and brands, and continuous improvement of the platform's user experience. The platform will also invest in marketing and advertising to drive traffic and increase sales.\n\n### Success Metrics\nThe success of the platform will be measured using key performance indicators (KPIs) such as:\n\n- **Customer Acquisition Cost (CAC)**: The cost of acquiring a new customer.\n- **Customer Lifetime Value (LTV)**: The total revenue generated from a customer over their lifetime.\n- **Conversion Rate**: The percentage of visitors who complete a purchase.\n- **Average Order Value (AOV)**: The average amount spent per order.\n- **Net Promoter Score (NPS)**: A measure of customer loyalty and satisfaction.\n\n## User Roles\n\n### Guest\nUnauthenticated users who can browse products and add items to cart.\n\n### Member\nAuthenticated users who can place orders, manage their profile, and view order history.\n\n### Seller\nUsers who can manage their products, inventory, and view sales reports.\n\n### Admin\nSystem administrators who can manage all users, products, orders, and system settings.\n\n## Core Features\n\n### User Registration and Login\n- Users can register with email and password.\n- Users can log in to access their account.\n- Users can log out to end their session.\n- System maintains user sessions securely.\n- Users can verify their email address.\n- Users can reset forgotten passwords.\n- Users can change their password.\n- Users can revoke access from all devices.\n\n### Product Catalog and Search\n- Products are organized into categories.\n- Users can search for products by name, category, and keywords.\n- Search results are displayed with product images, names, prices, and ratings.\n- Users can filter search results by price, rating, and availability.\n\n### Product Variants\n- Products can have multiple variants based on color, size, and options.\n- Each variant has a unique SKU and inventory level.\n- Users can select variants before adding to cart.\n\n### Shopping Cart and Wishlist\n- Users can add products to their shopping cart.\n- Users can view and edit their shopping cart.\n- Users can save items to their wishlist for future purchase.\n- Users can move items from their wishlist to their shopping cart.\n\n### Order Placement and Payment\n- Users can review their order before placing it.\n- Users can select a shipping address and payment method.\n- System processes payment securely.\n- Users receive an order confirmation email.\n\n### Order Tracking and Shipping\n- Users can track their order status.\n- Users receive shipping updates via email and SMS.\n- Users can view shipping details, including carrier and tracking number.\n\n### Product Reviews and Ratings\n- Users can leave reviews and ratings for products they have purchased.\n- Reviews are displayed on the product page.\n- Users can report inappropriate reviews.\n\n### Seller Account Management\n- Sellers can manage their product listings.\n- Sellers can update inventory levels.\n- Sellers can view sales reports and analytics.\n\n### Inventory Management\n- Sellers can track inventory levels for each SKU.\n- System alerts sellers when inventory is low.\n- Sellers can receive restocking recommendations.\n\n### Order History and Refunds\n- Users can view their order history.\n- Users can request order cancellations or refunds.\n- System processes refund requests and updates order status.\n\n### Admin Dashboard\n- Admins can manage all users, products, orders, and system settings.\n- Admins can view analytics and reports.\n- Admins can resolve customer support issues.\n\n## Success Criteria\n\n### User Satisfaction\n- Achieve a Net Promoter Score (NPS) of 50 or higher.\n- Maintain a customer satisfaction rating of 4.5 stars or higher.\n- Reduce customer support inquiries by 30% within the first year.\n\n### Order Fulfillment\n- Achieve a 99% order fulfillment rate.\n- Reduce order processing time to 24 hours or less.\n- Maintain a 95% on-time delivery rate.\n\n### System Performance\n- Achieve a 99.9% uptime for the platform.\n- Ensure the platform can handle 10,000 concurrent users.\n- Reduce page load times to 2 seconds or less.\n\n### Security and Compliance\n- Achieve a PCI DSS compliance level of 3.2.1.\n- Implement two-factor authentication for all user accounts.\n- Regularly update and patch the platform to address security vulnerabilities.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To outline the user journey and interaction flow for the e-commerce platform, ensuring a seamless experience for all user roles.","filename":"02-user-flow.md","documentType":"user-flow","outline":["User Registration and Login","Product Catalog and Search","Product Details and Variants","Shopping Cart and Wishlist","Order Placement and Payment","Order Tracking and Shipping","Product Reviews and Ratings","Seller Account Management","Inventory Management","Order History and Refunds","Admin Dashboard"],"audience":"development team","keyQuestions":["What is the user journey for each core feature?","How will users interact with the platform?","What are the decision points and branching paths in the user flow?","How will the platform handle errors and exceptions during user interactions?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-service-overview.md"],"constraints":["Must include user authentication and authorization requirements","Must define data models and relationships","Must specify API endpoints and request/response formats","Must include error handling and recovery procedures","Must address performance and scalability requirements"],"content":"# User Flow Documentation for E-commerce Shopping Mall Platform\n\n## User Registration and Login\n\n### User Journey\n\n1. **Guest User**:\n   - Browses the product catalog\n   - Adds items to the cart\n   - Proceeds to checkout\n   - Creates an account during checkout\n   - Logs in to complete the purchase\n\n2. **Registered User**:\n   - Logs in to the platform\n   - Views their profile and order history\n   - Updates their personal information\n   - Manages their addresses\n\n### Interaction Flow\n\n- **Guest User**:\n  - WHEN a guest adds an item to the cart, THE system SHALL prompt them to create an account or log in to proceed to checkout.\n  - WHEN a guest creates an account, THE system SHALL verify their email address and send a confirmation email.\n  - WHEN a guest logs in, THE system SHALL authenticate their credentials and grant access to their account.\n\n- **Registered User**:\n  - WHEN a user logs in, THE system SHALL authenticate their credentials and grant access to their account.\n  - WHEN a user updates their profile, THE system SHALL validate the input and update their information.\n  - WHEN a user manages their addresses, THE system SHALL allow them to add, edit, or delete addresses.\n\n## Product Catalog and Search\n\n### User Journey\n\n1. **Guest User**:\n   - Browses the product catalog\n   - Searches for products using keywords\n   - Filters products by categories, price range, and ratings\n   - Views product details\n\n2. **Registered User**:\n   - Browses the product catalog\n   - Searches for products using keywords\n   - Filters products by categories, price range, and ratings\n   - Views product details\n   - Adds items to the wishlist\n\n### Interaction Flow\n\n- **Guest User**:\n  - WHEN a guest searches for products, THE system SHALL display a list of matching products.\n  - WHEN a guest filters products, THE system SHALL update the list based on the selected criteria.\n  - WHEN a guest views product details, THE system SHALL display the product information, including images, description, and price.\n\n- **Registered User**:\n  - WHEN a user searches for products, THE system SHALL display a list of matching products.\n  - WHEN a user filters products, THE system SHALL update the list based on the selected criteria.\n  - WHEN a user views product details, THE system SHALL display the product information, including images, description, and price.\n  - WHEN a user adds an item to the wishlist, THE system SHALL save the item to their wishlist.\n\n## Product Details and Variants\n\n### User Journey\n\n1. **Guest User**:\n   - Views product details\n   - Selects product variants (SKU) based on color, size, and options\n   - Adds items to the cart\n\n2. **Registered User**:\n   - Views product details\n   - Selects product variants (SKU) based on color, size, and options\n   - Adds items to the cart\n   - Adds items to the wishlist\n\n### Interaction Flow\n\n- **Guest User**:\n  - WHEN a guest views product details, THE system SHALL display the product information, including images, description, and price.\n  - WHEN a guest selects product variants, THE system SHALL update the product information based on the selected options.\n  - WHEN a guest adds an item to the cart, THE system SHALL save the item to their cart.\n\n- **Registered User**:\n  - WHEN a user views product details, THE system SHALL display the product information, including images, description, and price.\n  - WHEN a user selects product variants, THE system SHALL update the product information based on the selected options.\n  - WHEN a user adds an item to the cart, THE system SHALL save the item to their cart.\n  - WHEN a user adds an item to the wishlist, THE system SHALL save the item to their wishlist.\n\n## Shopping Cart and Wishlist\n\n### User Journey\n\n1. **Guest User**:\n   - Adds items to the cart\n   - Views the cart\n   - Updates the quantity of items in the cart\n   - Removes items from the cart\n   - Proceeds to checkout\n\n2. **Registered User**:\n   - Adds items to the cart\n   - Views the cart\n   - Updates the quantity of items in the cart\n   - Removes items from the cart\n   - Proceeds to checkout\n   - Adds items to the wishlist\n   - Views the wishlist\n   - Moves items from the wishlist to the cart\n   - Removes items from the wishlist\n\n### Interaction Flow\n\n- **Guest User**:\n  - WHEN a guest adds an item to the cart, THE system SHALL save the item to their cart.\n  - WHEN a guest views the cart, THE system SHALL display the items in the cart, including the product information, quantity, and total price.\n  - WHEN a guest updates the quantity of items in the cart, THE system SHALL update the total price.\n  - WHEN a guest removes an item from the cart, THE system SHALL remove the item from the cart.\n  - WHEN a guest proceeds to checkout, THE system SHALL prompt them to create an account or log in to complete the purchase.\n\n- **Registered User**:\n  - WHEN a user adds an item to the cart, THE system SHALL save the item to their cart.\n  - WHEN a user views the cart, THE system SHALL display the items in the cart, including the product information, quantity, and total price.\n  - WHEN a user updates the quantity of items in the cart, THE system SHALL update the total price.\n  - WHEN a user removes an item from the cart, THE system SHALL remove the item from the cart.\n  - WHEN a user proceeds to checkout, THE system SHALL redirect them to the checkout page.\n  - WHEN a user adds an item to the wishlist, THE system SHALL save the item to their wishlist.\n  - WHEN a user views the wishlist, THE system SHALL display the items in the wishlist, including the product information.\n  - WHEN a user moves an item from the wishlist to the cart, THE system SHALL remove the item from the wishlist and add it to the cart.\n  - WHEN a user removes an item from the wishlist, THE system SHALL remove the item from the wishlist.\n\n## Order Placement and Payment\n\n### User Journey\n\n1. **Registered User**:\n   - Reviews the items in the cart\n   - Selects a shipping address\n   - Chooses a shipping method\n   - Selects a payment method\n   - Enters payment information\n   - Places the order\n   - Receives an order confirmation\n\n### Interaction Flow\n\n- **Registered User**:\n  - WHEN a user reviews the items in the cart, THE system SHALL display the items, including the product information, quantity, and total price.\n  - WHEN a user selects a shipping address, THE system SHALL save the selected address.\n  - WHEN a user chooses a shipping method, THE system SHALL update the shipping cost and total price.\n  - WHEN a user selects a payment method, THE system SHALL save the selected payment method.\n  - WHEN a user enters payment information, THE system SHALL validate the payment information.\n  - WHEN a user places the order, THE system SHALL process the payment and create the order.\n  - WHEN a user receives an order confirmation, THE system SHALL send an email confirmation to the user.\n\n## Order Tracking and Shipping\n\n### User Journey\n\n1. **Registered User**:\n   - Views their order history\n   - Tracks the shipping status of their order\n   - Receives shipping updates\n   - Confirms the delivery of their order\n\n### Interaction Flow\n\n- **Registered User**:\n  - WHEN a user views their order history, THE system SHALL display the list of their orders, including the order number, date, and status.\n  - WHEN a user tracks the shipping status of their order, THE system SHALL display the shipping status, including the tracking number and estimated delivery date.\n  - WHEN a user receives shipping updates, THE system SHALL send an email notification to the user.\n  - WHEN a user confirms the delivery of their order, THE system SHALL update the order status to \"Delivered\".\n\n## Product Reviews and Ratings\n\n### User Journey\n\n1. **Registered User**:\n   - Views product reviews and ratings\n   - Writes a product review\n   - Rates a product\n   - Edits or deletes their review\n\n### Interaction Flow\n\n- **Registered User**:\n  - WHEN a user views product reviews and ratings, THE system SHALL display the list of reviews, including the user's name, rating, and review text.\n  - WHEN a user writes a product review, THE system SHALL save the review and update the product's average rating.\n  - WHEN a user rates a product, THE system SHALL save the rating and update the product's average rating.\n  - WHEN a user edits or deletes their review, THE system SHALL update the review or remove it from the list.\n\n## Seller Account Management\n\n### User Journey\n\n1. **Seller**:\n   - Logs in to their seller account\n   - Views their product listings\n   - Adds or edits product listings\n   - Manages inventory for their products\n   - Views sales reports\n\n### Interaction Flow\n\n- **Seller**:\n  - WHEN a seller logs in to their seller account, THE system SHALL authenticate their credentials and grant access to their account.\n  - WHEN a seller views their product listings, THE system SHALL display the list of their products, including the product name, price, and inventory level.\n  - WHEN a seller adds or edits a product listing, THE system SHALL save the product information and update the product listing.\n  - WHEN a seller manages inventory for their products, THE system SHALL allow them to update the inventory level for each product.\n  - WHEN a seller views sales reports, THE system SHALL display the sales data, including the number of orders, revenue, and average order value.\n\n## Inventory Management\n\n### User Journey\n\n1. **Seller**:\n   - Views inventory levels for their products\n   - Updates inventory levels\n   - Receives low inventory alerts\n   - Manages stock for product variants (SKU)\n\n### Interaction Flow\n\n- **Seller**:\n  - WHEN a seller views inventory levels for their products, THE system SHALL display the inventory level for each product, including the product name, SKU, and quantity.\n  - WHEN a seller updates inventory levels, THE system SHALL save the updated inventory level and notify the user if the inventory level is low.\n  - WHEN a seller receives low inventory alerts, THE system SHALL send an email notification to the seller.\n  - WHEN a seller manages stock for product variants (SKU), THE system SHALL allow them to update the inventory level for each SKU.\n\n## Order History and Refunds\n\n### User Journey\n\n1. **Registered User**:\n   - Views their order history\n   - Requests a refund for an order\n   - Tracks the status of their refund request\n   - Cancels an order\n\n### Interaction Flow\n\n- **Registered User**:\n  - WHEN a user views their order history, THE system SHALL display the list of their orders, including the order number, date, and status.\n  - WHEN a user requests a refund for an order, THE system SHALL process the refund request and update the order status.\n  - WHEN a user tracks the status of their refund request, THE system SHALL display the status of the refund request.\n  - WHEN a user cancels an order, THE system SHALL cancel the order and update the inventory levels for the products in the order.\n\n## Admin Dashboard\n\n### User Journey\n\n1. **Admin**:\n   - Logs in to the admin dashboard\n   - Views and manages user accounts\n   - Views and manages product listings\n   - Views and manages orders\n   - Manages system settings\n\n### Interaction Flow\n\n- **Admin**:\n  - WHEN an admin logs in to the admin dashboard, THE system SHALL authenticate their credentials and grant access to the dashboard.\n  - WHEN an admin views and manages user accounts, THE system SHALL display the list of user accounts and allow the admin to edit or delete user accounts.\n  - WHEN an admin views and manages product listings, THE system SHALL display the list of product listings and allow the admin to edit or delete product listings.\n  - WHEN an admin views and manages orders, THE system SHALL display the list of orders and allow the admin to update the order status or process refund requests.\n  - WHEN an admin manages system settings, THE system SHALL allow the admin to update the system settings, including payment methods, shipping methods, and tax rates.\n\n## Conclusion\n\nThis document outlines the user journey and interaction flow for the e-commerce shopping mall platform, ensuring a seamless experience for all user roles. The document provides a comprehensive guide for developers on how to implement the platform, including technical specifications and best practices."},{"reason":"To provide a comprehensive guide for developers on how to implement the e-commerce platform, including technical specifications and best practices.","filename":"03-technical-guide.md","documentType":"requirement","outline":["System Architecture","Database Design","API Specifications","Authentication and Authorization","Error Handling","Performance Optimization","Security Considerations","Deployment and Scaling"],"audience":"development team","keyQuestions":["What is the system architecture for the e-commerce platform?","How will data be stored and managed?","What are the API specifications for the platform?","How will user authentication and authorization be implemented?","How will errors be handled and recovered?","What are the performance optimization strategies?","What are the security considerations for the platform?","How will the platform be deployed and scaled?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-service-overview.md","02-user-flow.md"],"constraints":["Must include system architecture and design patterns","Must define database schemas and relationships","Must specify API endpoints and request/response formats","Must include authentication and authorization mechanisms","Must address error handling and recovery procedures","Must include performance optimization techniques","Must address security considerations and best practices","Must include deployment and scaling strategies"],"content":"## Technical Guide for E-commerce Platform\n\n### System Architecture\n\n#### Overview of the System Architecture\n\nThe e-commerce platform will be built using a microservices architecture to ensure scalability, maintainability, and flexibility. The system will consist of the following services:\n\n- **User Service**: Handles user registration, login, and profile management.\n- **Product Service**: Manages product catalog, categories, and search functionality.\n- **Order Service**: Processes order placement, payment, and order tracking.\n- **Inventory Service**: Manages inventory levels and stock updates.\n- **Notification Service**: Sends notifications to users via email and SMS.\n- **Admin Service**: Provides an admin dashboard for managing users, products, and orders.\n\n#### Design Patterns and Best Practices\n\n- **Microservices Architecture**: Each service will be independently deployable and scalable.\n- **API Gateway**: A single entry point for all client requests, handling routing, authentication, and load balancing.\n- **Event-Driven Architecture**: Services will communicate asynchronously using events.\n- **Containerization**: Docker containers for consistent deployment and scaling.\n- **CI/CD Pipeline**: Automated build, test, and deployment processes.\n\n### Database Design\n\n#### Database Schemas and Relationships\n\nThe database will be designed using a relational database management system (RDBMS) to ensure data integrity and consistency. The following schemas will be used:\n\n- **User Schema**: Stores user information, including personal details, addresses, and authentication credentials.\n- **Product Schema**: Stores product information, including name, description, price, and images.\n- **Order Schema**: Stores order details, including order items, shipping address, and payment information.\n- **Inventory Schema**: Stores inventory levels and stock updates.\n- **Notification Schema**: Stores notification templates and user preferences.\n\n#### Data Models and Entity-Relationship Diagrams\n\n```mermaid\nclassDiagram\n    class User {\n        +String \"userId\"\n        +String \"username\"\n        +String \"email\"\n        +String \"password\"\n        +String \"address\"\n        +String \"phone\"\n        +Date \"createdAt\"\n        +Date \"updatedAt\"\n    }\n\n    class Product {\n        +String \"productId\"\n        +String \"name\"\n        +String \"description\"\n        +Double \"price\"\n        +String \"category\"\n        +String \"imageUrl\"\n        +Date \"createdAt\"\n        +Date \"updatedAt\"\n    }\n\n    class Order {\n        +String \"orderId\"\n        +String \"userId\"\n        +String \"status\"\n        +Double \"totalAmount\"\n        +String \"shippingAddress\"\n        +String \"paymentMethod\"\n        +Date \"createdAt\"\n        +Date \"updatedAt\"\n    }\n\n    class OrderItem {\n        +String \"orderItemId\"\n        +String \"orderId\"\n        +String \"productId\"\n        +Integer \"quantity\"\n        +Double \"price\"\n    }\n\n    class Inventory {\n        +String \"inventoryId\"\n        +String \"productId\"\n        +Integer \"stock\"\n        +Date \"lastUpdated\"\n    }\n\n    User \"1\" -- \"0..*\" Order : places\n    Order \"1\" -- \"1..*\" OrderItem : contains\n    Product \"1\" -- \"1\" Inventory : has\n```\n\n### API Specifications\n\n#### API Endpoints and Request/Response Formats\n\nThe API will follow RESTful principles and use JSON for request/response formats. The following endpoints will be available:\n\n- **User Service**:\n  - `POST /api/users/register` - Register a new user.\n  - `POST /api/users/login` - Login a user.\n  - `GET /api/users/{userId}` - Get user details.\n  - `PUT /api/users/{userId}` - Update user details.\n\n- **Product Service**:\n  - `GET /api/products` - Get a list of products.\n  - `GET /api/products/{productId}` - Get product details.\n  - `POST /api/products` - Add a new product.\n  - `PUT /api/products/{productId}` - Update product details.\n  - `DELETE /api/products/{productId}` - Delete a product.\n\n- **Order Service**:\n  - `POST /api/orders` - Place a new order.\n  - `GET /api/orders/{orderId}` - Get order details.\n  - `PUT /api/orders/{orderId}` - Update order status.\n  - `GET /api/orders/user/{userId}` - Get user's order history.\n\n- **Inventory Service**:\n  - `GET /api/inventory/{productId}` - Get inventory levels.\n  - `PUT /api/inventory/{productId}` - Update inventory levels.\n\n#### Authentication and Authorization Requirements\n\n- **JWT Tokens**: JSON Web Tokens for authentication and authorization.\n- **Role-Based Access Control (RBAC)**: Different roles for users, sellers, and admins.\n- **API Gateway**: Handles authentication and authorization for all services.\n\n### Authentication and Authorization\n\n#### User Authentication Mechanisms\n\n- **JWT Tokens**: JSON Web Tokens for authentication and authorization.\n- **OAuth 2.0**: For third-party authentication and authorization.\n- **Password Hashing**: Secure password storage using bcrypt.\n\n#### Role-Based Access Control (RBAC)\n\n- **User Roles**:\n  - **Guest**: Unauthenticated users who can browse products and add items to cart.\n  - **Member**: Authenticated users who can place orders, manage their profile, and view order history.\n  - **Seller**: Users who can manage their products, inventory, and view sales reports.\n  - **Admin**: System administrators who can manage all users, products, orders, and system settings.\n\n#### JWT Token Management\n\n- **Access Tokens**: Short-lived tokens for accessing protected resources.\n- **Refresh Tokens**: Long-lived tokens for obtaining new access tokens.\n- **Token Storage**: Secure storage of tokens in HTTP-only cookies.\n\n### Error Handling\n\n#### Error Handling and Recovery Procedures\n\n- **HTTP Status Codes**: Standard HTTP status codes for error responses.\n- **Error Responses**: JSON error responses with error codes and messages.\n- **Logging and Monitoring**: Centralized logging and monitoring for error tracking.\n\n#### Logging and Monitoring\n\n- **Centralized Logging**: Aggregates logs from all services.\n- **Monitoring**: Real-time monitoring of system performance and health.\n\n### Performance Optimization\n\n#### Performance Optimization Techniques\n\n- **Caching**: Redis for caching frequently accessed data.\n- **Load Balancing**: Distributes traffic across multiple instances.\n- **Database Optimization**: Indexing and query optimization.\n\n#### Caching Strategies\n\n- **Redis**: In-memory data store for caching.\n- **Cache Invalidation**: Strategies for cache invalidation.\n\n#### Load Balancing and Scaling\n\n- **Horizontal Scaling**: Adds more instances to handle increased load.\n- **Vertical Scaling**: Increases resources for existing instances.\n\n### Security Considerations\n\n#### Security Best Practices\n\n- **Data Encryption**: Encrypts sensitive data at rest and in transit.\n- **Secure Authentication**: Secure authentication mechanisms.\n- **Input Validation**: Validates all user inputs to prevent injection attacks.\n\n#### Data Protection and Encryption\n\n- **Encryption**: Encrypts sensitive data using AES-256.\n- **Secure Storage**: Secure storage of sensitive data.\n\n#### Compliance and Regulations\n\n- **GDPR**: Compliance with GDPR regulations.\n- **PCI DSS**: Compliance with PCI DSS regulations.\n\n### Deployment and Scaling\n\n#### Deployment Strategies\n\n- **Containerization**: Docker containers for consistent deployment.\n- **Orchestration**: Kubernetes for container orchestration.\n- **CI/CD Pipeline**: Automated build, test, and deployment processes.\n\n#### Scaling and Load Balancing\n\n- **Horizontal Scaling**: Adds more instances to handle increased load.\n- **Vertical Scaling**: Increases resources for existing instances.\n\n#### Monitoring and Maintenance\n\n- **Centralized Logging**: Aggregates logs from all services.\n- **Monitoring**: Real-time monitoring of system performance and health.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"}],"created_at":"2025-10-14T14:59:29.966Z","completed_at":"2025-10-14T15:05:59.383Z","step":0},{"id":"0199e341-b9a4-70bc-ae6b-cc5e1f2bdc47","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-10-14T15:05:59.460Z"},{"type":"prisma","id":"0199e342-a669-754f-8447-cc49a316bfcf","instruction":"Design flexible product catalog with variant support","schemas":{"schema-01-systematic.prisma":"/// Represents the shopping channels available in the system. Each channel\n/// has a unique code and name, and is associated with a specific mall.\n/// Channels are the top-level organizational units for products and\n/// services.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channels {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Unique code identifying the channel.\n  code String\n  \n  /// Name of the channel.\n  name String\n  \n  /// Description of the channel.\n  description String?\n  \n  /// Timestamp when the channel was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the channel was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the channel was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_sections shopping_sections[]\n  shopping_configurations shopping_configurations[]\n  shopping_sales shopping_sales[]\n  shopping_articles shopping_articles[]\n  \n  @@unique([code])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the sections within a shopping channel. Each section has a\n/// unique code and name, and is associated with a specific channel. Sections\n/// help organize products and services within a channel.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sections {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The channel to which this section belongs. {@link shopping_channels.id}\n  shopping_channel_id String @db.Uuid\n  \n  /// Unique code identifying the section.\n  code String\n  \n  /// Name of the section.\n  name String\n  \n  /// Description of the section.\n  description String?\n  \n  /// Timestamp when the section was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the section was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the section was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  \n  shopping_configurations shopping_configurations[]\n  shopping_sales shopping_sales[]\n  shopping_articles shopping_articles[]\n  \n  @@unique([shopping_channel_id, code])\n  @@index([shopping_channel_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the configurations for a shopping channel or section. Each\n/// configuration has a unique key and value, and is associated with a\n/// specific channel or section. Configurations define system behavior and\n/// settings for different parts of the system.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_configurations {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The channel to which this configuration belongs. {@link\n  /// shopping_channels.id}\n  shopping_channel_id String? @db.Uuid\n  \n  /// The section to which this configuration belongs. {@link\n  /// shopping_sections.id}\n  shopping_section_id String? @db.Uuid\n  \n  /// Unique key identifying the configuration.\n  key String\n  \n  /// Value of the configuration.\n  value String\n  \n  /// Description of the configuration.\n  description String?\n  \n  /// Timestamp when the configuration was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the configuration was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the configuration was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels? @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections? @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_channel_id, key])\n  @@unique([shopping_section_id, key])\n  @@index([shopping_channel_id])\n  @@index([shopping_section_id])\n  @@index([key(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-02-actors.prisma":"/// Represents unauthenticated users who can browse products and add items to\n/// cart.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Unique identifier for the guest session.\n  session_id String @db.Uuid\n  \n  /// Timestamp when the guest record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the guest record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([session_id])\n  @@index([created_at])\n}\n\n/// Represents authenticated users who can place orders, manage their\n/// profile, and view order history.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_member {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Email address of the member.\n  email String\n  \n  /// Hashed password for authentication.\n  password_hash String\n  \n  /// Full name of the member.\n  name String\n  \n  /// Phone number of the member.\n  phone String?\n  \n  /// Shipping address of the member.\n  address String?\n  \n  /// Timestamp when the member record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the member record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the member record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_carts shopping_carts[]\n  shopping_orders shopping_orders[]\n  shopping_coupon_usage shopping_coupon_usage[]\n  shopping_coins shopping_coins?\n  shopping_coin_transactions shopping_coin_transactions[]\n  shopping_inquiries shopping_inquiries[]\n  shopping_favorites shopping_favorites[]\n  shopping_article_comments shopping_article_comments[]\n  \n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents users who can manage their products, inventory, and view sales\n/// reports.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_seller {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Email address of the seller.\n  email String\n  \n  /// Hashed password for authentication.\n  password_hash String\n  \n  /// Full name of the seller.\n  name String\n  \n  /// Phone number of the seller.\n  phone String?\n  \n  /// Business name of the seller.\n  business_name String\n  \n  /// Business address of the seller.\n  business_address String\n  \n  /// Timestamp when the seller record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([business_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents system administrators who can manage all users, products,\n/// orders, and system settings.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Email address of the admin.\n  email String\n  \n  /// Hashed password for authentication.\n  password_hash String\n  \n  /// Full name of the admin.\n  name String\n  \n  /// Phone number of the admin.\n  phone String?\n  \n  /// Role of the admin (e.g., superadmin, moderator).\n  role String\n  \n  /// Timestamp when the admin record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the admin record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the admin record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_inquiry_responses shopping_inquiry_responses[]\n  \n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-03-sales.prisma":"/// Main sales entity representing product offerings in the shopping mall.\n/// This table captures all essential information about products available\n/// for purchase, including pricing, availability, and basic attributes. It\n/// serves as the primary reference for all sales-related operations.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sales {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged channel's {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n  \n  /// Belonged section's {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n  \n  /// Unique business identifier for the sale.\n  code String\n  \n  /// Display name of the sale.\n  name String\n  \n  /// Detailed description of the sale.\n  description String?\n  \n  /// Current price of the sale.\n  price Float @db.DoublePrecision\n  \n  /// Current inventory stock level.\n  stock Int @db.Integer\n  \n  /// Timestamp when the sale was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n  \n  shopping_sale_snapshots shopping_sale_snapshots[]\n  shopping_sale_units shopping_sale_units[]\n  \n  @@index([shopping_section_id])\n  \n  @@unique([code])\n  @@index([shopping_channel_id, shopping_section_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Historical snapshots of shopping_sales for audit trails and version\n/// control. This table captures point-in-time states of sales entities,\n/// allowing for complete historical tracking of all changes to product\n/// offerings. Each snapshot represents a complete state of a sale at a\n/// specific moment in time.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged sale's {@link shopping_sales.id}.\n  shopping_sale_id String @db.Uuid\n  \n  /// Unique business identifier for the sale at this snapshot.\n  code String\n  \n  /// Display name of the sale at this snapshot.\n  name String\n  \n  /// Detailed description of the sale at this snapshot.\n  description String?\n  \n  /// Price of the sale at this snapshot.\n  price Float @db.DoublePrecision\n  \n  /// Inventory stock level at this snapshot.\n  stock Int @db.Integer\n  \n  /// Timestamp when this snapshot was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  sale shopping_sales @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_sale_id, created_at])\n}\n\n/// Product variants for sales entities. This table represents different\n/// versions or options of a product offering, allowing for flexible product\n/// configurations and customization. Each unit belongs to a specific sale\n/// and has its own unique attributes and pricing.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_units {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged sale's {@link shopping_sales.id}.\n  shopping_sale_id String @db.Uuid\n  \n  /// Unique business identifier for the sale unit.\n  code String\n  \n  /// Display name of the sale unit.\n  name String\n  \n  /// Detailed description of the sale unit.\n  description String?\n  \n  /// Price of the sale unit.\n  price Float @db.DoublePrecision\n  \n  /// Inventory stock level of the sale unit.\n  stock Int @db.Integer\n  \n  /// Timestamp when the sale unit was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale unit was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale unit was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  sale shopping_sales @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)\n  \n  shopping_sale_unit_options shopping_sale_unit_options[]\n  shopping_cart_items shopping_cart_items[]\n  shopping_favorite_items shopping_favorite_items[]\n  \n  @@unique([shopping_sale_id, code])\n  @@index([shopping_sale_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Customizable options for sale units. This table represents additional\n/// configuration choices that can be made for product variants, allowing\n/// customers to personalize their purchases. Each option belongs to a\n/// specific sale unit and has its own unique attributes and pricing.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_unit_options {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged sale unit's {@link shopping_sale_units.id}.\n  shopping_sale_unit_id String @db.Uuid\n  \n  /// Unique business identifier for the sale unit option.\n  code String\n  \n  /// Display name of the sale unit option.\n  name String\n  \n  /// Detailed description of the sale unit option.\n  description String?\n  \n  /// Price of the sale unit option.\n  price Float @db.DoublePrecision\n  \n  /// Timestamp when the sale unit option was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale unit option was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the sale unit option was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_sale_unit_id, code])\n  @@index([shopping_sale_unit_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-04-carts.prisma":"/// Shopping carts represent temporary holding areas for items that users\n/// intend to purchase. Each cart is associated with a specific user and\n/// contains multiple cart items. The cart system supports session-based\n/// interactions, allowing users to accumulate items before proceeding to\n/// checkout. The cart maintains temporal fields for tracking creation and\n/// updates, and includes a status field to manage its lifecycle.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_carts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Status of the shopping cart.\n  status String\n  \n  /// Creation timestamp of the shopping cart.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last update timestamp of the shopping cart.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  shopping_cart_items shopping_cart_items[]\n  \n  @@index([shopping_mall_member_id])\n}\n\n/// Shopping cart items represent individual products or product variants\n/// that users have added to their shopping carts. Each cart item is\n/// associated with a specific cart and product variant, and includes details\n/// such as quantity and price. The cart item system supports session-based\n/// interactions, allowing users to manage their selections before checkout.\n/// The cart item maintains temporal fields for tracking creation and\n/// updates.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_cart_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged cart's {@link shopping_carts.id}.\n  shopping_cart_id String @db.Uuid\n  \n  /// Belonged sale unit's {@link shopping_sale_units.id}.\n  shopping_sale_unit_id String @db.Uuid\n  \n  /// Quantity of the product variant in the cart.\n  quantity Int @db.Integer\n  \n  /// Price of the product variant at the time of adding to the cart.\n  price Float @db.DoublePrecision\n  \n  /// Creation timestamp of the cart item.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last update timestamp of the cart item.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  cart shopping_carts @relation(fields: [shopping_cart_id], references: [id], onDelete: Cascade)\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_cart_id])\n  @@index([shopping_sale_unit_id])\n}","schema-05-orders.prisma":"/// Primary table for managing customer orders. This table captures all\n/// essential order information including customer details, order status, and\n/// total amount. It serves as the central entity for order processing and\n/// tracking.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the customer who placed the order. {@link\n  /// shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Unique order code for tracking and reference purposes.\n  code String\n  \n  /// Current status of the order (e.g., pending, processing, shipped,\n  /// delivered).\n  status String\n  \n  /// Total amount of the order including all items and taxes.\n  total_amount Float @db.DoublePrecision\n  \n  /// Shipping address for the order.\n  shipping_address String\n  \n  /// Payment method used for the order (e.g., credit card, PayPal).\n  payment_method String\n  \n  /// Timestamp when the order was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  shopping_order_snapshots shopping_order_snapshots[]\n  shopping_order_items shopping_order_items[]\n  shopping_coin_transactions shopping_coin_transactions[]\n  \n  @@unique([code])\n  @@index([shopping_mall_member_id, created_at])\n}\n\n/// Table for capturing historical states of orders for audit trails and\n/// version control. This table records all changes to order information over\n/// time, allowing for comprehensive tracking and analysis.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the order being snapshotted. {@link shopping_orders.id}\n  shopping_order_id String @db.Uuid\n  \n  /// Unique order code for tracking and reference purposes.\n  code String\n  \n  /// Status of the order at the time of the snapshot.\n  status String\n  \n  /// Total amount of the order including all items and taxes.\n  total_amount Float @db.DoublePrecision\n  \n  /// Shipping address for the order.\n  shipping_address String\n  \n  /// Payment method used for the order.\n  payment_method String\n  \n  /// Timestamp when the snapshot was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id, created_at])\n}\n\n/// Table for managing items within each order. This table captures detailed\n/// information about each item in the order, including quantity, price, and\n/// product details.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the order that contains this item. {@link shopping_orders.id}\n  shopping_order_id String @db.Uuid\n  \n  /// Unique identifier for the product.\n  product_id String @db.Uuid\n  \n  /// Quantity of the product ordered.\n  quantity Int @db.Integer\n  \n  /// Price of the product at the time of order.\n  price Float @db.DoublePrecision\n  \n  /// Timestamp when the order item was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order item was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id])\n}","schema-06-coupons.prisma":"/// Coupon definitions for promotional discounts. Represents available\n/// coupons that can be applied to orders.\n///\n/// @namespace Coupons\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coupons {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Unique coupon code for redemption.\n  code String\n  \n  /// Type of discount (percentage or fixed amount).\n  discount_type String\n  \n  /// Discount value (percentage or fixed amount).\n  value Float @db.DoublePrecision\n  \n  /// Start date when the coupon becomes valid.\n  valid_from DateTime @db.Timestamptz\n  \n  /// End date when the coupon expires.\n  valid_until DateTime @db.Timestamptz\n  \n  /// Maximum number of times the coupon can be used.\n  max_uses Int? @db.Integer\n  \n  /// Timestamp when the coupon was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the coupon was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_coupon_usage shopping_coupon_usage[]\n  \n  @@unique([code])\n  @@index([valid_from])\n  @@index([valid_until])\n}\n\n/// Records of coupon usage by users. Tracks each application of a coupon to\n/// an order.\n///\n/// @namespace Coupons\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coupon_usage {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Coupon that was used. {@link shopping_coupons.id}\n  shopping_coupon_id String @db.Uuid\n  \n  /// User who applied the coupon. {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Order to which the coupon was applied.\n  order_id String @db.Uuid\n  \n  /// Timestamp when the coupon was used.\n  used_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the usage record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the usage record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  coupon shopping_coupons @relation(fields: [shopping_coupon_id], references: [id], onDelete: Cascade)\n  user shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_coupon_id])\n  @@index([shopping_mall_member_id])\n  @@index([used_at])\n}","schema-07-coins.prisma":"/// Tracks user coin balances and financial information. Represents the\n/// current state of a user's coin account.\n///\n/// @namespace Coins\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Current coin balance.\n  balance Float @db.DoublePrecision\n  \n  /// When the coin account was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the coin account was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the coin account was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_mall_member_id])\n  @@index([balance])\n}\n\n/// Records all financial activities related to coin usage. Captures every\n/// transaction for audit and tracking purposes.\n///\n/// @namespace Coins\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coin_transactions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Belonged order's {@link shopping_orders.id}.\n  shopping_order_id String? @db.Uuid\n  \n  /// Amount of coins involved in the transaction.\n  amount Float @db.DoublePrecision\n  \n  /// Type of transaction (e.g., 'purchase', 'refund', 'earn').\n  transaction_type String\n  \n  /// Description of the transaction.\n  description String?\n  \n  /// When the transaction occurred.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  order shopping_orders? @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_mall_member_id])\n  @@index([shopping_order_id])\n  @@index([transaction_type])\n  @@index([created_at])\n}","schema-08-inquiries.prisma":"/// Customer inquiries for support or information. Represents the initial\n/// contact point for customer service interactions. {@link\n/// shopping_mall_member} for the customer who created the inquiry.\n///\n/// @namespace Inquiries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inquiries {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Customer who created the inquiry. {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Title of the inquiry.\n  title String\n  \n  /// Detailed content of the inquiry.\n  content String\n  \n  /// Current status of the inquiry (e.g., 'open', 'in-progress', 'resolved').\n  status String\n  \n  /// When the inquiry was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the inquiry was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the inquiry was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  customer shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  shopping_inquiry_responses shopping_inquiry_responses[]\n  \n  @@index([shopping_mall_member_id, created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Responses to customer inquiries. Represents support activities and\n/// resolutions. {@link shopping_inquiries} for the inquiry being responded\n/// to. {@link shopping_mall_admin} for the admin who responded.\n///\n/// @namespace Inquiries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inquiry_responses {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Inquiry being responded to. {@link shopping_inquiries.id}\n  shopping_inquiry_id String @db.Uuid\n  \n  /// Admin who created the response. {@link shopping_mall_admin.id}\n  shopping_mall_admin_id String @db.Uuid\n  \n  /// Content of the response.\n  content String\n  \n  /// When the response was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the response was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the response was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  inquiry shopping_inquiries @relation(fields: [shopping_inquiry_id], references: [id], onDelete: Cascade)\n  admin shopping_mall_admin @relation(fields: [shopping_mall_admin_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_mall_admin_id])\n  \n  @@index([shopping_inquiry_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-09-favorites.prisma":"/// User preference management for favorite items. Represents a user's\n/// collection of favorite items across different products. {@link\n/// shopping_mall_member.id}\n///\n/// @namespace Favorites\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_favorites {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged member's {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Name of the favorite collection.\n  name String\n  \n  /// Description of the favorite collection.\n  description String?\n  \n  /// When the favorite collection was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the favorite collection was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the favorite collection was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  shopping_favorite_items shopping_favorite_items[]\n  \n  @@unique([shopping_mall_member_id, name])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Favorite items within a user's favorite collection. Represents individual\n/// items that a user has marked as favorites within their collections.\n/// {@link shopping_favorites.id} {@link shopping_sale_units.id}\n///\n/// @namespace Favorites\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_favorite_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged favorite collection's {@link shopping_favorites.id}\n  shopping_favorite_id String @db.Uuid\n  \n  /// Belonged sale unit's {@link shopping_sale_units.id}\n  shopping_sale_unit_id String @db.Uuid\n  \n  /// When the favorite item was added to the collection.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  favorite shopping_favorites @relation(fields: [shopping_favorite_id], references: [id], onDelete: Cascade)\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_sale_unit_id])\n  \n  @@unique([shopping_favorite_id, shopping_sale_unit_id], map: \"shopping_favorite_items_shopping_favorite_id_shopping__85380852\")\n  @@index([created_at])\n}","schema-10-articles.prisma":"/// Represents articles in the shopping mall. This table stores information\n/// about articles that are displayed in the shopping mall. The articles can\n/// be categorized and have various attributes such as title, content, and\n/// status. The table also includes temporal fields for tracking creation,\n/// updates, and deletion times.\n///\n/// @namespace Articles\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_articles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged channel's {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n  \n  /// Belonged section's {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n  \n  /// Article code.\n  code String\n  \n  /// Article title.\n  title String\n  \n  /// Article content.\n  content String\n  \n  /// Article status.\n  status String\n  \n  /// When the article was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the article was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the article was deleted.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n  \n  shopping_article_comments shopping_article_comments[]\n  \n  @@index([shopping_section_id])\n  \n  @@unique([code])\n  @@index([shopping_channel_id, shopping_section_id])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents comments on articles in the shopping mall. This table stores\n/// information about comments made on articles. Each comment is associated\n/// with a specific article and a user. The table includes temporal fields\n/// for tracking creation, updates, and deletion times.\n///\n/// @namespace Articles\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_article_comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged article's {@link shopping_articles.id}.\n  shopping_article_id String @db.Uuid\n  \n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n  \n  /// Comment content.\n  content String\n  \n  /// When the comment was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the comment was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// When the comment was deleted.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  article shopping_articles @relation(fields: [shopping_article_id], references: [id], onDelete: Cascade)\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_mall_member_id])\n  \n  @@index([shopping_article_id])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-systematic.prisma","namespace":"Systematic","models":[{"name":"shopping_channels","description":"Represents the shopping channels available in the system. Each channel has a unique code and name, and is associated with a specific mall. Channels are the top-level organizational units for products and services.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"code","type":"string","description":"Unique code identifying the channel.","nullable":false},{"name":"name","type":"string","description":"Name of the channel.","nullable":false},{"name":"description","type":"string","description":"Description of the channel.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the channel was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the channel was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the channel was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_sections","description":"Represents the sections within a shopping channel. Each section has a unique code and name, and is associated with a specific channel. Sections help organize products and services within a channel.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"The channel to which this section belongs. {@link shopping_channels.id}","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique code identifying the section.","nullable":false},{"name":"name","type":"string","description":"Name of the section.","nullable":false},{"name":"description","type":"string","description":"Description of the section.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the section was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the section was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the section was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_channel_id","code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_configurations","description":"Represents the configurations for a shopping channel or section. Each configuration has a unique key and value, and is associated with a specific channel or section. Configurations define system behavior and settings for different parts of the system.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"The channel to which this configuration belongs. {@link shopping_channels.id}","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":true},{"name":"shopping_section_id","type":"uuid","description":"The section to which this configuration belongs. {@link shopping_sections.id}","relation":{"name":"section","targetModel":"shopping_sections"},"unique":false,"nullable":true}],"plainFields":[{"name":"key","type":"string","description":"Unique key identifying the configuration.","nullable":false},{"name":"value","type":"string","description":"Value of the configuration.","nullable":false},{"name":"description","type":"string","description":"Description of the configuration.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the configuration was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the configuration was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the configuration was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_channel_id","key"],"unique":true},{"fieldNames":["shopping_section_id","key"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id"]},{"fieldNames":["shopping_section_id"]}],"ginIndexes":[{"fieldName":"key"}]}]},{"filename":"schema-02-actors.prisma","namespace":"Actors","models":[{"name":"shopping_mall_guest","description":"Represents unauthenticated users who can browse products and add items to cart.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"session_id","type":"uuid","description":"Unique identifier for the guest session.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the guest record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the guest record was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["session_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"shopping_mall_member","description":"Represents authenticated users who can place orders, manage their profile, and view order history.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Email address of the member.","nullable":false},{"name":"password_hash","type":"string","description":"Hashed password for authentication.","nullable":false},{"name":"name","type":"string","description":"Full name of the member.","nullable":false},{"name":"phone","type":"string","description":"Phone number of the member.","nullable":true},{"name":"address","type":"string","description":"Shipping address of the member.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the member record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the member record was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the member record was soft deleted.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_mall_seller","description":"Represents users who can manage their products, inventory, and view sales reports.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Email address of the seller.","nullable":false},{"name":"password_hash","type":"string","description":"Hashed password for authentication.","nullable":false},{"name":"name","type":"string","description":"Full name of the seller.","nullable":false},{"name":"phone","type":"string","description":"Phone number of the seller.","nullable":true},{"name":"business_name","type":"string","description":"Business name of the seller.","nullable":false},{"name":"business_address","type":"string","description":"Business address of the seller.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the seller record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the seller record was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the seller record was soft deleted.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"name"},{"fieldName":"business_name"}]},{"name":"shopping_mall_admin","description":"Represents system administrators who can manage all users, products, orders, and system settings.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Email address of the admin.","nullable":false},{"name":"password_hash","type":"string","description":"Hashed password for authentication.","nullable":false},{"name":"name","type":"string","description":"Full name of the admin.","nullable":false},{"name":"phone","type":"string","description":"Phone number of the admin.","nullable":true},{"name":"role","type":"string","description":"Role of the admin (e.g., superadmin, moderator).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the admin record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the admin record was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the admin record was soft deleted.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"name"}]}]},{"filename":"schema-03-sales.prisma","namespace":"Sales","models":[{"name":"shopping_sales","description":"Main sales entity representing product offerings in the shopping mall. This table captures all essential information about products available for purchase, including pricing, availability, and basic attributes. It serves as the primary reference for all sales-related operations.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"Belonged channel's {@link shopping_channels.id}.","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":false},{"name":"shopping_section_id","type":"uuid","description":"Belonged section's {@link shopping_sections.id}.","relation":{"name":"section","targetModel":"shopping_sections"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique business identifier for the sale.","nullable":false},{"name":"name","type":"string","description":"Display name of the sale.","nullable":false},{"name":"description","type":"string","description":"Detailed description of the sale.","nullable":true},{"name":"price","type":"double","description":"Current price of the sale.","nullable":false},{"name":"stock","type":"int","description":"Current inventory stock level.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the sale was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the sale was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the sale was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id","shopping_section_id"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_sale_snapshots","description":"Historical snapshots of shopping_sales for audit trails and version control. This table captures point-in-time states of sales entities, allowing for complete historical tracking of all changes to product offerings. Each snapshot represents a complete state of a sale at a specific moment in time.","material":false,"stance":"snapshot","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_sale_id","type":"uuid","description":"Belonged sale's {@link shopping_sales.id}.","relation":{"name":"sale","targetModel":"shopping_sales"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique business identifier for the sale at this snapshot.","nullable":false},{"name":"name","type":"string","description":"Display name of the sale at this snapshot.","nullable":false},{"name":"description","type":"string","description":"Detailed description of the sale at this snapshot.","nullable":true},{"name":"price","type":"double","description":"Price of the sale at this snapshot.","nullable":false},{"name":"stock","type":"int","description":"Inventory stock level at this snapshot.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when this snapshot was created.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_sale_id","created_at"]}],"ginIndexes":[]},{"name":"shopping_sale_units","description":"Product variants for sales entities. This table represents different versions or options of a product offering, allowing for flexible product configurations and customization. Each unit belongs to a specific sale and has its own unique attributes and pricing.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_sale_id","type":"uuid","description":"Belonged sale's {@link shopping_sales.id}.","relation":{"name":"sale","targetModel":"shopping_sales"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique business identifier for the sale unit.","nullable":false},{"name":"name","type":"string","description":"Display name of the sale unit.","nullable":false},{"name":"description","type":"string","description":"Detailed description of the sale unit.","nullable":true},{"name":"price","type":"double","description":"Price of the sale unit.","nullable":false},{"name":"stock","type":"int","description":"Inventory stock level of the sale unit.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the sale unit was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the sale unit was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the sale unit was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_sale_id","code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_sale_id"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_sale_unit_options","description":"Customizable options for sale units. This table represents additional configuration choices that can be made for product variants, allowing customers to personalize their purchases. Each option belongs to a specific sale unit and has its own unique attributes and pricing.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_sale_unit_id","type":"uuid","description":"Belonged sale unit's {@link shopping_sale_units.id}.","relation":{"name":"saleUnit","targetModel":"shopping_sale_units"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique business identifier for the sale unit option.","nullable":false},{"name":"name","type":"string","description":"Display name of the sale unit option.","nullable":false},{"name":"description","type":"string","description":"Detailed description of the sale unit option.","nullable":true},{"name":"price","type":"double","description":"Price of the sale unit option.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the sale unit option was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the sale unit option was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the sale unit option was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_sale_unit_id","code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_sale_unit_id"]}],"ginIndexes":[{"fieldName":"name"}]}]},{"filename":"schema-04-carts.prisma","namespace":"Carts","models":[{"name":"shopping_carts","description":"Shopping carts represent temporary holding areas for items that users intend to purchase. Each cart is associated with a specific user and contains multiple cart items. The cart system supports session-based interactions, allowing users to accumulate items before proceeding to checkout. The cart maintains temporal fields for tracking creation and updates, and includes a status field to manage its lifecycle.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Belonged member's {@link shopping_mall_member.id}.","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"status","type":"string","description":"Status of the shopping cart.","nullable":false},{"name":"created_at","type":"datetime","description":"Creation timestamp of the shopping cart.","nullable":false},{"name":"updated_at","type":"datetime","description":"Last update timestamp of the shopping cart.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_mall_member_id"]}],"ginIndexes":[]},{"name":"shopping_cart_items","description":"Shopping cart items represent individual products or product variants that users have added to their shopping carts. Each cart item is associated with a specific cart and product variant, and includes details such as quantity and price. The cart item system supports session-based interactions, allowing users to manage their selections before checkout. The cart item maintains temporal fields for tracking creation and updates.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_cart_id","type":"uuid","description":"Belonged cart's {@link shopping_carts.id}.","relation":{"name":"cart","targetModel":"shopping_carts"},"unique":false,"nullable":false},{"name":"shopping_sale_unit_id","type":"uuid","description":"Belonged sale unit's {@link shopping_sale_units.id}.","relation":{"name":"saleUnit","targetModel":"shopping_sale_units"},"unique":false,"nullable":false}],"plainFields":[{"name":"quantity","type":"int","description":"Quantity of the product variant in the cart.","nullable":false},{"name":"price","type":"double","description":"Price of the product variant at the time of adding to the cart.","nullable":false},{"name":"created_at","type":"datetime","description":"Creation timestamp of the cart item.","nullable":false},{"name":"updated_at","type":"datetime","description":"Last update timestamp of the cart item.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_cart_id"]},{"fieldNames":["shopping_sale_unit_id"]}],"ginIndexes":[]}]},{"filename":"schema-05-orders.prisma","namespace":"Orders","models":[{"name":"shopping_orders","description":"Primary table for managing customer orders. This table captures all essential order information including customer details, order status, and total amount. It serves as the central entity for order processing and tracking.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Reference to the customer who placed the order. {@link shopping_mall_member.id}","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique order code for tracking and reference purposes.","nullable":false},{"name":"status","type":"string","description":"Current status of the order (e.g., pending, processing, shipped, delivered).","nullable":false},{"name":"total_amount","type":"double","description":"Total amount of the order including all items and taxes.","nullable":false},{"name":"shipping_address","type":"string","description":"Shipping address for the order.","nullable":false},{"name":"payment_method","type":"string","description":"Payment method used for the order (e.g., credit card, PayPal).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the order was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the order was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the order was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_mall_member_id","created_at"]}],"ginIndexes":[]},{"name":"shopping_order_snapshots","description":"Table for capturing historical states of orders for audit trails and version control. This table records all changes to order information over time, allowing for comprehensive tracking and analysis.","material":false,"stance":"snapshot","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"Reference to the order being snapshotted. {@link shopping_orders.id}","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Unique order code for tracking and reference purposes.","nullable":false},{"name":"status","type":"string","description":"Status of the order at the time of the snapshot.","nullable":false},{"name":"total_amount","type":"double","description":"Total amount of the order including all items and taxes.","nullable":false},{"name":"shipping_address","type":"string","description":"Shipping address for the order.","nullable":false},{"name":"payment_method","type":"string","description":"Payment method used for the order.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the snapshot was created.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_order_id","created_at"]}],"ginIndexes":[]},{"name":"shopping_order_items","description":"Table for managing items within each order. This table captures detailed information about each item in the order, including quantity, price, and product details.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"Reference to the order that contains this item. {@link shopping_orders.id}","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"product_id","type":"uuid","description":"Unique identifier for the product.","nullable":false},{"name":"quantity","type":"int","description":"Quantity of the product ordered.","nullable":false},{"name":"price","type":"double","description":"Price of the product at the time of order.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the order item was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the order item was last updated.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_order_id"]}],"ginIndexes":[]}]},{"filename":"schema-06-coupons.prisma","namespace":"Coupons","models":[{"name":"shopping_coupons","description":"Coupon definitions for promotional discounts. Represents available coupons that can be applied to orders.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"code","type":"string","description":"Unique coupon code for redemption.","nullable":false},{"name":"discount_type","type":"string","description":"Type of discount (percentage or fixed amount).","nullable":false},{"name":"value","type":"double","description":"Discount value (percentage or fixed amount).","nullable":false},{"name":"valid_from","type":"datetime","description":"Start date when the coupon becomes valid.","nullable":false},{"name":"valid_until","type":"datetime","description":"End date when the coupon expires.","nullable":false},{"name":"max_uses","type":"int","description":"Maximum number of times the coupon can be used.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the coupon was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the coupon was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[{"fieldNames":["valid_from"]},{"fieldNames":["valid_until"]}],"ginIndexes":[]},{"name":"shopping_coupon_usage","description":"Records of coupon usage by users. Tracks each application of a coupon to an order.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_coupon_id","type":"uuid","description":"Coupon that was used. {@link shopping_coupons.id}","relation":{"name":"coupon","targetModel":"shopping_coupons"},"unique":false,"nullable":false},{"name":"shopping_mall_member_id","type":"uuid","description":"User who applied the coupon. {@link shopping_mall_member.id}","relation":{"name":"user","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"order_id","type":"uuid","description":"Order to which the coupon was applied.","nullable":false},{"name":"used_at","type":"datetime","description":"Timestamp when the coupon was used.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the usage record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the usage record was last updated.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_coupon_id"]},{"fieldNames":["shopping_mall_member_id"]},{"fieldNames":["used_at"]}],"ginIndexes":[]}]},{"filename":"schema-07-coins.prisma","namespace":"Coins","models":[{"name":"shopping_coins","description":"Tracks user coin balances and financial information. Represents the current state of a user's coin account.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Belonged member's {@link shopping_mall_member.id}.","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":true,"nullable":false}],"plainFields":[{"name":"balance","type":"double","description":"Current coin balance.","nullable":false},{"name":"created_at","type":"datetime","description":"When the coin account was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the coin account was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the coin account was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_mall_member_id"],"unique":true}],"plainIndexes":[{"fieldNames":["balance"]}],"ginIndexes":[]},{"name":"shopping_coin_transactions","description":"Records all financial activities related to coin usage. Captures every transaction for audit and tracking purposes.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Belonged member's {@link shopping_mall_member.id}.","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":false,"nullable":false},{"name":"shopping_order_id","type":"uuid","description":"Belonged order's {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":true}],"plainFields":[{"name":"amount","type":"double","description":"Amount of coins involved in the transaction.","nullable":false},{"name":"transaction_type","type":"string","description":"Type of transaction (e.g., 'purchase', 'refund', 'earn').","nullable":false},{"name":"description","type":"string","description":"Description of the transaction.","nullable":true},{"name":"created_at","type":"datetime","description":"When the transaction occurred.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_mall_member_id"]},{"fieldNames":["shopping_order_id"]},{"fieldNames":["transaction_type"]},{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-08-inquiries.prisma","namespace":"Inquiries","models":[{"name":"shopping_inquiries","description":"Customer inquiries for support or information. Represents the initial contact point for customer service interactions. {@link shopping_mall_member} for the customer who created the inquiry.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Customer who created the inquiry. {@link shopping_mall_member.id}","relation":{"name":"customer","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","description":"Title of the inquiry.","nullable":false},{"name":"content","type":"string","description":"Detailed content of the inquiry.","nullable":false},{"name":"status","type":"string","description":"Current status of the inquiry (e.g., 'open', 'in-progress', 'resolved').","nullable":false},{"name":"created_at","type":"datetime","description":"When the inquiry was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the inquiry was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the inquiry was deleted (soft delete).","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_mall_member_id","created_at"]}],"ginIndexes":[{"fieldName":"title"},{"fieldName":"content"}]},{"name":"shopping_inquiry_responses","description":"Responses to customer inquiries. Represents support activities and resolutions. {@link shopping_inquiries} for the inquiry being responded to. {@link shopping_mall_admin} for the admin who responded.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_inquiry_id","type":"uuid","description":"Inquiry being responded to. {@link shopping_inquiries.id}","relation":{"name":"inquiry","targetModel":"shopping_inquiries"},"unique":false,"nullable":false},{"name":"shopping_mall_admin_id","type":"uuid","description":"Admin who created the response. {@link shopping_mall_admin.id}","relation":{"name":"admin","targetModel":"shopping_mall_admin"},"unique":false,"nullable":false}],"plainFields":[{"name":"content","type":"string","description":"Content of the response.","nullable":false},{"name":"created_at","type":"datetime","description":"When the response was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the response was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the response was deleted (soft delete).","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_inquiry_id","created_at"]}],"ginIndexes":[{"fieldName":"content"}]}]},{"filename":"schema-09-favorites.prisma","namespace":"Favorites","models":[{"name":"shopping_favorites","description":"User preference management for favorite items. Represents a user's collection of favorite items across different products. {@link shopping_mall_member.id}","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_mall_member_id","type":"uuid","description":"Belonged member's {@link shopping_mall_member.id}","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"name","type":"string","description":"Name of the favorite collection.","nullable":false},{"name":"description","type":"string","description":"Description of the favorite collection.","nullable":true},{"name":"created_at","type":"datetime","description":"When the favorite collection was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the favorite collection was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the favorite collection was deleted (soft delete).","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_mall_member_id","name"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_favorite_items","description":"Favorite items within a user's favorite collection. Represents individual items that a user has marked as favorites within their collections. {@link shopping_favorites.id} {@link shopping_sale_units.id}","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_favorite_id","type":"uuid","description":"Belonged favorite collection's {@link shopping_favorites.id}","relation":{"name":"favorite","targetModel":"shopping_favorites"},"unique":false,"nullable":false},{"name":"shopping_sale_unit_id","type":"uuid","description":"Belonged sale unit's {@link shopping_sale_units.id}","relation":{"name":"saleUnit","targetModel":"shopping_sale_units"},"unique":false,"nullable":false}],"plainFields":[{"name":"created_at","type":"datetime","description":"When the favorite item was added to the collection.","nullable":false}],"uniqueIndexes":[{"fieldNames":["shopping_favorite_id","shopping_sale_unit_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-10-articles.prisma","namespace":"Articles","models":[{"name":"shopping_articles","description":"Represents articles in the shopping mall. This table stores information about articles that are displayed in the shopping mall. The articles can be categorized and have various attributes such as title, content, and status. The table also includes temporal fields for tracking creation, updates, and deletion times.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"Belonged channel's {@link shopping_channels.id}.","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":false},{"name":"shopping_section_id","type":"uuid","description":"Belonged section's {@link shopping_sections.id}.","relation":{"name":"section","targetModel":"shopping_sections"},"unique":false,"nullable":false}],"plainFields":[{"name":"code","type":"string","description":"Article code.","nullable":false},{"name":"title","type":"string","description":"Article title.","nullable":false},{"name":"content","type":"string","description":"Article content.","nullable":false},{"name":"status","type":"string","description":"Article status.","nullable":false},{"name":"created_at","type":"datetime","description":"When the article was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the article was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the article was deleted.","nullable":true}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id","shopping_section_id"]}],"ginIndexes":[{"fieldName":"title"},{"fieldName":"content"}]},{"name":"shopping_article_comments","description":"Represents comments on articles in the shopping mall. This table stores information about comments made on articles. Each comment is associated with a specific article and a user. The table includes temporal fields for tracking creation, updates, and deletion times.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_article_id","type":"uuid","description":"Belonged article's {@link shopping_articles.id}.","relation":{"name":"article","targetModel":"shopping_articles"},"unique":false,"nullable":false},{"name":"shopping_mall_member_id","type":"uuid","description":"Belonged member's {@link shopping_mall_member.id}.","relation":{"name":"member","targetModel":"shopping_mall_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"content","type":"string","description":"Comment content.","nullable":false},{"name":"created_at","type":"datetime","description":"When the comment was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the comment was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"When the comment was deleted.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_article_id"]}],"ginIndexes":[{"fieldName":"content"}]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-systematic.prisma":"/// Represents the shopping channels available in the system. Each channel\n/// has a unique code and name, and is associated with a specific mall.\n/// Channels are the top-level organizational units for products and\n/// services.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channels {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Unique code identifying the channel.\n  code String\n\n  /// Name of the channel.\n  name String\n\n  /// Description of the channel.\n  description String?\n\n  /// Timestamp when the channel was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the channel was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the channel was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_sections       shopping_sections[]\n  shopping_configurations shopping_configurations[]\n  shopping_sales          shopping_sales[]\n  shopping_articles       shopping_articles[]\n\n  @@unique([code])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the sections within a shopping channel. Each section has a\n/// unique code and name, and is associated with a specific channel. Sections\n/// help organize products and services within a channel.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sections {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The channel to which this section belongs. {@link shopping_channels.id}\n  shopping_channel_id String @db.Uuid\n\n  /// Unique code identifying the section.\n  code String\n\n  /// Name of the section.\n  name String\n\n  /// Description of the section.\n  description String?\n\n  /// Timestamp when the section was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the section was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the section was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n\n  shopping_configurations shopping_configurations[]\n  shopping_sales          shopping_sales[]\n  shopping_articles       shopping_articles[]\n\n  @@unique([shopping_channel_id, code])\n  @@index([shopping_channel_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the configurations for a shopping channel or section. Each\n/// configuration has a unique key and value, and is associated with a\n/// specific channel or section. Configurations define system behavior and\n/// settings for different parts of the system.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_configurations {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The channel to which this configuration belongs. {@link\n  /// shopping_channels.id}\n  shopping_channel_id String? @db.Uuid\n\n  /// The section to which this configuration belongs. {@link\n  /// shopping_sections.id}\n  shopping_section_id String? @db.Uuid\n\n  /// Unique key identifying the configuration.\n  key String\n\n  /// Value of the configuration.\n  value String\n\n  /// Description of the configuration.\n  description String?\n\n  /// Timestamp when the configuration was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the configuration was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the configuration was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels? @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections? @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_channel_id, key])\n  @@unique([shopping_section_id, key])\n  @@index([shopping_channel_id])\n  @@index([shopping_section_id])\n  @@index([key(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-02-actors.prisma":"/// Represents unauthenticated users who can browse products and add items to\n/// cart.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Unique identifier for the guest session.\n  session_id String @db.Uuid\n\n  /// Timestamp when the guest record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the guest record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([session_id])\n  @@index([created_at])\n}\n\n/// Represents authenticated users who can place orders, manage their\n/// profile, and view order history.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_member {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Email address of the member.\n  email String\n\n  /// Hashed password for authentication.\n  password_hash String\n\n  /// Full name of the member.\n  name String\n\n  /// Phone number of the member.\n  phone String?\n\n  /// Shipping address of the member.\n  address String?\n\n  /// Timestamp when the member record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the member record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the member record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_carts             shopping_carts[]\n  shopping_orders            shopping_orders[]\n  shopping_coupon_usage      shopping_coupon_usage[]\n  shopping_coins             shopping_coins?\n  shopping_coin_transactions shopping_coin_transactions[]\n  shopping_inquiries         shopping_inquiries[]\n  shopping_favorites         shopping_favorites[]\n  shopping_article_comments  shopping_article_comments[]\n\n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents users who can manage their products, inventory, and view sales\n/// reports.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_seller {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Email address of the seller.\n  email String\n\n  /// Hashed password for authentication.\n  password_hash String\n\n  /// Full name of the seller.\n  name String\n\n  /// Phone number of the seller.\n  phone String?\n\n  /// Business name of the seller.\n  business_name String\n\n  /// Business address of the seller.\n  business_address String\n\n  /// Timestamp when the seller record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([business_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents system administrators who can manage all users, products,\n/// orders, and system settings.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_mall_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Email address of the admin.\n  email String\n\n  /// Hashed password for authentication.\n  password_hash String\n\n  /// Full name of the admin.\n  name String\n\n  /// Phone number of the admin.\n  phone String?\n\n  /// Role of the admin (e.g., superadmin, moderator).\n  role String\n\n  /// Timestamp when the admin record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the admin record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the admin record was soft deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_inquiry_responses shopping_inquiry_responses[]\n\n  @@unique([email])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-03-sales.prisma":"/// Main sales entity representing product offerings in the shopping mall.\n/// This table captures all essential information about products available\n/// for purchase, including pricing, availability, and basic attributes. It\n/// serves as the primary reference for all sales-related operations.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sales {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged channel's {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n\n  /// Belonged section's {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n\n  /// Unique business identifier for the sale.\n  code String\n\n  /// Display name of the sale.\n  name String\n\n  /// Detailed description of the sale.\n  description String?\n\n  /// Current price of the sale.\n  price Float @db.DoublePrecision\n\n  /// Current inventory stock level.\n  stock Int @db.Integer\n\n  /// Timestamp when the sale was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n\n  shopping_sale_snapshots shopping_sale_snapshots[]\n  shopping_sale_units     shopping_sale_units[]\n\n  @@unique([code])\n  @@index([shopping_section_id])\n  @@index([shopping_channel_id, shopping_section_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Historical snapshots of shopping_sales for audit trails and version\n/// control. This table captures point-in-time states of sales entities,\n/// allowing for complete historical tracking of all changes to product\n/// offerings. Each snapshot represents a complete state of a sale at a\n/// specific moment in time.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged sale's {@link shopping_sales.id}.\n  shopping_sale_id String @db.Uuid\n\n  /// Unique business identifier for the sale at this snapshot.\n  code String\n\n  /// Display name of the sale at this snapshot.\n  name String\n\n  /// Detailed description of the sale at this snapshot.\n  description String?\n\n  /// Price of the sale at this snapshot.\n  price Float @db.DoublePrecision\n\n  /// Inventory stock level at this snapshot.\n  stock Int @db.Integer\n\n  /// Timestamp when this snapshot was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  sale shopping_sales @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_sale_id, created_at])\n}\n\n/// Product variants for sales entities. This table represents different\n/// versions or options of a product offering, allowing for flexible product\n/// configurations and customization. Each unit belongs to a specific sale\n/// and has its own unique attributes and pricing.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_units {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged sale's {@link shopping_sales.id}.\n  shopping_sale_id String @db.Uuid\n\n  /// Unique business identifier for the sale unit.\n  code String\n\n  /// Display name of the sale unit.\n  name String\n\n  /// Detailed description of the sale unit.\n  description String?\n\n  /// Price of the sale unit.\n  price Float @db.DoublePrecision\n\n  /// Inventory stock level of the sale unit.\n  stock Int @db.Integer\n\n  /// Timestamp when the sale unit was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale unit was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale unit was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  sale shopping_sales @relation(fields: [shopping_sale_id], references: [id], onDelete: Cascade)\n\n  shopping_sale_unit_options shopping_sale_unit_options[]\n  shopping_cart_items        shopping_cart_items[]\n  shopping_favorite_items    shopping_favorite_items[]\n\n  @@unique([shopping_sale_id, code])\n  @@index([shopping_sale_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Customizable options for sale units. This table represents additional\n/// configuration choices that can be made for product variants, allowing\n/// customers to personalize their purchases. Each option belongs to a\n/// specific sale unit and has its own unique attributes and pricing.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sale_unit_options {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged sale unit's {@link shopping_sale_units.id}.\n  shopping_sale_unit_id String @db.Uuid\n\n  /// Unique business identifier for the sale unit option.\n  code String\n\n  /// Display name of the sale unit option.\n  name String\n\n  /// Detailed description of the sale unit option.\n  description String?\n\n  /// Price of the sale unit option.\n  price Float @db.DoublePrecision\n\n  /// Timestamp when the sale unit option was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale unit option was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the sale unit option was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_sale_unit_id, code])\n  @@index([shopping_sale_unit_id])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-04-carts.prisma":"/// Shopping carts represent temporary holding areas for items that users\n/// intend to purchase. Each cart is associated with a specific user and\n/// contains multiple cart items. The cart system supports session-based\n/// interactions, allowing users to accumulate items before proceeding to\n/// checkout. The cart maintains temporal fields for tracking creation and\n/// updates, and includes a status field to manage its lifecycle.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_carts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n\n  /// Status of the shopping cart.\n  status String\n\n  /// Creation timestamp of the shopping cart.\n  created_at DateTime @db.Timestamptz\n\n  /// Last update timestamp of the shopping cart.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  shopping_cart_items shopping_cart_items[]\n\n  @@index([shopping_mall_member_id])\n}\n\n/// Shopping cart items represent individual products or product variants\n/// that users have added to their shopping carts. Each cart item is\n/// associated with a specific cart and product variant, and includes details\n/// such as quantity and price. The cart item system supports session-based\n/// interactions, allowing users to manage their selections before checkout.\n/// The cart item maintains temporal fields for tracking creation and\n/// updates.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_cart_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged cart's {@link shopping_carts.id}.\n  shopping_cart_id String @db.Uuid\n\n  /// Belonged sale unit's {@link shopping_sale_units.id}.\n  shopping_sale_unit_id String @db.Uuid\n\n  /// Quantity of the product variant in the cart.\n  quantity Int @db.Integer\n\n  /// Price of the product variant at the time of adding to the cart.\n  price Float @db.DoublePrecision\n\n  /// Creation timestamp of the cart item.\n  created_at DateTime @db.Timestamptz\n\n  /// Last update timestamp of the cart item.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  cart     shopping_carts      @relation(fields: [shopping_cart_id], references: [id], onDelete: Cascade)\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_cart_id])\n  @@index([shopping_sale_unit_id])\n}\n","schema-05-orders.prisma":"/// Primary table for managing customer orders. This table captures all\n/// essential order information including customer details, order status, and\n/// total amount. It serves as the central entity for order processing and\n/// tracking.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the customer who placed the order. {@link\n  /// shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n\n  /// Unique order code for tracking and reference purposes.\n  code String\n\n  /// Current status of the order (e.g., pending, processing, shipped,\n  /// delivered).\n  status String\n\n  /// Total amount of the order including all items and taxes.\n  total_amount Float @db.DoublePrecision\n\n  /// Shipping address for the order.\n  shipping_address String\n\n  /// Payment method used for the order (e.g., credit card, PayPal).\n  payment_method String\n\n  /// Timestamp when the order was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  shopping_order_snapshots   shopping_order_snapshots[]\n  shopping_order_items       shopping_order_items[]\n  shopping_coin_transactions shopping_coin_transactions[]\n\n  @@unique([code])\n  @@index([shopping_mall_member_id, created_at])\n}\n\n/// Table for capturing historical states of orders for audit trails and\n/// version control. This table records all changes to order information over\n/// time, allowing for comprehensive tracking and analysis.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the order being snapshotted. {@link shopping_orders.id}\n  shopping_order_id String @db.Uuid\n\n  /// Unique order code for tracking and reference purposes.\n  code String\n\n  /// Status of the order at the time of the snapshot.\n  status String\n\n  /// Total amount of the order including all items and taxes.\n  total_amount Float @db.DoublePrecision\n\n  /// Shipping address for the order.\n  shipping_address String\n\n  /// Payment method used for the order.\n  payment_method String\n\n  /// Timestamp when the snapshot was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_order_id, created_at])\n}\n\n/// Table for managing items within each order. This table captures detailed\n/// information about each item in the order, including quantity, price, and\n/// product details.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the order that contains this item. {@link shopping_orders.id}\n  shopping_order_id String @db.Uuid\n\n  /// Unique identifier for the product.\n  product_id String @db.Uuid\n\n  /// Quantity of the product ordered.\n  quantity Int @db.Integer\n\n  /// Price of the product at the time of order.\n  price Float @db.DoublePrecision\n\n  /// Timestamp when the order item was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order item was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_order_id])\n}\n","schema-06-coupons.prisma":"/// Coupon definitions for promotional discounts. Represents available\n/// coupons that can be applied to orders.\n///\n/// @namespace Coupons\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coupons {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Unique coupon code for redemption.\n  code String\n\n  /// Type of discount (percentage or fixed amount).\n  discount_type String\n\n  /// Discount value (percentage or fixed amount).\n  value Float @db.DoublePrecision\n\n  /// Start date when the coupon becomes valid.\n  valid_from DateTime @db.Timestamptz\n\n  /// End date when the coupon expires.\n  valid_until DateTime @db.Timestamptz\n\n  /// Maximum number of times the coupon can be used.\n  max_uses Int? @db.Integer\n\n  /// Timestamp when the coupon was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the coupon was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_coupon_usage shopping_coupon_usage[]\n\n  @@unique([code])\n  @@index([valid_from])\n  @@index([valid_until])\n}\n\n/// Records of coupon usage by users. Tracks each application of a coupon to\n/// an order.\n///\n/// @namespace Coupons\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coupon_usage {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Coupon that was used. {@link shopping_coupons.id}\n  shopping_coupon_id String @db.Uuid\n\n  /// User who applied the coupon. {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n\n  /// Order to which the coupon was applied.\n  order_id String @db.Uuid\n\n  /// Timestamp when the coupon was used.\n  used_at DateTime @db.Timestamptz\n\n  /// Timestamp when the usage record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the usage record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  coupon shopping_coupons     @relation(fields: [shopping_coupon_id], references: [id], onDelete: Cascade)\n  user   shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_coupon_id])\n  @@index([shopping_mall_member_id])\n  @@index([used_at])\n}\n","schema-07-coins.prisma":"/// Tracks user coin balances and financial information. Represents the\n/// current state of a user's coin account.\n///\n/// @namespace Coins\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coins {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n\n  /// Current coin balance.\n  balance Float @db.DoublePrecision\n\n  /// When the coin account was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the coin account was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the coin account was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_mall_member_id])\n  @@index([balance])\n}\n\n/// Records all financial activities related to coin usage. Captures every\n/// transaction for audit and tracking purposes.\n///\n/// @namespace Coins\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_coin_transactions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n\n  /// Belonged order's {@link shopping_orders.id}.\n  shopping_order_id String? @db.Uuid\n\n  /// Amount of coins involved in the transaction.\n  amount Float @db.DoublePrecision\n\n  /// Type of transaction (e.g., 'purchase', 'refund', 'earn').\n  transaction_type String\n\n  /// Description of the transaction.\n  description String?\n\n  /// When the transaction occurred.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n  order  shopping_orders?     @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_mall_member_id])\n  @@index([shopping_order_id])\n  @@index([transaction_type])\n  @@index([created_at])\n}\n","schema-08-inquiries.prisma":"/// Customer inquiries for support or information. Represents the initial\n/// contact point for customer service interactions. {@link\n/// shopping_mall_member} for the customer who created the inquiry.\n///\n/// @namespace Inquiries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inquiries {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Customer who created the inquiry. {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n\n  /// Title of the inquiry.\n  title String\n\n  /// Detailed content of the inquiry.\n  content String\n\n  /// Current status of the inquiry (e.g., 'open', 'in-progress', 'resolved').\n  status String\n\n  /// When the inquiry was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the inquiry was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the inquiry was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  customer shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  shopping_inquiry_responses shopping_inquiry_responses[]\n\n  @@index([shopping_mall_member_id, created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Responses to customer inquiries. Represents support activities and\n/// resolutions. {@link shopping_inquiries} for the inquiry being responded\n/// to. {@link shopping_mall_admin} for the admin who responded.\n///\n/// @namespace Inquiries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inquiry_responses {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Inquiry being responded to. {@link shopping_inquiries.id}\n  shopping_inquiry_id String @db.Uuid\n\n  /// Admin who created the response. {@link shopping_mall_admin.id}\n  shopping_mall_admin_id String @db.Uuid\n\n  /// Content of the response.\n  content String\n\n  /// When the response was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the response was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the response was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  inquiry shopping_inquiries  @relation(fields: [shopping_inquiry_id], references: [id], onDelete: Cascade)\n  admin   shopping_mall_admin @relation(fields: [shopping_mall_admin_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_mall_admin_id])\n  @@index([shopping_inquiry_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-09-favorites.prisma":"/// User preference management for favorite items. Represents a user's\n/// collection of favorite items across different products. {@link\n/// shopping_mall_member.id}\n///\n/// @namespace Favorites\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_favorites {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged member's {@link shopping_mall_member.id}\n  shopping_mall_member_id String @db.Uuid\n\n  /// Name of the favorite collection.\n  name String\n\n  /// Description of the favorite collection.\n  description String?\n\n  /// When the favorite collection was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the favorite collection was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the favorite collection was deleted (soft delete).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  shopping_favorite_items shopping_favorite_items[]\n\n  @@unique([shopping_mall_member_id, name])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Favorite items within a user's favorite collection. Represents individual\n/// items that a user has marked as favorites within their collections.\n/// {@link shopping_favorites.id} {@link shopping_sale_units.id}\n///\n/// @namespace Favorites\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_favorite_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged favorite collection's {@link shopping_favorites.id}\n  shopping_favorite_id String @db.Uuid\n\n  /// Belonged sale unit's {@link shopping_sale_units.id}\n  shopping_sale_unit_id String @db.Uuid\n\n  /// When the favorite item was added to the collection.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  favorite shopping_favorites  @relation(fields: [shopping_favorite_id], references: [id], onDelete: Cascade)\n  saleUnit shopping_sale_units @relation(fields: [shopping_sale_unit_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_favorite_id, shopping_sale_unit_id], map: \"shopping_favorite_items_shopping_favorite_id_shopping__85380852\")\n  @@index([shopping_sale_unit_id])\n  @@index([created_at])\n}\n","schema-10-articles.prisma":"/// Represents articles in the shopping mall. This table stores information\n/// about articles that are displayed in the shopping mall. The articles can\n/// be categorized and have various attributes such as title, content, and\n/// status. The table also includes temporal fields for tracking creation,\n/// updates, and deletion times.\n///\n/// @namespace Articles\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_articles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged channel's {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n\n  /// Belonged section's {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n\n  /// Article code.\n  code String\n\n  /// Article title.\n  title String\n\n  /// Article content.\n  content String\n\n  /// Article status.\n  status String\n\n  /// When the article was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the article was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the article was deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n\n  shopping_article_comments shopping_article_comments[]\n\n  @@unique([code])\n  @@index([shopping_section_id])\n  @@index([shopping_channel_id, shopping_section_id])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents comments on articles in the shopping mall. This table stores\n/// information about comments made on articles. Each comment is associated\n/// with a specific article and a user. The table includes temporal fields\n/// for tracking creation, updates, and deletion times.\n///\n/// @namespace Articles\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_article_comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged article's {@link shopping_articles.id}.\n  shopping_article_id String @db.Uuid\n\n  /// Belonged member's {@link shopping_mall_member.id}.\n  shopping_mall_member_id String @db.Uuid\n\n  /// Comment content.\n  content String\n\n  /// When the comment was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the comment was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// When the comment was deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  article shopping_articles    @relation(fields: [shopping_article_id], references: [id], onDelete: Cascade)\n  member  shopping_mall_member @relation(fields: [shopping_mall_member_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_mall_member_id])\n  @@index([shopping_article_id])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model shopping_channels\n * Represents the shopping channels available in the system. Each channel\n * has a unique code and name, and is associated with a specific mall.\n * Channels are the top-level organizational units for products and\n * services.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_channels = $Result.DefaultSelection<Prisma.$shopping_channelsPayload>\n/**\n * Model shopping_sections\n * Represents the sections within a shopping channel. Each section has a\n * unique code and name, and is associated with a specific channel. Sections\n * help organize products and services within a channel.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sections = $Result.DefaultSelection<Prisma.$shopping_sectionsPayload>\n/**\n * Model shopping_configurations\n * Represents the configurations for a shopping channel or section. Each\n * configuration has a unique key and value, and is associated with a\n * specific channel or section. Configurations define system behavior and\n * settings for different parts of the system.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_configurations = $Result.DefaultSelection<Prisma.$shopping_configurationsPayload>\n/**\n * Model shopping_mall_guest\n * Represents unauthenticated users who can browse products and add items to\n * cart.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_mall_guest = $Result.DefaultSelection<Prisma.$shopping_mall_guestPayload>\n/**\n * Model shopping_mall_member\n * Represents authenticated users who can place orders, manage their\n * profile, and view order history.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_mall_member = $Result.DefaultSelection<Prisma.$shopping_mall_memberPayload>\n/**\n * Model shopping_mall_seller\n * Represents users who can manage their products, inventory, and view sales\n * reports.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_mall_seller = $Result.DefaultSelection<Prisma.$shopping_mall_sellerPayload>\n/**\n * Model shopping_mall_admin\n * Represents system administrators who can manage all users, products,\n * orders, and system settings.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_mall_admin = $Result.DefaultSelection<Prisma.$shopping_mall_adminPayload>\n/**\n * Model shopping_sales\n * Main sales entity representing product offerings in the shopping mall.\n * This table captures all essential information about products available\n * for purchase, including pricing, availability, and basic attributes. It\n * serves as the primary reference for all sales-related operations.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sales = $Result.DefaultSelection<Prisma.$shopping_salesPayload>\n/**\n * Model shopping_sale_snapshots\n * Historical snapshots of shopping_sales for audit trails and version\n * control. This table captures point-in-time states of sales entities,\n * allowing for complete historical tracking of all changes to product\n * offerings. Each snapshot represents a complete state of a sale at a\n * specific moment in time.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sale_snapshots = $Result.DefaultSelection<Prisma.$shopping_sale_snapshotsPayload>\n/**\n * Model shopping_sale_units\n * Product variants for sales entities. This table represents different\n * versions or options of a product offering, allowing for flexible product\n * configurations and customization. Each unit belongs to a specific sale\n * and has its own unique attributes and pricing.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sale_units = $Result.DefaultSelection<Prisma.$shopping_sale_unitsPayload>\n/**\n * Model shopping_sale_unit_options\n * Customizable options for sale units. This table represents additional\n * configuration choices that can be made for product variants, allowing\n * customers to personalize their purchases. Each option belongs to a\n * specific sale unit and has its own unique attributes and pricing.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sale_unit_options = $Result.DefaultSelection<Prisma.$shopping_sale_unit_optionsPayload>\n/**\n * Model shopping_carts\n * Shopping carts represent temporary holding areas for items that users\n * intend to purchase. Each cart is associated with a specific user and\n * contains multiple cart items. The cart system supports session-based\n * interactions, allowing users to accumulate items before proceeding to\n * checkout. The cart maintains temporal fields for tracking creation and\n * updates, and includes a status field to manage its lifecycle.\n * \n * @namespace Carts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_carts = $Result.DefaultSelection<Prisma.$shopping_cartsPayload>\n/**\n * Model shopping_cart_items\n * Shopping cart items represent individual products or product variants\n * that users have added to their shopping carts. Each cart item is\n * associated with a specific cart and product variant, and includes details\n * such as quantity and price. The cart item system supports session-based\n * interactions, allowing users to manage their selections before checkout.\n * The cart item maintains temporal fields for tracking creation and\n * updates.\n * \n * @namespace Carts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_cart_items = $Result.DefaultSelection<Prisma.$shopping_cart_itemsPayload>\n/**\n * Model shopping_orders\n * Primary table for managing customer orders. This table captures all\n * essential order information including customer details, order status, and\n * total amount. It serves as the central entity for order processing and\n * tracking.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_orders = $Result.DefaultSelection<Prisma.$shopping_ordersPayload>\n/**\n * Model shopping_order_snapshots\n * Table for capturing historical states of orders for audit trails and\n * version control. This table records all changes to order information over\n * time, allowing for comprehensive tracking and analysis.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_order_snapshots = $Result.DefaultSelection<Prisma.$shopping_order_snapshotsPayload>\n/**\n * Model shopping_order_items\n * Table for managing items within each order. This table captures detailed\n * information about each item in the order, including quantity, price, and\n * product details.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_order_items = $Result.DefaultSelection<Prisma.$shopping_order_itemsPayload>\n/**\n * Model shopping_coupons\n * Coupon definitions for promotional discounts. Represents available\n * coupons that can be applied to orders.\n * \n * @namespace Coupons\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_coupons = $Result.DefaultSelection<Prisma.$shopping_couponsPayload>\n/**\n * Model shopping_coupon_usage\n * Records of coupon usage by users. Tracks each application of a coupon to\n * an order.\n * \n * @namespace Coupons\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_coupon_usage = $Result.DefaultSelection<Prisma.$shopping_coupon_usagePayload>\n/**\n * Model shopping_coins\n * Tracks user coin balances and financial information. Represents the\n * current state of a user's coin account.\n * \n * @namespace Coins\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_coins = $Result.DefaultSelection<Prisma.$shopping_coinsPayload>\n/**\n * Model shopping_coin_transactions\n * Records all financial activities related to coin usage. Captures every\n * transaction for audit and tracking purposes.\n * \n * @namespace Coins\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_coin_transactions = $Result.DefaultSelection<Prisma.$shopping_coin_transactionsPayload>\n/**\n * Model shopping_inquiries\n * Customer inquiries for support or information. Represents the initial\n * contact point for customer service interactions. {@link\n * shopping_mall_member} for the customer who created the inquiry.\n * \n * @namespace Inquiries\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_inquiries = $Result.DefaultSelection<Prisma.$shopping_inquiriesPayload>\n/**\n * Model shopping_inquiry_responses\n * Responses to customer inquiries. Represents support activities and\n * resolutions. {@link shopping_inquiries} for the inquiry being responded\n * to. {@link shopping_mall_admin} for the admin who responded.\n * \n * @namespace Inquiries\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_inquiry_responses = $Result.DefaultSelection<Prisma.$shopping_inquiry_responsesPayload>\n/**\n * Model shopping_favorites\n * User preference management for favorite items. Represents a user's\n * collection of favorite items across different products. {@link\n * shopping_mall_member.id}\n * \n * @namespace Favorites\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_favorites = $Result.DefaultSelection<Prisma.$shopping_favoritesPayload>\n/**\n * Model shopping_favorite_items\n * Favorite items within a user's favorite collection. Represents individual\n * items that a user has marked as favorites within their collections.\n * {@link shopping_favorites.id} {@link shopping_sale_units.id}\n * \n * @namespace Favorites\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_favorite_items = $Result.DefaultSelection<Prisma.$shopping_favorite_itemsPayload>\n/**\n * Model shopping_articles\n * Represents articles in the shopping mall. This table stores information\n * about articles that are displayed in the shopping mall. The articles can\n * be categorized and have various attributes such as title, content, and\n * status. The table also includes temporal fields for tracking creation,\n * updates, and deletion times.\n * \n * @namespace Articles\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_articles = $Result.DefaultSelection<Prisma.$shopping_articlesPayload>\n/**\n * Model shopping_article_comments\n * Represents comments on articles in the shopping mall. This table stores\n * information about comments made on articles. Each comment is associated\n * with a specific article and a user. The table includes temporal fields\n * for tracking creation, updates, and deletion times.\n * \n * @namespace Articles\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_article_comments = $Result.DefaultSelection<Prisma.$shopping_article_commentsPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Shopping_channels\n * const shopping_channels = await prisma.shopping_channels.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Shopping_channels\n   * const shopping_channels = await prisma.shopping_channels.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.shopping_channels`: Exposes CRUD operations for the **shopping_channels** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_channels\n    * const shopping_channels = await prisma.shopping_channels.findMany()\n    * ```\n    */\n  get shopping_channels(): Prisma.shopping_channelsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sections`: Exposes CRUD operations for the **shopping_sections** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sections\n    * const shopping_sections = await prisma.shopping_sections.findMany()\n    * ```\n    */\n  get shopping_sections(): Prisma.shopping_sectionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_configurations`: Exposes CRUD operations for the **shopping_configurations** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_configurations\n    * const shopping_configurations = await prisma.shopping_configurations.findMany()\n    * ```\n    */\n  get shopping_configurations(): Prisma.shopping_configurationsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_mall_guest`: Exposes CRUD operations for the **shopping_mall_guest** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_mall_guests\n    * const shopping_mall_guests = await prisma.shopping_mall_guest.findMany()\n    * ```\n    */\n  get shopping_mall_guest(): Prisma.shopping_mall_guestDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_mall_member`: Exposes CRUD operations for the **shopping_mall_member** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_mall_members\n    * const shopping_mall_members = await prisma.shopping_mall_member.findMany()\n    * ```\n    */\n  get shopping_mall_member(): Prisma.shopping_mall_memberDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_mall_seller`: Exposes CRUD operations for the **shopping_mall_seller** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_mall_sellers\n    * const shopping_mall_sellers = await prisma.shopping_mall_seller.findMany()\n    * ```\n    */\n  get shopping_mall_seller(): Prisma.shopping_mall_sellerDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_mall_admin`: Exposes CRUD operations for the **shopping_mall_admin** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_mall_admins\n    * const shopping_mall_admins = await prisma.shopping_mall_admin.findMany()\n    * ```\n    */\n  get shopping_mall_admin(): Prisma.shopping_mall_adminDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sales`: Exposes CRUD operations for the **shopping_sales** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sales\n    * const shopping_sales = await prisma.shopping_sales.findMany()\n    * ```\n    */\n  get shopping_sales(): Prisma.shopping_salesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sale_snapshots`: Exposes CRUD operations for the **shopping_sale_snapshots** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sale_snapshots\n    * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findMany()\n    * ```\n    */\n  get shopping_sale_snapshots(): Prisma.shopping_sale_snapshotsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sale_units`: Exposes CRUD operations for the **shopping_sale_units** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sale_units\n    * const shopping_sale_units = await prisma.shopping_sale_units.findMany()\n    * ```\n    */\n  get shopping_sale_units(): Prisma.shopping_sale_unitsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sale_unit_options`: Exposes CRUD operations for the **shopping_sale_unit_options** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sale_unit_options\n    * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findMany()\n    * ```\n    */\n  get shopping_sale_unit_options(): Prisma.shopping_sale_unit_optionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_carts`: Exposes CRUD operations for the **shopping_carts** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_carts\n    * const shopping_carts = await prisma.shopping_carts.findMany()\n    * ```\n    */\n  get shopping_carts(): Prisma.shopping_cartsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_cart_items`: Exposes CRUD operations for the **shopping_cart_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_cart_items\n    * const shopping_cart_items = await prisma.shopping_cart_items.findMany()\n    * ```\n    */\n  get shopping_cart_items(): Prisma.shopping_cart_itemsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_orders`: Exposes CRUD operations for the **shopping_orders** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_orders\n    * const shopping_orders = await prisma.shopping_orders.findMany()\n    * ```\n    */\n  get shopping_orders(): Prisma.shopping_ordersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_order_snapshots`: Exposes CRUD operations for the **shopping_order_snapshots** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_order_snapshots\n    * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findMany()\n    * ```\n    */\n  get shopping_order_snapshots(): Prisma.shopping_order_snapshotsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_order_items`: Exposes CRUD operations for the **shopping_order_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_order_items\n    * const shopping_order_items = await prisma.shopping_order_items.findMany()\n    * ```\n    */\n  get shopping_order_items(): Prisma.shopping_order_itemsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_coupons`: Exposes CRUD operations for the **shopping_coupons** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_coupons\n    * const shopping_coupons = await prisma.shopping_coupons.findMany()\n    * ```\n    */\n  get shopping_coupons(): Prisma.shopping_couponsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_coupon_usage`: Exposes CRUD operations for the **shopping_coupon_usage** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_coupon_usages\n    * const shopping_coupon_usages = await prisma.shopping_coupon_usage.findMany()\n    * ```\n    */\n  get shopping_coupon_usage(): Prisma.shopping_coupon_usageDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_coins`: Exposes CRUD operations for the **shopping_coins** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_coins\n    * const shopping_coins = await prisma.shopping_coins.findMany()\n    * ```\n    */\n  get shopping_coins(): Prisma.shopping_coinsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_coin_transactions`: Exposes CRUD operations for the **shopping_coin_transactions** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_coin_transactions\n    * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findMany()\n    * ```\n    */\n  get shopping_coin_transactions(): Prisma.shopping_coin_transactionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_inquiries`: Exposes CRUD operations for the **shopping_inquiries** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_inquiries\n    * const shopping_inquiries = await prisma.shopping_inquiries.findMany()\n    * ```\n    */\n  get shopping_inquiries(): Prisma.shopping_inquiriesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_inquiry_responses`: Exposes CRUD operations for the **shopping_inquiry_responses** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_inquiry_responses\n    * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findMany()\n    * ```\n    */\n  get shopping_inquiry_responses(): Prisma.shopping_inquiry_responsesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_favorites`: Exposes CRUD operations for the **shopping_favorites** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_favorites\n    * const shopping_favorites = await prisma.shopping_favorites.findMany()\n    * ```\n    */\n  get shopping_favorites(): Prisma.shopping_favoritesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_favorite_items`: Exposes CRUD operations for the **shopping_favorite_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_favorite_items\n    * const shopping_favorite_items = await prisma.shopping_favorite_items.findMany()\n    * ```\n    */\n  get shopping_favorite_items(): Prisma.shopping_favorite_itemsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_articles`: Exposes CRUD operations for the **shopping_articles** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_articles\n    * const shopping_articles = await prisma.shopping_articles.findMany()\n    * ```\n    */\n  get shopping_articles(): Prisma.shopping_articlesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_article_comments`: Exposes CRUD operations for the **shopping_article_comments** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_article_comments\n    * const shopping_article_comments = await prisma.shopping_article_comments.findMany()\n    * ```\n    */\n  get shopping_article_comments(): Prisma.shopping_article_commentsDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    shopping_channels: 'shopping_channels',\n    shopping_sections: 'shopping_sections',\n    shopping_configurations: 'shopping_configurations',\n    shopping_mall_guest: 'shopping_mall_guest',\n    shopping_mall_member: 'shopping_mall_member',\n    shopping_mall_seller: 'shopping_mall_seller',\n    shopping_mall_admin: 'shopping_mall_admin',\n    shopping_sales: 'shopping_sales',\n    shopping_sale_snapshots: 'shopping_sale_snapshots',\n    shopping_sale_units: 'shopping_sale_units',\n    shopping_sale_unit_options: 'shopping_sale_unit_options',\n    shopping_carts: 'shopping_carts',\n    shopping_cart_items: 'shopping_cart_items',\n    shopping_orders: 'shopping_orders',\n    shopping_order_snapshots: 'shopping_order_snapshots',\n    shopping_order_items: 'shopping_order_items',\n    shopping_coupons: 'shopping_coupons',\n    shopping_coupon_usage: 'shopping_coupon_usage',\n    shopping_coins: 'shopping_coins',\n    shopping_coin_transactions: 'shopping_coin_transactions',\n    shopping_inquiries: 'shopping_inquiries',\n    shopping_inquiry_responses: 'shopping_inquiry_responses',\n    shopping_favorites: 'shopping_favorites',\n    shopping_favorite_items: 'shopping_favorite_items',\n    shopping_articles: 'shopping_articles',\n    shopping_article_comments: 'shopping_article_comments'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"shopping_channels\" | \"shopping_sections\" | \"shopping_configurations\" | \"shopping_mall_guest\" | \"shopping_mall_member\" | \"shopping_mall_seller\" | \"shopping_mall_admin\" | \"shopping_sales\" | \"shopping_sale_snapshots\" | \"shopping_sale_units\" | \"shopping_sale_unit_options\" | \"shopping_carts\" | \"shopping_cart_items\" | \"shopping_orders\" | \"shopping_order_snapshots\" | \"shopping_order_items\" | \"shopping_coupons\" | \"shopping_coupon_usage\" | \"shopping_coins\" | \"shopping_coin_transactions\" | \"shopping_inquiries\" | \"shopping_inquiry_responses\" | \"shopping_favorites\" | \"shopping_favorite_items\" | \"shopping_articles\" | \"shopping_article_comments\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      shopping_channels: {\n        payload: Prisma.$shopping_channelsPayload<ExtArgs>\n        fields: Prisma.shopping_channelsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_channelsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_channelsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_channelsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_channelsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_channelsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_channelsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_channelsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_channelsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_channelsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          update: {\n            args: Prisma.shopping_channelsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_channelsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_channelsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_channelsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_channelsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_channelsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_channels>\n          }\n          groupBy: {\n            args: Prisma.shopping_channelsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channelsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_channelsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channelsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sections: {\n        payload: Prisma.$shopping_sectionsPayload<ExtArgs>\n        fields: Prisma.shopping_sectionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sectionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sectionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sectionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sectionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sectionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sectionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sectionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sectionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sectionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_sectionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sectionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sectionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sectionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sectionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sectionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sections>\n          }\n          groupBy: {\n            args: Prisma.shopping_sectionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sectionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sectionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sectionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_configurations: {\n        payload: Prisma.$shopping_configurationsPayload<ExtArgs>\n        fields: Prisma.shopping_configurationsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_configurationsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_configurationsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_configurationsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_configurationsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_configurationsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_configurationsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_configurationsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_configurationsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_configurationsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          update: {\n            args: Prisma.shopping_configurationsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_configurationsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_configurationsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_configurationsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_configurationsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_configurationsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_configurationsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_configurations>\n          }\n          groupBy: {\n            args: Prisma.shopping_configurationsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_configurationsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_configurationsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_configurationsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_mall_guest: {\n        payload: Prisma.$shopping_mall_guestPayload<ExtArgs>\n        fields: Prisma.shopping_mall_guestFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_mall_guestFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_mall_guestFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_mall_guestFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_mall_guestFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_mall_guestFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_mall_guestCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_mall_guestCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_mall_guestCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_mall_guestDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          update: {\n            args: Prisma.shopping_mall_guestUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_mall_guestDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_mall_guestUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_mall_guestUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_mall_guestUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_guestPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_mall_guestAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_mall_guest>\n          }\n          groupBy: {\n            args: Prisma.shopping_mall_guestGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_guestGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_mall_guestCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_guestCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_mall_member: {\n        payload: Prisma.$shopping_mall_memberPayload<ExtArgs>\n        fields: Prisma.shopping_mall_memberFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_mall_memberFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_mall_memberFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_mall_memberFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_mall_memberFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_mall_memberFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_mall_memberCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_mall_memberCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_mall_memberCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_mall_memberDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          update: {\n            args: Prisma.shopping_mall_memberUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_mall_memberDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_mall_memberUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_mall_memberUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_mall_memberUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_memberPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_mall_memberAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_mall_member>\n          }\n          groupBy: {\n            args: Prisma.shopping_mall_memberGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_memberGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_mall_memberCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_memberCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_mall_seller: {\n        payload: Prisma.$shopping_mall_sellerPayload<ExtArgs>\n        fields: Prisma.shopping_mall_sellerFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_mall_sellerFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_mall_sellerFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_mall_sellerFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_mall_sellerFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_mall_sellerFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_mall_sellerCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_mall_sellerCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_mall_sellerCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_mall_sellerDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          update: {\n            args: Prisma.shopping_mall_sellerUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_mall_sellerDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_mall_sellerUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_mall_sellerUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_mall_sellerUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_sellerPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_mall_sellerAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_mall_seller>\n          }\n          groupBy: {\n            args: Prisma.shopping_mall_sellerGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_sellerGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_mall_sellerCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_sellerCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_mall_admin: {\n        payload: Prisma.$shopping_mall_adminPayload<ExtArgs>\n        fields: Prisma.shopping_mall_adminFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_mall_adminFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_mall_adminFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_mall_adminFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_mall_adminFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_mall_adminFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_mall_adminCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_mall_adminCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_mall_adminCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_mall_adminDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          update: {\n            args: Prisma.shopping_mall_adminUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_mall_adminDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_mall_adminUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_mall_adminUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_mall_adminUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_mall_adminPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_mall_adminAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_mall_admin>\n          }\n          groupBy: {\n            args: Prisma.shopping_mall_adminGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_adminGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_mall_adminCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_mall_adminCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sales: {\n        payload: Prisma.$shopping_salesPayload<ExtArgs>\n        fields: Prisma.shopping_salesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_salesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_salesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_salesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_salesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_salesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_salesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_salesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_salesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_salesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          update: {\n            args: Prisma.shopping_salesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_salesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_salesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_salesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_salesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_salesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_salesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sales>\n          }\n          groupBy: {\n            args: Prisma.shopping_salesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_salesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_salesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_salesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sale_snapshots: {\n        payload: Prisma.$shopping_sale_snapshotsPayload<ExtArgs>\n        fields: Prisma.shopping_sale_snapshotsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sale_snapshotsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sale_snapshotsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sale_snapshotsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sale_snapshotsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sale_snapshotsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sale_snapshotsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sale_snapshotsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sale_snapshotsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sale_snapshotsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          update: {\n            args: Prisma.shopping_sale_snapshotsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sale_snapshotsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sale_snapshotsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sale_snapshotsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sale_snapshotsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_snapshotsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sale_snapshotsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sale_snapshots>\n          }\n          groupBy: {\n            args: Prisma.shopping_sale_snapshotsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_snapshotsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sale_snapshotsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_snapshotsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sale_units: {\n        payload: Prisma.$shopping_sale_unitsPayload<ExtArgs>\n        fields: Prisma.shopping_sale_unitsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sale_unitsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sale_unitsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sale_unitsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sale_unitsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sale_unitsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sale_unitsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sale_unitsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sale_unitsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sale_unitsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          update: {\n            args: Prisma.shopping_sale_unitsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sale_unitsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sale_unitsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sale_unitsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sale_unitsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unitsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sale_unitsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sale_units>\n          }\n          groupBy: {\n            args: Prisma.shopping_sale_unitsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_unitsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sale_unitsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_unitsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sale_unit_options: {\n        payload: Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>\n        fields: Prisma.shopping_sale_unit_optionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sale_unit_optionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sale_unit_optionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sale_unit_optionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sale_unit_optionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sale_unit_optionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sale_unit_optionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sale_unit_optionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sale_unit_optionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sale_unit_optionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_sale_unit_optionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sale_unit_optionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sale_unit_optionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sale_unit_optionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sale_unit_optionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sale_unit_optionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sale_unit_optionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sale_unit_options>\n          }\n          groupBy: {\n            args: Prisma.shopping_sale_unit_optionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_unit_optionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sale_unit_optionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sale_unit_optionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_carts: {\n        payload: Prisma.$shopping_cartsPayload<ExtArgs>\n        fields: Prisma.shopping_cartsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_cartsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_cartsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_cartsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_cartsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_cartsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_cartsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_cartsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_cartsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_cartsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          update: {\n            args: Prisma.shopping_cartsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_cartsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_cartsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_cartsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_cartsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cartsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_cartsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_carts>\n          }\n          groupBy: {\n            args: Prisma.shopping_cartsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cartsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_cartsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cartsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_cart_items: {\n        payload: Prisma.$shopping_cart_itemsPayload<ExtArgs>\n        fields: Prisma.shopping_cart_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_cart_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_cart_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_cart_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_cart_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_cart_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_cart_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          update: {\n            args: Prisma.shopping_cart_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_cart_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_cart_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_cart_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_cart_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_cart_items>\n          }\n          groupBy: {\n            args: Prisma.shopping_cart_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cart_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_cart_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cart_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_orders: {\n        payload: Prisma.$shopping_ordersPayload<ExtArgs>\n        fields: Prisma.shopping_ordersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_ordersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_ordersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_ordersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_ordersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_ordersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_ordersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_ordersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_ordersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_ordersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          update: {\n            args: Prisma.shopping_ordersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_ordersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_ordersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_ordersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_ordersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_ordersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_orders>\n          }\n          groupBy: {\n            args: Prisma.shopping_ordersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_ordersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_ordersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_ordersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_order_snapshots: {\n        payload: Prisma.$shopping_order_snapshotsPayload<ExtArgs>\n        fields: Prisma.shopping_order_snapshotsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_order_snapshotsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_order_snapshotsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_order_snapshotsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_order_snapshotsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_order_snapshotsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_order_snapshotsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_order_snapshotsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_order_snapshotsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_order_snapshotsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          update: {\n            args: Prisma.shopping_order_snapshotsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_order_snapshotsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_order_snapshotsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_order_snapshotsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_order_snapshotsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_snapshotsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_order_snapshotsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_order_snapshots>\n          }\n          groupBy: {\n            args: Prisma.shopping_order_snapshotsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_snapshotsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_order_snapshotsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_snapshotsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_order_items: {\n        payload: Prisma.$shopping_order_itemsPayload<ExtArgs>\n        fields: Prisma.shopping_order_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_order_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_order_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_order_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_order_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_order_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_order_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_order_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_order_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          update: {\n            args: Prisma.shopping_order_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_order_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_order_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_order_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_order_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_order_items>\n          }\n          groupBy: {\n            args: Prisma.shopping_order_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_order_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_coupons: {\n        payload: Prisma.$shopping_couponsPayload<ExtArgs>\n        fields: Prisma.shopping_couponsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_couponsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_couponsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_couponsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_couponsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_couponsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_couponsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_couponsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_couponsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_couponsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          update: {\n            args: Prisma.shopping_couponsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_couponsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_couponsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_couponsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_couponsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_couponsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_couponsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_coupons>\n          }\n          groupBy: {\n            args: Prisma.shopping_couponsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_couponsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_couponsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_couponsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_coupon_usage: {\n        payload: Prisma.$shopping_coupon_usagePayload<ExtArgs>\n        fields: Prisma.shopping_coupon_usageFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_coupon_usageFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_coupon_usageFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_coupon_usageFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_coupon_usageFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          findMany: {\n            args: Prisma.shopping_coupon_usageFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>[]\n          }\n          create: {\n            args: Prisma.shopping_coupon_usageCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          createMany: {\n            args: Prisma.shopping_coupon_usageCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_coupon_usageCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_coupon_usageDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          update: {\n            args: Prisma.shopping_coupon_usageUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_coupon_usageDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_coupon_usageUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_coupon_usageUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_coupon_usageUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coupon_usagePayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_coupon_usageAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_coupon_usage>\n          }\n          groupBy: {\n            args: Prisma.shopping_coupon_usageGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coupon_usageGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_coupon_usageCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coupon_usageCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_coins: {\n        payload: Prisma.$shopping_coinsPayload<ExtArgs>\n        fields: Prisma.shopping_coinsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_coinsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_coinsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_coinsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_coinsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_coinsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_coinsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_coinsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_coinsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_coinsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          update: {\n            args: Prisma.shopping_coinsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_coinsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_coinsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_coinsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_coinsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coinsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_coinsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_coins>\n          }\n          groupBy: {\n            args: Prisma.shopping_coinsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coinsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_coinsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coinsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_coin_transactions: {\n        payload: Prisma.$shopping_coin_transactionsPayload<ExtArgs>\n        fields: Prisma.shopping_coin_transactionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_coin_transactionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_coin_transactionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_coin_transactionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_coin_transactionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_coin_transactionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_coin_transactionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_coin_transactionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_coin_transactionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_coin_transactionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_coin_transactionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_coin_transactionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_coin_transactionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_coin_transactionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_coin_transactionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_coin_transactionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_coin_transactionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_coin_transactions>\n          }\n          groupBy: {\n            args: Prisma.shopping_coin_transactionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coin_transactionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_coin_transactionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_coin_transactionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_inquiries: {\n        payload: Prisma.$shopping_inquiriesPayload<ExtArgs>\n        fields: Prisma.shopping_inquiriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_inquiriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_inquiriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_inquiriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_inquiriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_inquiriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_inquiriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_inquiriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_inquiriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_inquiriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          update: {\n            args: Prisma.shopping_inquiriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_inquiriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_inquiriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_inquiriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_inquiriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiriesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_inquiriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_inquiries>\n          }\n          groupBy: {\n            args: Prisma.shopping_inquiriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inquiriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_inquiriesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inquiriesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_inquiry_responses: {\n        payload: Prisma.$shopping_inquiry_responsesPayload<ExtArgs>\n        fields: Prisma.shopping_inquiry_responsesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_inquiry_responsesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_inquiry_responsesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_inquiry_responsesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_inquiry_responsesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_inquiry_responsesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_inquiry_responsesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_inquiry_responsesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_inquiry_responsesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_inquiry_responsesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          update: {\n            args: Prisma.shopping_inquiry_responsesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_inquiry_responsesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_inquiry_responsesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_inquiry_responsesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_inquiry_responsesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inquiry_responsesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_inquiry_responsesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_inquiry_responses>\n          }\n          groupBy: {\n            args: Prisma.shopping_inquiry_responsesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inquiry_responsesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_inquiry_responsesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inquiry_responsesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_favorites: {\n        payload: Prisma.$shopping_favoritesPayload<ExtArgs>\n        fields: Prisma.shopping_favoritesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_favoritesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_favoritesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_favoritesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_favoritesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_favoritesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_favoritesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_favoritesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_favoritesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_favoritesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          update: {\n            args: Prisma.shopping_favoritesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_favoritesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_favoritesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_favoritesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_favoritesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favoritesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_favoritesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_favorites>\n          }\n          groupBy: {\n            args: Prisma.shopping_favoritesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_favoritesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_favoritesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_favoritesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_favorite_items: {\n        payload: Prisma.$shopping_favorite_itemsPayload<ExtArgs>\n        fields: Prisma.shopping_favorite_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_favorite_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_favorite_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_favorite_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_favorite_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_favorite_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_favorite_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_favorite_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_favorite_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_favorite_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          update: {\n            args: Prisma.shopping_favorite_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_favorite_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_favorite_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_favorite_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_favorite_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_favorite_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_favorite_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_favorite_items>\n          }\n          groupBy: {\n            args: Prisma.shopping_favorite_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_favorite_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_favorite_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_favorite_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_articles: {\n        payload: Prisma.$shopping_articlesPayload<ExtArgs>\n        fields: Prisma.shopping_articlesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_articlesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_articlesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_articlesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_articlesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_articlesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_articlesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_articlesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_articlesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_articlesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          update: {\n            args: Prisma.shopping_articlesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_articlesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_articlesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_articlesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_articlesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_articlesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_articlesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_articles>\n          }\n          groupBy: {\n            args: Prisma.shopping_articlesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_articlesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_articlesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_articlesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_article_comments: {\n        payload: Prisma.$shopping_article_commentsPayload<ExtArgs>\n        fields: Prisma.shopping_article_commentsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_article_commentsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_article_commentsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_article_commentsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_article_commentsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_article_commentsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_article_commentsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_article_commentsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_article_commentsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_article_commentsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          update: {\n            args: Prisma.shopping_article_commentsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_article_commentsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_article_commentsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_article_commentsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_article_commentsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_article_commentsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_article_commentsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_article_comments>\n          }\n          groupBy: {\n            args: Prisma.shopping_article_commentsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_article_commentsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_article_commentsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_article_commentsCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    shopping_channels?: shopping_channelsOmit\n    shopping_sections?: shopping_sectionsOmit\n    shopping_configurations?: shopping_configurationsOmit\n    shopping_mall_guest?: shopping_mall_guestOmit\n    shopping_mall_member?: shopping_mall_memberOmit\n    shopping_mall_seller?: shopping_mall_sellerOmit\n    shopping_mall_admin?: shopping_mall_adminOmit\n    shopping_sales?: shopping_salesOmit\n    shopping_sale_snapshots?: shopping_sale_snapshotsOmit\n    shopping_sale_units?: shopping_sale_unitsOmit\n    shopping_sale_unit_options?: shopping_sale_unit_optionsOmit\n    shopping_carts?: shopping_cartsOmit\n    shopping_cart_items?: shopping_cart_itemsOmit\n    shopping_orders?: shopping_ordersOmit\n    shopping_order_snapshots?: shopping_order_snapshotsOmit\n    shopping_order_items?: shopping_order_itemsOmit\n    shopping_coupons?: shopping_couponsOmit\n    shopping_coupon_usage?: shopping_coupon_usageOmit\n    shopping_coins?: shopping_coinsOmit\n    shopping_coin_transactions?: shopping_coin_transactionsOmit\n    shopping_inquiries?: shopping_inquiriesOmit\n    shopping_inquiry_responses?: shopping_inquiry_responsesOmit\n    shopping_favorites?: shopping_favoritesOmit\n    shopping_favorite_items?: shopping_favorite_itemsOmit\n    shopping_articles?: shopping_articlesOmit\n    shopping_article_comments?: shopping_article_commentsOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Shopping_channelsCountOutputType\n   */\n\n  export type Shopping_channelsCountOutputType = {\n    shopping_sections: number\n    shopping_configurations: number\n    shopping_sales: number\n    shopping_articles: number\n  }\n\n  export type Shopping_channelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sections?: boolean | Shopping_channelsCountOutputTypeCountShopping_sectionsArgs\n    shopping_configurations?: boolean | Shopping_channelsCountOutputTypeCountShopping_configurationsArgs\n    shopping_sales?: boolean | Shopping_channelsCountOutputTypeCountShopping_salesArgs\n    shopping_articles?: boolean | Shopping_channelsCountOutputTypeCountShopping_articlesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_channelsCountOutputType\n     */\n    select?: Shopping_channelsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sectionsWhereInput\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_configurationsWhereInput\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_salesWhereInput\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_articlesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_sectionsCountOutputType\n   */\n\n  export type Shopping_sectionsCountOutputType = {\n    shopping_configurations: number\n    shopping_sales: number\n    shopping_articles: number\n  }\n\n  export type Shopping_sectionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_configurations?: boolean | Shopping_sectionsCountOutputTypeCountShopping_configurationsArgs\n    shopping_sales?: boolean | Shopping_sectionsCountOutputTypeCountShopping_salesArgs\n    shopping_articles?: boolean | Shopping_sectionsCountOutputTypeCountShopping_articlesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_sectionsCountOutputType\n     */\n    select?: Shopping_sectionsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeCountShopping_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_configurationsWhereInput\n  }\n\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeCountShopping_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_salesWhereInput\n  }\n\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeCountShopping_articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_articlesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_mall_memberCountOutputType\n   */\n\n  export type Shopping_mall_memberCountOutputType = {\n    shopping_carts: number\n    shopping_orders: number\n    shopping_coupon_usage: number\n    shopping_coin_transactions: number\n    shopping_inquiries: number\n    shopping_favorites: number\n    shopping_article_comments: number\n  }\n\n  export type Shopping_mall_memberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_carts?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_cartsArgs\n    shopping_orders?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_ordersArgs\n    shopping_coupon_usage?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_coupon_usageArgs\n    shopping_coin_transactions?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_coin_transactionsArgs\n    shopping_inquiries?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_inquiriesArgs\n    shopping_favorites?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_favoritesArgs\n    shopping_article_comments?: boolean | Shopping_mall_memberCountOutputTypeCountShopping_article_commentsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_mall_memberCountOutputType\n     */\n    select?: Shopping_mall_memberCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cartsWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_ordersWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_coupon_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coupon_usageWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_coin_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coin_transactionsWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inquiriesWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_favoritesWhereInput\n  }\n\n  /**\n   * Shopping_mall_memberCountOutputType without action\n   */\n  export type Shopping_mall_memberCountOutputTypeCountShopping_article_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_article_commentsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_mall_adminCountOutputType\n   */\n\n  export type Shopping_mall_adminCountOutputType = {\n    shopping_inquiry_responses: number\n  }\n\n  export type Shopping_mall_adminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_inquiry_responses?: boolean | Shopping_mall_adminCountOutputTypeCountShopping_inquiry_responsesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_mall_adminCountOutputType without action\n   */\n  export type Shopping_mall_adminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_mall_adminCountOutputType\n     */\n    select?: Shopping_mall_adminCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_mall_adminCountOutputType without action\n   */\n  export type Shopping_mall_adminCountOutputTypeCountShopping_inquiry_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inquiry_responsesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_salesCountOutputType\n   */\n\n  export type Shopping_salesCountOutputType = {\n    shopping_sale_snapshots: number\n    shopping_sale_units: number\n  }\n\n  export type Shopping_salesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sale_snapshots?: boolean | Shopping_salesCountOutputTypeCountShopping_sale_snapshotsArgs\n    shopping_sale_units?: boolean | Shopping_salesCountOutputTypeCountShopping_sale_unitsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_salesCountOutputType without action\n   */\n  export type Shopping_salesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_salesCountOutputType\n     */\n    select?: Shopping_salesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_salesCountOutputType without action\n   */\n  export type Shopping_salesCountOutputTypeCountShopping_sale_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_snapshotsWhereInput\n  }\n\n  /**\n   * Shopping_salesCountOutputType without action\n   */\n  export type Shopping_salesCountOutputTypeCountShopping_sale_unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_unitsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_sale_unitsCountOutputType\n   */\n\n  export type Shopping_sale_unitsCountOutputType = {\n    shopping_sale_unit_options: number\n    shopping_cart_items: number\n    shopping_favorite_items: number\n  }\n\n  export type Shopping_sale_unitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sale_unit_options?: boolean | Shopping_sale_unitsCountOutputTypeCountShopping_sale_unit_optionsArgs\n    shopping_cart_items?: boolean | Shopping_sale_unitsCountOutputTypeCountShopping_cart_itemsArgs\n    shopping_favorite_items?: boolean | Shopping_sale_unitsCountOutputTypeCountShopping_favorite_itemsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_sale_unitsCountOutputType without action\n   */\n  export type Shopping_sale_unitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_sale_unitsCountOutputType\n     */\n    select?: Shopping_sale_unitsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_sale_unitsCountOutputType without action\n   */\n  export type Shopping_sale_unitsCountOutputTypeCountShopping_sale_unit_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_unit_optionsWhereInput\n  }\n\n  /**\n   * Shopping_sale_unitsCountOutputType without action\n   */\n  export type Shopping_sale_unitsCountOutputTypeCountShopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n  }\n\n  /**\n   * Shopping_sale_unitsCountOutputType without action\n   */\n  export type Shopping_sale_unitsCountOutputTypeCountShopping_favorite_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_favorite_itemsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_cartsCountOutputType\n   */\n\n  export type Shopping_cartsCountOutputType = {\n    shopping_cart_items: number\n  }\n\n  export type Shopping_cartsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_cart_items?: boolean | Shopping_cartsCountOutputTypeCountShopping_cart_itemsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_cartsCountOutputType without action\n   */\n  export type Shopping_cartsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_cartsCountOutputType\n     */\n    select?: Shopping_cartsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_cartsCountOutputType without action\n   */\n  export type Shopping_cartsCountOutputTypeCountShopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_ordersCountOutputType\n   */\n\n  export type Shopping_ordersCountOutputType = {\n    shopping_order_snapshots: number\n    shopping_order_items: number\n    shopping_coin_transactions: number\n  }\n\n  export type Shopping_ordersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_order_snapshots?: boolean | Shopping_ordersCountOutputTypeCountShopping_order_snapshotsArgs\n    shopping_order_items?: boolean | Shopping_ordersCountOutputTypeCountShopping_order_itemsArgs\n    shopping_coin_transactions?: boolean | Shopping_ordersCountOutputTypeCountShopping_coin_transactionsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_ordersCountOutputType\n     */\n    select?: Shopping_ordersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_order_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_snapshotsWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_itemsWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_coin_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coin_transactionsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_couponsCountOutputType\n   */\n\n  export type Shopping_couponsCountOutputType = {\n    shopping_coupon_usage: number\n  }\n\n  export type Shopping_couponsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_coupon_usage?: boolean | Shopping_couponsCountOutputTypeCountShopping_coupon_usageArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_couponsCountOutputType without action\n   */\n  export type Shopping_couponsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_couponsCountOutputType\n     */\n    select?: Shopping_couponsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_couponsCountOutputType without action\n   */\n  export type Shopping_couponsCountOutputTypeCountShopping_coupon_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coupon_usageWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_inquiriesCountOutputType\n   */\n\n  export type Shopping_inquiriesCountOutputType = {\n    shopping_inquiry_responses: number\n  }\n\n  export type Shopping_inquiriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_inquiry_responses?: boolean | Shopping_inquiriesCountOutputTypeCountShopping_inquiry_responsesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_inquiriesCountOutputType without action\n   */\n  export type Shopping_inquiriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_inquiriesCountOutputType\n     */\n    select?: Shopping_inquiriesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_inquiriesCountOutputType without action\n   */\n  export type Shopping_inquiriesCountOutputTypeCountShopping_inquiry_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inquiry_responsesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_favoritesCountOutputType\n   */\n\n  export type Shopping_favoritesCountOutputType = {\n    shopping_favorite_items: number\n  }\n\n  export type Shopping_favoritesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_favorite_items?: boolean | Shopping_favoritesCountOutputTypeCountShopping_favorite_itemsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_favoritesCountOutputType without action\n   */\n  export type Shopping_favoritesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_favoritesCountOutputType\n     */\n    select?: Shopping_favoritesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_favoritesCountOutputType without action\n   */\n  export type Shopping_favoritesCountOutputTypeCountShopping_favorite_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_favorite_itemsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_articlesCountOutputType\n   */\n\n  export type Shopping_articlesCountOutputType = {\n    shopping_article_comments: number\n  }\n\n  export type Shopping_articlesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_article_comments?: boolean | Shopping_articlesCountOutputTypeCountShopping_article_commentsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_articlesCountOutputType without action\n   */\n  export type Shopping_articlesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_articlesCountOutputType\n     */\n    select?: Shopping_articlesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_articlesCountOutputType without action\n   */\n  export type Shopping_articlesCountOutputTypeCountShopping_article_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_article_commentsWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model shopping_channels\n   */\n\n  export type AggregateShopping_channels = {\n    _count: Shopping_channelsCountAggregateOutputType | null\n    _min: Shopping_channelsMinAggregateOutputType | null\n    _max: Shopping_channelsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_channelsMinAggregateOutputType = {\n    id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channelsMaxAggregateOutputType = {\n    id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channelsCountAggregateOutputType = {\n    id: number\n    code: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_channelsMinAggregateInputType = {\n    id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channelsMaxAggregateInputType = {\n    id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channelsCountAggregateInputType = {\n    id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_channelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channels to aggregate.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_channels\n    **/\n    _count?: true | Shopping_channelsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_channelsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_channelsMaxAggregateInputType\n  }\n\n  export type GetShopping_channelsAggregateType<T extends Shopping_channelsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_channels]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_channels[P]>\n      : GetScalarType<T[P], AggregateShopping_channels[P]>\n  }\n\n\n\n\n  export type shopping_channelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_channelsWhereInput\n    orderBy?: shopping_channelsOrderByWithAggregationInput | shopping_channelsOrderByWithAggregationInput[]\n    by: Shopping_channelsScalarFieldEnum[] | Shopping_channelsScalarFieldEnum\n    having?: shopping_channelsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_channelsCountAggregateInputType | true\n    _min?: Shopping_channelsMinAggregateInputType\n    _max?: Shopping_channelsMaxAggregateInputType\n  }\n\n  export type Shopping_channelsGroupByOutputType = {\n    id: string\n    code: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_channelsCountAggregateOutputType | null\n    _min: Shopping_channelsMinAggregateOutputType | null\n    _max: Shopping_channelsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_channelsGroupByPayload<T extends shopping_channelsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_channelsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_channelsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_channelsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_channelsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_channelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    shopping_sections?: boolean | shopping_channels$shopping_sectionsArgs<ExtArgs>\n    shopping_configurations?: boolean | shopping_channels$shopping_configurationsArgs<ExtArgs>\n    shopping_sales?: boolean | shopping_channels$shopping_salesArgs<ExtArgs>\n    shopping_articles?: boolean | shopping_channels$shopping_articlesArgs<ExtArgs>\n    _count?: boolean | Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectScalar = {\n    id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_channelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"code\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_channels\"]>\n  export type shopping_channelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sections?: boolean | shopping_channels$shopping_sectionsArgs<ExtArgs>\n    shopping_configurations?: boolean | shopping_channels$shopping_configurationsArgs<ExtArgs>\n    shopping_sales?: boolean | shopping_channels$shopping_salesArgs<ExtArgs>\n    shopping_articles?: boolean | shopping_channels$shopping_articlesArgs<ExtArgs>\n    _count?: boolean | Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_channelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_channelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_channelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_channels\"\n    objects: {\n      shopping_sections: Prisma.$shopping_sectionsPayload<ExtArgs>[]\n      shopping_configurations: Prisma.$shopping_configurationsPayload<ExtArgs>[]\n      shopping_sales: Prisma.$shopping_salesPayload<ExtArgs>[]\n      shopping_articles: Prisma.$shopping_articlesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Unique code identifying the channel.\n       */\n      code: string\n      /**\n       * Name of the channel.\n       */\n      name: string\n      /**\n       * Description of the channel.\n       */\n      description: string | null\n      /**\n       * Timestamp when the channel was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the channel was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the channel was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_channels\"]>\n    composites: {}\n  }\n\n  type shopping_channelsGetPayload<S extends boolean | null | undefined | shopping_channelsDefaultArgs> = $Result.GetResult<Prisma.$shopping_channelsPayload, S>\n\n  type shopping_channelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_channelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_channelsCountAggregateInputType | true\n    }\n\n  export interface shopping_channelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_channels'], meta: { name: 'shopping_channels' } }\n    /**\n     * Find zero or one Shopping_channels that matches the filter.\n     * @param {shopping_channelsFindUniqueArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_channelsFindUniqueArgs>(args: SelectSubset<T, shopping_channelsFindUniqueArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_channels that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_channelsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_channelsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_channelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channels that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindFirstArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_channelsFindFirstArgs>(args?: SelectSubset<T, shopping_channelsFindFirstArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channels that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindFirstOrThrowArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_channelsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_channelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_channels that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findMany()\n     * \n     * // Get first 10 Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_channelsFindManyArgs>(args?: SelectSubset<T, shopping_channelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_channels.\n     * @param {shopping_channelsCreateArgs} args - Arguments to create a Shopping_channels.\n     * @example\n     * // Create one Shopping_channels\n     * const Shopping_channels = await prisma.shopping_channels.create({\n     *   data: {\n     *     // ... data to create a Shopping_channels\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_channelsCreateArgs>(args: SelectSubset<T, shopping_channelsCreateArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_channels.\n     * @param {shopping_channelsCreateManyArgs} args - Arguments to create many Shopping_channels.\n     * @example\n     * // Create many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_channelsCreateManyArgs>(args?: SelectSubset<T, shopping_channelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_channels and returns the data saved in the database.\n     * @param {shopping_channelsCreateManyAndReturnArgs} args - Arguments to create many Shopping_channels.\n     * @example\n     * // Create many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_channels and only return the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_channelsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_channelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_channels.\n     * @param {shopping_channelsDeleteArgs} args - Arguments to delete one Shopping_channels.\n     * @example\n     * // Delete one Shopping_channels\n     * const Shopping_channels = await prisma.shopping_channels.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_channels\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_channelsDeleteArgs>(args: SelectSubset<T, shopping_channelsDeleteArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_channels.\n     * @param {shopping_channelsUpdateArgs} args - Arguments to update one Shopping_channels.\n     * @example\n     * // Update one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_channelsUpdateArgs>(args: SelectSubset<T, shopping_channelsUpdateArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_channels.\n     * @param {shopping_channelsDeleteManyArgs} args - Arguments to filter Shopping_channels to delete.\n     * @example\n     * // Delete a few Shopping_channels\n     * const { count } = await prisma.shopping_channels.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_channelsDeleteManyArgs>(args?: SelectSubset<T, shopping_channelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_channelsUpdateManyArgs>(args: SelectSubset<T, shopping_channelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channels and returns the data updated in the database.\n     * @param {shopping_channelsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_channels.\n     * @example\n     * // Update many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_channels and only return the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_channelsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_channelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_channels.\n     * @param {shopping_channelsUpsertArgs} args - Arguments to update or create a Shopping_channels.\n     * @example\n     * // Update or create a Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_channels\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_channels we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_channelsUpsertArgs>(args: SelectSubset<T, shopping_channelsUpsertArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsCountArgs} args - Arguments to filter Shopping_channels to count.\n     * @example\n     * // Count the number of Shopping_channels\n     * const count = await prisma.shopping_channels.count({\n     *   where: {\n     *     // ... the filter for the Shopping_channels we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_channelsCountArgs>(\n      args?: Subset<T, shopping_channelsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_channelsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_channelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_channelsAggregateArgs>(args: Subset<T, Shopping_channelsAggregateArgs>): Prisma.PrismaPromise<GetShopping_channelsAggregateType<T>>\n\n    /**\n     * Group by Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_channelsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_channelsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_channelsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_channelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_channelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_channels model\n   */\n  readonly fields: shopping_channelsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_channels.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_channelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_sections<T extends shopping_channels$shopping_sectionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_configurations<T extends shopping_channels$shopping_configurationsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_sales<T extends shopping_channels$shopping_salesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_articles<T extends shopping_channels$shopping_articlesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_channels model\n   */\n  interface shopping_channelsFieldRefs {\n    readonly id: FieldRef<\"shopping_channels\", 'String'>\n    readonly code: FieldRef<\"shopping_channels\", 'String'>\n    readonly name: FieldRef<\"shopping_channels\", 'String'>\n    readonly description: FieldRef<\"shopping_channels\", 'String'>\n    readonly created_at: FieldRef<\"shopping_channels\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_channels\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_channels\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_channels findUnique\n   */\n  export type shopping_channelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels findUniqueOrThrow\n   */\n  export type shopping_channelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels findFirst\n   */\n  export type shopping_channelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channels.\n     */\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels findFirstOrThrow\n   */\n  export type shopping_channelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channels.\n     */\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels findMany\n   */\n  export type shopping_channelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels create\n   */\n  export type shopping_channelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_channels.\n     */\n    data: XOR<shopping_channelsCreateInput, shopping_channelsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_channels createMany\n   */\n  export type shopping_channelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_channels.\n     */\n    data: shopping_channelsCreateManyInput | shopping_channelsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_channels createManyAndReturn\n   */\n  export type shopping_channelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_channels.\n     */\n    data: shopping_channelsCreateManyInput | shopping_channelsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_channels update\n   */\n  export type shopping_channelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateInput, shopping_channelsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_channels to update.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels updateMany\n   */\n  export type shopping_channelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateManyMutationInput, shopping_channelsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channels to update\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels updateManyAndReturn\n   */\n  export type shopping_channelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateManyMutationInput, shopping_channelsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channels to update\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels upsert\n   */\n  export type shopping_channelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_channels to update in case it exists.\n     */\n    where: shopping_channelsWhereUniqueInput\n    /**\n     * In case the shopping_channels found by the `where` argument doesn't exist, create a new shopping_channels with this data.\n     */\n    create: XOR<shopping_channelsCreateInput, shopping_channelsUncheckedCreateInput>\n    /**\n     * In case the shopping_channels was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_channelsUpdateInput, shopping_channelsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_channels delete\n   */\n  export type shopping_channelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_channels to delete.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels deleteMany\n   */\n  export type shopping_channelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channels to delete\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels.shopping_sections\n   */\n  export type shopping_channels$shopping_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    where?: shopping_sectionsWhereInput\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    cursor?: shopping_sectionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels.shopping_configurations\n   */\n  export type shopping_channels$shopping_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    where?: shopping_configurationsWhereInput\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    cursor?: shopping_configurationsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_configurationsScalarFieldEnum | Shopping_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels.shopping_sales\n   */\n  export type shopping_channels$shopping_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    where?: shopping_salesWhereInput\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    cursor?: shopping_salesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_salesScalarFieldEnum | Shopping_salesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels.shopping_articles\n   */\n  export type shopping_channels$shopping_articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    where?: shopping_articlesWhereInput\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    cursor?: shopping_articlesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_articlesScalarFieldEnum | Shopping_articlesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels without action\n   */\n  export type shopping_channelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sections\n   */\n\n  export type AggregateShopping_sections = {\n    _count: Shopping_sectionsCountAggregateOutputType | null\n    _min: Shopping_sectionsMinAggregateOutputType | null\n    _max: Shopping_sectionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sectionsMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sectionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sectionsCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    code: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_sectionsMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sectionsMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sectionsCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    code?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_sectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sections to aggregate.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sections\n    **/\n    _count?: true | Shopping_sectionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sectionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sectionsMaxAggregateInputType\n  }\n\n  export type GetShopping_sectionsAggregateType<T extends Shopping_sectionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sections]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sections[P]>\n      : GetScalarType<T[P], AggregateShopping_sections[P]>\n  }\n\n\n\n\n  export type shopping_sectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sectionsWhereInput\n    orderBy?: shopping_sectionsOrderByWithAggregationInput | shopping_sectionsOrderByWithAggregationInput[]\n    by: Shopping_sectionsScalarFieldEnum[] | Shopping_sectionsScalarFieldEnum\n    having?: shopping_sectionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sectionsCountAggregateInputType | true\n    _min?: Shopping_sectionsMinAggregateInputType\n    _max?: Shopping_sectionsMaxAggregateInputType\n  }\n\n  export type Shopping_sectionsGroupByOutputType = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_sectionsCountAggregateOutputType | null\n    _min: Shopping_sectionsMinAggregateOutputType | null\n    _max: Shopping_sectionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sectionsGroupByPayload<T extends shopping_sectionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sectionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sectionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sectionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sectionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    shopping_configurations?: boolean | shopping_sections$shopping_configurationsArgs<ExtArgs>\n    shopping_sales?: boolean | shopping_sections$shopping_salesArgs<ExtArgs>\n    shopping_articles?: boolean | shopping_sections$shopping_articlesArgs<ExtArgs>\n    _count?: boolean | Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_sectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"code\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_sections\"]>\n  export type shopping_sectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    shopping_configurations?: boolean | shopping_sections$shopping_configurationsArgs<ExtArgs>\n    shopping_sales?: boolean | shopping_sections$shopping_salesArgs<ExtArgs>\n    shopping_articles?: boolean | shopping_sections$shopping_articlesArgs<ExtArgs>\n    _count?: boolean | Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_sectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }\n  export type shopping_sectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_sectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sections\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs>\n      shopping_configurations: Prisma.$shopping_configurationsPayload<ExtArgs>[]\n      shopping_sales: Prisma.$shopping_salesPayload<ExtArgs>[]\n      shopping_articles: Prisma.$shopping_articlesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The channel to which this section belongs. {@link shopping_channels.id}\n       */\n      shopping_channel_id: string\n      /**\n       * Unique code identifying the section.\n       */\n      code: string\n      /**\n       * Name of the section.\n       */\n      name: string\n      /**\n       * Description of the section.\n       */\n      description: string | null\n      /**\n       * Timestamp when the section was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the section was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the section was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_sections\"]>\n    composites: {}\n  }\n\n  type shopping_sectionsGetPayload<S extends boolean | null | undefined | shopping_sectionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_sectionsPayload, S>\n\n  type shopping_sectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sectionsCountAggregateInputType | true\n    }\n\n  export interface shopping_sectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sections'], meta: { name: 'shopping_sections' } }\n    /**\n     * Find zero or one Shopping_sections that matches the filter.\n     * @param {shopping_sectionsFindUniqueArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sectionsFindUniqueArgs>(args: SelectSubset<T, shopping_sectionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sections that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sectionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sections that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindFirstArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sectionsFindFirstArgs>(args?: SelectSubset<T, shopping_sectionsFindFirstArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sections that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sections that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findMany()\n     * \n     * // Get first 10 Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sectionsFindManyArgs>(args?: SelectSubset<T, shopping_sectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sections.\n     * @param {shopping_sectionsCreateArgs} args - Arguments to create a Shopping_sections.\n     * @example\n     * // Create one Shopping_sections\n     * const Shopping_sections = await prisma.shopping_sections.create({\n     *   data: {\n     *     // ... data to create a Shopping_sections\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sectionsCreateArgs>(args: SelectSubset<T, shopping_sectionsCreateArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sections.\n     * @param {shopping_sectionsCreateManyArgs} args - Arguments to create many Shopping_sections.\n     * @example\n     * // Create many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sectionsCreateManyArgs>(args?: SelectSubset<T, shopping_sectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sections and returns the data saved in the database.\n     * @param {shopping_sectionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_sections.\n     * @example\n     * // Create many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sections and only return the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sections.\n     * @param {shopping_sectionsDeleteArgs} args - Arguments to delete one Shopping_sections.\n     * @example\n     * // Delete one Shopping_sections\n     * const Shopping_sections = await prisma.shopping_sections.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sections\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sectionsDeleteArgs>(args: SelectSubset<T, shopping_sectionsDeleteArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sections.\n     * @param {shopping_sectionsUpdateArgs} args - Arguments to update one Shopping_sections.\n     * @example\n     * // Update one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sectionsUpdateArgs>(args: SelectSubset<T, shopping_sectionsUpdateArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sections.\n     * @param {shopping_sectionsDeleteManyArgs} args - Arguments to filter Shopping_sections to delete.\n     * @example\n     * // Delete a few Shopping_sections\n     * const { count } = await prisma.shopping_sections.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sectionsDeleteManyArgs>(args?: SelectSubset<T, shopping_sectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sectionsUpdateManyArgs>(args: SelectSubset<T, shopping_sectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sections and returns the data updated in the database.\n     * @param {shopping_sectionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sections.\n     * @example\n     * // Update many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sections and only return the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sections.\n     * @param {shopping_sectionsUpsertArgs} args - Arguments to update or create a Shopping_sections.\n     * @example\n     * // Update or create a Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sections\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sections we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sectionsUpsertArgs>(args: SelectSubset<T, shopping_sectionsUpsertArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsCountArgs} args - Arguments to filter Shopping_sections to count.\n     * @example\n     * // Count the number of Shopping_sections\n     * const count = await prisma.shopping_sections.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sections we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sectionsCountArgs>(\n      args?: Subset<T, shopping_sectionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sectionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sectionsAggregateArgs>(args: Subset<T, Shopping_sectionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_sectionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sectionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sectionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sectionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sections model\n   */\n  readonly fields: shopping_sectionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sections.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channelsDefaultArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_configurations<T extends shopping_sections$shopping_configurationsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sections$shopping_configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_sales<T extends shopping_sections$shopping_salesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sections$shopping_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_articles<T extends shopping_sections$shopping_articlesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sections$shopping_articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sections model\n   */\n  interface shopping_sectionsFieldRefs {\n    readonly id: FieldRef<\"shopping_sections\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_sections\", 'String'>\n    readonly code: FieldRef<\"shopping_sections\", 'String'>\n    readonly name: FieldRef<\"shopping_sections\", 'String'>\n    readonly description: FieldRef<\"shopping_sections\", 'String'>\n    readonly created_at: FieldRef<\"shopping_sections\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_sections\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_sections\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sections findUnique\n   */\n  export type shopping_sectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections findUniqueOrThrow\n   */\n  export type shopping_sectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections findFirst\n   */\n  export type shopping_sectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sections.\n     */\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections findFirstOrThrow\n   */\n  export type shopping_sectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sections.\n     */\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections findMany\n   */\n  export type shopping_sectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections create\n   */\n  export type shopping_sectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sections.\n     */\n    data: XOR<shopping_sectionsCreateInput, shopping_sectionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sections createMany\n   */\n  export type shopping_sectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sections.\n     */\n    data: shopping_sectionsCreateManyInput | shopping_sectionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sections createManyAndReturn\n   */\n  export type shopping_sectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sections.\n     */\n    data: shopping_sectionsCreateManyInput | shopping_sectionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sections update\n   */\n  export type shopping_sectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateInput, shopping_sectionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sections to update.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections updateMany\n   */\n  export type shopping_sectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sections to update\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sections updateManyAndReturn\n   */\n  export type shopping_sectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sections to update\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sections upsert\n   */\n  export type shopping_sectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sections to update in case it exists.\n     */\n    where: shopping_sectionsWhereUniqueInput\n    /**\n     * In case the shopping_sections found by the `where` argument doesn't exist, create a new shopping_sections with this data.\n     */\n    create: XOR<shopping_sectionsCreateInput, shopping_sectionsUncheckedCreateInput>\n    /**\n     * In case the shopping_sections was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sectionsUpdateInput, shopping_sectionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sections delete\n   */\n  export type shopping_sectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sections to delete.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections deleteMany\n   */\n  export type shopping_sectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sections to delete\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sections.shopping_configurations\n   */\n  export type shopping_sections$shopping_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    where?: shopping_configurationsWhereInput\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    cursor?: shopping_configurationsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_configurationsScalarFieldEnum | Shopping_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections.shopping_sales\n   */\n  export type shopping_sections$shopping_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    where?: shopping_salesWhereInput\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    cursor?: shopping_salesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_salesScalarFieldEnum | Shopping_salesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections.shopping_articles\n   */\n  export type shopping_sections$shopping_articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    where?: shopping_articlesWhereInput\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    cursor?: shopping_articlesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_articlesScalarFieldEnum | Shopping_articlesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections without action\n   */\n  export type shopping_sectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_configurations\n   */\n\n  export type AggregateShopping_configurations = {\n    _count: Shopping_configurationsCountAggregateOutputType | null\n    _min: Shopping_configurationsMinAggregateOutputType | null\n    _max: Shopping_configurationsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_configurationsMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    key: string | null\n    value: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_configurationsMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    key: string | null\n    value: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_configurationsCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    shopping_section_id: number\n    key: number\n    value: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_configurationsMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_configurationsMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_configurationsCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_configurationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_configurations to aggregate.\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_configurations to fetch.\n     */\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_configurations\n    **/\n    _count?: true | Shopping_configurationsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_configurationsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_configurationsMaxAggregateInputType\n  }\n\n  export type GetShopping_configurationsAggregateType<T extends Shopping_configurationsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_configurations]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_configurations[P]>\n      : GetScalarType<T[P], AggregateShopping_configurations[P]>\n  }\n\n\n\n\n  export type shopping_configurationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_configurationsWhereInput\n    orderBy?: shopping_configurationsOrderByWithAggregationInput | shopping_configurationsOrderByWithAggregationInput[]\n    by: Shopping_configurationsScalarFieldEnum[] | Shopping_configurationsScalarFieldEnum\n    having?: shopping_configurationsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_configurationsCountAggregateInputType | true\n    _min?: Shopping_configurationsMinAggregateInputType\n    _max?: Shopping_configurationsMaxAggregateInputType\n  }\n\n  export type Shopping_configurationsGroupByOutputType = {\n    id: string\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    key: string\n    value: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_configurationsCountAggregateOutputType | null\n    _min: Shopping_configurationsMinAggregateOutputType | null\n    _max: Shopping_configurationsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_configurationsGroupByPayload<T extends shopping_configurationsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_configurationsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_configurationsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_configurationsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_configurationsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_configurationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_configurations\"]>\n\n  export type shopping_configurationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_configurations\"]>\n\n  export type shopping_configurationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_configurations\"]>\n\n  export type shopping_configurationsSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_configurationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"shopping_section_id\" | \"key\" | \"value\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_configurations\"]>\n  export type shopping_configurationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }\n  export type shopping_configurationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }\n  export type shopping_configurationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_configurations$channelArgs<ExtArgs>\n    section?: boolean | shopping_configurations$sectionArgs<ExtArgs>\n  }\n\n  export type $shopping_configurationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_configurations\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs> | null\n      section: Prisma.$shopping_sectionsPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The channel to which this configuration belongs. {@link\n       * shopping_channels.id}\n       */\n      shopping_channel_id: string | null\n      /**\n       * The section to which this configuration belongs. {@link\n       * shopping_sections.id}\n       */\n      shopping_section_id: string | null\n      /**\n       * Unique key identifying the configuration.\n       */\n      key: string\n      /**\n       * Value of the configuration.\n       */\n      value: string\n      /**\n       * Description of the configuration.\n       */\n      description: string | null\n      /**\n       * Timestamp when the configuration was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the configuration was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the configuration was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_configurations\"]>\n    composites: {}\n  }\n\n  type shopping_configurationsGetPayload<S extends boolean | null | undefined | shopping_configurationsDefaultArgs> = $Result.GetResult<Prisma.$shopping_configurationsPayload, S>\n\n  type shopping_configurationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_configurationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_configurationsCountAggregateInputType | true\n    }\n\n  export interface shopping_configurationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_configurations'], meta: { name: 'shopping_configurations' } }\n    /**\n     * Find zero or one Shopping_configurations that matches the filter.\n     * @param {shopping_configurationsFindUniqueArgs} args - Arguments to find a Shopping_configurations\n     * @example\n     * // Get one Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_configurationsFindUniqueArgs>(args: SelectSubset<T, shopping_configurationsFindUniqueArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_configurations that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_configurationsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_configurations\n     * @example\n     * // Get one Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_configurationsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_configurationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_configurations that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsFindFirstArgs} args - Arguments to find a Shopping_configurations\n     * @example\n     * // Get one Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_configurationsFindFirstArgs>(args?: SelectSubset<T, shopping_configurationsFindFirstArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_configurations that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsFindFirstOrThrowArgs} args - Arguments to find a Shopping_configurations\n     * @example\n     * // Get one Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_configurationsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_configurationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_configurations that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findMany()\n     * \n     * // Get first 10 Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_configurationsWithIdOnly = await prisma.shopping_configurations.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_configurationsFindManyArgs>(args?: SelectSubset<T, shopping_configurationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_configurations.\n     * @param {shopping_configurationsCreateArgs} args - Arguments to create a Shopping_configurations.\n     * @example\n     * // Create one Shopping_configurations\n     * const Shopping_configurations = await prisma.shopping_configurations.create({\n     *   data: {\n     *     // ... data to create a Shopping_configurations\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_configurationsCreateArgs>(args: SelectSubset<T, shopping_configurationsCreateArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_configurations.\n     * @param {shopping_configurationsCreateManyArgs} args - Arguments to create many Shopping_configurations.\n     * @example\n     * // Create many Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_configurationsCreateManyArgs>(args?: SelectSubset<T, shopping_configurationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_configurations and returns the data saved in the database.\n     * @param {shopping_configurationsCreateManyAndReturnArgs} args - Arguments to create many Shopping_configurations.\n     * @example\n     * // Create many Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_configurations and only return the `id`\n     * const shopping_configurationsWithIdOnly = await prisma.shopping_configurations.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_configurationsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_configurationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_configurations.\n     * @param {shopping_configurationsDeleteArgs} args - Arguments to delete one Shopping_configurations.\n     * @example\n     * // Delete one Shopping_configurations\n     * const Shopping_configurations = await prisma.shopping_configurations.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_configurations\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_configurationsDeleteArgs>(args: SelectSubset<T, shopping_configurationsDeleteArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_configurations.\n     * @param {shopping_configurationsUpdateArgs} args - Arguments to update one Shopping_configurations.\n     * @example\n     * // Update one Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_configurationsUpdateArgs>(args: SelectSubset<T, shopping_configurationsUpdateArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_configurations.\n     * @param {shopping_configurationsDeleteManyArgs} args - Arguments to filter Shopping_configurations to delete.\n     * @example\n     * // Delete a few Shopping_configurations\n     * const { count } = await prisma.shopping_configurations.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_configurationsDeleteManyArgs>(args?: SelectSubset<T, shopping_configurationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_configurationsUpdateManyArgs>(args: SelectSubset<T, shopping_configurationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_configurations and returns the data updated in the database.\n     * @param {shopping_configurationsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_configurations.\n     * @example\n     * // Update many Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_configurations and only return the `id`\n     * const shopping_configurationsWithIdOnly = await prisma.shopping_configurations.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_configurationsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_configurationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_configurations.\n     * @param {shopping_configurationsUpsertArgs} args - Arguments to update or create a Shopping_configurations.\n     * @example\n     * // Update or create a Shopping_configurations\n     * const shopping_configurations = await prisma.shopping_configurations.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_configurations\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_configurations we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_configurationsUpsertArgs>(args: SelectSubset<T, shopping_configurationsUpsertArgs<ExtArgs>>): Prisma__shopping_configurationsClient<$Result.GetResult<Prisma.$shopping_configurationsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsCountArgs} args - Arguments to filter Shopping_configurations to count.\n     * @example\n     * // Count the number of Shopping_configurations\n     * const count = await prisma.shopping_configurations.count({\n     *   where: {\n     *     // ... the filter for the Shopping_configurations we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_configurationsCountArgs>(\n      args?: Subset<T, shopping_configurationsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_configurationsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_configurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_configurationsAggregateArgs>(args: Subset<T, Shopping_configurationsAggregateArgs>): Prisma.PrismaPromise<GetShopping_configurationsAggregateType<T>>\n\n    /**\n     * Group by Shopping_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_configurationsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_configurationsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_configurationsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_configurationsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_configurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_configurationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_configurations model\n   */\n  readonly fields: shopping_configurationsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_configurations.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_configurationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_configurations$channelArgs<ExtArgs> = {}>(args?: Subset<T, shopping_configurations$channelArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    section<T extends shopping_configurations$sectionArgs<ExtArgs> = {}>(args?: Subset<T, shopping_configurations$sectionArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_configurations model\n   */\n  interface shopping_configurationsFieldRefs {\n    readonly id: FieldRef<\"shopping_configurations\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_configurations\", 'String'>\n    readonly shopping_section_id: FieldRef<\"shopping_configurations\", 'String'>\n    readonly key: FieldRef<\"shopping_configurations\", 'String'>\n    readonly value: FieldRef<\"shopping_configurations\", 'String'>\n    readonly description: FieldRef<\"shopping_configurations\", 'String'>\n    readonly created_at: FieldRef<\"shopping_configurations\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_configurations\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_configurations\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_configurations findUnique\n   */\n  export type shopping_configurationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_configurations to fetch.\n     */\n    where: shopping_configurationsWhereUniqueInput\n  }\n\n  /**\n   * shopping_configurations findUniqueOrThrow\n   */\n  export type shopping_configurationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_configurations to fetch.\n     */\n    where: shopping_configurationsWhereUniqueInput\n  }\n\n  /**\n   * shopping_configurations findFirst\n   */\n  export type shopping_configurationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_configurations to fetch.\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_configurations to fetch.\n     */\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_configurations.\n     */\n    cursor?: shopping_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_configurations.\n     */\n    distinct?: Shopping_configurationsScalarFieldEnum | Shopping_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_configurations findFirstOrThrow\n   */\n  export type shopping_configurationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_configurations to fetch.\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_configurations to fetch.\n     */\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_configurations.\n     */\n    cursor?: shopping_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_configurations.\n     */\n    distinct?: Shopping_configurationsScalarFieldEnum | Shopping_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_configurations findMany\n   */\n  export type shopping_configurationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_configurations to fetch.\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_configurations to fetch.\n     */\n    orderBy?: shopping_configurationsOrderByWithRelationInput | shopping_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_configurations.\n     */\n    cursor?: shopping_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_configurations.\n     */\n    skip?: number\n    distinct?: Shopping_configurationsScalarFieldEnum | Shopping_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_configurations create\n   */\n  export type shopping_configurationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_configurations.\n     */\n    data: XOR<shopping_configurationsCreateInput, shopping_configurationsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_configurations createMany\n   */\n  export type shopping_configurationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_configurations.\n     */\n    data: shopping_configurationsCreateManyInput | shopping_configurationsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_configurations createManyAndReturn\n   */\n  export type shopping_configurationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_configurations.\n     */\n    data: shopping_configurationsCreateManyInput | shopping_configurationsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_configurations update\n   */\n  export type shopping_configurationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_configurations.\n     */\n    data: XOR<shopping_configurationsUpdateInput, shopping_configurationsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_configurations to update.\n     */\n    where: shopping_configurationsWhereUniqueInput\n  }\n\n  /**\n   * shopping_configurations updateMany\n   */\n  export type shopping_configurationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_configurations.\n     */\n    data: XOR<shopping_configurationsUpdateManyMutationInput, shopping_configurationsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_configurations to update\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * Limit how many shopping_configurations to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_configurations updateManyAndReturn\n   */\n  export type shopping_configurationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_configurations.\n     */\n    data: XOR<shopping_configurationsUpdateManyMutationInput, shopping_configurationsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_configurations to update\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * Limit how many shopping_configurations to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_configurations upsert\n   */\n  export type shopping_configurationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_configurations to update in case it exists.\n     */\n    where: shopping_configurationsWhereUniqueInput\n    /**\n     * In case the shopping_configurations found by the `where` argument doesn't exist, create a new shopping_configurations with this data.\n     */\n    create: XOR<shopping_configurationsCreateInput, shopping_configurationsUncheckedCreateInput>\n    /**\n     * In case the shopping_configurations was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_configurationsUpdateInput, shopping_configurationsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_configurations delete\n   */\n  export type shopping_configurationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_configurations to delete.\n     */\n    where: shopping_configurationsWhereUniqueInput\n  }\n\n  /**\n   * shopping_configurations deleteMany\n   */\n  export type shopping_configurationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_configurations to delete\n     */\n    where?: shopping_configurationsWhereInput\n    /**\n     * Limit how many shopping_configurations to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_configurations.channel\n   */\n  export type shopping_configurations$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    where?: shopping_channelsWhereInput\n  }\n\n  /**\n   * shopping_configurations.section\n   */\n  export type shopping_configurations$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    where?: shopping_sectionsWhereInput\n  }\n\n  /**\n   * shopping_configurations without action\n   */\n  export type shopping_configurationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_configurations\n     */\n    select?: shopping_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_configurations\n     */\n    omit?: shopping_configurationsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_configurationsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_mall_guest\n   */\n\n  export type AggregateShopping_mall_guest = {\n    _count: Shopping_mall_guestCountAggregateOutputType | null\n    _min: Shopping_mall_guestMinAggregateOutputType | null\n    _max: Shopping_mall_guestMaxAggregateOutputType | null\n  }\n\n  export type Shopping_mall_guestMinAggregateOutputType = {\n    id: string | null\n    session_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_mall_guestMaxAggregateOutputType = {\n    id: string | null\n    session_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_mall_guestCountAggregateOutputType = {\n    id: number\n    session_id: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_mall_guestMinAggregateInputType = {\n    id?: true\n    session_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_mall_guestMaxAggregateInputType = {\n    id?: true\n    session_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_mall_guestCountAggregateInputType = {\n    id?: true\n    session_id?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_mall_guestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_guest to aggregate.\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_guests to fetch.\n     */\n    orderBy?: shopping_mall_guestOrderByWithRelationInput | shopping_mall_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_mall_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_mall_guests\n    **/\n    _count?: true | Shopping_mall_guestCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_mall_guestMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_mall_guestMaxAggregateInputType\n  }\n\n  export type GetShopping_mall_guestAggregateType<T extends Shopping_mall_guestAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_mall_guest]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_mall_guest[P]>\n      : GetScalarType<T[P], AggregateShopping_mall_guest[P]>\n  }\n\n\n\n\n  export type shopping_mall_guestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_mall_guestWhereInput\n    orderBy?: shopping_mall_guestOrderByWithAggregationInput | shopping_mall_guestOrderByWithAggregationInput[]\n    by: Shopping_mall_guestScalarFieldEnum[] | Shopping_mall_guestScalarFieldEnum\n    having?: shopping_mall_guestScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_mall_guestCountAggregateInputType | true\n    _min?: Shopping_mall_guestMinAggregateInputType\n    _max?: Shopping_mall_guestMaxAggregateInputType\n  }\n\n  export type Shopping_mall_guestGroupByOutputType = {\n    id: string\n    session_id: string\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_mall_guestCountAggregateOutputType | null\n    _min: Shopping_mall_guestMinAggregateOutputType | null\n    _max: Shopping_mall_guestMaxAggregateOutputType | null\n  }\n\n  type GetShopping_mall_guestGroupByPayload<T extends shopping_mall_guestGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_mall_guestGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_mall_guestGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_mall_guestGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_mall_guestGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_mall_guestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    session_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_guest\"]>\n\n  export type shopping_mall_guestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    session_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_guest\"]>\n\n  export type shopping_mall_guestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    session_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_guest\"]>\n\n  export type shopping_mall_guestSelectScalar = {\n    id?: boolean\n    session_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_mall_guestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"session_id\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_mall_guest\"]>\n\n  export type $shopping_mall_guestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_mall_guest\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Unique identifier for the guest session.\n       */\n      session_id: string\n      /**\n       * Timestamp when the guest record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the guest record was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_mall_guest\"]>\n    composites: {}\n  }\n\n  type shopping_mall_guestGetPayload<S extends boolean | null | undefined | shopping_mall_guestDefaultArgs> = $Result.GetResult<Prisma.$shopping_mall_guestPayload, S>\n\n  type shopping_mall_guestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_mall_guestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_mall_guestCountAggregateInputType | true\n    }\n\n  export interface shopping_mall_guestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_mall_guest'], meta: { name: 'shopping_mall_guest' } }\n    /**\n     * Find zero or one Shopping_mall_guest that matches the filter.\n     * @param {shopping_mall_guestFindUniqueArgs} args - Arguments to find a Shopping_mall_guest\n     * @example\n     * // Get one Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_mall_guestFindUniqueArgs>(args: SelectSubset<T, shopping_mall_guestFindUniqueArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_mall_guest that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_mall_guestFindUniqueOrThrowArgs} args - Arguments to find a Shopping_mall_guest\n     * @example\n     * // Get one Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_mall_guestFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_mall_guestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_guest that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestFindFirstArgs} args - Arguments to find a Shopping_mall_guest\n     * @example\n     * // Get one Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_mall_guestFindFirstArgs>(args?: SelectSubset<T, shopping_mall_guestFindFirstArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_guest that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestFindFirstOrThrowArgs} args - Arguments to find a Shopping_mall_guest\n     * @example\n     * // Get one Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_mall_guestFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_mall_guestFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_mall_guests that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_mall_guests\n     * const shopping_mall_guests = await prisma.shopping_mall_guest.findMany()\n     * \n     * // Get first 10 Shopping_mall_guests\n     * const shopping_mall_guests = await prisma.shopping_mall_guest.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_mall_guestWithIdOnly = await prisma.shopping_mall_guest.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_mall_guestFindManyArgs>(args?: SelectSubset<T, shopping_mall_guestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_mall_guest.\n     * @param {shopping_mall_guestCreateArgs} args - Arguments to create a Shopping_mall_guest.\n     * @example\n     * // Create one Shopping_mall_guest\n     * const Shopping_mall_guest = await prisma.shopping_mall_guest.create({\n     *   data: {\n     *     // ... data to create a Shopping_mall_guest\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_mall_guestCreateArgs>(args: SelectSubset<T, shopping_mall_guestCreateArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_mall_guests.\n     * @param {shopping_mall_guestCreateManyArgs} args - Arguments to create many Shopping_mall_guests.\n     * @example\n     * // Create many Shopping_mall_guests\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_mall_guestCreateManyArgs>(args?: SelectSubset<T, shopping_mall_guestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_mall_guests and returns the data saved in the database.\n     * @param {shopping_mall_guestCreateManyAndReturnArgs} args - Arguments to create many Shopping_mall_guests.\n     * @example\n     * // Create many Shopping_mall_guests\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_mall_guests and only return the `id`\n     * const shopping_mall_guestWithIdOnly = await prisma.shopping_mall_guest.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_mall_guestCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_mall_guestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_mall_guest.\n     * @param {shopping_mall_guestDeleteArgs} args - Arguments to delete one Shopping_mall_guest.\n     * @example\n     * // Delete one Shopping_mall_guest\n     * const Shopping_mall_guest = await prisma.shopping_mall_guest.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_mall_guest\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_mall_guestDeleteArgs>(args: SelectSubset<T, shopping_mall_guestDeleteArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_mall_guest.\n     * @param {shopping_mall_guestUpdateArgs} args - Arguments to update one Shopping_mall_guest.\n     * @example\n     * // Update one Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_mall_guestUpdateArgs>(args: SelectSubset<T, shopping_mall_guestUpdateArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_mall_guests.\n     * @param {shopping_mall_guestDeleteManyArgs} args - Arguments to filter Shopping_mall_guests to delete.\n     * @example\n     * // Delete a few Shopping_mall_guests\n     * const { count } = await prisma.shopping_mall_guest.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_mall_guestDeleteManyArgs>(args?: SelectSubset<T, shopping_mall_guestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_mall_guests\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_mall_guestUpdateManyArgs>(args: SelectSubset<T, shopping_mall_guestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_guests and returns the data updated in the database.\n     * @param {shopping_mall_guestUpdateManyAndReturnArgs} args - Arguments to update many Shopping_mall_guests.\n     * @example\n     * // Update many Shopping_mall_guests\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_mall_guests and only return the `id`\n     * const shopping_mall_guestWithIdOnly = await prisma.shopping_mall_guest.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_mall_guestUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_mall_guestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_mall_guest.\n     * @param {shopping_mall_guestUpsertArgs} args - Arguments to update or create a Shopping_mall_guest.\n     * @example\n     * // Update or create a Shopping_mall_guest\n     * const shopping_mall_guest = await prisma.shopping_mall_guest.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_mall_guest\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_mall_guest we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_mall_guestUpsertArgs>(args: SelectSubset<T, shopping_mall_guestUpsertArgs<ExtArgs>>): Prisma__shopping_mall_guestClient<$Result.GetResult<Prisma.$shopping_mall_guestPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_mall_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestCountArgs} args - Arguments to filter Shopping_mall_guests to count.\n     * @example\n     * // Count the number of Shopping_mall_guests\n     * const count = await prisma.shopping_mall_guest.count({\n     *   where: {\n     *     // ... the filter for the Shopping_mall_guests we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_mall_guestCountArgs>(\n      args?: Subset<T, shopping_mall_guestCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_mall_guestCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_mall_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_mall_guestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_mall_guestAggregateArgs>(args: Subset<T, Shopping_mall_guestAggregateArgs>): Prisma.PrismaPromise<GetShopping_mall_guestAggregateType<T>>\n\n    /**\n     * Group by Shopping_mall_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_guestGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_mall_guestGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_mall_guestGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_mall_guestGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_mall_guestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_mall_guestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_mall_guest model\n   */\n  readonly fields: shopping_mall_guestFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_mall_guest.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_mall_guestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_mall_guest model\n   */\n  interface shopping_mall_guestFieldRefs {\n    readonly id: FieldRef<\"shopping_mall_guest\", 'String'>\n    readonly session_id: FieldRef<\"shopping_mall_guest\", 'String'>\n    readonly created_at: FieldRef<\"shopping_mall_guest\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_mall_guest\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_mall_guest findUnique\n   */\n  export type shopping_mall_guestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_guest to fetch.\n     */\n    where: shopping_mall_guestWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_guest findUniqueOrThrow\n   */\n  export type shopping_mall_guestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_guest to fetch.\n     */\n    where: shopping_mall_guestWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_guest findFirst\n   */\n  export type shopping_mall_guestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_guest to fetch.\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_guests to fetch.\n     */\n    orderBy?: shopping_mall_guestOrderByWithRelationInput | shopping_mall_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_guests.\n     */\n    cursor?: shopping_mall_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_guests.\n     */\n    distinct?: Shopping_mall_guestScalarFieldEnum | Shopping_mall_guestScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_guest findFirstOrThrow\n   */\n  export type shopping_mall_guestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_guest to fetch.\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_guests to fetch.\n     */\n    orderBy?: shopping_mall_guestOrderByWithRelationInput | shopping_mall_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_guests.\n     */\n    cursor?: shopping_mall_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_guests.\n     */\n    distinct?: Shopping_mall_guestScalarFieldEnum | Shopping_mall_guestScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_guest findMany\n   */\n  export type shopping_mall_guestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_guests to fetch.\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_guests to fetch.\n     */\n    orderBy?: shopping_mall_guestOrderByWithRelationInput | shopping_mall_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_mall_guests.\n     */\n    cursor?: shopping_mall_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_guests.\n     */\n    skip?: number\n    distinct?: Shopping_mall_guestScalarFieldEnum | Shopping_mall_guestScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_guest create\n   */\n  export type shopping_mall_guestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_mall_guest.\n     */\n    data: XOR<shopping_mall_guestCreateInput, shopping_mall_guestUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_mall_guest createMany\n   */\n  export type shopping_mall_guestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_mall_guests.\n     */\n    data: shopping_mall_guestCreateManyInput | shopping_mall_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_guest createManyAndReturn\n   */\n  export type shopping_mall_guestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_mall_guests.\n     */\n    data: shopping_mall_guestCreateManyInput | shopping_mall_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_guest update\n   */\n  export type shopping_mall_guestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_mall_guest.\n     */\n    data: XOR<shopping_mall_guestUpdateInput, shopping_mall_guestUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_mall_guest to update.\n     */\n    where: shopping_mall_guestWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_guest updateMany\n   */\n  export type shopping_mall_guestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_mall_guests.\n     */\n    data: XOR<shopping_mall_guestUpdateManyMutationInput, shopping_mall_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_guests to update\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * Limit how many shopping_mall_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_guest updateManyAndReturn\n   */\n  export type shopping_mall_guestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_mall_guests.\n     */\n    data: XOR<shopping_mall_guestUpdateManyMutationInput, shopping_mall_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_guests to update\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * Limit how many shopping_mall_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_guest upsert\n   */\n  export type shopping_mall_guestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_mall_guest to update in case it exists.\n     */\n    where: shopping_mall_guestWhereUniqueInput\n    /**\n     * In case the shopping_mall_guest found by the `where` argument doesn't exist, create a new shopping_mall_guest with this data.\n     */\n    create: XOR<shopping_mall_guestCreateInput, shopping_mall_guestUncheckedCreateInput>\n    /**\n     * In case the shopping_mall_guest was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_mall_guestUpdateInput, shopping_mall_guestUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_mall_guest delete\n   */\n  export type shopping_mall_guestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n    /**\n     * Filter which shopping_mall_guest to delete.\n     */\n    where: shopping_mall_guestWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_guest deleteMany\n   */\n  export type shopping_mall_guestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_guests to delete\n     */\n    where?: shopping_mall_guestWhereInput\n    /**\n     * Limit how many shopping_mall_guests to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_guest without action\n   */\n  export type shopping_mall_guestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_guest\n     */\n    select?: shopping_mall_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_guest\n     */\n    omit?: shopping_mall_guestOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_mall_member\n   */\n\n  export type AggregateShopping_mall_member = {\n    _count: Shopping_mall_memberCountAggregateOutputType | null\n    _min: Shopping_mall_memberMinAggregateOutputType | null\n    _max: Shopping_mall_memberMaxAggregateOutputType | null\n  }\n\n  export type Shopping_mall_memberMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_memberMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_memberCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    phone: number\n    address: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_mall_memberMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_memberMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_memberCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_mall_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_member to aggregate.\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_members to fetch.\n     */\n    orderBy?: shopping_mall_memberOrderByWithRelationInput | shopping_mall_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_mall_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_mall_members\n    **/\n    _count?: true | Shopping_mall_memberCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_mall_memberMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_mall_memberMaxAggregateInputType\n  }\n\n  export type GetShopping_mall_memberAggregateType<T extends Shopping_mall_memberAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_mall_member]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_mall_member[P]>\n      : GetScalarType<T[P], AggregateShopping_mall_member[P]>\n  }\n\n\n\n\n  export type shopping_mall_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_mall_memberWhereInput\n    orderBy?: shopping_mall_memberOrderByWithAggregationInput | shopping_mall_memberOrderByWithAggregationInput[]\n    by: Shopping_mall_memberScalarFieldEnum[] | Shopping_mall_memberScalarFieldEnum\n    having?: shopping_mall_memberScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_mall_memberCountAggregateInputType | true\n    _min?: Shopping_mall_memberMinAggregateInputType\n    _max?: Shopping_mall_memberMaxAggregateInputType\n  }\n\n  export type Shopping_mall_memberGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone: string | null\n    address: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_mall_memberCountAggregateOutputType | null\n    _min: Shopping_mall_memberMinAggregateOutputType | null\n    _max: Shopping_mall_memberMaxAggregateOutputType | null\n  }\n\n  type GetShopping_mall_memberGroupByPayload<T extends shopping_mall_memberGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_mall_memberGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_mall_memberGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_mall_memberGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_mall_memberGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_mall_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    shopping_carts?: boolean | shopping_mall_member$shopping_cartsArgs<ExtArgs>\n    shopping_orders?: boolean | shopping_mall_member$shopping_ordersArgs<ExtArgs>\n    shopping_coupon_usage?: boolean | shopping_mall_member$shopping_coupon_usageArgs<ExtArgs>\n    shopping_coins?: boolean | shopping_mall_member$shopping_coinsArgs<ExtArgs>\n    shopping_coin_transactions?: boolean | shopping_mall_member$shopping_coin_transactionsArgs<ExtArgs>\n    shopping_inquiries?: boolean | shopping_mall_member$shopping_inquiriesArgs<ExtArgs>\n    shopping_favorites?: boolean | shopping_mall_member$shopping_favoritesArgs<ExtArgs>\n    shopping_article_comments?: boolean | shopping_mall_member$shopping_article_commentsArgs<ExtArgs>\n    _count?: boolean | Shopping_mall_memberCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_mall_member\"]>\n\n  export type shopping_mall_memberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_member\"]>\n\n  export type shopping_mall_memberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_member\"]>\n\n  export type shopping_mall_memberSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_mall_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"phone\" | \"address\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_mall_member\"]>\n  export type shopping_mall_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_carts?: boolean | shopping_mall_member$shopping_cartsArgs<ExtArgs>\n    shopping_orders?: boolean | shopping_mall_member$shopping_ordersArgs<ExtArgs>\n    shopping_coupon_usage?: boolean | shopping_mall_member$shopping_coupon_usageArgs<ExtArgs>\n    shopping_coins?: boolean | shopping_mall_member$shopping_coinsArgs<ExtArgs>\n    shopping_coin_transactions?: boolean | shopping_mall_member$shopping_coin_transactionsArgs<ExtArgs>\n    shopping_inquiries?: boolean | shopping_mall_member$shopping_inquiriesArgs<ExtArgs>\n    shopping_favorites?: boolean | shopping_mall_member$shopping_favoritesArgs<ExtArgs>\n    shopping_article_comments?: boolean | shopping_mall_member$shopping_article_commentsArgs<ExtArgs>\n    _count?: boolean | Shopping_mall_memberCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_mall_memberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_mall_memberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_mall_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_mall_member\"\n    objects: {\n      shopping_carts: Prisma.$shopping_cartsPayload<ExtArgs>[]\n      shopping_orders: Prisma.$shopping_ordersPayload<ExtArgs>[]\n      shopping_coupon_usage: Prisma.$shopping_coupon_usagePayload<ExtArgs>[]\n      shopping_coins: Prisma.$shopping_coinsPayload<ExtArgs> | null\n      shopping_coin_transactions: Prisma.$shopping_coin_transactionsPayload<ExtArgs>[]\n      shopping_inquiries: Prisma.$shopping_inquiriesPayload<ExtArgs>[]\n      shopping_favorites: Prisma.$shopping_favoritesPayload<ExtArgs>[]\n      shopping_article_comments: Prisma.$shopping_article_commentsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Email address of the member.\n       */\n      email: string\n      /**\n       * Hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Full name of the member.\n       */\n      name: string\n      /**\n       * Phone number of the member.\n       */\n      phone: string | null\n      /**\n       * Shipping address of the member.\n       */\n      address: string | null\n      /**\n       * Timestamp when the member record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the member record was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the member record was soft deleted.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_mall_member\"]>\n    composites: {}\n  }\n\n  type shopping_mall_memberGetPayload<S extends boolean | null | undefined | shopping_mall_memberDefaultArgs> = $Result.GetResult<Prisma.$shopping_mall_memberPayload, S>\n\n  type shopping_mall_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_mall_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_mall_memberCountAggregateInputType | true\n    }\n\n  export interface shopping_mall_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_mall_member'], meta: { name: 'shopping_mall_member' } }\n    /**\n     * Find zero or one Shopping_mall_member that matches the filter.\n     * @param {shopping_mall_memberFindUniqueArgs} args - Arguments to find a Shopping_mall_member\n     * @example\n     * // Get one Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_mall_memberFindUniqueArgs>(args: SelectSubset<T, shopping_mall_memberFindUniqueArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_mall_member that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_mall_memberFindUniqueOrThrowArgs} args - Arguments to find a Shopping_mall_member\n     * @example\n     * // Get one Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_mall_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_mall_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_member that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberFindFirstArgs} args - Arguments to find a Shopping_mall_member\n     * @example\n     * // Get one Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_mall_memberFindFirstArgs>(args?: SelectSubset<T, shopping_mall_memberFindFirstArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_member that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberFindFirstOrThrowArgs} args - Arguments to find a Shopping_mall_member\n     * @example\n     * // Get one Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_mall_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_mall_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_mall_members that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_mall_members\n     * const shopping_mall_members = await prisma.shopping_mall_member.findMany()\n     * \n     * // Get first 10 Shopping_mall_members\n     * const shopping_mall_members = await prisma.shopping_mall_member.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_mall_memberWithIdOnly = await prisma.shopping_mall_member.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_mall_memberFindManyArgs>(args?: SelectSubset<T, shopping_mall_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_mall_member.\n     * @param {shopping_mall_memberCreateArgs} args - Arguments to create a Shopping_mall_member.\n     * @example\n     * // Create one Shopping_mall_member\n     * const Shopping_mall_member = await prisma.shopping_mall_member.create({\n     *   data: {\n     *     // ... data to create a Shopping_mall_member\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_mall_memberCreateArgs>(args: SelectSubset<T, shopping_mall_memberCreateArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_mall_members.\n     * @param {shopping_mall_memberCreateManyArgs} args - Arguments to create many Shopping_mall_members.\n     * @example\n     * // Create many Shopping_mall_members\n     * const shopping_mall_member = await prisma.shopping_mall_member.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_mall_memberCreateManyArgs>(args?: SelectSubset<T, shopping_mall_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_mall_members and returns the data saved in the database.\n     * @param {shopping_mall_memberCreateManyAndReturnArgs} args - Arguments to create many Shopping_mall_members.\n     * @example\n     * // Create many Shopping_mall_members\n     * const shopping_mall_member = await prisma.shopping_mall_member.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_mall_members and only return the `id`\n     * const shopping_mall_memberWithIdOnly = await prisma.shopping_mall_member.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_mall_memberCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_mall_memberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_mall_member.\n     * @param {shopping_mall_memberDeleteArgs} args - Arguments to delete one Shopping_mall_member.\n     * @example\n     * // Delete one Shopping_mall_member\n     * const Shopping_mall_member = await prisma.shopping_mall_member.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_mall_member\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_mall_memberDeleteArgs>(args: SelectSubset<T, shopping_mall_memberDeleteArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_mall_member.\n     * @param {shopping_mall_memberUpdateArgs} args - Arguments to update one Shopping_mall_member.\n     * @example\n     * // Update one Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_mall_memberUpdateArgs>(args: SelectSubset<T, shopping_mall_memberUpdateArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_mall_members.\n     * @param {shopping_mall_memberDeleteManyArgs} args - Arguments to filter Shopping_mall_members to delete.\n     * @example\n     * // Delete a few Shopping_mall_members\n     * const { count } = await prisma.shopping_mall_member.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_mall_memberDeleteManyArgs>(args?: SelectSubset<T, shopping_mall_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_members.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_mall_members\n     * const shopping_mall_member = await prisma.shopping_mall_member.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_mall_memberUpdateManyArgs>(args: SelectSubset<T, shopping_mall_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_members and returns the data updated in the database.\n     * @param {shopping_mall_memberUpdateManyAndReturnArgs} args - Arguments to update many Shopping_mall_members.\n     * @example\n     * // Update many Shopping_mall_members\n     * const shopping_mall_member = await prisma.shopping_mall_member.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_mall_members and only return the `id`\n     * const shopping_mall_memberWithIdOnly = await prisma.shopping_mall_member.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_mall_memberUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_mall_memberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_mall_member.\n     * @param {shopping_mall_memberUpsertArgs} args - Arguments to update or create a Shopping_mall_member.\n     * @example\n     * // Update or create a Shopping_mall_member\n     * const shopping_mall_member = await prisma.shopping_mall_member.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_mall_member\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_mall_member we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_mall_memberUpsertArgs>(args: SelectSubset<T, shopping_mall_memberUpsertArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_mall_members.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberCountArgs} args - Arguments to filter Shopping_mall_members to count.\n     * @example\n     * // Count the number of Shopping_mall_members\n     * const count = await prisma.shopping_mall_member.count({\n     *   where: {\n     *     // ... the filter for the Shopping_mall_members we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_mall_memberCountArgs>(\n      args?: Subset<T, shopping_mall_memberCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_mall_memberCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_mall_member.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_mall_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_mall_memberAggregateArgs>(args: Subset<T, Shopping_mall_memberAggregateArgs>): Prisma.PrismaPromise<GetShopping_mall_memberAggregateType<T>>\n\n    /**\n     * Group by Shopping_mall_member.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_memberGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_mall_memberGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_mall_memberGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_mall_memberGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_mall_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_mall_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_mall_member model\n   */\n  readonly fields: shopping_mall_memberFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_mall_member.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_mall_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_carts<T extends shopping_mall_member$shopping_cartsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_orders<T extends shopping_mall_member$shopping_ordersArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_coupon_usage<T extends shopping_mall_member$shopping_coupon_usageArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_coupon_usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_coins<T extends shopping_mall_member$shopping_coinsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_coinsArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    shopping_coin_transactions<T extends shopping_mall_member$shopping_coin_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_coin_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_inquiries<T extends shopping_mall_member$shopping_inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_favorites<T extends shopping_mall_member$shopping_favoritesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_article_comments<T extends shopping_mall_member$shopping_article_commentsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_member$shopping_article_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_mall_member model\n   */\n  interface shopping_mall_memberFieldRefs {\n    readonly id: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly email: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly name: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly phone: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly address: FieldRef<\"shopping_mall_member\", 'String'>\n    readonly created_at: FieldRef<\"shopping_mall_member\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_mall_member\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_mall_member\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_mall_member findUnique\n   */\n  export type shopping_mall_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_member to fetch.\n     */\n    where: shopping_mall_memberWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_member findUniqueOrThrow\n   */\n  export type shopping_mall_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_member to fetch.\n     */\n    where: shopping_mall_memberWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_member findFirst\n   */\n  export type shopping_mall_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_member to fetch.\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_members to fetch.\n     */\n    orderBy?: shopping_mall_memberOrderByWithRelationInput | shopping_mall_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_members.\n     */\n    cursor?: shopping_mall_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_members.\n     */\n    distinct?: Shopping_mall_memberScalarFieldEnum | Shopping_mall_memberScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member findFirstOrThrow\n   */\n  export type shopping_mall_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_member to fetch.\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_members to fetch.\n     */\n    orderBy?: shopping_mall_memberOrderByWithRelationInput | shopping_mall_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_members.\n     */\n    cursor?: shopping_mall_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_members.\n     */\n    distinct?: Shopping_mall_memberScalarFieldEnum | Shopping_mall_memberScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member findMany\n   */\n  export type shopping_mall_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_members to fetch.\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_members to fetch.\n     */\n    orderBy?: shopping_mall_memberOrderByWithRelationInput | shopping_mall_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_mall_members.\n     */\n    cursor?: shopping_mall_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_members.\n     */\n    skip?: number\n    distinct?: Shopping_mall_memberScalarFieldEnum | Shopping_mall_memberScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member create\n   */\n  export type shopping_mall_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_mall_member.\n     */\n    data: XOR<shopping_mall_memberCreateInput, shopping_mall_memberUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_mall_member createMany\n   */\n  export type shopping_mall_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_mall_members.\n     */\n    data: shopping_mall_memberCreateManyInput | shopping_mall_memberCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_member createManyAndReturn\n   */\n  export type shopping_mall_memberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_mall_members.\n     */\n    data: shopping_mall_memberCreateManyInput | shopping_mall_memberCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_member update\n   */\n  export type shopping_mall_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_mall_member.\n     */\n    data: XOR<shopping_mall_memberUpdateInput, shopping_mall_memberUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_mall_member to update.\n     */\n    where: shopping_mall_memberWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_member updateMany\n   */\n  export type shopping_mall_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_mall_members.\n     */\n    data: XOR<shopping_mall_memberUpdateManyMutationInput, shopping_mall_memberUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_members to update\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * Limit how many shopping_mall_members to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_member updateManyAndReturn\n   */\n  export type shopping_mall_memberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_mall_members.\n     */\n    data: XOR<shopping_mall_memberUpdateManyMutationInput, shopping_mall_memberUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_members to update\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * Limit how many shopping_mall_members to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_member upsert\n   */\n  export type shopping_mall_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_mall_member to update in case it exists.\n     */\n    where: shopping_mall_memberWhereUniqueInput\n    /**\n     * In case the shopping_mall_member found by the `where` argument doesn't exist, create a new shopping_mall_member with this data.\n     */\n    create: XOR<shopping_mall_memberCreateInput, shopping_mall_memberUncheckedCreateInput>\n    /**\n     * In case the shopping_mall_member was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_mall_memberUpdateInput, shopping_mall_memberUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_mall_member delete\n   */\n  export type shopping_mall_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_mall_member to delete.\n     */\n    where: shopping_mall_memberWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_member deleteMany\n   */\n  export type shopping_mall_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_members to delete\n     */\n    where?: shopping_mall_memberWhereInput\n    /**\n     * Limit how many shopping_mall_members to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_member.shopping_carts\n   */\n  export type shopping_mall_member$shopping_cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    where?: shopping_cartsWhereInput\n    orderBy?: shopping_cartsOrderByWithRelationInput | shopping_cartsOrderByWithRelationInput[]\n    cursor?: shopping_cartsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_cartsScalarFieldEnum | Shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_orders\n   */\n  export type shopping_mall_member$shopping_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    where?: shopping_ordersWhereInput\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    cursor?: shopping_ordersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_coupon_usage\n   */\n  export type shopping_mall_member$shopping_coupon_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    where?: shopping_coupon_usageWhereInput\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_coupon_usageScalarFieldEnum | Shopping_coupon_usageScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_coins\n   */\n  export type shopping_mall_member$shopping_coinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    where?: shopping_coinsWhereInput\n  }\n\n  /**\n   * shopping_mall_member.shopping_coin_transactions\n   */\n  export type shopping_mall_member$shopping_coin_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    where?: shopping_coin_transactionsWhereInput\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_coin_transactionsScalarFieldEnum | Shopping_coin_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_inquiries\n   */\n  export type shopping_mall_member$shopping_inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    where?: shopping_inquiriesWhereInput\n    orderBy?: shopping_inquiriesOrderByWithRelationInput | shopping_inquiriesOrderByWithRelationInput[]\n    cursor?: shopping_inquiriesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_inquiriesScalarFieldEnum | Shopping_inquiriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_favorites\n   */\n  export type shopping_mall_member$shopping_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    where?: shopping_favoritesWhereInput\n    orderBy?: shopping_favoritesOrderByWithRelationInput | shopping_favoritesOrderByWithRelationInput[]\n    cursor?: shopping_favoritesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_favoritesScalarFieldEnum | Shopping_favoritesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member.shopping_article_comments\n   */\n  export type shopping_mall_member$shopping_article_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    where?: shopping_article_commentsWhereInput\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    cursor?: shopping_article_commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_article_commentsScalarFieldEnum | Shopping_article_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_member without action\n   */\n  export type shopping_mall_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_member\n     */\n    select?: shopping_mall_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_member\n     */\n    omit?: shopping_mall_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_memberInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_mall_seller\n   */\n\n  export type AggregateShopping_mall_seller = {\n    _count: Shopping_mall_sellerCountAggregateOutputType | null\n    _min: Shopping_mall_sellerMinAggregateOutputType | null\n    _max: Shopping_mall_sellerMaxAggregateOutputType | null\n  }\n\n  export type Shopping_mall_sellerMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    business_name: string | null\n    business_address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_sellerMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    business_name: string | null\n    business_address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_sellerCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    phone: number\n    business_name: number\n    business_address: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_mall_sellerMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    business_name?: true\n    business_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_sellerMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    business_name?: true\n    business_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_sellerCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    business_name?: true\n    business_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_mall_sellerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_seller to aggregate.\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_sellers to fetch.\n     */\n    orderBy?: shopping_mall_sellerOrderByWithRelationInput | shopping_mall_sellerOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_mall_sellerWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_mall_sellers\n    **/\n    _count?: true | Shopping_mall_sellerCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_mall_sellerMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_mall_sellerMaxAggregateInputType\n  }\n\n  export type GetShopping_mall_sellerAggregateType<T extends Shopping_mall_sellerAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_mall_seller]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_mall_seller[P]>\n      : GetScalarType<T[P], AggregateShopping_mall_seller[P]>\n  }\n\n\n\n\n  export type shopping_mall_sellerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_mall_sellerWhereInput\n    orderBy?: shopping_mall_sellerOrderByWithAggregationInput | shopping_mall_sellerOrderByWithAggregationInput[]\n    by: Shopping_mall_sellerScalarFieldEnum[] | Shopping_mall_sellerScalarFieldEnum\n    having?: shopping_mall_sellerScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_mall_sellerCountAggregateInputType | true\n    _min?: Shopping_mall_sellerMinAggregateInputType\n    _max?: Shopping_mall_sellerMaxAggregateInputType\n  }\n\n  export type Shopping_mall_sellerGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone: string | null\n    business_name: string\n    business_address: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_mall_sellerCountAggregateOutputType | null\n    _min: Shopping_mall_sellerMinAggregateOutputType | null\n    _max: Shopping_mall_sellerMaxAggregateOutputType | null\n  }\n\n  type GetShopping_mall_sellerGroupByPayload<T extends shopping_mall_sellerGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_mall_sellerGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_mall_sellerGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_mall_sellerGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_mall_sellerGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_mall_sellerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    business_name?: boolean\n    business_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_seller\"]>\n\n  export type shopping_mall_sellerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    business_name?: boolean\n    business_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_seller\"]>\n\n  export type shopping_mall_sellerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    business_name?: boolean\n    business_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_seller\"]>\n\n  export type shopping_mall_sellerSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    business_name?: boolean\n    business_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_mall_sellerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"phone\" | \"business_name\" | \"business_address\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_mall_seller\"]>\n\n  export type $shopping_mall_sellerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_mall_seller\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Email address of the seller.\n       */\n      email: string\n      /**\n       * Hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Full name of the seller.\n       */\n      name: string\n      /**\n       * Phone number of the seller.\n       */\n      phone: string | null\n      /**\n       * Business name of the seller.\n       */\n      business_name: string\n      /**\n       * Business address of the seller.\n       */\n      business_address: string\n      /**\n       * Timestamp when the seller record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the seller record was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the seller record was soft deleted.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_mall_seller\"]>\n    composites: {}\n  }\n\n  type shopping_mall_sellerGetPayload<S extends boolean | null | undefined | shopping_mall_sellerDefaultArgs> = $Result.GetResult<Prisma.$shopping_mall_sellerPayload, S>\n\n  type shopping_mall_sellerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_mall_sellerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_mall_sellerCountAggregateInputType | true\n    }\n\n  export interface shopping_mall_sellerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_mall_seller'], meta: { name: 'shopping_mall_seller' } }\n    /**\n     * Find zero or one Shopping_mall_seller that matches the filter.\n     * @param {shopping_mall_sellerFindUniqueArgs} args - Arguments to find a Shopping_mall_seller\n     * @example\n     * // Get one Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_mall_sellerFindUniqueArgs>(args: SelectSubset<T, shopping_mall_sellerFindUniqueArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_mall_seller that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_mall_sellerFindUniqueOrThrowArgs} args - Arguments to find a Shopping_mall_seller\n     * @example\n     * // Get one Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_mall_sellerFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_mall_sellerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_seller that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerFindFirstArgs} args - Arguments to find a Shopping_mall_seller\n     * @example\n     * // Get one Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_mall_sellerFindFirstArgs>(args?: SelectSubset<T, shopping_mall_sellerFindFirstArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_seller that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerFindFirstOrThrowArgs} args - Arguments to find a Shopping_mall_seller\n     * @example\n     * // Get one Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_mall_sellerFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_mall_sellerFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_mall_sellers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_mall_sellers\n     * const shopping_mall_sellers = await prisma.shopping_mall_seller.findMany()\n     * \n     * // Get first 10 Shopping_mall_sellers\n     * const shopping_mall_sellers = await prisma.shopping_mall_seller.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_mall_sellerWithIdOnly = await prisma.shopping_mall_seller.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_mall_sellerFindManyArgs>(args?: SelectSubset<T, shopping_mall_sellerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_mall_seller.\n     * @param {shopping_mall_sellerCreateArgs} args - Arguments to create a Shopping_mall_seller.\n     * @example\n     * // Create one Shopping_mall_seller\n     * const Shopping_mall_seller = await prisma.shopping_mall_seller.create({\n     *   data: {\n     *     // ... data to create a Shopping_mall_seller\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_mall_sellerCreateArgs>(args: SelectSubset<T, shopping_mall_sellerCreateArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_mall_sellers.\n     * @param {shopping_mall_sellerCreateManyArgs} args - Arguments to create many Shopping_mall_sellers.\n     * @example\n     * // Create many Shopping_mall_sellers\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_mall_sellerCreateManyArgs>(args?: SelectSubset<T, shopping_mall_sellerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_mall_sellers and returns the data saved in the database.\n     * @param {shopping_mall_sellerCreateManyAndReturnArgs} args - Arguments to create many Shopping_mall_sellers.\n     * @example\n     * // Create many Shopping_mall_sellers\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_mall_sellers and only return the `id`\n     * const shopping_mall_sellerWithIdOnly = await prisma.shopping_mall_seller.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_mall_sellerCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_mall_sellerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_mall_seller.\n     * @param {shopping_mall_sellerDeleteArgs} args - Arguments to delete one Shopping_mall_seller.\n     * @example\n     * // Delete one Shopping_mall_seller\n     * const Shopping_mall_seller = await prisma.shopping_mall_seller.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_mall_seller\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_mall_sellerDeleteArgs>(args: SelectSubset<T, shopping_mall_sellerDeleteArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_mall_seller.\n     * @param {shopping_mall_sellerUpdateArgs} args - Arguments to update one Shopping_mall_seller.\n     * @example\n     * // Update one Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_mall_sellerUpdateArgs>(args: SelectSubset<T, shopping_mall_sellerUpdateArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_mall_sellers.\n     * @param {shopping_mall_sellerDeleteManyArgs} args - Arguments to filter Shopping_mall_sellers to delete.\n     * @example\n     * // Delete a few Shopping_mall_sellers\n     * const { count } = await prisma.shopping_mall_seller.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_mall_sellerDeleteManyArgs>(args?: SelectSubset<T, shopping_mall_sellerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_mall_sellers\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_mall_sellerUpdateManyArgs>(args: SelectSubset<T, shopping_mall_sellerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_sellers and returns the data updated in the database.\n     * @param {shopping_mall_sellerUpdateManyAndReturnArgs} args - Arguments to update many Shopping_mall_sellers.\n     * @example\n     * // Update many Shopping_mall_sellers\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_mall_sellers and only return the `id`\n     * const shopping_mall_sellerWithIdOnly = await prisma.shopping_mall_seller.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_mall_sellerUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_mall_sellerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_mall_seller.\n     * @param {shopping_mall_sellerUpsertArgs} args - Arguments to update or create a Shopping_mall_seller.\n     * @example\n     * // Update or create a Shopping_mall_seller\n     * const shopping_mall_seller = await prisma.shopping_mall_seller.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_mall_seller\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_mall_seller we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_mall_sellerUpsertArgs>(args: SelectSubset<T, shopping_mall_sellerUpsertArgs<ExtArgs>>): Prisma__shopping_mall_sellerClient<$Result.GetResult<Prisma.$shopping_mall_sellerPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_mall_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerCountArgs} args - Arguments to filter Shopping_mall_sellers to count.\n     * @example\n     * // Count the number of Shopping_mall_sellers\n     * const count = await prisma.shopping_mall_seller.count({\n     *   where: {\n     *     // ... the filter for the Shopping_mall_sellers we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_mall_sellerCountArgs>(\n      args?: Subset<T, shopping_mall_sellerCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_mall_sellerCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_mall_seller.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_mall_sellerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_mall_sellerAggregateArgs>(args: Subset<T, Shopping_mall_sellerAggregateArgs>): Prisma.PrismaPromise<GetShopping_mall_sellerAggregateType<T>>\n\n    /**\n     * Group by Shopping_mall_seller.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_sellerGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_mall_sellerGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_mall_sellerGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_mall_sellerGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_mall_sellerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_mall_sellerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_mall_seller model\n   */\n  readonly fields: shopping_mall_sellerFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_mall_seller.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_mall_sellerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_mall_seller model\n   */\n  interface shopping_mall_sellerFieldRefs {\n    readonly id: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly email: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly name: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly phone: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly business_name: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly business_address: FieldRef<\"shopping_mall_seller\", 'String'>\n    readonly created_at: FieldRef<\"shopping_mall_seller\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_mall_seller\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_mall_seller\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_mall_seller findUnique\n   */\n  export type shopping_mall_sellerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_seller to fetch.\n     */\n    where: shopping_mall_sellerWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_seller findUniqueOrThrow\n   */\n  export type shopping_mall_sellerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_seller to fetch.\n     */\n    where: shopping_mall_sellerWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_seller findFirst\n   */\n  export type shopping_mall_sellerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_seller to fetch.\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_sellers to fetch.\n     */\n    orderBy?: shopping_mall_sellerOrderByWithRelationInput | shopping_mall_sellerOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_sellers.\n     */\n    cursor?: shopping_mall_sellerWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_sellers.\n     */\n    distinct?: Shopping_mall_sellerScalarFieldEnum | Shopping_mall_sellerScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_seller findFirstOrThrow\n   */\n  export type shopping_mall_sellerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_seller to fetch.\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_sellers to fetch.\n     */\n    orderBy?: shopping_mall_sellerOrderByWithRelationInput | shopping_mall_sellerOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_sellers.\n     */\n    cursor?: shopping_mall_sellerWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_sellers.\n     */\n    distinct?: Shopping_mall_sellerScalarFieldEnum | Shopping_mall_sellerScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_seller findMany\n   */\n  export type shopping_mall_sellerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_sellers to fetch.\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_sellers to fetch.\n     */\n    orderBy?: shopping_mall_sellerOrderByWithRelationInput | shopping_mall_sellerOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_mall_sellers.\n     */\n    cursor?: shopping_mall_sellerWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_sellers.\n     */\n    skip?: number\n    distinct?: Shopping_mall_sellerScalarFieldEnum | Shopping_mall_sellerScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_seller create\n   */\n  export type shopping_mall_sellerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_mall_seller.\n     */\n    data: XOR<shopping_mall_sellerCreateInput, shopping_mall_sellerUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_mall_seller createMany\n   */\n  export type shopping_mall_sellerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_mall_sellers.\n     */\n    data: shopping_mall_sellerCreateManyInput | shopping_mall_sellerCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_seller createManyAndReturn\n   */\n  export type shopping_mall_sellerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_mall_sellers.\n     */\n    data: shopping_mall_sellerCreateManyInput | shopping_mall_sellerCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_seller update\n   */\n  export type shopping_mall_sellerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_mall_seller.\n     */\n    data: XOR<shopping_mall_sellerUpdateInput, shopping_mall_sellerUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_mall_seller to update.\n     */\n    where: shopping_mall_sellerWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_seller updateMany\n   */\n  export type shopping_mall_sellerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_mall_sellers.\n     */\n    data: XOR<shopping_mall_sellerUpdateManyMutationInput, shopping_mall_sellerUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_sellers to update\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * Limit how many shopping_mall_sellers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_seller updateManyAndReturn\n   */\n  export type shopping_mall_sellerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_mall_sellers.\n     */\n    data: XOR<shopping_mall_sellerUpdateManyMutationInput, shopping_mall_sellerUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_sellers to update\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * Limit how many shopping_mall_sellers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_seller upsert\n   */\n  export type shopping_mall_sellerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_mall_seller to update in case it exists.\n     */\n    where: shopping_mall_sellerWhereUniqueInput\n    /**\n     * In case the shopping_mall_seller found by the `where` argument doesn't exist, create a new shopping_mall_seller with this data.\n     */\n    create: XOR<shopping_mall_sellerCreateInput, shopping_mall_sellerUncheckedCreateInput>\n    /**\n     * In case the shopping_mall_seller was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_mall_sellerUpdateInput, shopping_mall_sellerUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_mall_seller delete\n   */\n  export type shopping_mall_sellerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n    /**\n     * Filter which shopping_mall_seller to delete.\n     */\n    where: shopping_mall_sellerWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_seller deleteMany\n   */\n  export type shopping_mall_sellerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_sellers to delete\n     */\n    where?: shopping_mall_sellerWhereInput\n    /**\n     * Limit how many shopping_mall_sellers to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_seller without action\n   */\n  export type shopping_mall_sellerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_seller\n     */\n    select?: shopping_mall_sellerSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_seller\n     */\n    omit?: shopping_mall_sellerOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_mall_admin\n   */\n\n  export type AggregateShopping_mall_admin = {\n    _count: Shopping_mall_adminCountAggregateOutputType | null\n    _min: Shopping_mall_adminMinAggregateOutputType | null\n    _max: Shopping_mall_adminMaxAggregateOutputType | null\n  }\n\n  export type Shopping_mall_adminMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    role: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_adminMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    role: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_mall_adminCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    phone: number\n    role: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_mall_adminMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_adminMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_mall_adminCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_mall_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_admin to aggregate.\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_admins to fetch.\n     */\n    orderBy?: shopping_mall_adminOrderByWithRelationInput | shopping_mall_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_mall_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_mall_admins\n    **/\n    _count?: true | Shopping_mall_adminCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_mall_adminMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_mall_adminMaxAggregateInputType\n  }\n\n  export type GetShopping_mall_adminAggregateType<T extends Shopping_mall_adminAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_mall_admin]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_mall_admin[P]>\n      : GetScalarType<T[P], AggregateShopping_mall_admin[P]>\n  }\n\n\n\n\n  export type shopping_mall_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_mall_adminWhereInput\n    orderBy?: shopping_mall_adminOrderByWithAggregationInput | shopping_mall_adminOrderByWithAggregationInput[]\n    by: Shopping_mall_adminScalarFieldEnum[] | Shopping_mall_adminScalarFieldEnum\n    having?: shopping_mall_adminScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_mall_adminCountAggregateInputType | true\n    _min?: Shopping_mall_adminMinAggregateInputType\n    _max?: Shopping_mall_adminMaxAggregateInputType\n  }\n\n  export type Shopping_mall_adminGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone: string | null\n    role: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_mall_adminCountAggregateOutputType | null\n    _min: Shopping_mall_adminMinAggregateOutputType | null\n    _max: Shopping_mall_adminMaxAggregateOutputType | null\n  }\n\n  type GetShopping_mall_adminGroupByPayload<T extends shopping_mall_adminGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_mall_adminGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_mall_adminGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_mall_adminGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_mall_adminGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_mall_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    shopping_inquiry_responses?: boolean | shopping_mall_admin$shopping_inquiry_responsesArgs<ExtArgs>\n    _count?: boolean | Shopping_mall_adminCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_mall_admin\"]>\n\n  export type shopping_mall_adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_admin\"]>\n\n  export type shopping_mall_adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_mall_admin\"]>\n\n  export type shopping_mall_adminSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_mall_adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"phone\" | \"role\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_mall_admin\"]>\n  export type shopping_mall_adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_inquiry_responses?: boolean | shopping_mall_admin$shopping_inquiry_responsesArgs<ExtArgs>\n    _count?: boolean | Shopping_mall_adminCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_mall_adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_mall_adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_mall_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_mall_admin\"\n    objects: {\n      shopping_inquiry_responses: Prisma.$shopping_inquiry_responsesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Email address of the admin.\n       */\n      email: string\n      /**\n       * Hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Full name of the admin.\n       */\n      name: string\n      /**\n       * Phone number of the admin.\n       */\n      phone: string | null\n      /**\n       * Role of the admin (e.g., superadmin, moderator).\n       */\n      role: string\n      /**\n       * Timestamp when the admin record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the admin record was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the admin record was soft deleted.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_mall_admin\"]>\n    composites: {}\n  }\n\n  type shopping_mall_adminGetPayload<S extends boolean | null | undefined | shopping_mall_adminDefaultArgs> = $Result.GetResult<Prisma.$shopping_mall_adminPayload, S>\n\n  type shopping_mall_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_mall_adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_mall_adminCountAggregateInputType | true\n    }\n\n  export interface shopping_mall_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_mall_admin'], meta: { name: 'shopping_mall_admin' } }\n    /**\n     * Find zero or one Shopping_mall_admin that matches the filter.\n     * @param {shopping_mall_adminFindUniqueArgs} args - Arguments to find a Shopping_mall_admin\n     * @example\n     * // Get one Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_mall_adminFindUniqueArgs>(args: SelectSubset<T, shopping_mall_adminFindUniqueArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_mall_admin that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_mall_adminFindUniqueOrThrowArgs} args - Arguments to find a Shopping_mall_admin\n     * @example\n     * // Get one Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_mall_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_mall_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_admin that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminFindFirstArgs} args - Arguments to find a Shopping_mall_admin\n     * @example\n     * // Get one Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_mall_adminFindFirstArgs>(args?: SelectSubset<T, shopping_mall_adminFindFirstArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_mall_admin that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminFindFirstOrThrowArgs} args - Arguments to find a Shopping_mall_admin\n     * @example\n     * // Get one Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_mall_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_mall_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_mall_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_mall_admins\n     * const shopping_mall_admins = await prisma.shopping_mall_admin.findMany()\n     * \n     * // Get first 10 Shopping_mall_admins\n     * const shopping_mall_admins = await prisma.shopping_mall_admin.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_mall_adminWithIdOnly = await prisma.shopping_mall_admin.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_mall_adminFindManyArgs>(args?: SelectSubset<T, shopping_mall_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_mall_admin.\n     * @param {shopping_mall_adminCreateArgs} args - Arguments to create a Shopping_mall_admin.\n     * @example\n     * // Create one Shopping_mall_admin\n     * const Shopping_mall_admin = await prisma.shopping_mall_admin.create({\n     *   data: {\n     *     // ... data to create a Shopping_mall_admin\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_mall_adminCreateArgs>(args: SelectSubset<T, shopping_mall_adminCreateArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_mall_admins.\n     * @param {shopping_mall_adminCreateManyArgs} args - Arguments to create many Shopping_mall_admins.\n     * @example\n     * // Create many Shopping_mall_admins\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_mall_adminCreateManyArgs>(args?: SelectSubset<T, shopping_mall_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_mall_admins and returns the data saved in the database.\n     * @param {shopping_mall_adminCreateManyAndReturnArgs} args - Arguments to create many Shopping_mall_admins.\n     * @example\n     * // Create many Shopping_mall_admins\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_mall_admins and only return the `id`\n     * const shopping_mall_adminWithIdOnly = await prisma.shopping_mall_admin.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_mall_adminCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_mall_adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_mall_admin.\n     * @param {shopping_mall_adminDeleteArgs} args - Arguments to delete one Shopping_mall_admin.\n     * @example\n     * // Delete one Shopping_mall_admin\n     * const Shopping_mall_admin = await prisma.shopping_mall_admin.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_mall_admin\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_mall_adminDeleteArgs>(args: SelectSubset<T, shopping_mall_adminDeleteArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_mall_admin.\n     * @param {shopping_mall_adminUpdateArgs} args - Arguments to update one Shopping_mall_admin.\n     * @example\n     * // Update one Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_mall_adminUpdateArgs>(args: SelectSubset<T, shopping_mall_adminUpdateArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_mall_admins.\n     * @param {shopping_mall_adminDeleteManyArgs} args - Arguments to filter Shopping_mall_admins to delete.\n     * @example\n     * // Delete a few Shopping_mall_admins\n     * const { count } = await prisma.shopping_mall_admin.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_mall_adminDeleteManyArgs>(args?: SelectSubset<T, shopping_mall_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_mall_admins\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_mall_adminUpdateManyArgs>(args: SelectSubset<T, shopping_mall_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_mall_admins and returns the data updated in the database.\n     * @param {shopping_mall_adminUpdateManyAndReturnArgs} args - Arguments to update many Shopping_mall_admins.\n     * @example\n     * // Update many Shopping_mall_admins\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_mall_admins and only return the `id`\n     * const shopping_mall_adminWithIdOnly = await prisma.shopping_mall_admin.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_mall_adminUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_mall_adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_mall_admin.\n     * @param {shopping_mall_adminUpsertArgs} args - Arguments to update or create a Shopping_mall_admin.\n     * @example\n     * // Update or create a Shopping_mall_admin\n     * const shopping_mall_admin = await prisma.shopping_mall_admin.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_mall_admin\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_mall_admin we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_mall_adminUpsertArgs>(args: SelectSubset<T, shopping_mall_adminUpsertArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_mall_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminCountArgs} args - Arguments to filter Shopping_mall_admins to count.\n     * @example\n     * // Count the number of Shopping_mall_admins\n     * const count = await prisma.shopping_mall_admin.count({\n     *   where: {\n     *     // ... the filter for the Shopping_mall_admins we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_mall_adminCountArgs>(\n      args?: Subset<T, shopping_mall_adminCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_mall_adminCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_mall_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_mall_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_mall_adminAggregateArgs>(args: Subset<T, Shopping_mall_adminAggregateArgs>): Prisma.PrismaPromise<GetShopping_mall_adminAggregateType<T>>\n\n    /**\n     * Group by Shopping_mall_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_mall_adminGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_mall_adminGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_mall_adminGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_mall_adminGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_mall_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_mall_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_mall_admin model\n   */\n  readonly fields: shopping_mall_adminFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_mall_admin.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_mall_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_inquiry_responses<T extends shopping_mall_admin$shopping_inquiry_responsesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_admin$shopping_inquiry_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_mall_admin model\n   */\n  interface shopping_mall_adminFieldRefs {\n    readonly id: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly email: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly name: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly phone: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly role: FieldRef<\"shopping_mall_admin\", 'String'>\n    readonly created_at: FieldRef<\"shopping_mall_admin\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_mall_admin\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_mall_admin\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_mall_admin findUnique\n   */\n  export type shopping_mall_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_admin to fetch.\n     */\n    where: shopping_mall_adminWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_admin findUniqueOrThrow\n   */\n  export type shopping_mall_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_admin to fetch.\n     */\n    where: shopping_mall_adminWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_admin findFirst\n   */\n  export type shopping_mall_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_admin to fetch.\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_admins to fetch.\n     */\n    orderBy?: shopping_mall_adminOrderByWithRelationInput | shopping_mall_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_admins.\n     */\n    cursor?: shopping_mall_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_admins.\n     */\n    distinct?: Shopping_mall_adminScalarFieldEnum | Shopping_mall_adminScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_admin findFirstOrThrow\n   */\n  export type shopping_mall_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_admin to fetch.\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_admins to fetch.\n     */\n    orderBy?: shopping_mall_adminOrderByWithRelationInput | shopping_mall_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_mall_admins.\n     */\n    cursor?: shopping_mall_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_mall_admins.\n     */\n    distinct?: Shopping_mall_adminScalarFieldEnum | Shopping_mall_adminScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_admin findMany\n   */\n  export type shopping_mall_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_mall_admins to fetch.\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_mall_admins to fetch.\n     */\n    orderBy?: shopping_mall_adminOrderByWithRelationInput | shopping_mall_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_mall_admins.\n     */\n    cursor?: shopping_mall_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_mall_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_mall_admins.\n     */\n    skip?: number\n    distinct?: Shopping_mall_adminScalarFieldEnum | Shopping_mall_adminScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_admin create\n   */\n  export type shopping_mall_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_mall_admin.\n     */\n    data: XOR<shopping_mall_adminCreateInput, shopping_mall_adminUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_mall_admin createMany\n   */\n  export type shopping_mall_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_mall_admins.\n     */\n    data: shopping_mall_adminCreateManyInput | shopping_mall_adminCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_admin createManyAndReturn\n   */\n  export type shopping_mall_adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_mall_admins.\n     */\n    data: shopping_mall_adminCreateManyInput | shopping_mall_adminCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_mall_admin update\n   */\n  export type shopping_mall_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_mall_admin.\n     */\n    data: XOR<shopping_mall_adminUpdateInput, shopping_mall_adminUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_mall_admin to update.\n     */\n    where: shopping_mall_adminWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_admin updateMany\n   */\n  export type shopping_mall_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_mall_admins.\n     */\n    data: XOR<shopping_mall_adminUpdateManyMutationInput, shopping_mall_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_admins to update\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * Limit how many shopping_mall_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_admin updateManyAndReturn\n   */\n  export type shopping_mall_adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_mall_admins.\n     */\n    data: XOR<shopping_mall_adminUpdateManyMutationInput, shopping_mall_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_mall_admins to update\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * Limit how many shopping_mall_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_admin upsert\n   */\n  export type shopping_mall_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_mall_admin to update in case it exists.\n     */\n    where: shopping_mall_adminWhereUniqueInput\n    /**\n     * In case the shopping_mall_admin found by the `where` argument doesn't exist, create a new shopping_mall_admin with this data.\n     */\n    create: XOR<shopping_mall_adminCreateInput, shopping_mall_adminUncheckedCreateInput>\n    /**\n     * In case the shopping_mall_admin was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_mall_adminUpdateInput, shopping_mall_adminUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_mall_admin delete\n   */\n  export type shopping_mall_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_mall_admin to delete.\n     */\n    where: shopping_mall_adminWhereUniqueInput\n  }\n\n  /**\n   * shopping_mall_admin deleteMany\n   */\n  export type shopping_mall_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_mall_admins to delete\n     */\n    where?: shopping_mall_adminWhereInput\n    /**\n     * Limit how many shopping_mall_admins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_mall_admin.shopping_inquiry_responses\n   */\n  export type shopping_mall_admin$shopping_inquiry_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    where?: shopping_inquiry_responsesWhereInput\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_inquiry_responsesScalarFieldEnum | Shopping_inquiry_responsesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_mall_admin without action\n   */\n  export type shopping_mall_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_mall_admin\n     */\n    select?: shopping_mall_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_mall_admin\n     */\n    omit?: shopping_mall_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_mall_adminInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sales\n   */\n\n  export type AggregateShopping_sales = {\n    _count: Shopping_salesCountAggregateOutputType | null\n    _avg: Shopping_salesAvgAggregateOutputType | null\n    _sum: Shopping_salesSumAggregateOutputType | null\n    _min: Shopping_salesMinAggregateOutputType | null\n    _max: Shopping_salesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_salesAvgAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_salesSumAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_salesMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_salesMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_salesCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    shopping_section_id: number\n    code: number\n    name: number\n    description: number\n    price: number\n    stock: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_salesAvgAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_salesSumAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_salesMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_salesMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_salesCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sales to aggregate.\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sales to fetch.\n     */\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_salesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sales from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sales.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sales\n    **/\n    _count?: true | Shopping_salesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_salesAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_salesSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_salesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_salesMaxAggregateInputType\n  }\n\n  export type GetShopping_salesAggregateType<T extends Shopping_salesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sales]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sales[P]>\n      : GetScalarType<T[P], AggregateShopping_sales[P]>\n  }\n\n\n\n\n  export type shopping_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_salesWhereInput\n    orderBy?: shopping_salesOrderByWithAggregationInput | shopping_salesOrderByWithAggregationInput[]\n    by: Shopping_salesScalarFieldEnum[] | Shopping_salesScalarFieldEnum\n    having?: shopping_salesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_salesCountAggregateInputType | true\n    _avg?: Shopping_salesAvgAggregateInputType\n    _sum?: Shopping_salesSumAggregateInputType\n    _min?: Shopping_salesMinAggregateInputType\n    _max?: Shopping_salesMaxAggregateInputType\n  }\n\n  export type Shopping_salesGroupByOutputType = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description: string | null\n    price: number\n    stock: number\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_salesCountAggregateOutputType | null\n    _avg: Shopping_salesAvgAggregateOutputType | null\n    _sum: Shopping_salesSumAggregateOutputType | null\n    _min: Shopping_salesMinAggregateOutputType | null\n    _max: Shopping_salesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_salesGroupByPayload<T extends shopping_salesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_salesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_salesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_salesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_salesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n    shopping_sale_snapshots?: boolean | shopping_sales$shopping_sale_snapshotsArgs<ExtArgs>\n    shopping_sale_units?: boolean | shopping_sales$shopping_sale_unitsArgs<ExtArgs>\n    _count?: boolean | Shopping_salesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sales\"]>\n\n  export type shopping_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sales\"]>\n\n  export type shopping_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sales\"]>\n\n  export type shopping_salesSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"shopping_section_id\" | \"code\" | \"name\" | \"description\" | \"price\" | \"stock\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_sales\"]>\n  export type shopping_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n    shopping_sale_snapshots?: boolean | shopping_sales$shopping_sale_snapshotsArgs<ExtArgs>\n    shopping_sale_units?: boolean | shopping_sales$shopping_sale_unitsArgs<ExtArgs>\n    _count?: boolean | Shopping_salesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n  export type shopping_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sales\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs>\n      section: Prisma.$shopping_sectionsPayload<ExtArgs>\n      shopping_sale_snapshots: Prisma.$shopping_sale_snapshotsPayload<ExtArgs>[]\n      shopping_sale_units: Prisma.$shopping_sale_unitsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged channel's {@link shopping_channels.id}.\n       */\n      shopping_channel_id: string\n      /**\n       * Belonged section's {@link shopping_sections.id}.\n       */\n      shopping_section_id: string\n      /**\n       * Unique business identifier for the sale.\n       */\n      code: string\n      /**\n       * Display name of the sale.\n       */\n      name: string\n      /**\n       * Detailed description of the sale.\n       */\n      description: string | null\n      /**\n       * Current price of the sale.\n       */\n      price: number\n      /**\n       * Current inventory stock level.\n       */\n      stock: number\n      /**\n       * Timestamp when the sale was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the sale was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the sale was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_sales\"]>\n    composites: {}\n  }\n\n  type shopping_salesGetPayload<S extends boolean | null | undefined | shopping_salesDefaultArgs> = $Result.GetResult<Prisma.$shopping_salesPayload, S>\n\n  type shopping_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_salesCountAggregateInputType | true\n    }\n\n  export interface shopping_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sales'], meta: { name: 'shopping_sales' } }\n    /**\n     * Find zero or one Shopping_sales that matches the filter.\n     * @param {shopping_salesFindUniqueArgs} args - Arguments to find a Shopping_sales\n     * @example\n     * // Get one Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_salesFindUniqueArgs>(args: SelectSubset<T, shopping_salesFindUniqueArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sales that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_salesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sales\n     * @example\n     * // Get one Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sales that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesFindFirstArgs} args - Arguments to find a Shopping_sales\n     * @example\n     * // Get one Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_salesFindFirstArgs>(args?: SelectSubset<T, shopping_salesFindFirstArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sales that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesFindFirstOrThrowArgs} args - Arguments to find a Shopping_sales\n     * @example\n     * // Get one Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sales that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findMany()\n     * \n     * // Get first 10 Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_salesWithIdOnly = await prisma.shopping_sales.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_salesFindManyArgs>(args?: SelectSubset<T, shopping_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sales.\n     * @param {shopping_salesCreateArgs} args - Arguments to create a Shopping_sales.\n     * @example\n     * // Create one Shopping_sales\n     * const Shopping_sales = await prisma.shopping_sales.create({\n     *   data: {\n     *     // ... data to create a Shopping_sales\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_salesCreateArgs>(args: SelectSubset<T, shopping_salesCreateArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sales.\n     * @param {shopping_salesCreateManyArgs} args - Arguments to create many Shopping_sales.\n     * @example\n     * // Create many Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_salesCreateManyArgs>(args?: SelectSubset<T, shopping_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sales and returns the data saved in the database.\n     * @param {shopping_salesCreateManyAndReturnArgs} args - Arguments to create many Shopping_sales.\n     * @example\n     * // Create many Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sales and only return the `id`\n     * const shopping_salesWithIdOnly = await prisma.shopping_sales.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sales.\n     * @param {shopping_salesDeleteArgs} args - Arguments to delete one Shopping_sales.\n     * @example\n     * // Delete one Shopping_sales\n     * const Shopping_sales = await prisma.shopping_sales.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sales\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_salesDeleteArgs>(args: SelectSubset<T, shopping_salesDeleteArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sales.\n     * @param {shopping_salesUpdateArgs} args - Arguments to update one Shopping_sales.\n     * @example\n     * // Update one Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_salesUpdateArgs>(args: SelectSubset<T, shopping_salesUpdateArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sales.\n     * @param {shopping_salesDeleteManyArgs} args - Arguments to filter Shopping_sales to delete.\n     * @example\n     * // Delete a few Shopping_sales\n     * const { count } = await prisma.shopping_sales.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_salesDeleteManyArgs>(args?: SelectSubset<T, shopping_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sales.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_salesUpdateManyArgs>(args: SelectSubset<T, shopping_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sales and returns the data updated in the database.\n     * @param {shopping_salesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sales.\n     * @example\n     * // Update many Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sales and only return the `id`\n     * const shopping_salesWithIdOnly = await prisma.shopping_sales.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sales.\n     * @param {shopping_salesUpsertArgs} args - Arguments to update or create a Shopping_sales.\n     * @example\n     * // Update or create a Shopping_sales\n     * const shopping_sales = await prisma.shopping_sales.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sales\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sales we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_salesUpsertArgs>(args: SelectSubset<T, shopping_salesUpsertArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sales.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesCountArgs} args - Arguments to filter Shopping_sales to count.\n     * @example\n     * // Count the number of Shopping_sales\n     * const count = await prisma.shopping_sales.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sales we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_salesCountArgs>(\n      args?: Subset<T, shopping_salesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_salesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sales.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_salesAggregateArgs>(args: Subset<T, Shopping_salesAggregateArgs>): Prisma.PrismaPromise<GetShopping_salesAggregateType<T>>\n\n    /**\n     * Group by Shopping_sales.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_salesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_salesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_salesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_salesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sales model\n   */\n  readonly fields: shopping_salesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sales.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channelsDefaultArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    section<T extends shopping_sectionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sectionsDefaultArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_sale_snapshots<T extends shopping_sales$shopping_sale_snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sales$shopping_sale_snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_sale_units<T extends shopping_sales$shopping_sale_unitsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sales$shopping_sale_unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sales model\n   */\n  interface shopping_salesFieldRefs {\n    readonly id: FieldRef<\"shopping_sales\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_sales\", 'String'>\n    readonly shopping_section_id: FieldRef<\"shopping_sales\", 'String'>\n    readonly code: FieldRef<\"shopping_sales\", 'String'>\n    readonly name: FieldRef<\"shopping_sales\", 'String'>\n    readonly description: FieldRef<\"shopping_sales\", 'String'>\n    readonly price: FieldRef<\"shopping_sales\", 'Float'>\n    readonly stock: FieldRef<\"shopping_sales\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_sales\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_sales\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_sales\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sales findUnique\n   */\n  export type shopping_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sales to fetch.\n     */\n    where: shopping_salesWhereUniqueInput\n  }\n\n  /**\n   * shopping_sales findUniqueOrThrow\n   */\n  export type shopping_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sales to fetch.\n     */\n    where: shopping_salesWhereUniqueInput\n  }\n\n  /**\n   * shopping_sales findFirst\n   */\n  export type shopping_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sales to fetch.\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sales to fetch.\n     */\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sales.\n     */\n    cursor?: shopping_salesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sales from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sales.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sales.\n     */\n    distinct?: Shopping_salesScalarFieldEnum | Shopping_salesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sales findFirstOrThrow\n   */\n  export type shopping_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sales to fetch.\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sales to fetch.\n     */\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sales.\n     */\n    cursor?: shopping_salesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sales from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sales.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sales.\n     */\n    distinct?: Shopping_salesScalarFieldEnum | Shopping_salesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sales findMany\n   */\n  export type shopping_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sales to fetch.\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sales to fetch.\n     */\n    orderBy?: shopping_salesOrderByWithRelationInput | shopping_salesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sales.\n     */\n    cursor?: shopping_salesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sales from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sales.\n     */\n    skip?: number\n    distinct?: Shopping_salesScalarFieldEnum | Shopping_salesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sales create\n   */\n  export type shopping_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sales.\n     */\n    data: XOR<shopping_salesCreateInput, shopping_salesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sales createMany\n   */\n  export type shopping_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sales.\n     */\n    data: shopping_salesCreateManyInput | shopping_salesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sales createManyAndReturn\n   */\n  export type shopping_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sales.\n     */\n    data: shopping_salesCreateManyInput | shopping_salesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sales update\n   */\n  export type shopping_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sales.\n     */\n    data: XOR<shopping_salesUpdateInput, shopping_salesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sales to update.\n     */\n    where: shopping_salesWhereUniqueInput\n  }\n\n  /**\n   * shopping_sales updateMany\n   */\n  export type shopping_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sales.\n     */\n    data: XOR<shopping_salesUpdateManyMutationInput, shopping_salesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sales to update\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * Limit how many shopping_sales to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sales updateManyAndReturn\n   */\n  export type shopping_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sales.\n     */\n    data: XOR<shopping_salesUpdateManyMutationInput, shopping_salesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sales to update\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * Limit how many shopping_sales to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sales upsert\n   */\n  export type shopping_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sales to update in case it exists.\n     */\n    where: shopping_salesWhereUniqueInput\n    /**\n     * In case the shopping_sales found by the `where` argument doesn't exist, create a new shopping_sales with this data.\n     */\n    create: XOR<shopping_salesCreateInput, shopping_salesUncheckedCreateInput>\n    /**\n     * In case the shopping_sales was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_salesUpdateInput, shopping_salesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sales delete\n   */\n  export type shopping_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sales to delete.\n     */\n    where: shopping_salesWhereUniqueInput\n  }\n\n  /**\n   * shopping_sales deleteMany\n   */\n  export type shopping_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sales to delete\n     */\n    where?: shopping_salesWhereInput\n    /**\n     * Limit how many shopping_sales to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sales.shopping_sale_snapshots\n   */\n  export type shopping_sales$shopping_sale_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    where?: shopping_sale_snapshotsWhereInput\n    orderBy?: shopping_sale_snapshotsOrderByWithRelationInput | shopping_sale_snapshotsOrderByWithRelationInput[]\n    cursor?: shopping_sale_snapshotsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_sale_snapshotsScalarFieldEnum | Shopping_sale_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sales.shopping_sale_units\n   */\n  export type shopping_sales$shopping_sale_unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    where?: shopping_sale_unitsWhereInput\n    orderBy?: shopping_sale_unitsOrderByWithRelationInput | shopping_sale_unitsOrderByWithRelationInput[]\n    cursor?: shopping_sale_unitsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_sale_unitsScalarFieldEnum | Shopping_sale_unitsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sales without action\n   */\n  export type shopping_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sales\n     */\n    select?: shopping_salesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sales\n     */\n    omit?: shopping_salesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_salesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sale_snapshots\n   */\n\n  export type AggregateShopping_sale_snapshots = {\n    _count: Shopping_sale_snapshotsCountAggregateOutputType | null\n    _avg: Shopping_sale_snapshotsAvgAggregateOutputType | null\n    _sum: Shopping_sale_snapshotsSumAggregateOutputType | null\n    _min: Shopping_sale_snapshotsMinAggregateOutputType | null\n    _max: Shopping_sale_snapshotsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sale_snapshotsAvgAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_sale_snapshotsSumAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_sale_snapshotsMinAggregateOutputType = {\n    id: string | null\n    shopping_sale_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n  }\n\n  export type Shopping_sale_snapshotsMaxAggregateOutputType = {\n    id: string | null\n    shopping_sale_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n  }\n\n  export type Shopping_sale_snapshotsCountAggregateOutputType = {\n    id: number\n    shopping_sale_id: number\n    code: number\n    name: number\n    description: number\n    price: number\n    stock: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_sale_snapshotsAvgAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_sale_snapshotsSumAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_sale_snapshotsMinAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n  }\n\n  export type Shopping_sale_snapshotsMaxAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n  }\n\n  export type Shopping_sale_snapshotsCountAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_sale_snapshotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_snapshots to aggregate.\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_snapshots to fetch.\n     */\n    orderBy?: shopping_sale_snapshotsOrderByWithRelationInput | shopping_sale_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sale_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sale_snapshots\n    **/\n    _count?: true | Shopping_sale_snapshotsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_sale_snapshotsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_sale_snapshotsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sale_snapshotsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sale_snapshotsMaxAggregateInputType\n  }\n\n  export type GetShopping_sale_snapshotsAggregateType<T extends Shopping_sale_snapshotsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sale_snapshots]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sale_snapshots[P]>\n      : GetScalarType<T[P], AggregateShopping_sale_snapshots[P]>\n  }\n\n\n\n\n  export type shopping_sale_snapshotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_snapshotsWhereInput\n    orderBy?: shopping_sale_snapshotsOrderByWithAggregationInput | shopping_sale_snapshotsOrderByWithAggregationInput[]\n    by: Shopping_sale_snapshotsScalarFieldEnum[] | Shopping_sale_snapshotsScalarFieldEnum\n    having?: shopping_sale_snapshotsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sale_snapshotsCountAggregateInputType | true\n    _avg?: Shopping_sale_snapshotsAvgAggregateInputType\n    _sum?: Shopping_sale_snapshotsSumAggregateInputType\n    _min?: Shopping_sale_snapshotsMinAggregateInputType\n    _max?: Shopping_sale_snapshotsMaxAggregateInputType\n  }\n\n  export type Shopping_sale_snapshotsGroupByOutputType = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description: string | null\n    price: number\n    stock: number\n    created_at: Date\n    _count: Shopping_sale_snapshotsCountAggregateOutputType | null\n    _avg: Shopping_sale_snapshotsAvgAggregateOutputType | null\n    _sum: Shopping_sale_snapshotsSumAggregateOutputType | null\n    _min: Shopping_sale_snapshotsMinAggregateOutputType | null\n    _max: Shopping_sale_snapshotsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sale_snapshotsGroupByPayload<T extends shopping_sale_snapshotsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sale_snapshotsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sale_snapshotsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sale_snapshotsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sale_snapshotsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sale_snapshotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_snapshots\"]>\n\n  export type shopping_sale_snapshotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_snapshots\"]>\n\n  export type shopping_sale_snapshotsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_snapshots\"]>\n\n  export type shopping_sale_snapshotsSelectScalar = {\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_sale_snapshotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_sale_id\" | \"code\" | \"name\" | \"description\" | \"price\" | \"stock\" | \"created_at\", ExtArgs[\"result\"][\"shopping_sale_snapshots\"]>\n  export type shopping_sale_snapshotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_snapshotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_snapshotsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_sale_snapshotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sale_snapshots\"\n    objects: {\n      sale: Prisma.$shopping_salesPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged sale's {@link shopping_sales.id}.\n       */\n      shopping_sale_id: string\n      /**\n       * Unique business identifier for the sale at this snapshot.\n       */\n      code: string\n      /**\n       * Display name of the sale at this snapshot.\n       */\n      name: string\n      /**\n       * Detailed description of the sale at this snapshot.\n       */\n      description: string | null\n      /**\n       * Price of the sale at this snapshot.\n       */\n      price: number\n      /**\n       * Inventory stock level at this snapshot.\n       */\n      stock: number\n      /**\n       * Timestamp when this snapshot was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_sale_snapshots\"]>\n    composites: {}\n  }\n\n  type shopping_sale_snapshotsGetPayload<S extends boolean | null | undefined | shopping_sale_snapshotsDefaultArgs> = $Result.GetResult<Prisma.$shopping_sale_snapshotsPayload, S>\n\n  type shopping_sale_snapshotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sale_snapshotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sale_snapshotsCountAggregateInputType | true\n    }\n\n  export interface shopping_sale_snapshotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sale_snapshots'], meta: { name: 'shopping_sale_snapshots' } }\n    /**\n     * Find zero or one Shopping_sale_snapshots that matches the filter.\n     * @param {shopping_sale_snapshotsFindUniqueArgs} args - Arguments to find a Shopping_sale_snapshots\n     * @example\n     * // Get one Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sale_snapshotsFindUniqueArgs>(args: SelectSubset<T, shopping_sale_snapshotsFindUniqueArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sale_snapshots that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sale_snapshotsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sale_snapshots\n     * @example\n     * // Get one Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sale_snapshotsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sale_snapshotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsFindFirstArgs} args - Arguments to find a Shopping_sale_snapshots\n     * @example\n     * // Get one Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sale_snapshotsFindFirstArgs>(args?: SelectSubset<T, shopping_sale_snapshotsFindFirstArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_snapshots that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsFindFirstOrThrowArgs} args - Arguments to find a Shopping_sale_snapshots\n     * @example\n     * // Get one Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sale_snapshotsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sale_snapshotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sale_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findMany()\n     * \n     * // Get first 10 Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sale_snapshotsWithIdOnly = await prisma.shopping_sale_snapshots.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sale_snapshotsFindManyArgs>(args?: SelectSubset<T, shopping_sale_snapshotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsCreateArgs} args - Arguments to create a Shopping_sale_snapshots.\n     * @example\n     * // Create one Shopping_sale_snapshots\n     * const Shopping_sale_snapshots = await prisma.shopping_sale_snapshots.create({\n     *   data: {\n     *     // ... data to create a Shopping_sale_snapshots\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sale_snapshotsCreateArgs>(args: SelectSubset<T, shopping_sale_snapshotsCreateArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsCreateManyArgs} args - Arguments to create many Shopping_sale_snapshots.\n     * @example\n     * // Create many Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sale_snapshotsCreateManyArgs>(args?: SelectSubset<T, shopping_sale_snapshotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sale_snapshots and returns the data saved in the database.\n     * @param {shopping_sale_snapshotsCreateManyAndReturnArgs} args - Arguments to create many Shopping_sale_snapshots.\n     * @example\n     * // Create many Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sale_snapshots and only return the `id`\n     * const shopping_sale_snapshotsWithIdOnly = await prisma.shopping_sale_snapshots.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sale_snapshotsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sale_snapshotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsDeleteArgs} args - Arguments to delete one Shopping_sale_snapshots.\n     * @example\n     * // Delete one Shopping_sale_snapshots\n     * const Shopping_sale_snapshots = await prisma.shopping_sale_snapshots.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sale_snapshots\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sale_snapshotsDeleteArgs>(args: SelectSubset<T, shopping_sale_snapshotsDeleteArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsUpdateArgs} args - Arguments to update one Shopping_sale_snapshots.\n     * @example\n     * // Update one Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sale_snapshotsUpdateArgs>(args: SelectSubset<T, shopping_sale_snapshotsUpdateArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsDeleteManyArgs} args - Arguments to filter Shopping_sale_snapshots to delete.\n     * @example\n     * // Delete a few Shopping_sale_snapshots\n     * const { count } = await prisma.shopping_sale_snapshots.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sale_snapshotsDeleteManyArgs>(args?: SelectSubset<T, shopping_sale_snapshotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sale_snapshotsUpdateManyArgs>(args: SelectSubset<T, shopping_sale_snapshotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_snapshots and returns the data updated in the database.\n     * @param {shopping_sale_snapshotsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sale_snapshots.\n     * @example\n     * // Update many Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sale_snapshots and only return the `id`\n     * const shopping_sale_snapshotsWithIdOnly = await prisma.shopping_sale_snapshots.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sale_snapshotsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sale_snapshotsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sale_snapshots.\n     * @param {shopping_sale_snapshotsUpsertArgs} args - Arguments to update or create a Shopping_sale_snapshots.\n     * @example\n     * // Update or create a Shopping_sale_snapshots\n     * const shopping_sale_snapshots = await prisma.shopping_sale_snapshots.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sale_snapshots\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sale_snapshots we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sale_snapshotsUpsertArgs>(args: SelectSubset<T, shopping_sale_snapshotsUpsertArgs<ExtArgs>>): Prisma__shopping_sale_snapshotsClient<$Result.GetResult<Prisma.$shopping_sale_snapshotsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sale_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsCountArgs} args - Arguments to filter Shopping_sale_snapshots to count.\n     * @example\n     * // Count the number of Shopping_sale_snapshots\n     * const count = await prisma.shopping_sale_snapshots.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sale_snapshots we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sale_snapshotsCountArgs>(\n      args?: Subset<T, shopping_sale_snapshotsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sale_snapshotsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sale_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sale_snapshotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sale_snapshotsAggregateArgs>(args: Subset<T, Shopping_sale_snapshotsAggregateArgs>): Prisma.PrismaPromise<GetShopping_sale_snapshotsAggregateType<T>>\n\n    /**\n     * Group by Shopping_sale_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_snapshotsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sale_snapshotsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sale_snapshotsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sale_snapshotsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sale_snapshotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sale_snapshotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sale_snapshots model\n   */\n  readonly fields: shopping_sale_snapshotsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sale_snapshots.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sale_snapshotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    sale<T extends shopping_salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_salesDefaultArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sale_snapshots model\n   */\n  interface shopping_sale_snapshotsFieldRefs {\n    readonly id: FieldRef<\"shopping_sale_snapshots\", 'String'>\n    readonly shopping_sale_id: FieldRef<\"shopping_sale_snapshots\", 'String'>\n    readonly code: FieldRef<\"shopping_sale_snapshots\", 'String'>\n    readonly name: FieldRef<\"shopping_sale_snapshots\", 'String'>\n    readonly description: FieldRef<\"shopping_sale_snapshots\", 'String'>\n    readonly price: FieldRef<\"shopping_sale_snapshots\", 'Float'>\n    readonly stock: FieldRef<\"shopping_sale_snapshots\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_sale_snapshots\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sale_snapshots findUnique\n   */\n  export type shopping_sale_snapshotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_snapshots to fetch.\n     */\n    where: shopping_sale_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_snapshots findUniqueOrThrow\n   */\n  export type shopping_sale_snapshotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_snapshots to fetch.\n     */\n    where: shopping_sale_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_snapshots findFirst\n   */\n  export type shopping_sale_snapshotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_snapshots to fetch.\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_snapshots to fetch.\n     */\n    orderBy?: shopping_sale_snapshotsOrderByWithRelationInput | shopping_sale_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_snapshots.\n     */\n    cursor?: shopping_sale_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_snapshots.\n     */\n    distinct?: Shopping_sale_snapshotsScalarFieldEnum | Shopping_sale_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_snapshots findFirstOrThrow\n   */\n  export type shopping_sale_snapshotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_snapshots to fetch.\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_snapshots to fetch.\n     */\n    orderBy?: shopping_sale_snapshotsOrderByWithRelationInput | shopping_sale_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_snapshots.\n     */\n    cursor?: shopping_sale_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_snapshots.\n     */\n    distinct?: Shopping_sale_snapshotsScalarFieldEnum | Shopping_sale_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_snapshots findMany\n   */\n  export type shopping_sale_snapshotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_snapshots to fetch.\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_snapshots to fetch.\n     */\n    orderBy?: shopping_sale_snapshotsOrderByWithRelationInput | shopping_sale_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sale_snapshots.\n     */\n    cursor?: shopping_sale_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_snapshots.\n     */\n    skip?: number\n    distinct?: Shopping_sale_snapshotsScalarFieldEnum | Shopping_sale_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_snapshots create\n   */\n  export type shopping_sale_snapshotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sale_snapshots.\n     */\n    data: XOR<shopping_sale_snapshotsCreateInput, shopping_sale_snapshotsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sale_snapshots createMany\n   */\n  export type shopping_sale_snapshotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sale_snapshots.\n     */\n    data: shopping_sale_snapshotsCreateManyInput | shopping_sale_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sale_snapshots createManyAndReturn\n   */\n  export type shopping_sale_snapshotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sale_snapshots.\n     */\n    data: shopping_sale_snapshotsCreateManyInput | shopping_sale_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_snapshots update\n   */\n  export type shopping_sale_snapshotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sale_snapshots.\n     */\n    data: XOR<shopping_sale_snapshotsUpdateInput, shopping_sale_snapshotsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sale_snapshots to update.\n     */\n    where: shopping_sale_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_snapshots updateMany\n   */\n  export type shopping_sale_snapshotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sale_snapshots.\n     */\n    data: XOR<shopping_sale_snapshotsUpdateManyMutationInput, shopping_sale_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_snapshots to update\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * Limit how many shopping_sale_snapshots to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_snapshots updateManyAndReturn\n   */\n  export type shopping_sale_snapshotsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sale_snapshots.\n     */\n    data: XOR<shopping_sale_snapshotsUpdateManyMutationInput, shopping_sale_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_snapshots to update\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * Limit how many shopping_sale_snapshots to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_snapshots upsert\n   */\n  export type shopping_sale_snapshotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sale_snapshots to update in case it exists.\n     */\n    where: shopping_sale_snapshotsWhereUniqueInput\n    /**\n     * In case the shopping_sale_snapshots found by the `where` argument doesn't exist, create a new shopping_sale_snapshots with this data.\n     */\n    create: XOR<shopping_sale_snapshotsCreateInput, shopping_sale_snapshotsUncheckedCreateInput>\n    /**\n     * In case the shopping_sale_snapshots was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sale_snapshotsUpdateInput, shopping_sale_snapshotsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sale_snapshots delete\n   */\n  export type shopping_sale_snapshotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sale_snapshots to delete.\n     */\n    where: shopping_sale_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_snapshots deleteMany\n   */\n  export type shopping_sale_snapshotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_snapshots to delete\n     */\n    where?: shopping_sale_snapshotsWhereInput\n    /**\n     * Limit how many shopping_sale_snapshots to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_snapshots without action\n   */\n  export type shopping_sale_snapshotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_snapshots\n     */\n    select?: shopping_sale_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_snapshots\n     */\n    omit?: shopping_sale_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_snapshotsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sale_units\n   */\n\n  export type AggregateShopping_sale_units = {\n    _count: Shopping_sale_unitsCountAggregateOutputType | null\n    _avg: Shopping_sale_unitsAvgAggregateOutputType | null\n    _sum: Shopping_sale_unitsSumAggregateOutputType | null\n    _min: Shopping_sale_unitsMinAggregateOutputType | null\n    _max: Shopping_sale_unitsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sale_unitsAvgAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_sale_unitsSumAggregateOutputType = {\n    price: number | null\n    stock: number | null\n  }\n\n  export type Shopping_sale_unitsMinAggregateOutputType = {\n    id: string | null\n    shopping_sale_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sale_unitsMaxAggregateOutputType = {\n    id: string | null\n    shopping_sale_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    stock: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sale_unitsCountAggregateOutputType = {\n    id: number\n    shopping_sale_id: number\n    code: number\n    name: number\n    description: number\n    price: number\n    stock: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_sale_unitsAvgAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_sale_unitsSumAggregateInputType = {\n    price?: true\n    stock?: true\n  }\n\n  export type Shopping_sale_unitsMinAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sale_unitsMaxAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sale_unitsCountAggregateInputType = {\n    id?: true\n    shopping_sale_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    stock?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_sale_unitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_units to aggregate.\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_units to fetch.\n     */\n    orderBy?: shopping_sale_unitsOrderByWithRelationInput | shopping_sale_unitsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sale_unitsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_units from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_units.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sale_units\n    **/\n    _count?: true | Shopping_sale_unitsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_sale_unitsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_sale_unitsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sale_unitsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sale_unitsMaxAggregateInputType\n  }\n\n  export type GetShopping_sale_unitsAggregateType<T extends Shopping_sale_unitsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sale_units]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sale_units[P]>\n      : GetScalarType<T[P], AggregateShopping_sale_units[P]>\n  }\n\n\n\n\n  export type shopping_sale_unitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_unitsWhereInput\n    orderBy?: shopping_sale_unitsOrderByWithAggregationInput | shopping_sale_unitsOrderByWithAggregationInput[]\n    by: Shopping_sale_unitsScalarFieldEnum[] | Shopping_sale_unitsScalarFieldEnum\n    having?: shopping_sale_unitsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sale_unitsCountAggregateInputType | true\n    _avg?: Shopping_sale_unitsAvgAggregateInputType\n    _sum?: Shopping_sale_unitsSumAggregateInputType\n    _min?: Shopping_sale_unitsMinAggregateInputType\n    _max?: Shopping_sale_unitsMaxAggregateInputType\n  }\n\n  export type Shopping_sale_unitsGroupByOutputType = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description: string | null\n    price: number\n    stock: number\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_sale_unitsCountAggregateOutputType | null\n    _avg: Shopping_sale_unitsAvgAggregateOutputType | null\n    _sum: Shopping_sale_unitsSumAggregateOutputType | null\n    _min: Shopping_sale_unitsMinAggregateOutputType | null\n    _max: Shopping_sale_unitsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sale_unitsGroupByPayload<T extends shopping_sale_unitsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sale_unitsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sale_unitsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sale_unitsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sale_unitsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sale_unitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n    shopping_sale_unit_options?: boolean | shopping_sale_units$shopping_sale_unit_optionsArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_sale_units$shopping_cart_itemsArgs<ExtArgs>\n    shopping_favorite_items?: boolean | shopping_sale_units$shopping_favorite_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_sale_unitsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_units\"]>\n\n  export type shopping_sale_unitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_units\"]>\n\n  export type shopping_sale_unitsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_units\"]>\n\n  export type shopping_sale_unitsSelectScalar = {\n    id?: boolean\n    shopping_sale_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    stock?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_sale_unitsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_sale_id\" | \"code\" | \"name\" | \"description\" | \"price\" | \"stock\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_sale_units\"]>\n  export type shopping_sale_unitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n    shopping_sale_unit_options?: boolean | shopping_sale_units$shopping_sale_unit_optionsArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_sale_units$shopping_cart_itemsArgs<ExtArgs>\n    shopping_favorite_items?: boolean | shopping_sale_units$shopping_favorite_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_sale_unitsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_unitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_unitsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sale?: boolean | shopping_salesDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_sale_unitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sale_units\"\n    objects: {\n      sale: Prisma.$shopping_salesPayload<ExtArgs>\n      shopping_sale_unit_options: Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>[]\n      shopping_cart_items: Prisma.$shopping_cart_itemsPayload<ExtArgs>[]\n      shopping_favorite_items: Prisma.$shopping_favorite_itemsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged sale's {@link shopping_sales.id}.\n       */\n      shopping_sale_id: string\n      /**\n       * Unique business identifier for the sale unit.\n       */\n      code: string\n      /**\n       * Display name of the sale unit.\n       */\n      name: string\n      /**\n       * Detailed description of the sale unit.\n       */\n      description: string | null\n      /**\n       * Price of the sale unit.\n       */\n      price: number\n      /**\n       * Inventory stock level of the sale unit.\n       */\n      stock: number\n      /**\n       * Timestamp when the sale unit was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the sale unit was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the sale unit was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_sale_units\"]>\n    composites: {}\n  }\n\n  type shopping_sale_unitsGetPayload<S extends boolean | null | undefined | shopping_sale_unitsDefaultArgs> = $Result.GetResult<Prisma.$shopping_sale_unitsPayload, S>\n\n  type shopping_sale_unitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sale_unitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sale_unitsCountAggregateInputType | true\n    }\n\n  export interface shopping_sale_unitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sale_units'], meta: { name: 'shopping_sale_units' } }\n    /**\n     * Find zero or one Shopping_sale_units that matches the filter.\n     * @param {shopping_sale_unitsFindUniqueArgs} args - Arguments to find a Shopping_sale_units\n     * @example\n     * // Get one Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sale_unitsFindUniqueArgs>(args: SelectSubset<T, shopping_sale_unitsFindUniqueArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sale_units that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sale_unitsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sale_units\n     * @example\n     * // Get one Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sale_unitsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sale_unitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_units that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsFindFirstArgs} args - Arguments to find a Shopping_sale_units\n     * @example\n     * // Get one Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sale_unitsFindFirstArgs>(args?: SelectSubset<T, shopping_sale_unitsFindFirstArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_units that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsFindFirstOrThrowArgs} args - Arguments to find a Shopping_sale_units\n     * @example\n     * // Get one Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sale_unitsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sale_unitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sale_units that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findMany()\n     * \n     * // Get first 10 Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sale_unitsWithIdOnly = await prisma.shopping_sale_units.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sale_unitsFindManyArgs>(args?: SelectSubset<T, shopping_sale_unitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sale_units.\n     * @param {shopping_sale_unitsCreateArgs} args - Arguments to create a Shopping_sale_units.\n     * @example\n     * // Create one Shopping_sale_units\n     * const Shopping_sale_units = await prisma.shopping_sale_units.create({\n     *   data: {\n     *     // ... data to create a Shopping_sale_units\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sale_unitsCreateArgs>(args: SelectSubset<T, shopping_sale_unitsCreateArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sale_units.\n     * @param {shopping_sale_unitsCreateManyArgs} args - Arguments to create many Shopping_sale_units.\n     * @example\n     * // Create many Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sale_unitsCreateManyArgs>(args?: SelectSubset<T, shopping_sale_unitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sale_units and returns the data saved in the database.\n     * @param {shopping_sale_unitsCreateManyAndReturnArgs} args - Arguments to create many Shopping_sale_units.\n     * @example\n     * // Create many Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sale_units and only return the `id`\n     * const shopping_sale_unitsWithIdOnly = await prisma.shopping_sale_units.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sale_unitsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sale_unitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sale_units.\n     * @param {shopping_sale_unitsDeleteArgs} args - Arguments to delete one Shopping_sale_units.\n     * @example\n     * // Delete one Shopping_sale_units\n     * const Shopping_sale_units = await prisma.shopping_sale_units.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sale_units\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sale_unitsDeleteArgs>(args: SelectSubset<T, shopping_sale_unitsDeleteArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sale_units.\n     * @param {shopping_sale_unitsUpdateArgs} args - Arguments to update one Shopping_sale_units.\n     * @example\n     * // Update one Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sale_unitsUpdateArgs>(args: SelectSubset<T, shopping_sale_unitsUpdateArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sale_units.\n     * @param {shopping_sale_unitsDeleteManyArgs} args - Arguments to filter Shopping_sale_units to delete.\n     * @example\n     * // Delete a few Shopping_sale_units\n     * const { count } = await prisma.shopping_sale_units.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sale_unitsDeleteManyArgs>(args?: SelectSubset<T, shopping_sale_unitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_units.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sale_unitsUpdateManyArgs>(args: SelectSubset<T, shopping_sale_unitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_units and returns the data updated in the database.\n     * @param {shopping_sale_unitsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sale_units.\n     * @example\n     * // Update many Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sale_units and only return the `id`\n     * const shopping_sale_unitsWithIdOnly = await prisma.shopping_sale_units.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sale_unitsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sale_unitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sale_units.\n     * @param {shopping_sale_unitsUpsertArgs} args - Arguments to update or create a Shopping_sale_units.\n     * @example\n     * // Update or create a Shopping_sale_units\n     * const shopping_sale_units = await prisma.shopping_sale_units.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sale_units\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sale_units we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sale_unitsUpsertArgs>(args: SelectSubset<T, shopping_sale_unitsUpsertArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sale_units.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsCountArgs} args - Arguments to filter Shopping_sale_units to count.\n     * @example\n     * // Count the number of Shopping_sale_units\n     * const count = await prisma.shopping_sale_units.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sale_units we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sale_unitsCountArgs>(\n      args?: Subset<T, shopping_sale_unitsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sale_unitsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sale_units.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sale_unitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sale_unitsAggregateArgs>(args: Subset<T, Shopping_sale_unitsAggregateArgs>): Prisma.PrismaPromise<GetShopping_sale_unitsAggregateType<T>>\n\n    /**\n     * Group by Shopping_sale_units.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unitsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sale_unitsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sale_unitsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sale_unitsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sale_unitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sale_unitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sale_units model\n   */\n  readonly fields: shopping_sale_unitsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sale_units.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sale_unitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    sale<T extends shopping_salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_salesDefaultArgs<ExtArgs>>): Prisma__shopping_salesClient<$Result.GetResult<Prisma.$shopping_salesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_sale_unit_options<T extends shopping_sale_units$shopping_sale_unit_optionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_units$shopping_sale_unit_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_cart_items<T extends shopping_sale_units$shopping_cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_units$shopping_cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_favorite_items<T extends shopping_sale_units$shopping_favorite_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_units$shopping_favorite_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sale_units model\n   */\n  interface shopping_sale_unitsFieldRefs {\n    readonly id: FieldRef<\"shopping_sale_units\", 'String'>\n    readonly shopping_sale_id: FieldRef<\"shopping_sale_units\", 'String'>\n    readonly code: FieldRef<\"shopping_sale_units\", 'String'>\n    readonly name: FieldRef<\"shopping_sale_units\", 'String'>\n    readonly description: FieldRef<\"shopping_sale_units\", 'String'>\n    readonly price: FieldRef<\"shopping_sale_units\", 'Float'>\n    readonly stock: FieldRef<\"shopping_sale_units\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_sale_units\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_sale_units\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_sale_units\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sale_units findUnique\n   */\n  export type shopping_sale_unitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_units to fetch.\n     */\n    where: shopping_sale_unitsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_units findUniqueOrThrow\n   */\n  export type shopping_sale_unitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_units to fetch.\n     */\n    where: shopping_sale_unitsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_units findFirst\n   */\n  export type shopping_sale_unitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_units to fetch.\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_units to fetch.\n     */\n    orderBy?: shopping_sale_unitsOrderByWithRelationInput | shopping_sale_unitsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_units.\n     */\n    cursor?: shopping_sale_unitsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_units from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_units.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_units.\n     */\n    distinct?: Shopping_sale_unitsScalarFieldEnum | Shopping_sale_unitsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units findFirstOrThrow\n   */\n  export type shopping_sale_unitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_units to fetch.\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_units to fetch.\n     */\n    orderBy?: shopping_sale_unitsOrderByWithRelationInput | shopping_sale_unitsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_units.\n     */\n    cursor?: shopping_sale_unitsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_units from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_units.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_units.\n     */\n    distinct?: Shopping_sale_unitsScalarFieldEnum | Shopping_sale_unitsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units findMany\n   */\n  export type shopping_sale_unitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_units to fetch.\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_units to fetch.\n     */\n    orderBy?: shopping_sale_unitsOrderByWithRelationInput | shopping_sale_unitsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sale_units.\n     */\n    cursor?: shopping_sale_unitsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_units from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_units.\n     */\n    skip?: number\n    distinct?: Shopping_sale_unitsScalarFieldEnum | Shopping_sale_unitsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units create\n   */\n  export type shopping_sale_unitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sale_units.\n     */\n    data: XOR<shopping_sale_unitsCreateInput, shopping_sale_unitsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sale_units createMany\n   */\n  export type shopping_sale_unitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sale_units.\n     */\n    data: shopping_sale_unitsCreateManyInput | shopping_sale_unitsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sale_units createManyAndReturn\n   */\n  export type shopping_sale_unitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sale_units.\n     */\n    data: shopping_sale_unitsCreateManyInput | shopping_sale_unitsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_units update\n   */\n  export type shopping_sale_unitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sale_units.\n     */\n    data: XOR<shopping_sale_unitsUpdateInput, shopping_sale_unitsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sale_units to update.\n     */\n    where: shopping_sale_unitsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_units updateMany\n   */\n  export type shopping_sale_unitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sale_units.\n     */\n    data: XOR<shopping_sale_unitsUpdateManyMutationInput, shopping_sale_unitsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_units to update\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * Limit how many shopping_sale_units to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_units updateManyAndReturn\n   */\n  export type shopping_sale_unitsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sale_units.\n     */\n    data: XOR<shopping_sale_unitsUpdateManyMutationInput, shopping_sale_unitsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_units to update\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * Limit how many shopping_sale_units to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_units upsert\n   */\n  export type shopping_sale_unitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sale_units to update in case it exists.\n     */\n    where: shopping_sale_unitsWhereUniqueInput\n    /**\n     * In case the shopping_sale_units found by the `where` argument doesn't exist, create a new shopping_sale_units with this data.\n     */\n    create: XOR<shopping_sale_unitsCreateInput, shopping_sale_unitsUncheckedCreateInput>\n    /**\n     * In case the shopping_sale_units was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sale_unitsUpdateInput, shopping_sale_unitsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sale_units delete\n   */\n  export type shopping_sale_unitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sale_units to delete.\n     */\n    where: shopping_sale_unitsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_units deleteMany\n   */\n  export type shopping_sale_unitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_units to delete\n     */\n    where?: shopping_sale_unitsWhereInput\n    /**\n     * Limit how many shopping_sale_units to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_units.shopping_sale_unit_options\n   */\n  export type shopping_sale_units$shopping_sale_unit_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    where?: shopping_sale_unit_optionsWhereInput\n    orderBy?: shopping_sale_unit_optionsOrderByWithRelationInput | shopping_sale_unit_optionsOrderByWithRelationInput[]\n    cursor?: shopping_sale_unit_optionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_sale_unit_optionsScalarFieldEnum | Shopping_sale_unit_optionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units.shopping_cart_items\n   */\n  export type shopping_sale_units$shopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units.shopping_favorite_items\n   */\n  export type shopping_sale_units$shopping_favorite_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    where?: shopping_favorite_itemsWhereInput\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_favorite_itemsScalarFieldEnum | Shopping_favorite_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_units without action\n   */\n  export type shopping_sale_unitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_units\n     */\n    select?: shopping_sale_unitsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_units\n     */\n    omit?: shopping_sale_unitsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unitsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sale_unit_options\n   */\n\n  export type AggregateShopping_sale_unit_options = {\n    _count: Shopping_sale_unit_optionsCountAggregateOutputType | null\n    _avg: Shopping_sale_unit_optionsAvgAggregateOutputType | null\n    _sum: Shopping_sale_unit_optionsSumAggregateOutputType | null\n    _min: Shopping_sale_unit_optionsMinAggregateOutputType | null\n    _max: Shopping_sale_unit_optionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sale_unit_optionsAvgAggregateOutputType = {\n    price: number | null\n  }\n\n  export type Shopping_sale_unit_optionsSumAggregateOutputType = {\n    price: number | null\n  }\n\n  export type Shopping_sale_unit_optionsMinAggregateOutputType = {\n    id: string | null\n    shopping_sale_unit_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sale_unit_optionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_sale_unit_id: string | null\n    code: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sale_unit_optionsCountAggregateOutputType = {\n    id: number\n    shopping_sale_unit_id: number\n    code: number\n    name: number\n    description: number\n    price: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_sale_unit_optionsAvgAggregateInputType = {\n    price?: true\n  }\n\n  export type Shopping_sale_unit_optionsSumAggregateInputType = {\n    price?: true\n  }\n\n  export type Shopping_sale_unit_optionsMinAggregateInputType = {\n    id?: true\n    shopping_sale_unit_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sale_unit_optionsMaxAggregateInputType = {\n    id?: true\n    shopping_sale_unit_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sale_unit_optionsCountAggregateInputType = {\n    id?: true\n    shopping_sale_unit_id?: true\n    code?: true\n    name?: true\n    description?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_sale_unit_optionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_unit_options to aggregate.\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_unit_options to fetch.\n     */\n    orderBy?: shopping_sale_unit_optionsOrderByWithRelationInput | shopping_sale_unit_optionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sale_unit_optionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_unit_options from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_unit_options.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sale_unit_options\n    **/\n    _count?: true | Shopping_sale_unit_optionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_sale_unit_optionsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_sale_unit_optionsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sale_unit_optionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sale_unit_optionsMaxAggregateInputType\n  }\n\n  export type GetShopping_sale_unit_optionsAggregateType<T extends Shopping_sale_unit_optionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sale_unit_options]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sale_unit_options[P]>\n      : GetScalarType<T[P], AggregateShopping_sale_unit_options[P]>\n  }\n\n\n\n\n  export type shopping_sale_unit_optionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sale_unit_optionsWhereInput\n    orderBy?: shopping_sale_unit_optionsOrderByWithAggregationInput | shopping_sale_unit_optionsOrderByWithAggregationInput[]\n    by: Shopping_sale_unit_optionsScalarFieldEnum[] | Shopping_sale_unit_optionsScalarFieldEnum\n    having?: shopping_sale_unit_optionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sale_unit_optionsCountAggregateInputType | true\n    _avg?: Shopping_sale_unit_optionsAvgAggregateInputType\n    _sum?: Shopping_sale_unit_optionsSumAggregateInputType\n    _min?: Shopping_sale_unit_optionsMinAggregateInputType\n    _max?: Shopping_sale_unit_optionsMaxAggregateInputType\n  }\n\n  export type Shopping_sale_unit_optionsGroupByOutputType = {\n    id: string\n    shopping_sale_unit_id: string\n    code: string\n    name: string\n    description: string | null\n    price: number\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_sale_unit_optionsCountAggregateOutputType | null\n    _avg: Shopping_sale_unit_optionsAvgAggregateOutputType | null\n    _sum: Shopping_sale_unit_optionsSumAggregateOutputType | null\n    _min: Shopping_sale_unit_optionsMinAggregateOutputType | null\n    _max: Shopping_sale_unit_optionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sale_unit_optionsGroupByPayload<T extends shopping_sale_unit_optionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sale_unit_optionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sale_unit_optionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sale_unit_optionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sale_unit_optionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sale_unit_optionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_unit_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_unit_options\"]>\n\n  export type shopping_sale_unit_optionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_unit_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_unit_options\"]>\n\n  export type shopping_sale_unit_optionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_sale_unit_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sale_unit_options\"]>\n\n  export type shopping_sale_unit_optionsSelectScalar = {\n    id?: boolean\n    shopping_sale_unit_id?: boolean\n    code?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_sale_unit_optionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_sale_unit_id\" | \"code\" | \"name\" | \"description\" | \"price\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_sale_unit_options\"]>\n  export type shopping_sale_unit_optionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_unit_optionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_sale_unit_optionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_sale_unit_optionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sale_unit_options\"\n    objects: {\n      saleUnit: Prisma.$shopping_sale_unitsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged sale unit's {@link shopping_sale_units.id}.\n       */\n      shopping_sale_unit_id: string\n      /**\n       * Unique business identifier for the sale unit option.\n       */\n      code: string\n      /**\n       * Display name of the sale unit option.\n       */\n      name: string\n      /**\n       * Detailed description of the sale unit option.\n       */\n      description: string | null\n      /**\n       * Price of the sale unit option.\n       */\n      price: number\n      /**\n       * Timestamp when the sale unit option was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the sale unit option was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the sale unit option was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_sale_unit_options\"]>\n    composites: {}\n  }\n\n  type shopping_sale_unit_optionsGetPayload<S extends boolean | null | undefined | shopping_sale_unit_optionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload, S>\n\n  type shopping_sale_unit_optionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sale_unit_optionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sale_unit_optionsCountAggregateInputType | true\n    }\n\n  export interface shopping_sale_unit_optionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sale_unit_options'], meta: { name: 'shopping_sale_unit_options' } }\n    /**\n     * Find zero or one Shopping_sale_unit_options that matches the filter.\n     * @param {shopping_sale_unit_optionsFindUniqueArgs} args - Arguments to find a Shopping_sale_unit_options\n     * @example\n     * // Get one Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sale_unit_optionsFindUniqueArgs>(args: SelectSubset<T, shopping_sale_unit_optionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sale_unit_options that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sale_unit_optionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sale_unit_options\n     * @example\n     * // Get one Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sale_unit_optionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sale_unit_optionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_unit_options that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsFindFirstArgs} args - Arguments to find a Shopping_sale_unit_options\n     * @example\n     * // Get one Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sale_unit_optionsFindFirstArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsFindFirstArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sale_unit_options that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_sale_unit_options\n     * @example\n     * // Get one Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sale_unit_optionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sale_unit_options that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findMany()\n     * \n     * // Get first 10 Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sale_unit_optionsWithIdOnly = await prisma.shopping_sale_unit_options.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sale_unit_optionsFindManyArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsCreateArgs} args - Arguments to create a Shopping_sale_unit_options.\n     * @example\n     * // Create one Shopping_sale_unit_options\n     * const Shopping_sale_unit_options = await prisma.shopping_sale_unit_options.create({\n     *   data: {\n     *     // ... data to create a Shopping_sale_unit_options\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sale_unit_optionsCreateArgs>(args: SelectSubset<T, shopping_sale_unit_optionsCreateArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsCreateManyArgs} args - Arguments to create many Shopping_sale_unit_options.\n     * @example\n     * // Create many Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sale_unit_optionsCreateManyArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sale_unit_options and returns the data saved in the database.\n     * @param {shopping_sale_unit_optionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_sale_unit_options.\n     * @example\n     * // Create many Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sale_unit_options and only return the `id`\n     * const shopping_sale_unit_optionsWithIdOnly = await prisma.shopping_sale_unit_options.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sale_unit_optionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsDeleteArgs} args - Arguments to delete one Shopping_sale_unit_options.\n     * @example\n     * // Delete one Shopping_sale_unit_options\n     * const Shopping_sale_unit_options = await prisma.shopping_sale_unit_options.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sale_unit_options\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sale_unit_optionsDeleteArgs>(args: SelectSubset<T, shopping_sale_unit_optionsDeleteArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsUpdateArgs} args - Arguments to update one Shopping_sale_unit_options.\n     * @example\n     * // Update one Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sale_unit_optionsUpdateArgs>(args: SelectSubset<T, shopping_sale_unit_optionsUpdateArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsDeleteManyArgs} args - Arguments to filter Shopping_sale_unit_options to delete.\n     * @example\n     * // Delete a few Shopping_sale_unit_options\n     * const { count } = await prisma.shopping_sale_unit_options.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sale_unit_optionsDeleteManyArgs>(args?: SelectSubset<T, shopping_sale_unit_optionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_unit_options.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sale_unit_optionsUpdateManyArgs>(args: SelectSubset<T, shopping_sale_unit_optionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sale_unit_options and returns the data updated in the database.\n     * @param {shopping_sale_unit_optionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sale_unit_options.\n     * @example\n     * // Update many Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sale_unit_options and only return the `id`\n     * const shopping_sale_unit_optionsWithIdOnly = await prisma.shopping_sale_unit_options.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sale_unit_optionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sale_unit_optionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sale_unit_options.\n     * @param {shopping_sale_unit_optionsUpsertArgs} args - Arguments to update or create a Shopping_sale_unit_options.\n     * @example\n     * // Update or create a Shopping_sale_unit_options\n     * const shopping_sale_unit_options = await prisma.shopping_sale_unit_options.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sale_unit_options\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sale_unit_options we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sale_unit_optionsUpsertArgs>(args: SelectSubset<T, shopping_sale_unit_optionsUpsertArgs<ExtArgs>>): Prisma__shopping_sale_unit_optionsClient<$Result.GetResult<Prisma.$shopping_sale_unit_optionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sale_unit_options.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsCountArgs} args - Arguments to filter Shopping_sale_unit_options to count.\n     * @example\n     * // Count the number of Shopping_sale_unit_options\n     * const count = await prisma.shopping_sale_unit_options.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sale_unit_options we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sale_unit_optionsCountArgs>(\n      args?: Subset<T, shopping_sale_unit_optionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sale_unit_optionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sale_unit_options.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sale_unit_optionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sale_unit_optionsAggregateArgs>(args: Subset<T, Shopping_sale_unit_optionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_sale_unit_optionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_sale_unit_options.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sale_unit_optionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sale_unit_optionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sale_unit_optionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sale_unit_optionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sale_unit_optionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sale_unit_optionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sale_unit_options model\n   */\n  readonly fields: shopping_sale_unit_optionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sale_unit_options.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sale_unit_optionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    saleUnit<T extends shopping_sale_unitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_unitsDefaultArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sale_unit_options model\n   */\n  interface shopping_sale_unit_optionsFieldRefs {\n    readonly id: FieldRef<\"shopping_sale_unit_options\", 'String'>\n    readonly shopping_sale_unit_id: FieldRef<\"shopping_sale_unit_options\", 'String'>\n    readonly code: FieldRef<\"shopping_sale_unit_options\", 'String'>\n    readonly name: FieldRef<\"shopping_sale_unit_options\", 'String'>\n    readonly description: FieldRef<\"shopping_sale_unit_options\", 'String'>\n    readonly price: FieldRef<\"shopping_sale_unit_options\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_sale_unit_options\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_sale_unit_options\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_sale_unit_options\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sale_unit_options findUnique\n   */\n  export type shopping_sale_unit_optionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_unit_options to fetch.\n     */\n    where: shopping_sale_unit_optionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_unit_options findUniqueOrThrow\n   */\n  export type shopping_sale_unit_optionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_unit_options to fetch.\n     */\n    where: shopping_sale_unit_optionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_unit_options findFirst\n   */\n  export type shopping_sale_unit_optionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_unit_options to fetch.\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_unit_options to fetch.\n     */\n    orderBy?: shopping_sale_unit_optionsOrderByWithRelationInput | shopping_sale_unit_optionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_unit_options.\n     */\n    cursor?: shopping_sale_unit_optionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_unit_options from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_unit_options.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_unit_options.\n     */\n    distinct?: Shopping_sale_unit_optionsScalarFieldEnum | Shopping_sale_unit_optionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_unit_options findFirstOrThrow\n   */\n  export type shopping_sale_unit_optionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_unit_options to fetch.\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_unit_options to fetch.\n     */\n    orderBy?: shopping_sale_unit_optionsOrderByWithRelationInput | shopping_sale_unit_optionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sale_unit_options.\n     */\n    cursor?: shopping_sale_unit_optionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_unit_options from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_unit_options.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sale_unit_options.\n     */\n    distinct?: Shopping_sale_unit_optionsScalarFieldEnum | Shopping_sale_unit_optionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_unit_options findMany\n   */\n  export type shopping_sale_unit_optionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sale_unit_options to fetch.\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sale_unit_options to fetch.\n     */\n    orderBy?: shopping_sale_unit_optionsOrderByWithRelationInput | shopping_sale_unit_optionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sale_unit_options.\n     */\n    cursor?: shopping_sale_unit_optionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sale_unit_options from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sale_unit_options.\n     */\n    skip?: number\n    distinct?: Shopping_sale_unit_optionsScalarFieldEnum | Shopping_sale_unit_optionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sale_unit_options create\n   */\n  export type shopping_sale_unit_optionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sale_unit_options.\n     */\n    data: XOR<shopping_sale_unit_optionsCreateInput, shopping_sale_unit_optionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sale_unit_options createMany\n   */\n  export type shopping_sale_unit_optionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sale_unit_options.\n     */\n    data: shopping_sale_unit_optionsCreateManyInput | shopping_sale_unit_optionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sale_unit_options createManyAndReturn\n   */\n  export type shopping_sale_unit_optionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sale_unit_options.\n     */\n    data: shopping_sale_unit_optionsCreateManyInput | shopping_sale_unit_optionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_unit_options update\n   */\n  export type shopping_sale_unit_optionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sale_unit_options.\n     */\n    data: XOR<shopping_sale_unit_optionsUpdateInput, shopping_sale_unit_optionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sale_unit_options to update.\n     */\n    where: shopping_sale_unit_optionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_unit_options updateMany\n   */\n  export type shopping_sale_unit_optionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sale_unit_options.\n     */\n    data: XOR<shopping_sale_unit_optionsUpdateManyMutationInput, shopping_sale_unit_optionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_unit_options to update\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * Limit how many shopping_sale_unit_options to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_unit_options updateManyAndReturn\n   */\n  export type shopping_sale_unit_optionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sale_unit_options.\n     */\n    data: XOR<shopping_sale_unit_optionsUpdateManyMutationInput, shopping_sale_unit_optionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sale_unit_options to update\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * Limit how many shopping_sale_unit_options to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sale_unit_options upsert\n   */\n  export type shopping_sale_unit_optionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sale_unit_options to update in case it exists.\n     */\n    where: shopping_sale_unit_optionsWhereUniqueInput\n    /**\n     * In case the shopping_sale_unit_options found by the `where` argument doesn't exist, create a new shopping_sale_unit_options with this data.\n     */\n    create: XOR<shopping_sale_unit_optionsCreateInput, shopping_sale_unit_optionsUncheckedCreateInput>\n    /**\n     * In case the shopping_sale_unit_options was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sale_unit_optionsUpdateInput, shopping_sale_unit_optionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sale_unit_options delete\n   */\n  export type shopping_sale_unit_optionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sale_unit_options to delete.\n     */\n    where: shopping_sale_unit_optionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sale_unit_options deleteMany\n   */\n  export type shopping_sale_unit_optionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sale_unit_options to delete\n     */\n    where?: shopping_sale_unit_optionsWhereInput\n    /**\n     * Limit how many shopping_sale_unit_options to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sale_unit_options without action\n   */\n  export type shopping_sale_unit_optionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sale_unit_options\n     */\n    select?: shopping_sale_unit_optionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sale_unit_options\n     */\n    omit?: shopping_sale_unit_optionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sale_unit_optionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_carts\n   */\n\n  export type AggregateShopping_carts = {\n    _count: Shopping_cartsCountAggregateOutputType | null\n    _min: Shopping_cartsMinAggregateOutputType | null\n    _max: Shopping_cartsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_cartsMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cartsMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cartsCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    status: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_cartsMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cartsMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cartsCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_cartsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_carts to aggregate.\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_carts to fetch.\n     */\n    orderBy?: shopping_cartsOrderByWithRelationInput | shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_carts\n    **/\n    _count?: true | Shopping_cartsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_cartsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_cartsMaxAggregateInputType\n  }\n\n  export type GetShopping_cartsAggregateType<T extends Shopping_cartsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_carts]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_carts[P]>\n      : GetScalarType<T[P], AggregateShopping_carts[P]>\n  }\n\n\n\n\n  export type shopping_cartsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cartsWhereInput\n    orderBy?: shopping_cartsOrderByWithAggregationInput | shopping_cartsOrderByWithAggregationInput[]\n    by: Shopping_cartsScalarFieldEnum[] | Shopping_cartsScalarFieldEnum\n    having?: shopping_cartsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_cartsCountAggregateInputType | true\n    _min?: Shopping_cartsMinAggregateInputType\n    _max?: Shopping_cartsMaxAggregateInputType\n  }\n\n  export type Shopping_cartsGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    status: string\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_cartsCountAggregateOutputType | null\n    _min: Shopping_cartsMinAggregateOutputType | null\n    _max: Shopping_cartsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_cartsGroupByPayload<T extends shopping_cartsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_cartsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_cartsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_cartsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_cartsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_cartsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_carts$shopping_cart_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_cartsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_carts\"]>\n\n  export type shopping_cartsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_carts\"]>\n\n  export type shopping_cartsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_carts\"]>\n\n  export type shopping_cartsSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_cartsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"status\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_carts\"]>\n  export type shopping_cartsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_carts$shopping_cart_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_cartsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_cartsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_cartsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_cartsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_carts\"\n    objects: {\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n      shopping_cart_items: Prisma.$shopping_cart_itemsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged member's {@link shopping_mall_member.id}.\n       */\n      shopping_mall_member_id: string\n      /**\n       * Status of the shopping cart.\n       */\n      status: string\n      /**\n       * Creation timestamp of the shopping cart.\n       */\n      created_at: Date\n      /**\n       * Last update timestamp of the shopping cart.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_carts\"]>\n    composites: {}\n  }\n\n  type shopping_cartsGetPayload<S extends boolean | null | undefined | shopping_cartsDefaultArgs> = $Result.GetResult<Prisma.$shopping_cartsPayload, S>\n\n  type shopping_cartsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_cartsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_cartsCountAggregateInputType | true\n    }\n\n  export interface shopping_cartsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_carts'], meta: { name: 'shopping_carts' } }\n    /**\n     * Find zero or one Shopping_carts that matches the filter.\n     * @param {shopping_cartsFindUniqueArgs} args - Arguments to find a Shopping_carts\n     * @example\n     * // Get one Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_cartsFindUniqueArgs>(args: SelectSubset<T, shopping_cartsFindUniqueArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_carts that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_cartsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_carts\n     * @example\n     * // Get one Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_cartsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_cartsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_carts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsFindFirstArgs} args - Arguments to find a Shopping_carts\n     * @example\n     * // Get one Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_cartsFindFirstArgs>(args?: SelectSubset<T, shopping_cartsFindFirstArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_carts that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsFindFirstOrThrowArgs} args - Arguments to find a Shopping_carts\n     * @example\n     * // Get one Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_cartsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_cartsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_carts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findMany()\n     * \n     * // Get first 10 Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_cartsWithIdOnly = await prisma.shopping_carts.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_cartsFindManyArgs>(args?: SelectSubset<T, shopping_cartsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_carts.\n     * @param {shopping_cartsCreateArgs} args - Arguments to create a Shopping_carts.\n     * @example\n     * // Create one Shopping_carts\n     * const Shopping_carts = await prisma.shopping_carts.create({\n     *   data: {\n     *     // ... data to create a Shopping_carts\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_cartsCreateArgs>(args: SelectSubset<T, shopping_cartsCreateArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_carts.\n     * @param {shopping_cartsCreateManyArgs} args - Arguments to create many Shopping_carts.\n     * @example\n     * // Create many Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_cartsCreateManyArgs>(args?: SelectSubset<T, shopping_cartsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_carts and returns the data saved in the database.\n     * @param {shopping_cartsCreateManyAndReturnArgs} args - Arguments to create many Shopping_carts.\n     * @example\n     * // Create many Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_carts and only return the `id`\n     * const shopping_cartsWithIdOnly = await prisma.shopping_carts.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_cartsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_cartsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_carts.\n     * @param {shopping_cartsDeleteArgs} args - Arguments to delete one Shopping_carts.\n     * @example\n     * // Delete one Shopping_carts\n     * const Shopping_carts = await prisma.shopping_carts.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_carts\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_cartsDeleteArgs>(args: SelectSubset<T, shopping_cartsDeleteArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_carts.\n     * @param {shopping_cartsUpdateArgs} args - Arguments to update one Shopping_carts.\n     * @example\n     * // Update one Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_cartsUpdateArgs>(args: SelectSubset<T, shopping_cartsUpdateArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_carts.\n     * @param {shopping_cartsDeleteManyArgs} args - Arguments to filter Shopping_carts to delete.\n     * @example\n     * // Delete a few Shopping_carts\n     * const { count } = await prisma.shopping_carts.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_cartsDeleteManyArgs>(args?: SelectSubset<T, shopping_cartsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_cartsUpdateManyArgs>(args: SelectSubset<T, shopping_cartsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_carts and returns the data updated in the database.\n     * @param {shopping_cartsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_carts.\n     * @example\n     * // Update many Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_carts and only return the `id`\n     * const shopping_cartsWithIdOnly = await prisma.shopping_carts.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_cartsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_cartsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_carts.\n     * @param {shopping_cartsUpsertArgs} args - Arguments to update or create a Shopping_carts.\n     * @example\n     * // Update or create a Shopping_carts\n     * const shopping_carts = await prisma.shopping_carts.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_carts\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_carts we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_cartsUpsertArgs>(args: SelectSubset<T, shopping_cartsUpsertArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsCountArgs} args - Arguments to filter Shopping_carts to count.\n     * @example\n     * // Count the number of Shopping_carts\n     * const count = await prisma.shopping_carts.count({\n     *   where: {\n     *     // ... the filter for the Shopping_carts we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_cartsCountArgs>(\n      args?: Subset<T, shopping_cartsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_cartsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_cartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_cartsAggregateArgs>(args: Subset<T, Shopping_cartsAggregateArgs>): Prisma.PrismaPromise<GetShopping_cartsAggregateType<T>>\n\n    /**\n     * Group by Shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cartsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_cartsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_cartsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_cartsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_cartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_cartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_carts model\n   */\n  readonly fields: shopping_cartsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_carts.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_cartsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_cart_items<T extends shopping_carts$shopping_cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_carts$shopping_cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_carts model\n   */\n  interface shopping_cartsFieldRefs {\n    readonly id: FieldRef<\"shopping_carts\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_carts\", 'String'>\n    readonly status: FieldRef<\"shopping_carts\", 'String'>\n    readonly created_at: FieldRef<\"shopping_carts\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_carts\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_carts findUnique\n   */\n  export type shopping_cartsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_carts to fetch.\n     */\n    where: shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_carts findUniqueOrThrow\n   */\n  export type shopping_cartsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_carts to fetch.\n     */\n    where: shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_carts findFirst\n   */\n  export type shopping_cartsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_carts to fetch.\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_carts to fetch.\n     */\n    orderBy?: shopping_cartsOrderByWithRelationInput | shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_carts.\n     */\n    cursor?: shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_carts.\n     */\n    distinct?: Shopping_cartsScalarFieldEnum | Shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_carts findFirstOrThrow\n   */\n  export type shopping_cartsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_carts to fetch.\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_carts to fetch.\n     */\n    orderBy?: shopping_cartsOrderByWithRelationInput | shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_carts.\n     */\n    cursor?: shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_carts.\n     */\n    distinct?: Shopping_cartsScalarFieldEnum | Shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_carts findMany\n   */\n  export type shopping_cartsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_carts to fetch.\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_carts to fetch.\n     */\n    orderBy?: shopping_cartsOrderByWithRelationInput | shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_carts.\n     */\n    cursor?: shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_carts.\n     */\n    skip?: number\n    distinct?: Shopping_cartsScalarFieldEnum | Shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_carts create\n   */\n  export type shopping_cartsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_carts.\n     */\n    data: XOR<shopping_cartsCreateInput, shopping_cartsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_carts createMany\n   */\n  export type shopping_cartsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_carts.\n     */\n    data: shopping_cartsCreateManyInput | shopping_cartsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_carts createManyAndReturn\n   */\n  export type shopping_cartsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_carts.\n     */\n    data: shopping_cartsCreateManyInput | shopping_cartsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_carts update\n   */\n  export type shopping_cartsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_carts.\n     */\n    data: XOR<shopping_cartsUpdateInput, shopping_cartsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_carts to update.\n     */\n    where: shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_carts updateMany\n   */\n  export type shopping_cartsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_carts.\n     */\n    data: XOR<shopping_cartsUpdateManyMutationInput, shopping_cartsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_carts to update\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_carts to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_carts updateManyAndReturn\n   */\n  export type shopping_cartsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_carts.\n     */\n    data: XOR<shopping_cartsUpdateManyMutationInput, shopping_cartsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_carts to update\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_carts to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_carts upsert\n   */\n  export type shopping_cartsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_carts to update in case it exists.\n     */\n    where: shopping_cartsWhereUniqueInput\n    /**\n     * In case the shopping_carts found by the `where` argument doesn't exist, create a new shopping_carts with this data.\n     */\n    create: XOR<shopping_cartsCreateInput, shopping_cartsUncheckedCreateInput>\n    /**\n     * In case the shopping_carts was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_cartsUpdateInput, shopping_cartsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_carts delete\n   */\n  export type shopping_cartsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_carts to delete.\n     */\n    where: shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_carts deleteMany\n   */\n  export type shopping_cartsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_carts to delete\n     */\n    where?: shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_carts to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_carts.shopping_cart_items\n   */\n  export type shopping_carts$shopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_carts without action\n   */\n  export type shopping_cartsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_carts\n     */\n    select?: shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_carts\n     */\n    omit?: shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cartsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_cart_items\n   */\n\n  export type AggregateShopping_cart_items = {\n    _count: Shopping_cart_itemsCountAggregateOutputType | null\n    _avg: Shopping_cart_itemsAvgAggregateOutputType | null\n    _sum: Shopping_cart_itemsSumAggregateOutputType | null\n    _min: Shopping_cart_itemsMinAggregateOutputType | null\n    _max: Shopping_cart_itemsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_cart_itemsAvgAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_cart_itemsSumAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_cart_itemsMinAggregateOutputType = {\n    id: string | null\n    shopping_cart_id: string | null\n    shopping_sale_unit_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cart_itemsMaxAggregateOutputType = {\n    id: string | null\n    shopping_cart_id: string | null\n    shopping_sale_unit_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cart_itemsCountAggregateOutputType = {\n    id: number\n    shopping_cart_id: number\n    shopping_sale_unit_id: number\n    quantity: number\n    price: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_cart_itemsAvgAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_cart_itemsSumAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_cart_itemsMinAggregateInputType = {\n    id?: true\n    shopping_cart_id?: true\n    shopping_sale_unit_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cart_itemsMaxAggregateInputType = {\n    id?: true\n    shopping_cart_id?: true\n    shopping_sale_unit_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cart_itemsCountAggregateInputType = {\n    id?: true\n    shopping_cart_id?: true\n    shopping_sale_unit_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_cart_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_cart_items to aggregate.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_cart_items\n    **/\n    _count?: true | Shopping_cart_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_cart_itemsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_cart_itemsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_cart_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_cart_itemsMaxAggregateInputType\n  }\n\n  export type GetShopping_cart_itemsAggregateType<T extends Shopping_cart_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_cart_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_cart_items[P]>\n      : GetScalarType<T[P], AggregateShopping_cart_items[P]>\n  }\n\n\n\n\n  export type shopping_cart_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithAggregationInput | shopping_cart_itemsOrderByWithAggregationInput[]\n    by: Shopping_cart_itemsScalarFieldEnum[] | Shopping_cart_itemsScalarFieldEnum\n    having?: shopping_cart_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_cart_itemsCountAggregateInputType | true\n    _avg?: Shopping_cart_itemsAvgAggregateInputType\n    _sum?: Shopping_cart_itemsSumAggregateInputType\n    _min?: Shopping_cart_itemsMinAggregateInputType\n    _max?: Shopping_cart_itemsMaxAggregateInputType\n  }\n\n  export type Shopping_cart_itemsGroupByOutputType = {\n    id: string\n    shopping_cart_id: string\n    shopping_sale_unit_id: string\n    quantity: number\n    price: number\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_cart_itemsCountAggregateOutputType | null\n    _avg: Shopping_cart_itemsAvgAggregateOutputType | null\n    _sum: Shopping_cart_itemsSumAggregateOutputType | null\n    _min: Shopping_cart_itemsMinAggregateOutputType | null\n    _max: Shopping_cart_itemsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_cart_itemsGroupByPayload<T extends shopping_cart_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_cart_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_cart_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_cart_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_cart_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_cart_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_cart_id?: boolean\n    shopping_sale_unit_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_cart_id?: boolean\n    shopping_sale_unit_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_cart_id?: boolean\n    shopping_sale_unit_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectScalar = {\n    id?: boolean\n    shopping_cart_id?: boolean\n    shopping_sale_unit_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_cart_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_cart_id\" | \"shopping_sale_unit_id\" | \"quantity\" | \"price\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_cart_items\"]>\n  export type shopping_cart_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_cart_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_cart_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_cartsDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_cart_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_cart_items\"\n    objects: {\n      cart: Prisma.$shopping_cartsPayload<ExtArgs>\n      saleUnit: Prisma.$shopping_sale_unitsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged cart's {@link shopping_carts.id}.\n       */\n      shopping_cart_id: string\n      /**\n       * Belonged sale unit's {@link shopping_sale_units.id}.\n       */\n      shopping_sale_unit_id: string\n      /**\n       * Quantity of the product variant in the cart.\n       */\n      quantity: number\n      /**\n       * Price of the product variant at the time of adding to the cart.\n       */\n      price: number\n      /**\n       * Creation timestamp of the cart item.\n       */\n      created_at: Date\n      /**\n       * Last update timestamp of the cart item.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n    composites: {}\n  }\n\n  type shopping_cart_itemsGetPayload<S extends boolean | null | undefined | shopping_cart_itemsDefaultArgs> = $Result.GetResult<Prisma.$shopping_cart_itemsPayload, S>\n\n  type shopping_cart_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_cart_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_cart_itemsCountAggregateInputType | true\n    }\n\n  export interface shopping_cart_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_cart_items'], meta: { name: 'shopping_cart_items' } }\n    /**\n     * Find zero or one Shopping_cart_items that matches the filter.\n     * @param {shopping_cart_itemsFindUniqueArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_cart_itemsFindUniqueArgs>(args: SelectSubset<T, shopping_cart_itemsFindUniqueArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_cart_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_cart_itemsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_cart_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_cart_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindFirstArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_cart_itemsFindFirstArgs>(args?: SelectSubset<T, shopping_cart_itemsFindFirstArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_cart_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindFirstOrThrowArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_cart_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_cart_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findMany()\n     * \n     * // Get first 10 Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_cart_itemsFindManyArgs>(args?: SelectSubset<T, shopping_cart_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_cart_items.\n     * @param {shopping_cart_itemsCreateArgs} args - Arguments to create a Shopping_cart_items.\n     * @example\n     * // Create one Shopping_cart_items\n     * const Shopping_cart_items = await prisma.shopping_cart_items.create({\n     *   data: {\n     *     // ... data to create a Shopping_cart_items\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_cart_itemsCreateArgs>(args: SelectSubset<T, shopping_cart_itemsCreateArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_cart_items.\n     * @param {shopping_cart_itemsCreateManyArgs} args - Arguments to create many Shopping_cart_items.\n     * @example\n     * // Create many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_cart_itemsCreateManyArgs>(args?: SelectSubset<T, shopping_cart_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_cart_items and returns the data saved in the database.\n     * @param {shopping_cart_itemsCreateManyAndReturnArgs} args - Arguments to create many Shopping_cart_items.\n     * @example\n     * // Create many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_cart_items and only return the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_cart_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_cart_items.\n     * @param {shopping_cart_itemsDeleteArgs} args - Arguments to delete one Shopping_cart_items.\n     * @example\n     * // Delete one Shopping_cart_items\n     * const Shopping_cart_items = await prisma.shopping_cart_items.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_cart_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_cart_itemsDeleteArgs>(args: SelectSubset<T, shopping_cart_itemsDeleteArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_cart_items.\n     * @param {shopping_cart_itemsUpdateArgs} args - Arguments to update one Shopping_cart_items.\n     * @example\n     * // Update one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_cart_itemsUpdateArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_cart_items.\n     * @param {shopping_cart_itemsDeleteManyArgs} args - Arguments to filter Shopping_cart_items to delete.\n     * @example\n     * // Delete a few Shopping_cart_items\n     * const { count } = await prisma.shopping_cart_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_cart_itemsDeleteManyArgs>(args?: SelectSubset<T, shopping_cart_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_cart_itemsUpdateManyArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_cart_items and returns the data updated in the database.\n     * @param {shopping_cart_itemsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_cart_items.\n     * @example\n     * // Update many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_cart_items and only return the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_cart_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_cart_items.\n     * @param {shopping_cart_itemsUpsertArgs} args - Arguments to update or create a Shopping_cart_items.\n     * @example\n     * // Update or create a Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_cart_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_cart_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_cart_itemsUpsertArgs>(args: SelectSubset<T, shopping_cart_itemsUpsertArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsCountArgs} args - Arguments to filter Shopping_cart_items to count.\n     * @example\n     * // Count the number of Shopping_cart_items\n     * const count = await prisma.shopping_cart_items.count({\n     *   where: {\n     *     // ... the filter for the Shopping_cart_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_cart_itemsCountArgs>(\n      args?: Subset<T, shopping_cart_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_cart_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_cart_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_cart_itemsAggregateArgs>(args: Subset<T, Shopping_cart_itemsAggregateArgs>): Prisma.PrismaPromise<GetShopping_cart_itemsAggregateType<T>>\n\n    /**\n     * Group by Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_cart_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_cart_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_cart_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_cart_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_cart_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_cart_items model\n   */\n  readonly fields: shopping_cart_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_cart_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_cart_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    cart<T extends shopping_cartsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_cartsDefaultArgs<ExtArgs>>): Prisma__shopping_cartsClient<$Result.GetResult<Prisma.$shopping_cartsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    saleUnit<T extends shopping_sale_unitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_unitsDefaultArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_cart_items model\n   */\n  interface shopping_cart_itemsFieldRefs {\n    readonly id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly shopping_cart_id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly shopping_sale_unit_id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly quantity: FieldRef<\"shopping_cart_items\", 'Int'>\n    readonly price: FieldRef<\"shopping_cart_items\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_cart_items\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_cart_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_cart_items findUnique\n   */\n  export type shopping_cart_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items findUniqueOrThrow\n   */\n  export type shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items findFirst\n   */\n  export type shopping_cart_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_cart_items.\n     */\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items findFirstOrThrow\n   */\n  export type shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_cart_items.\n     */\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items findMany\n   */\n  export type shopping_cart_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items create\n   */\n  export type shopping_cart_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsCreateInput, shopping_cart_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_cart_items createMany\n   */\n  export type shopping_cart_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_cart_items.\n     */\n    data: shopping_cart_itemsCreateManyInput | shopping_cart_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_cart_items createManyAndReturn\n   */\n  export type shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_cart_items.\n     */\n    data: shopping_cart_itemsCreateManyInput | shopping_cart_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_cart_items update\n   */\n  export type shopping_cart_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateInput, shopping_cart_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_cart_items to update.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items updateMany\n   */\n  export type shopping_cart_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_cart_items to update\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_cart_items updateManyAndReturn\n   */\n  export type shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_cart_items to update\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_cart_items upsert\n   */\n  export type shopping_cart_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_cart_items to update in case it exists.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n    /**\n     * In case the shopping_cart_items found by the `where` argument doesn't exist, create a new shopping_cart_items with this data.\n     */\n    create: XOR<shopping_cart_itemsCreateInput, shopping_cart_itemsUncheckedCreateInput>\n    /**\n     * In case the shopping_cart_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_cart_itemsUpdateInput, shopping_cart_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_cart_items delete\n   */\n  export type shopping_cart_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_cart_items to delete.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items deleteMany\n   */\n  export type shopping_cart_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_cart_items to delete\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_cart_items without action\n   */\n  export type shopping_cart_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_orders\n   */\n\n  export type AggregateShopping_orders = {\n    _count: Shopping_ordersCountAggregateOutputType | null\n    _avg: Shopping_ordersAvgAggregateOutputType | null\n    _sum: Shopping_ordersSumAggregateOutputType | null\n    _min: Shopping_ordersMinAggregateOutputType | null\n    _max: Shopping_ordersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_ordersAvgAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_ordersSumAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_ordersMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    code: string | null\n    status: string | null\n    total_amount: number | null\n    shipping_address: string | null\n    payment_method: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_ordersMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    code: string | null\n    status: string | null\n    total_amount: number | null\n    shipping_address: string | null\n    payment_method: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_ordersCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    code: number\n    status: number\n    total_amount: number\n    shipping_address: number\n    payment_method: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_ordersAvgAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_ordersSumAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_ordersMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_ordersMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_ordersCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_orders to aggregate.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_orders\n    **/\n    _count?: true | Shopping_ordersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_ordersAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_ordersSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_ordersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_ordersMaxAggregateInputType\n  }\n\n  export type GetShopping_ordersAggregateType<T extends Shopping_ordersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_orders]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_orders[P]>\n      : GetScalarType<T[P], AggregateShopping_orders[P]>\n  }\n\n\n\n\n  export type shopping_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_ordersWhereInput\n    orderBy?: shopping_ordersOrderByWithAggregationInput | shopping_ordersOrderByWithAggregationInput[]\n    by: Shopping_ordersScalarFieldEnum[] | Shopping_ordersScalarFieldEnum\n    having?: shopping_ordersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_ordersCountAggregateInputType | true\n    _avg?: Shopping_ordersAvgAggregateInputType\n    _sum?: Shopping_ordersSumAggregateInputType\n    _min?: Shopping_ordersMinAggregateInputType\n    _max?: Shopping_ordersMaxAggregateInputType\n  }\n\n  export type Shopping_ordersGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_ordersCountAggregateOutputType | null\n    _avg: Shopping_ordersAvgAggregateOutputType | null\n    _sum: Shopping_ordersSumAggregateOutputType | null\n    _min: Shopping_ordersMinAggregateOutputType | null\n    _max: Shopping_ordersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_ordersGroupByPayload<T extends shopping_ordersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_ordersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_ordersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_ordersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_ordersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_order_snapshots?: boolean | shopping_orders$shopping_order_snapshotsArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_orders$shopping_order_itemsArgs<ExtArgs>\n    shopping_coin_transactions?: boolean | shopping_orders$shopping_coin_transactionsArgs<ExtArgs>\n    _count?: boolean | Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"code\" | \"status\" | \"total_amount\" | \"shipping_address\" | \"payment_method\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_orders\"]>\n  export type shopping_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_order_snapshots?: boolean | shopping_orders$shopping_order_snapshotsArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_orders$shopping_order_itemsArgs<ExtArgs>\n    shopping_coin_transactions?: boolean | shopping_orders$shopping_coin_transactionsArgs<ExtArgs>\n    _count?: boolean | Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_orders\"\n    objects: {\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n      shopping_order_snapshots: Prisma.$shopping_order_snapshotsPayload<ExtArgs>[]\n      shopping_order_items: Prisma.$shopping_order_itemsPayload<ExtArgs>[]\n      shopping_coin_transactions: Prisma.$shopping_coin_transactionsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the customer who placed the order. {@link\n       * shopping_mall_member.id}\n       */\n      shopping_mall_member_id: string\n      /**\n       * Unique order code for tracking and reference purposes.\n       */\n      code: string\n      /**\n       * Current status of the order (e.g., pending, processing, shipped,\n       * delivered).\n       */\n      status: string\n      /**\n       * Total amount of the order including all items and taxes.\n       */\n      total_amount: number\n      /**\n       * Shipping address for the order.\n       */\n      shipping_address: string\n      /**\n       * Payment method used for the order (e.g., credit card, PayPal).\n       */\n      payment_method: string\n      /**\n       * Timestamp when the order was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the order was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the order was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_orders\"]>\n    composites: {}\n  }\n\n  type shopping_ordersGetPayload<S extends boolean | null | undefined | shopping_ordersDefaultArgs> = $Result.GetResult<Prisma.$shopping_ordersPayload, S>\n\n  type shopping_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_ordersCountAggregateInputType | true\n    }\n\n  export interface shopping_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_orders'], meta: { name: 'shopping_orders' } }\n    /**\n     * Find zero or one Shopping_orders that matches the filter.\n     * @param {shopping_ordersFindUniqueArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_ordersFindUniqueArgs>(args: SelectSubset<T, shopping_ordersFindUniqueArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_orders that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_ordersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindFirstArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_ordersFindFirstArgs>(args?: SelectSubset<T, shopping_ordersFindFirstArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_orders that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindFirstOrThrowArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findMany()\n     * \n     * // Get first 10 Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_ordersFindManyArgs>(args?: SelectSubset<T, shopping_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_orders.\n     * @param {shopping_ordersCreateArgs} args - Arguments to create a Shopping_orders.\n     * @example\n     * // Create one Shopping_orders\n     * const Shopping_orders = await prisma.shopping_orders.create({\n     *   data: {\n     *     // ... data to create a Shopping_orders\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_ordersCreateArgs>(args: SelectSubset<T, shopping_ordersCreateArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_orders.\n     * @param {shopping_ordersCreateManyArgs} args - Arguments to create many Shopping_orders.\n     * @example\n     * // Create many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_ordersCreateManyArgs>(args?: SelectSubset<T, shopping_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_orders and returns the data saved in the database.\n     * @param {shopping_ordersCreateManyAndReturnArgs} args - Arguments to create many Shopping_orders.\n     * @example\n     * // Create many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_orders and only return the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_orders.\n     * @param {shopping_ordersDeleteArgs} args - Arguments to delete one Shopping_orders.\n     * @example\n     * // Delete one Shopping_orders\n     * const Shopping_orders = await prisma.shopping_orders.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_orders\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_ordersDeleteArgs>(args: SelectSubset<T, shopping_ordersDeleteArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_orders.\n     * @param {shopping_ordersUpdateArgs} args - Arguments to update one Shopping_orders.\n     * @example\n     * // Update one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_ordersUpdateArgs>(args: SelectSubset<T, shopping_ordersUpdateArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_orders.\n     * @param {shopping_ordersDeleteManyArgs} args - Arguments to filter Shopping_orders to delete.\n     * @example\n     * // Delete a few Shopping_orders\n     * const { count } = await prisma.shopping_orders.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_ordersDeleteManyArgs>(args?: SelectSubset<T, shopping_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_ordersUpdateManyArgs>(args: SelectSubset<T, shopping_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_orders and returns the data updated in the database.\n     * @param {shopping_ordersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_orders.\n     * @example\n     * // Update many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_orders and only return the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_orders.\n     * @param {shopping_ordersUpsertArgs} args - Arguments to update or create a Shopping_orders.\n     * @example\n     * // Update or create a Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_orders\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_orders we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_ordersUpsertArgs>(args: SelectSubset<T, shopping_ordersUpsertArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersCountArgs} args - Arguments to filter Shopping_orders to count.\n     * @example\n     * // Count the number of Shopping_orders\n     * const count = await prisma.shopping_orders.count({\n     *   where: {\n     *     // ... the filter for the Shopping_orders we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_ordersCountArgs>(\n      args?: Subset<T, shopping_ordersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_ordersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_ordersAggregateArgs>(args: Subset<T, Shopping_ordersAggregateArgs>): Prisma.PrismaPromise<GetShopping_ordersAggregateType<T>>\n\n    /**\n     * Group by Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_ordersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_ordersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_ordersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_orders model\n   */\n  readonly fields: shopping_ordersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_orders.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_order_snapshots<T extends shopping_orders$shopping_order_snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_order_snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_order_items<T extends shopping_orders$shopping_order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_coin_transactions<T extends shopping_orders$shopping_coin_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_coin_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_orders model\n   */\n  interface shopping_ordersFieldRefs {\n    readonly id: FieldRef<\"shopping_orders\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_orders\", 'String'>\n    readonly code: FieldRef<\"shopping_orders\", 'String'>\n    readonly status: FieldRef<\"shopping_orders\", 'String'>\n    readonly total_amount: FieldRef<\"shopping_orders\", 'Float'>\n    readonly shipping_address: FieldRef<\"shopping_orders\", 'String'>\n    readonly payment_method: FieldRef<\"shopping_orders\", 'String'>\n    readonly created_at: FieldRef<\"shopping_orders\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_orders\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_orders\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_orders findUnique\n   */\n  export type shopping_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders findUniqueOrThrow\n   */\n  export type shopping_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders findFirst\n   */\n  export type shopping_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_orders.\n     */\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders findFirstOrThrow\n   */\n  export type shopping_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_orders.\n     */\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders findMany\n   */\n  export type shopping_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders create\n   */\n  export type shopping_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_orders.\n     */\n    data: XOR<shopping_ordersCreateInput, shopping_ordersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_orders createMany\n   */\n  export type shopping_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_orders.\n     */\n    data: shopping_ordersCreateManyInput | shopping_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_orders createManyAndReturn\n   */\n  export type shopping_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_orders.\n     */\n    data: shopping_ordersCreateManyInput | shopping_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_orders update\n   */\n  export type shopping_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateInput, shopping_ordersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_orders to update.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders updateMany\n   */\n  export type shopping_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_orders to update\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_orders updateManyAndReturn\n   */\n  export type shopping_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_orders to update\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_orders upsert\n   */\n  export type shopping_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_orders to update in case it exists.\n     */\n    where: shopping_ordersWhereUniqueInput\n    /**\n     * In case the shopping_orders found by the `where` argument doesn't exist, create a new shopping_orders with this data.\n     */\n    create: XOR<shopping_ordersCreateInput, shopping_ordersUncheckedCreateInput>\n    /**\n     * In case the shopping_orders was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_ordersUpdateInput, shopping_ordersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_orders delete\n   */\n  export type shopping_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_orders to delete.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders deleteMany\n   */\n  export type shopping_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_orders to delete\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_orders.shopping_order_snapshots\n   */\n  export type shopping_orders$shopping_order_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    where?: shopping_order_snapshotsWhereInput\n    orderBy?: shopping_order_snapshotsOrderByWithRelationInput | shopping_order_snapshotsOrderByWithRelationInput[]\n    cursor?: shopping_order_snapshotsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_snapshotsScalarFieldEnum | Shopping_order_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_order_items\n   */\n  export type shopping_orders$shopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    where?: shopping_order_itemsWhereInput\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    cursor?: shopping_order_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_coin_transactions\n   */\n  export type shopping_orders$shopping_coin_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    where?: shopping_coin_transactionsWhereInput\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_coin_transactionsScalarFieldEnum | Shopping_coin_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders without action\n   */\n  export type shopping_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_order_snapshots\n   */\n\n  export type AggregateShopping_order_snapshots = {\n    _count: Shopping_order_snapshotsCountAggregateOutputType | null\n    _avg: Shopping_order_snapshotsAvgAggregateOutputType | null\n    _sum: Shopping_order_snapshotsSumAggregateOutputType | null\n    _min: Shopping_order_snapshotsMinAggregateOutputType | null\n    _max: Shopping_order_snapshotsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_order_snapshotsAvgAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_order_snapshotsSumAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_order_snapshotsMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    code: string | null\n    status: string | null\n    total_amount: number | null\n    shipping_address: string | null\n    payment_method: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_order_snapshotsMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    code: string | null\n    status: string | null\n    total_amount: number | null\n    shipping_address: string | null\n    payment_method: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_order_snapshotsCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    code: number\n    status: number\n    total_amount: number\n    shipping_address: number\n    payment_method: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_order_snapshotsAvgAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_order_snapshotsSumAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_order_snapshotsMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n  }\n\n  export type Shopping_order_snapshotsMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n  }\n\n  export type Shopping_order_snapshotsCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    code?: true\n    status?: true\n    total_amount?: true\n    shipping_address?: true\n    payment_method?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_order_snapshotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_snapshots to aggregate.\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_snapshots to fetch.\n     */\n    orderBy?: shopping_order_snapshotsOrderByWithRelationInput | shopping_order_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_order_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_order_snapshots\n    **/\n    _count?: true | Shopping_order_snapshotsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_order_snapshotsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_order_snapshotsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_order_snapshotsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_order_snapshotsMaxAggregateInputType\n  }\n\n  export type GetShopping_order_snapshotsAggregateType<T extends Shopping_order_snapshotsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_order_snapshots]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_order_snapshots[P]>\n      : GetScalarType<T[P], AggregateShopping_order_snapshots[P]>\n  }\n\n\n\n\n  export type shopping_order_snapshotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_snapshotsWhereInput\n    orderBy?: shopping_order_snapshotsOrderByWithAggregationInput | shopping_order_snapshotsOrderByWithAggregationInput[]\n    by: Shopping_order_snapshotsScalarFieldEnum[] | Shopping_order_snapshotsScalarFieldEnum\n    having?: shopping_order_snapshotsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_order_snapshotsCountAggregateInputType | true\n    _avg?: Shopping_order_snapshotsAvgAggregateInputType\n    _sum?: Shopping_order_snapshotsSumAggregateInputType\n    _min?: Shopping_order_snapshotsMinAggregateInputType\n    _max?: Shopping_order_snapshotsMaxAggregateInputType\n  }\n\n  export type Shopping_order_snapshotsGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date\n    _count: Shopping_order_snapshotsCountAggregateOutputType | null\n    _avg: Shopping_order_snapshotsAvgAggregateOutputType | null\n    _sum: Shopping_order_snapshotsSumAggregateOutputType | null\n    _min: Shopping_order_snapshotsMinAggregateOutputType | null\n    _max: Shopping_order_snapshotsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_order_snapshotsGroupByPayload<T extends shopping_order_snapshotsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_order_snapshotsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_order_snapshotsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_order_snapshotsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_order_snapshotsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_order_snapshotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_snapshots\"]>\n\n  export type shopping_order_snapshotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_snapshots\"]>\n\n  export type shopping_order_snapshotsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_snapshots\"]>\n\n  export type shopping_order_snapshotsSelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    code?: boolean\n    status?: boolean\n    total_amount?: boolean\n    shipping_address?: boolean\n    payment_method?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_order_snapshotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"code\" | \"status\" | \"total_amount\" | \"shipping_address\" | \"payment_method\" | \"created_at\", ExtArgs[\"result\"][\"shopping_order_snapshots\"]>\n  export type shopping_order_snapshotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_snapshotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_snapshotsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_order_snapshotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_order_snapshots\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the order being snapshotted. {@link shopping_orders.id}\n       */\n      shopping_order_id: string\n      /**\n       * Unique order code for tracking and reference purposes.\n       */\n      code: string\n      /**\n       * Status of the order at the time of the snapshot.\n       */\n      status: string\n      /**\n       * Total amount of the order including all items and taxes.\n       */\n      total_amount: number\n      /**\n       * Shipping address for the order.\n       */\n      shipping_address: string\n      /**\n       * Payment method used for the order.\n       */\n      payment_method: string\n      /**\n       * Timestamp when the snapshot was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_order_snapshots\"]>\n    composites: {}\n  }\n\n  type shopping_order_snapshotsGetPayload<S extends boolean | null | undefined | shopping_order_snapshotsDefaultArgs> = $Result.GetResult<Prisma.$shopping_order_snapshotsPayload, S>\n\n  type shopping_order_snapshotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_order_snapshotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_order_snapshotsCountAggregateInputType | true\n    }\n\n  export interface shopping_order_snapshotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_order_snapshots'], meta: { name: 'shopping_order_snapshots' } }\n    /**\n     * Find zero or one Shopping_order_snapshots that matches the filter.\n     * @param {shopping_order_snapshotsFindUniqueArgs} args - Arguments to find a Shopping_order_snapshots\n     * @example\n     * // Get one Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_order_snapshotsFindUniqueArgs>(args: SelectSubset<T, shopping_order_snapshotsFindUniqueArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_order_snapshots that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_order_snapshotsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_order_snapshots\n     * @example\n     * // Get one Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_order_snapshotsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_order_snapshotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsFindFirstArgs} args - Arguments to find a Shopping_order_snapshots\n     * @example\n     * // Get one Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_order_snapshotsFindFirstArgs>(args?: SelectSubset<T, shopping_order_snapshotsFindFirstArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_snapshots that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsFindFirstOrThrowArgs} args - Arguments to find a Shopping_order_snapshots\n     * @example\n     * // Get one Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_order_snapshotsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_order_snapshotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_order_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findMany()\n     * \n     * // Get first 10 Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_order_snapshotsWithIdOnly = await prisma.shopping_order_snapshots.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_order_snapshotsFindManyArgs>(args?: SelectSubset<T, shopping_order_snapshotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsCreateArgs} args - Arguments to create a Shopping_order_snapshots.\n     * @example\n     * // Create one Shopping_order_snapshots\n     * const Shopping_order_snapshots = await prisma.shopping_order_snapshots.create({\n     *   data: {\n     *     // ... data to create a Shopping_order_snapshots\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_order_snapshotsCreateArgs>(args: SelectSubset<T, shopping_order_snapshotsCreateArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsCreateManyArgs} args - Arguments to create many Shopping_order_snapshots.\n     * @example\n     * // Create many Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_order_snapshotsCreateManyArgs>(args?: SelectSubset<T, shopping_order_snapshotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_order_snapshots and returns the data saved in the database.\n     * @param {shopping_order_snapshotsCreateManyAndReturnArgs} args - Arguments to create many Shopping_order_snapshots.\n     * @example\n     * // Create many Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_order_snapshots and only return the `id`\n     * const shopping_order_snapshotsWithIdOnly = await prisma.shopping_order_snapshots.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_order_snapshotsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_order_snapshotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsDeleteArgs} args - Arguments to delete one Shopping_order_snapshots.\n     * @example\n     * // Delete one Shopping_order_snapshots\n     * const Shopping_order_snapshots = await prisma.shopping_order_snapshots.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_order_snapshots\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_order_snapshotsDeleteArgs>(args: SelectSubset<T, shopping_order_snapshotsDeleteArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsUpdateArgs} args - Arguments to update one Shopping_order_snapshots.\n     * @example\n     * // Update one Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_order_snapshotsUpdateArgs>(args: SelectSubset<T, shopping_order_snapshotsUpdateArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsDeleteManyArgs} args - Arguments to filter Shopping_order_snapshots to delete.\n     * @example\n     * // Delete a few Shopping_order_snapshots\n     * const { count } = await prisma.shopping_order_snapshots.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_order_snapshotsDeleteManyArgs>(args?: SelectSubset<T, shopping_order_snapshotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_order_snapshotsUpdateManyArgs>(args: SelectSubset<T, shopping_order_snapshotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_snapshots and returns the data updated in the database.\n     * @param {shopping_order_snapshotsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_order_snapshots.\n     * @example\n     * // Update many Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_order_snapshots and only return the `id`\n     * const shopping_order_snapshotsWithIdOnly = await prisma.shopping_order_snapshots.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_order_snapshotsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_order_snapshotsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_order_snapshots.\n     * @param {shopping_order_snapshotsUpsertArgs} args - Arguments to update or create a Shopping_order_snapshots.\n     * @example\n     * // Update or create a Shopping_order_snapshots\n     * const shopping_order_snapshots = await prisma.shopping_order_snapshots.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_order_snapshots\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_order_snapshots we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_order_snapshotsUpsertArgs>(args: SelectSubset<T, shopping_order_snapshotsUpsertArgs<ExtArgs>>): Prisma__shopping_order_snapshotsClient<$Result.GetResult<Prisma.$shopping_order_snapshotsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_order_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsCountArgs} args - Arguments to filter Shopping_order_snapshots to count.\n     * @example\n     * // Count the number of Shopping_order_snapshots\n     * const count = await prisma.shopping_order_snapshots.count({\n     *   where: {\n     *     // ... the filter for the Shopping_order_snapshots we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_order_snapshotsCountArgs>(\n      args?: Subset<T, shopping_order_snapshotsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_order_snapshotsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_order_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_order_snapshotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_order_snapshotsAggregateArgs>(args: Subset<T, Shopping_order_snapshotsAggregateArgs>): Prisma.PrismaPromise<GetShopping_order_snapshotsAggregateType<T>>\n\n    /**\n     * Group by Shopping_order_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_snapshotsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_order_snapshotsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_order_snapshotsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_order_snapshotsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_order_snapshotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_order_snapshotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_order_snapshots model\n   */\n  readonly fields: shopping_order_snapshotsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_order_snapshots.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_order_snapshotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_order_snapshots model\n   */\n  interface shopping_order_snapshotsFieldRefs {\n    readonly id: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly code: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly status: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly total_amount: FieldRef<\"shopping_order_snapshots\", 'Float'>\n    readonly shipping_address: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly payment_method: FieldRef<\"shopping_order_snapshots\", 'String'>\n    readonly created_at: FieldRef<\"shopping_order_snapshots\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_order_snapshots findUnique\n   */\n  export type shopping_order_snapshotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_snapshots to fetch.\n     */\n    where: shopping_order_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_snapshots findUniqueOrThrow\n   */\n  export type shopping_order_snapshotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_snapshots to fetch.\n     */\n    where: shopping_order_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_snapshots findFirst\n   */\n  export type shopping_order_snapshotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_snapshots to fetch.\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_snapshots to fetch.\n     */\n    orderBy?: shopping_order_snapshotsOrderByWithRelationInput | shopping_order_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_snapshots.\n     */\n    cursor?: shopping_order_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_snapshots.\n     */\n    distinct?: Shopping_order_snapshotsScalarFieldEnum | Shopping_order_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_snapshots findFirstOrThrow\n   */\n  export type shopping_order_snapshotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_snapshots to fetch.\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_snapshots to fetch.\n     */\n    orderBy?: shopping_order_snapshotsOrderByWithRelationInput | shopping_order_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_snapshots.\n     */\n    cursor?: shopping_order_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_snapshots.\n     */\n    distinct?: Shopping_order_snapshotsScalarFieldEnum | Shopping_order_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_snapshots findMany\n   */\n  export type shopping_order_snapshotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_snapshots to fetch.\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_snapshots to fetch.\n     */\n    orderBy?: shopping_order_snapshotsOrderByWithRelationInput | shopping_order_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_order_snapshots.\n     */\n    cursor?: shopping_order_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_snapshots.\n     */\n    skip?: number\n    distinct?: Shopping_order_snapshotsScalarFieldEnum | Shopping_order_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_snapshots create\n   */\n  export type shopping_order_snapshotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_order_snapshots.\n     */\n    data: XOR<shopping_order_snapshotsCreateInput, shopping_order_snapshotsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_order_snapshots createMany\n   */\n  export type shopping_order_snapshotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_order_snapshots.\n     */\n    data: shopping_order_snapshotsCreateManyInput | shopping_order_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_order_snapshots createManyAndReturn\n   */\n  export type shopping_order_snapshotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_order_snapshots.\n     */\n    data: shopping_order_snapshotsCreateManyInput | shopping_order_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_snapshots update\n   */\n  export type shopping_order_snapshotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_order_snapshots.\n     */\n    data: XOR<shopping_order_snapshotsUpdateInput, shopping_order_snapshotsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_order_snapshots to update.\n     */\n    where: shopping_order_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_snapshots updateMany\n   */\n  export type shopping_order_snapshotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_order_snapshots.\n     */\n    data: XOR<shopping_order_snapshotsUpdateManyMutationInput, shopping_order_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_snapshots to update\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * Limit how many shopping_order_snapshots to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_snapshots updateManyAndReturn\n   */\n  export type shopping_order_snapshotsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_order_snapshots.\n     */\n    data: XOR<shopping_order_snapshotsUpdateManyMutationInput, shopping_order_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_snapshots to update\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * Limit how many shopping_order_snapshots to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_snapshots upsert\n   */\n  export type shopping_order_snapshotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_order_snapshots to update in case it exists.\n     */\n    where: shopping_order_snapshotsWhereUniqueInput\n    /**\n     * In case the shopping_order_snapshots found by the `where` argument doesn't exist, create a new shopping_order_snapshots with this data.\n     */\n    create: XOR<shopping_order_snapshotsCreateInput, shopping_order_snapshotsUncheckedCreateInput>\n    /**\n     * In case the shopping_order_snapshots was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_order_snapshotsUpdateInput, shopping_order_snapshotsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_order_snapshots delete\n   */\n  export type shopping_order_snapshotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_order_snapshots to delete.\n     */\n    where: shopping_order_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_snapshots deleteMany\n   */\n  export type shopping_order_snapshotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_snapshots to delete\n     */\n    where?: shopping_order_snapshotsWhereInput\n    /**\n     * Limit how many shopping_order_snapshots to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_snapshots without action\n   */\n  export type shopping_order_snapshotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_snapshots\n     */\n    select?: shopping_order_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_snapshots\n     */\n    omit?: shopping_order_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_snapshotsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_order_items\n   */\n\n  export type AggregateShopping_order_items = {\n    _count: Shopping_order_itemsCountAggregateOutputType | null\n    _avg: Shopping_order_itemsAvgAggregateOutputType | null\n    _sum: Shopping_order_itemsSumAggregateOutputType | null\n    _min: Shopping_order_itemsMinAggregateOutputType | null\n    _max: Shopping_order_itemsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_order_itemsAvgAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_order_itemsSumAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_order_itemsMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    product_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_order_itemsMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    product_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_order_itemsCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    product_id: number\n    quantity: number\n    price: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_order_itemsAvgAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_order_itemsSumAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_order_itemsMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    product_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_order_itemsMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    product_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_order_itemsCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    product_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_order_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_items to aggregate.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_order_items\n    **/\n    _count?: true | Shopping_order_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_order_itemsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_order_itemsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_order_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_order_itemsMaxAggregateInputType\n  }\n\n  export type GetShopping_order_itemsAggregateType<T extends Shopping_order_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_order_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_order_items[P]>\n      : GetScalarType<T[P], AggregateShopping_order_items[P]>\n  }\n\n\n\n\n  export type shopping_order_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_itemsWhereInput\n    orderBy?: shopping_order_itemsOrderByWithAggregationInput | shopping_order_itemsOrderByWithAggregationInput[]\n    by: Shopping_order_itemsScalarFieldEnum[] | Shopping_order_itemsScalarFieldEnum\n    having?: shopping_order_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_order_itemsCountAggregateInputType | true\n    _avg?: Shopping_order_itemsAvgAggregateInputType\n    _sum?: Shopping_order_itemsSumAggregateInputType\n    _min?: Shopping_order_itemsMinAggregateInputType\n    _max?: Shopping_order_itemsMaxAggregateInputType\n  }\n\n  export type Shopping_order_itemsGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_order_itemsCountAggregateOutputType | null\n    _avg: Shopping_order_itemsAvgAggregateOutputType | null\n    _sum: Shopping_order_itemsSumAggregateOutputType | null\n    _min: Shopping_order_itemsMinAggregateOutputType | null\n    _max: Shopping_order_itemsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_order_itemsGroupByPayload<T extends shopping_order_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_order_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_order_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_order_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_order_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_order_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    product_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    product_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    product_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    product_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_order_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"product_id\" | \"quantity\" | \"price\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_order_items\"]>\n  export type shopping_order_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_order_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_order_items\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the order that contains this item. {@link shopping_orders.id}\n       */\n      shopping_order_id: string\n      /**\n       * Unique identifier for the product.\n       */\n      product_id: string\n      /**\n       * Quantity of the product ordered.\n       */\n      quantity: number\n      /**\n       * Price of the product at the time of order.\n       */\n      price: number\n      /**\n       * Timestamp when the order item was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the order item was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n    composites: {}\n  }\n\n  type shopping_order_itemsGetPayload<S extends boolean | null | undefined | shopping_order_itemsDefaultArgs> = $Result.GetResult<Prisma.$shopping_order_itemsPayload, S>\n\n  type shopping_order_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_order_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_order_itemsCountAggregateInputType | true\n    }\n\n  export interface shopping_order_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_order_items'], meta: { name: 'shopping_order_items' } }\n    /**\n     * Find zero or one Shopping_order_items that matches the filter.\n     * @param {shopping_order_itemsFindUniqueArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_order_itemsFindUniqueArgs>(args: SelectSubset<T, shopping_order_itemsFindUniqueArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_order_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_order_itemsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_order_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindFirstArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_order_itemsFindFirstArgs>(args?: SelectSubset<T, shopping_order_itemsFindFirstArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindFirstOrThrowArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_order_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_order_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_order_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findMany()\n     * \n     * // Get first 10 Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_order_itemsFindManyArgs>(args?: SelectSubset<T, shopping_order_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_order_items.\n     * @param {shopping_order_itemsCreateArgs} args - Arguments to create a Shopping_order_items.\n     * @example\n     * // Create one Shopping_order_items\n     * const Shopping_order_items = await prisma.shopping_order_items.create({\n     *   data: {\n     *     // ... data to create a Shopping_order_items\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_order_itemsCreateArgs>(args: SelectSubset<T, shopping_order_itemsCreateArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_order_items.\n     * @param {shopping_order_itemsCreateManyArgs} args - Arguments to create many Shopping_order_items.\n     * @example\n     * // Create many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_order_itemsCreateManyArgs>(args?: SelectSubset<T, shopping_order_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_order_items and returns the data saved in the database.\n     * @param {shopping_order_itemsCreateManyAndReturnArgs} args - Arguments to create many Shopping_order_items.\n     * @example\n     * // Create many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_order_items and only return the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_order_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_order_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_order_items.\n     * @param {shopping_order_itemsDeleteArgs} args - Arguments to delete one Shopping_order_items.\n     * @example\n     * // Delete one Shopping_order_items\n     * const Shopping_order_items = await prisma.shopping_order_items.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_order_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_order_itemsDeleteArgs>(args: SelectSubset<T, shopping_order_itemsDeleteArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_order_items.\n     * @param {shopping_order_itemsUpdateArgs} args - Arguments to update one Shopping_order_items.\n     * @example\n     * // Update one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_order_itemsUpdateArgs>(args: SelectSubset<T, shopping_order_itemsUpdateArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_order_items.\n     * @param {shopping_order_itemsDeleteManyArgs} args - Arguments to filter Shopping_order_items to delete.\n     * @example\n     * // Delete a few Shopping_order_items\n     * const { count } = await prisma.shopping_order_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_order_itemsDeleteManyArgs>(args?: SelectSubset<T, shopping_order_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_order_itemsUpdateManyArgs>(args: SelectSubset<T, shopping_order_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_items and returns the data updated in the database.\n     * @param {shopping_order_itemsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_order_items.\n     * @example\n     * // Update many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_order_items and only return the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_order_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_order_items.\n     * @param {shopping_order_itemsUpsertArgs} args - Arguments to update or create a Shopping_order_items.\n     * @example\n     * // Update or create a Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_order_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_order_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_order_itemsUpsertArgs>(args: SelectSubset<T, shopping_order_itemsUpsertArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsCountArgs} args - Arguments to filter Shopping_order_items to count.\n     * @example\n     * // Count the number of Shopping_order_items\n     * const count = await prisma.shopping_order_items.count({\n     *   where: {\n     *     // ... the filter for the Shopping_order_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_order_itemsCountArgs>(\n      args?: Subset<T, shopping_order_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_order_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_order_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_order_itemsAggregateArgs>(args: Subset<T, Shopping_order_itemsAggregateArgs>): Prisma.PrismaPromise<GetShopping_order_itemsAggregateType<T>>\n\n    /**\n     * Group by Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_order_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_order_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_order_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_order_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_order_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_order_items model\n   */\n  readonly fields: shopping_order_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_order_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_order_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_order_items model\n   */\n  interface shopping_order_itemsFieldRefs {\n    readonly id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly product_id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly quantity: FieldRef<\"shopping_order_items\", 'Int'>\n    readonly price: FieldRef<\"shopping_order_items\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_order_items\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_order_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_order_items findUnique\n   */\n  export type shopping_order_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items findUniqueOrThrow\n   */\n  export type shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items findFirst\n   */\n  export type shopping_order_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_items.\n     */\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items findFirstOrThrow\n   */\n  export type shopping_order_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_items.\n     */\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items findMany\n   */\n  export type shopping_order_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items create\n   */\n  export type shopping_order_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsCreateInput, shopping_order_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_order_items createMany\n   */\n  export type shopping_order_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_order_items.\n     */\n    data: shopping_order_itemsCreateManyInput | shopping_order_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_order_items createManyAndReturn\n   */\n  export type shopping_order_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_order_items.\n     */\n    data: shopping_order_itemsCreateManyInput | shopping_order_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_items update\n   */\n  export type shopping_order_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateInput, shopping_order_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_order_items to update.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items updateMany\n   */\n  export type shopping_order_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_items to update\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_items updateManyAndReturn\n   */\n  export type shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_items to update\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_items upsert\n   */\n  export type shopping_order_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_order_items to update in case it exists.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n    /**\n     * In case the shopping_order_items found by the `where` argument doesn't exist, create a new shopping_order_items with this data.\n     */\n    create: XOR<shopping_order_itemsCreateInput, shopping_order_itemsUncheckedCreateInput>\n    /**\n     * In case the shopping_order_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_order_itemsUpdateInput, shopping_order_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_order_items delete\n   */\n  export type shopping_order_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_order_items to delete.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items deleteMany\n   */\n  export type shopping_order_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_items to delete\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_items without action\n   */\n  export type shopping_order_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_coupons\n   */\n\n  export type AggregateShopping_coupons = {\n    _count: Shopping_couponsCountAggregateOutputType | null\n    _avg: Shopping_couponsAvgAggregateOutputType | null\n    _sum: Shopping_couponsSumAggregateOutputType | null\n    _min: Shopping_couponsMinAggregateOutputType | null\n    _max: Shopping_couponsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_couponsAvgAggregateOutputType = {\n    value: number | null\n    max_uses: number | null\n  }\n\n  export type Shopping_couponsSumAggregateOutputType = {\n    value: number | null\n    max_uses: number | null\n  }\n\n  export type Shopping_couponsMinAggregateOutputType = {\n    id: string | null\n    code: string | null\n    discount_type: string | null\n    value: number | null\n    valid_from: Date | null\n    valid_until: Date | null\n    max_uses: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_couponsMaxAggregateOutputType = {\n    id: string | null\n    code: string | null\n    discount_type: string | null\n    value: number | null\n    valid_from: Date | null\n    valid_until: Date | null\n    max_uses: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_couponsCountAggregateOutputType = {\n    id: number\n    code: number\n    discount_type: number\n    value: number\n    valid_from: number\n    valid_until: number\n    max_uses: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_couponsAvgAggregateInputType = {\n    value?: true\n    max_uses?: true\n  }\n\n  export type Shopping_couponsSumAggregateInputType = {\n    value?: true\n    max_uses?: true\n  }\n\n  export type Shopping_couponsMinAggregateInputType = {\n    id?: true\n    code?: true\n    discount_type?: true\n    value?: true\n    valid_from?: true\n    valid_until?: true\n    max_uses?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_couponsMaxAggregateInputType = {\n    id?: true\n    code?: true\n    discount_type?: true\n    value?: true\n    valid_from?: true\n    valid_until?: true\n    max_uses?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_couponsCountAggregateInputType = {\n    id?: true\n    code?: true\n    discount_type?: true\n    value?: true\n    valid_from?: true\n    valid_until?: true\n    max_uses?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_couponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coupons to aggregate.\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupons to fetch.\n     */\n    orderBy?: shopping_couponsOrderByWithRelationInput | shopping_couponsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_couponsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupons from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupons.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_coupons\n    **/\n    _count?: true | Shopping_couponsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_couponsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_couponsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_couponsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_couponsMaxAggregateInputType\n  }\n\n  export type GetShopping_couponsAggregateType<T extends Shopping_couponsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_coupons]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_coupons[P]>\n      : GetScalarType<T[P], AggregateShopping_coupons[P]>\n  }\n\n\n\n\n  export type shopping_couponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_couponsWhereInput\n    orderBy?: shopping_couponsOrderByWithAggregationInput | shopping_couponsOrderByWithAggregationInput[]\n    by: Shopping_couponsScalarFieldEnum[] | Shopping_couponsScalarFieldEnum\n    having?: shopping_couponsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_couponsCountAggregateInputType | true\n    _avg?: Shopping_couponsAvgAggregateInputType\n    _sum?: Shopping_couponsSumAggregateInputType\n    _min?: Shopping_couponsMinAggregateInputType\n    _max?: Shopping_couponsMaxAggregateInputType\n  }\n\n  export type Shopping_couponsGroupByOutputType = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date\n    valid_until: Date\n    max_uses: number | null\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_couponsCountAggregateOutputType | null\n    _avg: Shopping_couponsAvgAggregateOutputType | null\n    _sum: Shopping_couponsSumAggregateOutputType | null\n    _min: Shopping_couponsMinAggregateOutputType | null\n    _max: Shopping_couponsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_couponsGroupByPayload<T extends shopping_couponsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_couponsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_couponsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_couponsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_couponsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_couponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    discount_type?: boolean\n    value?: boolean\n    valid_from?: boolean\n    valid_until?: boolean\n    max_uses?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    shopping_coupon_usage?: boolean | shopping_coupons$shopping_coupon_usageArgs<ExtArgs>\n    _count?: boolean | Shopping_couponsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coupons\"]>\n\n  export type shopping_couponsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    discount_type?: boolean\n    value?: boolean\n    valid_from?: boolean\n    valid_until?: boolean\n    max_uses?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_coupons\"]>\n\n  export type shopping_couponsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    code?: boolean\n    discount_type?: boolean\n    value?: boolean\n    valid_from?: boolean\n    valid_until?: boolean\n    max_uses?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_coupons\"]>\n\n  export type shopping_couponsSelectScalar = {\n    id?: boolean\n    code?: boolean\n    discount_type?: boolean\n    value?: boolean\n    valid_from?: boolean\n    valid_until?: boolean\n    max_uses?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_couponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"code\" | \"discount_type\" | \"value\" | \"valid_from\" | \"valid_until\" | \"max_uses\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_coupons\"]>\n  export type shopping_couponsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_coupon_usage?: boolean | shopping_coupons$shopping_coupon_usageArgs<ExtArgs>\n    _count?: boolean | Shopping_couponsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_couponsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_couponsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_couponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_coupons\"\n    objects: {\n      shopping_coupon_usage: Prisma.$shopping_coupon_usagePayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Unique coupon code for redemption.\n       */\n      code: string\n      /**\n       * Type of discount (percentage or fixed amount).\n       */\n      discount_type: string\n      /**\n       * Discount value (percentage or fixed amount).\n       */\n      value: number\n      /**\n       * Start date when the coupon becomes valid.\n       */\n      valid_from: Date\n      /**\n       * End date when the coupon expires.\n       */\n      valid_until: Date\n      /**\n       * Maximum number of times the coupon can be used.\n       */\n      max_uses: number | null\n      /**\n       * Timestamp when the coupon was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the coupon was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_coupons\"]>\n    composites: {}\n  }\n\n  type shopping_couponsGetPayload<S extends boolean | null | undefined | shopping_couponsDefaultArgs> = $Result.GetResult<Prisma.$shopping_couponsPayload, S>\n\n  type shopping_couponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_couponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_couponsCountAggregateInputType | true\n    }\n\n  export interface shopping_couponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_coupons'], meta: { name: 'shopping_coupons' } }\n    /**\n     * Find zero or one Shopping_coupons that matches the filter.\n     * @param {shopping_couponsFindUniqueArgs} args - Arguments to find a Shopping_coupons\n     * @example\n     * // Get one Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_couponsFindUniqueArgs>(args: SelectSubset<T, shopping_couponsFindUniqueArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_coupons that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_couponsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_coupons\n     * @example\n     * // Get one Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_couponsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_couponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coupons that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsFindFirstArgs} args - Arguments to find a Shopping_coupons\n     * @example\n     * // Get one Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_couponsFindFirstArgs>(args?: SelectSubset<T, shopping_couponsFindFirstArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coupons that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsFindFirstOrThrowArgs} args - Arguments to find a Shopping_coupons\n     * @example\n     * // Get one Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_couponsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_couponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_coupons that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findMany()\n     * \n     * // Get first 10 Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_couponsWithIdOnly = await prisma.shopping_coupons.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_couponsFindManyArgs>(args?: SelectSubset<T, shopping_couponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_coupons.\n     * @param {shopping_couponsCreateArgs} args - Arguments to create a Shopping_coupons.\n     * @example\n     * // Create one Shopping_coupons\n     * const Shopping_coupons = await prisma.shopping_coupons.create({\n     *   data: {\n     *     // ... data to create a Shopping_coupons\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_couponsCreateArgs>(args: SelectSubset<T, shopping_couponsCreateArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_coupons.\n     * @param {shopping_couponsCreateManyArgs} args - Arguments to create many Shopping_coupons.\n     * @example\n     * // Create many Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_couponsCreateManyArgs>(args?: SelectSubset<T, shopping_couponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_coupons and returns the data saved in the database.\n     * @param {shopping_couponsCreateManyAndReturnArgs} args - Arguments to create many Shopping_coupons.\n     * @example\n     * // Create many Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_coupons and only return the `id`\n     * const shopping_couponsWithIdOnly = await prisma.shopping_coupons.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_couponsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_couponsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_coupons.\n     * @param {shopping_couponsDeleteArgs} args - Arguments to delete one Shopping_coupons.\n     * @example\n     * // Delete one Shopping_coupons\n     * const Shopping_coupons = await prisma.shopping_coupons.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_coupons\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_couponsDeleteArgs>(args: SelectSubset<T, shopping_couponsDeleteArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_coupons.\n     * @param {shopping_couponsUpdateArgs} args - Arguments to update one Shopping_coupons.\n     * @example\n     * // Update one Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_couponsUpdateArgs>(args: SelectSubset<T, shopping_couponsUpdateArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_coupons.\n     * @param {shopping_couponsDeleteManyArgs} args - Arguments to filter Shopping_coupons to delete.\n     * @example\n     * // Delete a few Shopping_coupons\n     * const { count } = await prisma.shopping_coupons.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_couponsDeleteManyArgs>(args?: SelectSubset<T, shopping_couponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coupons.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_couponsUpdateManyArgs>(args: SelectSubset<T, shopping_couponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coupons and returns the data updated in the database.\n     * @param {shopping_couponsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_coupons.\n     * @example\n     * // Update many Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_coupons and only return the `id`\n     * const shopping_couponsWithIdOnly = await prisma.shopping_coupons.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_couponsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_couponsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_coupons.\n     * @param {shopping_couponsUpsertArgs} args - Arguments to update or create a Shopping_coupons.\n     * @example\n     * // Update or create a Shopping_coupons\n     * const shopping_coupons = await prisma.shopping_coupons.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_coupons\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_coupons we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_couponsUpsertArgs>(args: SelectSubset<T, shopping_couponsUpsertArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_coupons.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsCountArgs} args - Arguments to filter Shopping_coupons to count.\n     * @example\n     * // Count the number of Shopping_coupons\n     * const count = await prisma.shopping_coupons.count({\n     *   where: {\n     *     // ... the filter for the Shopping_coupons we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_couponsCountArgs>(\n      args?: Subset<T, shopping_couponsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_couponsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_coupons.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_couponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_couponsAggregateArgs>(args: Subset<T, Shopping_couponsAggregateArgs>): Prisma.PrismaPromise<GetShopping_couponsAggregateType<T>>\n\n    /**\n     * Group by Shopping_coupons.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_couponsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_couponsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_couponsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_couponsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_couponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_couponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_coupons model\n   */\n  readonly fields: shopping_couponsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_coupons.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_couponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_coupon_usage<T extends shopping_coupons$shopping_coupon_usageArgs<ExtArgs> = {}>(args?: Subset<T, shopping_coupons$shopping_coupon_usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_coupons model\n   */\n  interface shopping_couponsFieldRefs {\n    readonly id: FieldRef<\"shopping_coupons\", 'String'>\n    readonly code: FieldRef<\"shopping_coupons\", 'String'>\n    readonly discount_type: FieldRef<\"shopping_coupons\", 'String'>\n    readonly value: FieldRef<\"shopping_coupons\", 'Float'>\n    readonly valid_from: FieldRef<\"shopping_coupons\", 'DateTime'>\n    readonly valid_until: FieldRef<\"shopping_coupons\", 'DateTime'>\n    readonly max_uses: FieldRef<\"shopping_coupons\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_coupons\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_coupons\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_coupons findUnique\n   */\n  export type shopping_couponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupons to fetch.\n     */\n    where: shopping_couponsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupons findUniqueOrThrow\n   */\n  export type shopping_couponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupons to fetch.\n     */\n    where: shopping_couponsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupons findFirst\n   */\n  export type shopping_couponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupons to fetch.\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupons to fetch.\n     */\n    orderBy?: shopping_couponsOrderByWithRelationInput | shopping_couponsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coupons.\n     */\n    cursor?: shopping_couponsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupons from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupons.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coupons.\n     */\n    distinct?: Shopping_couponsScalarFieldEnum | Shopping_couponsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupons findFirstOrThrow\n   */\n  export type shopping_couponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupons to fetch.\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupons to fetch.\n     */\n    orderBy?: shopping_couponsOrderByWithRelationInput | shopping_couponsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coupons.\n     */\n    cursor?: shopping_couponsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupons from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupons.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coupons.\n     */\n    distinct?: Shopping_couponsScalarFieldEnum | Shopping_couponsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupons findMany\n   */\n  export type shopping_couponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupons to fetch.\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupons to fetch.\n     */\n    orderBy?: shopping_couponsOrderByWithRelationInput | shopping_couponsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_coupons.\n     */\n    cursor?: shopping_couponsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupons from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupons.\n     */\n    skip?: number\n    distinct?: Shopping_couponsScalarFieldEnum | Shopping_couponsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupons create\n   */\n  export type shopping_couponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_coupons.\n     */\n    data: XOR<shopping_couponsCreateInput, shopping_couponsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_coupons createMany\n   */\n  export type shopping_couponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_coupons.\n     */\n    data: shopping_couponsCreateManyInput | shopping_couponsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_coupons createManyAndReturn\n   */\n  export type shopping_couponsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_coupons.\n     */\n    data: shopping_couponsCreateManyInput | shopping_couponsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_coupons update\n   */\n  export type shopping_couponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_coupons.\n     */\n    data: XOR<shopping_couponsUpdateInput, shopping_couponsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_coupons to update.\n     */\n    where: shopping_couponsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupons updateMany\n   */\n  export type shopping_couponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_coupons.\n     */\n    data: XOR<shopping_couponsUpdateManyMutationInput, shopping_couponsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coupons to update\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * Limit how many shopping_coupons to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coupons updateManyAndReturn\n   */\n  export type shopping_couponsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_coupons.\n     */\n    data: XOR<shopping_couponsUpdateManyMutationInput, shopping_couponsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coupons to update\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * Limit how many shopping_coupons to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coupons upsert\n   */\n  export type shopping_couponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_coupons to update in case it exists.\n     */\n    where: shopping_couponsWhereUniqueInput\n    /**\n     * In case the shopping_coupons found by the `where` argument doesn't exist, create a new shopping_coupons with this data.\n     */\n    create: XOR<shopping_couponsCreateInput, shopping_couponsUncheckedCreateInput>\n    /**\n     * In case the shopping_coupons was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_couponsUpdateInput, shopping_couponsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_coupons delete\n   */\n  export type shopping_couponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_coupons to delete.\n     */\n    where: shopping_couponsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupons deleteMany\n   */\n  export type shopping_couponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coupons to delete\n     */\n    where?: shopping_couponsWhereInput\n    /**\n     * Limit how many shopping_coupons to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coupons.shopping_coupon_usage\n   */\n  export type shopping_coupons$shopping_coupon_usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    where?: shopping_coupon_usageWhereInput\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_coupon_usageScalarFieldEnum | Shopping_coupon_usageScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupons without action\n   */\n  export type shopping_couponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupons\n     */\n    select?: shopping_couponsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupons\n     */\n    omit?: shopping_couponsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_couponsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_coupon_usage\n   */\n\n  export type AggregateShopping_coupon_usage = {\n    _count: Shopping_coupon_usageCountAggregateOutputType | null\n    _min: Shopping_coupon_usageMinAggregateOutputType | null\n    _max: Shopping_coupon_usageMaxAggregateOutputType | null\n  }\n\n  export type Shopping_coupon_usageMinAggregateOutputType = {\n    id: string | null\n    shopping_coupon_id: string | null\n    shopping_mall_member_id: string | null\n    order_id: string | null\n    used_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_coupon_usageMaxAggregateOutputType = {\n    id: string | null\n    shopping_coupon_id: string | null\n    shopping_mall_member_id: string | null\n    order_id: string | null\n    used_at: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_coupon_usageCountAggregateOutputType = {\n    id: number\n    shopping_coupon_id: number\n    shopping_mall_member_id: number\n    order_id: number\n    used_at: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_coupon_usageMinAggregateInputType = {\n    id?: true\n    shopping_coupon_id?: true\n    shopping_mall_member_id?: true\n    order_id?: true\n    used_at?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_coupon_usageMaxAggregateInputType = {\n    id?: true\n    shopping_coupon_id?: true\n    shopping_mall_member_id?: true\n    order_id?: true\n    used_at?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_coupon_usageCountAggregateInputType = {\n    id?: true\n    shopping_coupon_id?: true\n    shopping_mall_member_id?: true\n    order_id?: true\n    used_at?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_coupon_usageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coupon_usage to aggregate.\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupon_usages to fetch.\n     */\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupon_usages from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupon_usages.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_coupon_usages\n    **/\n    _count?: true | Shopping_coupon_usageCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_coupon_usageMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_coupon_usageMaxAggregateInputType\n  }\n\n  export type GetShopping_coupon_usageAggregateType<T extends Shopping_coupon_usageAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_coupon_usage]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_coupon_usage[P]>\n      : GetScalarType<T[P], AggregateShopping_coupon_usage[P]>\n  }\n\n\n\n\n  export type shopping_coupon_usageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coupon_usageWhereInput\n    orderBy?: shopping_coupon_usageOrderByWithAggregationInput | shopping_coupon_usageOrderByWithAggregationInput[]\n    by: Shopping_coupon_usageScalarFieldEnum[] | Shopping_coupon_usageScalarFieldEnum\n    having?: shopping_coupon_usageScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_coupon_usageCountAggregateInputType | true\n    _min?: Shopping_coupon_usageMinAggregateInputType\n    _max?: Shopping_coupon_usageMaxAggregateInputType\n  }\n\n  export type Shopping_coupon_usageGroupByOutputType = {\n    id: string\n    shopping_coupon_id: string\n    shopping_mall_member_id: string\n    order_id: string\n    used_at: Date\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_coupon_usageCountAggregateOutputType | null\n    _min: Shopping_coupon_usageMinAggregateOutputType | null\n    _max: Shopping_coupon_usageMaxAggregateOutputType | null\n  }\n\n  type GetShopping_coupon_usageGroupByPayload<T extends shopping_coupon_usageGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_coupon_usageGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_coupon_usageGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_coupon_usageGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_coupon_usageGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_coupon_usageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_coupon_id?: boolean\n    shopping_mall_member_id?: boolean\n    order_id?: boolean\n    used_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coupon_usage\"]>\n\n  export type shopping_coupon_usageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_coupon_id?: boolean\n    shopping_mall_member_id?: boolean\n    order_id?: boolean\n    used_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coupon_usage\"]>\n\n  export type shopping_coupon_usageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_coupon_id?: boolean\n    shopping_mall_member_id?: boolean\n    order_id?: boolean\n    used_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coupon_usage\"]>\n\n  export type shopping_coupon_usageSelectScalar = {\n    id?: boolean\n    shopping_coupon_id?: boolean\n    shopping_mall_member_id?: boolean\n    order_id?: boolean\n    used_at?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_coupon_usageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_coupon_id\" | \"shopping_mall_member_id\" | \"order_id\" | \"used_at\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_coupon_usage\"]>\n  export type shopping_coupon_usageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_coupon_usageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_coupon_usageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    coupon?: boolean | shopping_couponsDefaultArgs<ExtArgs>\n    user?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_coupon_usagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_coupon_usage\"\n    objects: {\n      coupon: Prisma.$shopping_couponsPayload<ExtArgs>\n      user: Prisma.$shopping_mall_memberPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Coupon that was used. {@link shopping_coupons.id}\n       */\n      shopping_coupon_id: string\n      /**\n       * User who applied the coupon. {@link shopping_mall_member.id}\n       */\n      shopping_mall_member_id: string\n      /**\n       * Order to which the coupon was applied.\n       */\n      order_id: string\n      /**\n       * Timestamp when the coupon was used.\n       */\n      used_at: Date\n      /**\n       * Timestamp when the usage record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the usage record was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_coupon_usage\"]>\n    composites: {}\n  }\n\n  type shopping_coupon_usageGetPayload<S extends boolean | null | undefined | shopping_coupon_usageDefaultArgs> = $Result.GetResult<Prisma.$shopping_coupon_usagePayload, S>\n\n  type shopping_coupon_usageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_coupon_usageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_coupon_usageCountAggregateInputType | true\n    }\n\n  export interface shopping_coupon_usageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_coupon_usage'], meta: { name: 'shopping_coupon_usage' } }\n    /**\n     * Find zero or one Shopping_coupon_usage that matches the filter.\n     * @param {shopping_coupon_usageFindUniqueArgs} args - Arguments to find a Shopping_coupon_usage\n     * @example\n     * // Get one Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_coupon_usageFindUniqueArgs>(args: SelectSubset<T, shopping_coupon_usageFindUniqueArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_coupon_usage that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_coupon_usageFindUniqueOrThrowArgs} args - Arguments to find a Shopping_coupon_usage\n     * @example\n     * // Get one Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_coupon_usageFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_coupon_usageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coupon_usage that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageFindFirstArgs} args - Arguments to find a Shopping_coupon_usage\n     * @example\n     * // Get one Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_coupon_usageFindFirstArgs>(args?: SelectSubset<T, shopping_coupon_usageFindFirstArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coupon_usage that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageFindFirstOrThrowArgs} args - Arguments to find a Shopping_coupon_usage\n     * @example\n     * // Get one Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_coupon_usageFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_coupon_usageFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_coupon_usages that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_coupon_usages\n     * const shopping_coupon_usages = await prisma.shopping_coupon_usage.findMany()\n     * \n     * // Get first 10 Shopping_coupon_usages\n     * const shopping_coupon_usages = await prisma.shopping_coupon_usage.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_coupon_usageWithIdOnly = await prisma.shopping_coupon_usage.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_coupon_usageFindManyArgs>(args?: SelectSubset<T, shopping_coupon_usageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_coupon_usage.\n     * @param {shopping_coupon_usageCreateArgs} args - Arguments to create a Shopping_coupon_usage.\n     * @example\n     * // Create one Shopping_coupon_usage\n     * const Shopping_coupon_usage = await prisma.shopping_coupon_usage.create({\n     *   data: {\n     *     // ... data to create a Shopping_coupon_usage\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_coupon_usageCreateArgs>(args: SelectSubset<T, shopping_coupon_usageCreateArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_coupon_usages.\n     * @param {shopping_coupon_usageCreateManyArgs} args - Arguments to create many Shopping_coupon_usages.\n     * @example\n     * // Create many Shopping_coupon_usages\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_coupon_usageCreateManyArgs>(args?: SelectSubset<T, shopping_coupon_usageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_coupon_usages and returns the data saved in the database.\n     * @param {shopping_coupon_usageCreateManyAndReturnArgs} args - Arguments to create many Shopping_coupon_usages.\n     * @example\n     * // Create many Shopping_coupon_usages\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_coupon_usages and only return the `id`\n     * const shopping_coupon_usageWithIdOnly = await prisma.shopping_coupon_usage.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_coupon_usageCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_coupon_usageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_coupon_usage.\n     * @param {shopping_coupon_usageDeleteArgs} args - Arguments to delete one Shopping_coupon_usage.\n     * @example\n     * // Delete one Shopping_coupon_usage\n     * const Shopping_coupon_usage = await prisma.shopping_coupon_usage.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_coupon_usage\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_coupon_usageDeleteArgs>(args: SelectSubset<T, shopping_coupon_usageDeleteArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_coupon_usage.\n     * @param {shopping_coupon_usageUpdateArgs} args - Arguments to update one Shopping_coupon_usage.\n     * @example\n     * // Update one Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_coupon_usageUpdateArgs>(args: SelectSubset<T, shopping_coupon_usageUpdateArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_coupon_usages.\n     * @param {shopping_coupon_usageDeleteManyArgs} args - Arguments to filter Shopping_coupon_usages to delete.\n     * @example\n     * // Delete a few Shopping_coupon_usages\n     * const { count } = await prisma.shopping_coupon_usage.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_coupon_usageDeleteManyArgs>(args?: SelectSubset<T, shopping_coupon_usageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coupon_usages.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_coupon_usages\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_coupon_usageUpdateManyArgs>(args: SelectSubset<T, shopping_coupon_usageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coupon_usages and returns the data updated in the database.\n     * @param {shopping_coupon_usageUpdateManyAndReturnArgs} args - Arguments to update many Shopping_coupon_usages.\n     * @example\n     * // Update many Shopping_coupon_usages\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_coupon_usages and only return the `id`\n     * const shopping_coupon_usageWithIdOnly = await prisma.shopping_coupon_usage.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_coupon_usageUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_coupon_usageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_coupon_usage.\n     * @param {shopping_coupon_usageUpsertArgs} args - Arguments to update or create a Shopping_coupon_usage.\n     * @example\n     * // Update or create a Shopping_coupon_usage\n     * const shopping_coupon_usage = await prisma.shopping_coupon_usage.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_coupon_usage\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_coupon_usage we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_coupon_usageUpsertArgs>(args: SelectSubset<T, shopping_coupon_usageUpsertArgs<ExtArgs>>): Prisma__shopping_coupon_usageClient<$Result.GetResult<Prisma.$shopping_coupon_usagePayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_coupon_usages.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageCountArgs} args - Arguments to filter Shopping_coupon_usages to count.\n     * @example\n     * // Count the number of Shopping_coupon_usages\n     * const count = await prisma.shopping_coupon_usage.count({\n     *   where: {\n     *     // ... the filter for the Shopping_coupon_usages we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_coupon_usageCountArgs>(\n      args?: Subset<T, shopping_coupon_usageCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_coupon_usageCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_coupon_usage.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_coupon_usageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_coupon_usageAggregateArgs>(args: Subset<T, Shopping_coupon_usageAggregateArgs>): Prisma.PrismaPromise<GetShopping_coupon_usageAggregateType<T>>\n\n    /**\n     * Group by Shopping_coupon_usage.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coupon_usageGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_coupon_usageGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_coupon_usageGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_coupon_usageGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_coupon_usageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_coupon_usageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_coupon_usage model\n   */\n  readonly fields: shopping_coupon_usageFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_coupon_usage.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_coupon_usageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    coupon<T extends shopping_couponsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_couponsDefaultArgs<ExtArgs>>): Prisma__shopping_couponsClient<$Result.GetResult<Prisma.$shopping_couponsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    user<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_coupon_usage model\n   */\n  interface shopping_coupon_usageFieldRefs {\n    readonly id: FieldRef<\"shopping_coupon_usage\", 'String'>\n    readonly shopping_coupon_id: FieldRef<\"shopping_coupon_usage\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_coupon_usage\", 'String'>\n    readonly order_id: FieldRef<\"shopping_coupon_usage\", 'String'>\n    readonly used_at: FieldRef<\"shopping_coupon_usage\", 'DateTime'>\n    readonly created_at: FieldRef<\"shopping_coupon_usage\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_coupon_usage\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_coupon_usage findUnique\n   */\n  export type shopping_coupon_usageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupon_usage to fetch.\n     */\n    where: shopping_coupon_usageWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupon_usage findUniqueOrThrow\n   */\n  export type shopping_coupon_usageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupon_usage to fetch.\n     */\n    where: shopping_coupon_usageWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupon_usage findFirst\n   */\n  export type shopping_coupon_usageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupon_usage to fetch.\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupon_usages to fetch.\n     */\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coupon_usages.\n     */\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupon_usages from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupon_usages.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coupon_usages.\n     */\n    distinct?: Shopping_coupon_usageScalarFieldEnum | Shopping_coupon_usageScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupon_usage findFirstOrThrow\n   */\n  export type shopping_coupon_usageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupon_usage to fetch.\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupon_usages to fetch.\n     */\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coupon_usages.\n     */\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupon_usages from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupon_usages.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coupon_usages.\n     */\n    distinct?: Shopping_coupon_usageScalarFieldEnum | Shopping_coupon_usageScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupon_usage findMany\n   */\n  export type shopping_coupon_usageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coupon_usages to fetch.\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coupon_usages to fetch.\n     */\n    orderBy?: shopping_coupon_usageOrderByWithRelationInput | shopping_coupon_usageOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_coupon_usages.\n     */\n    cursor?: shopping_coupon_usageWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coupon_usages from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coupon_usages.\n     */\n    skip?: number\n    distinct?: Shopping_coupon_usageScalarFieldEnum | Shopping_coupon_usageScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coupon_usage create\n   */\n  export type shopping_coupon_usageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_coupon_usage.\n     */\n    data: XOR<shopping_coupon_usageCreateInput, shopping_coupon_usageUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_coupon_usage createMany\n   */\n  export type shopping_coupon_usageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_coupon_usages.\n     */\n    data: shopping_coupon_usageCreateManyInput | shopping_coupon_usageCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_coupon_usage createManyAndReturn\n   */\n  export type shopping_coupon_usageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_coupon_usages.\n     */\n    data: shopping_coupon_usageCreateManyInput | shopping_coupon_usageCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coupon_usage update\n   */\n  export type shopping_coupon_usageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_coupon_usage.\n     */\n    data: XOR<shopping_coupon_usageUpdateInput, shopping_coupon_usageUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_coupon_usage to update.\n     */\n    where: shopping_coupon_usageWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupon_usage updateMany\n   */\n  export type shopping_coupon_usageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_coupon_usages.\n     */\n    data: XOR<shopping_coupon_usageUpdateManyMutationInput, shopping_coupon_usageUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coupon_usages to update\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * Limit how many shopping_coupon_usages to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coupon_usage updateManyAndReturn\n   */\n  export type shopping_coupon_usageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_coupon_usages.\n     */\n    data: XOR<shopping_coupon_usageUpdateManyMutationInput, shopping_coupon_usageUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coupon_usages to update\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * Limit how many shopping_coupon_usages to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coupon_usage upsert\n   */\n  export type shopping_coupon_usageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_coupon_usage to update in case it exists.\n     */\n    where: shopping_coupon_usageWhereUniqueInput\n    /**\n     * In case the shopping_coupon_usage found by the `where` argument doesn't exist, create a new shopping_coupon_usage with this data.\n     */\n    create: XOR<shopping_coupon_usageCreateInput, shopping_coupon_usageUncheckedCreateInput>\n    /**\n     * In case the shopping_coupon_usage was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_coupon_usageUpdateInput, shopping_coupon_usageUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_coupon_usage delete\n   */\n  export type shopping_coupon_usageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_coupon_usage to delete.\n     */\n    where: shopping_coupon_usageWhereUniqueInput\n  }\n\n  /**\n   * shopping_coupon_usage deleteMany\n   */\n  export type shopping_coupon_usageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coupon_usages to delete\n     */\n    where?: shopping_coupon_usageWhereInput\n    /**\n     * Limit how many shopping_coupon_usages to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coupon_usage without action\n   */\n  export type shopping_coupon_usageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coupon_usage\n     */\n    select?: shopping_coupon_usageSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coupon_usage\n     */\n    omit?: shopping_coupon_usageOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coupon_usageInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_coins\n   */\n\n  export type AggregateShopping_coins = {\n    _count: Shopping_coinsCountAggregateOutputType | null\n    _avg: Shopping_coinsAvgAggregateOutputType | null\n    _sum: Shopping_coinsSumAggregateOutputType | null\n    _min: Shopping_coinsMinAggregateOutputType | null\n    _max: Shopping_coinsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_coinsAvgAggregateOutputType = {\n    balance: number | null\n  }\n\n  export type Shopping_coinsSumAggregateOutputType = {\n    balance: number | null\n  }\n\n  export type Shopping_coinsMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    balance: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_coinsMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    balance: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_coinsCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    balance: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_coinsAvgAggregateInputType = {\n    balance?: true\n  }\n\n  export type Shopping_coinsSumAggregateInputType = {\n    balance?: true\n  }\n\n  export type Shopping_coinsMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    balance?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_coinsMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    balance?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_coinsCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    balance?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_coinsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coins to aggregate.\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coins to fetch.\n     */\n    orderBy?: shopping_coinsOrderByWithRelationInput | shopping_coinsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_coinsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_coins\n    **/\n    _count?: true | Shopping_coinsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_coinsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_coinsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_coinsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_coinsMaxAggregateInputType\n  }\n\n  export type GetShopping_coinsAggregateType<T extends Shopping_coinsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_coins]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_coins[P]>\n      : GetScalarType<T[P], AggregateShopping_coins[P]>\n  }\n\n\n\n\n  export type shopping_coinsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coinsWhereInput\n    orderBy?: shopping_coinsOrderByWithAggregationInput | shopping_coinsOrderByWithAggregationInput[]\n    by: Shopping_coinsScalarFieldEnum[] | Shopping_coinsScalarFieldEnum\n    having?: shopping_coinsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_coinsCountAggregateInputType | true\n    _avg?: Shopping_coinsAvgAggregateInputType\n    _sum?: Shopping_coinsSumAggregateInputType\n    _min?: Shopping_coinsMinAggregateInputType\n    _max?: Shopping_coinsMaxAggregateInputType\n  }\n\n  export type Shopping_coinsGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    balance: number\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_coinsCountAggregateOutputType | null\n    _avg: Shopping_coinsAvgAggregateOutputType | null\n    _sum: Shopping_coinsSumAggregateOutputType | null\n    _min: Shopping_coinsMinAggregateOutputType | null\n    _max: Shopping_coinsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_coinsGroupByPayload<T extends shopping_coinsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_coinsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_coinsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_coinsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_coinsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_coinsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    balance?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coins\"]>\n\n  export type shopping_coinsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    balance?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coins\"]>\n\n  export type shopping_coinsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    balance?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coins\"]>\n\n  export type shopping_coinsSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    balance?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_coinsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"balance\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_coins\"]>\n  export type shopping_coinsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_coinsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_coinsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_coinsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_coins\"\n    objects: {\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged member's {@link shopping_mall_member.id}.\n       */\n      shopping_mall_member_id: string\n      /**\n       * Current coin balance.\n       */\n      balance: number\n      /**\n       * When the coin account was created.\n       */\n      created_at: Date\n      /**\n       * When the coin account was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the coin account was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_coins\"]>\n    composites: {}\n  }\n\n  type shopping_coinsGetPayload<S extends boolean | null | undefined | shopping_coinsDefaultArgs> = $Result.GetResult<Prisma.$shopping_coinsPayload, S>\n\n  type shopping_coinsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_coinsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_coinsCountAggregateInputType | true\n    }\n\n  export interface shopping_coinsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_coins'], meta: { name: 'shopping_coins' } }\n    /**\n     * Find zero or one Shopping_coins that matches the filter.\n     * @param {shopping_coinsFindUniqueArgs} args - Arguments to find a Shopping_coins\n     * @example\n     * // Get one Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_coinsFindUniqueArgs>(args: SelectSubset<T, shopping_coinsFindUniqueArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_coins that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_coinsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_coins\n     * @example\n     * // Get one Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_coinsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_coinsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsFindFirstArgs} args - Arguments to find a Shopping_coins\n     * @example\n     * // Get one Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_coinsFindFirstArgs>(args?: SelectSubset<T, shopping_coinsFindFirstArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coins that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsFindFirstOrThrowArgs} args - Arguments to find a Shopping_coins\n     * @example\n     * // Get one Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_coinsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_coinsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_coins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findMany()\n     * \n     * // Get first 10 Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_coinsWithIdOnly = await prisma.shopping_coins.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_coinsFindManyArgs>(args?: SelectSubset<T, shopping_coinsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_coins.\n     * @param {shopping_coinsCreateArgs} args - Arguments to create a Shopping_coins.\n     * @example\n     * // Create one Shopping_coins\n     * const Shopping_coins = await prisma.shopping_coins.create({\n     *   data: {\n     *     // ... data to create a Shopping_coins\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_coinsCreateArgs>(args: SelectSubset<T, shopping_coinsCreateArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_coins.\n     * @param {shopping_coinsCreateManyArgs} args - Arguments to create many Shopping_coins.\n     * @example\n     * // Create many Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_coinsCreateManyArgs>(args?: SelectSubset<T, shopping_coinsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_coins and returns the data saved in the database.\n     * @param {shopping_coinsCreateManyAndReturnArgs} args - Arguments to create many Shopping_coins.\n     * @example\n     * // Create many Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_coins and only return the `id`\n     * const shopping_coinsWithIdOnly = await prisma.shopping_coins.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_coinsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_coinsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_coins.\n     * @param {shopping_coinsDeleteArgs} args - Arguments to delete one Shopping_coins.\n     * @example\n     * // Delete one Shopping_coins\n     * const Shopping_coins = await prisma.shopping_coins.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_coins\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_coinsDeleteArgs>(args: SelectSubset<T, shopping_coinsDeleteArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_coins.\n     * @param {shopping_coinsUpdateArgs} args - Arguments to update one Shopping_coins.\n     * @example\n     * // Update one Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_coinsUpdateArgs>(args: SelectSubset<T, shopping_coinsUpdateArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_coins.\n     * @param {shopping_coinsDeleteManyArgs} args - Arguments to filter Shopping_coins to delete.\n     * @example\n     * // Delete a few Shopping_coins\n     * const { count } = await prisma.shopping_coins.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_coinsDeleteManyArgs>(args?: SelectSubset<T, shopping_coinsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_coinsUpdateManyArgs>(args: SelectSubset<T, shopping_coinsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coins and returns the data updated in the database.\n     * @param {shopping_coinsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_coins.\n     * @example\n     * // Update many Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_coins and only return the `id`\n     * const shopping_coinsWithIdOnly = await prisma.shopping_coins.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_coinsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_coinsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_coins.\n     * @param {shopping_coinsUpsertArgs} args - Arguments to update or create a Shopping_coins.\n     * @example\n     * // Update or create a Shopping_coins\n     * const shopping_coins = await prisma.shopping_coins.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_coins\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_coins we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_coinsUpsertArgs>(args: SelectSubset<T, shopping_coinsUpsertArgs<ExtArgs>>): Prisma__shopping_coinsClient<$Result.GetResult<Prisma.$shopping_coinsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_coins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsCountArgs} args - Arguments to filter Shopping_coins to count.\n     * @example\n     * // Count the number of Shopping_coins\n     * const count = await prisma.shopping_coins.count({\n     *   where: {\n     *     // ... the filter for the Shopping_coins we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_coinsCountArgs>(\n      args?: Subset<T, shopping_coinsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_coinsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_coins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_coinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_coinsAggregateArgs>(args: Subset<T, Shopping_coinsAggregateArgs>): Prisma.PrismaPromise<GetShopping_coinsAggregateType<T>>\n\n    /**\n     * Group by Shopping_coins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coinsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_coinsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_coinsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_coinsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_coinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_coinsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_coins model\n   */\n  readonly fields: shopping_coinsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_coins.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_coinsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_coins model\n   */\n  interface shopping_coinsFieldRefs {\n    readonly id: FieldRef<\"shopping_coins\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_coins\", 'String'>\n    readonly balance: FieldRef<\"shopping_coins\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_coins\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_coins\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_coins\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_coins findUnique\n   */\n  export type shopping_coinsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coins to fetch.\n     */\n    where: shopping_coinsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coins findUniqueOrThrow\n   */\n  export type shopping_coinsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coins to fetch.\n     */\n    where: shopping_coinsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coins findFirst\n   */\n  export type shopping_coinsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coins to fetch.\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coins to fetch.\n     */\n    orderBy?: shopping_coinsOrderByWithRelationInput | shopping_coinsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coins.\n     */\n    cursor?: shopping_coinsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coins.\n     */\n    distinct?: Shopping_coinsScalarFieldEnum | Shopping_coinsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coins findFirstOrThrow\n   */\n  export type shopping_coinsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coins to fetch.\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coins to fetch.\n     */\n    orderBy?: shopping_coinsOrderByWithRelationInput | shopping_coinsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coins.\n     */\n    cursor?: shopping_coinsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coins.\n     */\n    distinct?: Shopping_coinsScalarFieldEnum | Shopping_coinsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coins findMany\n   */\n  export type shopping_coinsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coins to fetch.\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coins to fetch.\n     */\n    orderBy?: shopping_coinsOrderByWithRelationInput | shopping_coinsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_coins.\n     */\n    cursor?: shopping_coinsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coins.\n     */\n    skip?: number\n    distinct?: Shopping_coinsScalarFieldEnum | Shopping_coinsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coins create\n   */\n  export type shopping_coinsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_coins.\n     */\n    data: XOR<shopping_coinsCreateInput, shopping_coinsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_coins createMany\n   */\n  export type shopping_coinsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_coins.\n     */\n    data: shopping_coinsCreateManyInput | shopping_coinsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_coins createManyAndReturn\n   */\n  export type shopping_coinsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_coins.\n     */\n    data: shopping_coinsCreateManyInput | shopping_coinsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coins update\n   */\n  export type shopping_coinsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_coins.\n     */\n    data: XOR<shopping_coinsUpdateInput, shopping_coinsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_coins to update.\n     */\n    where: shopping_coinsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coins updateMany\n   */\n  export type shopping_coinsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_coins.\n     */\n    data: XOR<shopping_coinsUpdateManyMutationInput, shopping_coinsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coins to update\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * Limit how many shopping_coins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coins updateManyAndReturn\n   */\n  export type shopping_coinsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_coins.\n     */\n    data: XOR<shopping_coinsUpdateManyMutationInput, shopping_coinsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coins to update\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * Limit how many shopping_coins to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coins upsert\n   */\n  export type shopping_coinsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_coins to update in case it exists.\n     */\n    where: shopping_coinsWhereUniqueInput\n    /**\n     * In case the shopping_coins found by the `where` argument doesn't exist, create a new shopping_coins with this data.\n     */\n    create: XOR<shopping_coinsCreateInput, shopping_coinsUncheckedCreateInput>\n    /**\n     * In case the shopping_coins was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_coinsUpdateInput, shopping_coinsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_coins delete\n   */\n  export type shopping_coinsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_coins to delete.\n     */\n    where: shopping_coinsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coins deleteMany\n   */\n  export type shopping_coinsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coins to delete\n     */\n    where?: shopping_coinsWhereInput\n    /**\n     * Limit how many shopping_coins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coins without action\n   */\n  export type shopping_coinsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coins\n     */\n    select?: shopping_coinsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coins\n     */\n    omit?: shopping_coinsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coinsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_coin_transactions\n   */\n\n  export type AggregateShopping_coin_transactions = {\n    _count: Shopping_coin_transactionsCountAggregateOutputType | null\n    _avg: Shopping_coin_transactionsAvgAggregateOutputType | null\n    _sum: Shopping_coin_transactionsSumAggregateOutputType | null\n    _min: Shopping_coin_transactionsMinAggregateOutputType | null\n    _max: Shopping_coin_transactionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_coin_transactionsAvgAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_coin_transactionsSumAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_coin_transactionsMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    shopping_order_id: string | null\n    amount: number | null\n    transaction_type: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_coin_transactionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    shopping_order_id: string | null\n    amount: number | null\n    transaction_type: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_coin_transactionsCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    shopping_order_id: number\n    amount: number\n    transaction_type: number\n    description: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_coin_transactionsAvgAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_coin_transactionsSumAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_coin_transactionsMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    shopping_order_id?: true\n    amount?: true\n    transaction_type?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type Shopping_coin_transactionsMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    shopping_order_id?: true\n    amount?: true\n    transaction_type?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type Shopping_coin_transactionsCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    shopping_order_id?: true\n    amount?: true\n    transaction_type?: true\n    description?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_coin_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coin_transactions to aggregate.\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coin_transactions to fetch.\n     */\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coin_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coin_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_coin_transactions\n    **/\n    _count?: true | Shopping_coin_transactionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_coin_transactionsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_coin_transactionsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_coin_transactionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_coin_transactionsMaxAggregateInputType\n  }\n\n  export type GetShopping_coin_transactionsAggregateType<T extends Shopping_coin_transactionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_coin_transactions]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_coin_transactions[P]>\n      : GetScalarType<T[P], AggregateShopping_coin_transactions[P]>\n  }\n\n\n\n\n  export type shopping_coin_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_coin_transactionsWhereInput\n    orderBy?: shopping_coin_transactionsOrderByWithAggregationInput | shopping_coin_transactionsOrderByWithAggregationInput[]\n    by: Shopping_coin_transactionsScalarFieldEnum[] | Shopping_coin_transactionsScalarFieldEnum\n    having?: shopping_coin_transactionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_coin_transactionsCountAggregateInputType | true\n    _avg?: Shopping_coin_transactionsAvgAggregateInputType\n    _sum?: Shopping_coin_transactionsSumAggregateInputType\n    _min?: Shopping_coin_transactionsMinAggregateInputType\n    _max?: Shopping_coin_transactionsMaxAggregateInputType\n  }\n\n  export type Shopping_coin_transactionsGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    shopping_order_id: string | null\n    amount: number\n    transaction_type: string\n    description: string | null\n    created_at: Date\n    _count: Shopping_coin_transactionsCountAggregateOutputType | null\n    _avg: Shopping_coin_transactionsAvgAggregateOutputType | null\n    _sum: Shopping_coin_transactionsSumAggregateOutputType | null\n    _min: Shopping_coin_transactionsMinAggregateOutputType | null\n    _max: Shopping_coin_transactionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_coin_transactionsGroupByPayload<T extends shopping_coin_transactionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_coin_transactionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_coin_transactionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_coin_transactionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_coin_transactionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_coin_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    shopping_order_id?: boolean\n    amount?: boolean\n    transaction_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coin_transactions\"]>\n\n  export type shopping_coin_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    shopping_order_id?: boolean\n    amount?: boolean\n    transaction_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coin_transactions\"]>\n\n  export type shopping_coin_transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    shopping_order_id?: boolean\n    amount?: boolean\n    transaction_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_coin_transactions\"]>\n\n  export type shopping_coin_transactionsSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    shopping_order_id?: boolean\n    amount?: boolean\n    transaction_type?: boolean\n    description?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_coin_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"shopping_order_id\" | \"amount\" | \"transaction_type\" | \"description\" | \"created_at\", ExtArgs[\"result\"][\"shopping_coin_transactions\"]>\n  export type shopping_coin_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }\n  export type shopping_coin_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }\n  export type shopping_coin_transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    order?: boolean | shopping_coin_transactions$orderArgs<ExtArgs>\n  }\n\n  export type $shopping_coin_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_coin_transactions\"\n    objects: {\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n      order: Prisma.$shopping_ordersPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged member's {@link shopping_mall_member.id}.\n       */\n      shopping_mall_member_id: string\n      /**\n       * Belonged order's {@link shopping_orders.id}.\n       */\n      shopping_order_id: string | null\n      /**\n       * Amount of coins involved in the transaction.\n       */\n      amount: number\n      /**\n       * Type of transaction (e.g., 'purchase', 'refund', 'earn').\n       */\n      transaction_type: string\n      /**\n       * Description of the transaction.\n       */\n      description: string | null\n      /**\n       * When the transaction occurred.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_coin_transactions\"]>\n    composites: {}\n  }\n\n  type shopping_coin_transactionsGetPayload<S extends boolean | null | undefined | shopping_coin_transactionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_coin_transactionsPayload, S>\n\n  type shopping_coin_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_coin_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_coin_transactionsCountAggregateInputType | true\n    }\n\n  export interface shopping_coin_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_coin_transactions'], meta: { name: 'shopping_coin_transactions' } }\n    /**\n     * Find zero or one Shopping_coin_transactions that matches the filter.\n     * @param {shopping_coin_transactionsFindUniqueArgs} args - Arguments to find a Shopping_coin_transactions\n     * @example\n     * // Get one Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_coin_transactionsFindUniqueArgs>(args: SelectSubset<T, shopping_coin_transactionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_coin_transactions that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_coin_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_coin_transactions\n     * @example\n     * // Get one Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_coin_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_coin_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coin_transactions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsFindFirstArgs} args - Arguments to find a Shopping_coin_transactions\n     * @example\n     * // Get one Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_coin_transactionsFindFirstArgs>(args?: SelectSubset<T, shopping_coin_transactionsFindFirstArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_coin_transactions that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_coin_transactions\n     * @example\n     * // Get one Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_coin_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_coin_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_coin_transactions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findMany()\n     * \n     * // Get first 10 Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_coin_transactionsWithIdOnly = await prisma.shopping_coin_transactions.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_coin_transactionsFindManyArgs>(args?: SelectSubset<T, shopping_coin_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsCreateArgs} args - Arguments to create a Shopping_coin_transactions.\n     * @example\n     * // Create one Shopping_coin_transactions\n     * const Shopping_coin_transactions = await prisma.shopping_coin_transactions.create({\n     *   data: {\n     *     // ... data to create a Shopping_coin_transactions\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_coin_transactionsCreateArgs>(args: SelectSubset<T, shopping_coin_transactionsCreateArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsCreateManyArgs} args - Arguments to create many Shopping_coin_transactions.\n     * @example\n     * // Create many Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_coin_transactionsCreateManyArgs>(args?: SelectSubset<T, shopping_coin_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_coin_transactions and returns the data saved in the database.\n     * @param {shopping_coin_transactionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_coin_transactions.\n     * @example\n     * // Create many Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_coin_transactions and only return the `id`\n     * const shopping_coin_transactionsWithIdOnly = await prisma.shopping_coin_transactions.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_coin_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_coin_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsDeleteArgs} args - Arguments to delete one Shopping_coin_transactions.\n     * @example\n     * // Delete one Shopping_coin_transactions\n     * const Shopping_coin_transactions = await prisma.shopping_coin_transactions.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_coin_transactions\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_coin_transactionsDeleteArgs>(args: SelectSubset<T, shopping_coin_transactionsDeleteArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsUpdateArgs} args - Arguments to update one Shopping_coin_transactions.\n     * @example\n     * // Update one Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_coin_transactionsUpdateArgs>(args: SelectSubset<T, shopping_coin_transactionsUpdateArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsDeleteManyArgs} args - Arguments to filter Shopping_coin_transactions to delete.\n     * @example\n     * // Delete a few Shopping_coin_transactions\n     * const { count } = await prisma.shopping_coin_transactions.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_coin_transactionsDeleteManyArgs>(args?: SelectSubset<T, shopping_coin_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coin_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_coin_transactionsUpdateManyArgs>(args: SelectSubset<T, shopping_coin_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_coin_transactions and returns the data updated in the database.\n     * @param {shopping_coin_transactionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_coin_transactions.\n     * @example\n     * // Update many Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_coin_transactions and only return the `id`\n     * const shopping_coin_transactionsWithIdOnly = await prisma.shopping_coin_transactions.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_coin_transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_coin_transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_coin_transactions.\n     * @param {shopping_coin_transactionsUpsertArgs} args - Arguments to update or create a Shopping_coin_transactions.\n     * @example\n     * // Update or create a Shopping_coin_transactions\n     * const shopping_coin_transactions = await prisma.shopping_coin_transactions.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_coin_transactions\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_coin_transactions we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_coin_transactionsUpsertArgs>(args: SelectSubset<T, shopping_coin_transactionsUpsertArgs<ExtArgs>>): Prisma__shopping_coin_transactionsClient<$Result.GetResult<Prisma.$shopping_coin_transactionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_coin_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsCountArgs} args - Arguments to filter Shopping_coin_transactions to count.\n     * @example\n     * // Count the number of Shopping_coin_transactions\n     * const count = await prisma.shopping_coin_transactions.count({\n     *   where: {\n     *     // ... the filter for the Shopping_coin_transactions we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_coin_transactionsCountArgs>(\n      args?: Subset<T, shopping_coin_transactionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_coin_transactionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_coin_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_coin_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_coin_transactionsAggregateArgs>(args: Subset<T, Shopping_coin_transactionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_coin_transactionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_coin_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_coin_transactionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_coin_transactionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_coin_transactionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_coin_transactionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_coin_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_coin_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_coin_transactions model\n   */\n  readonly fields: shopping_coin_transactionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_coin_transactions.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_coin_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    order<T extends shopping_coin_transactions$orderArgs<ExtArgs> = {}>(args?: Subset<T, shopping_coin_transactions$orderArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_coin_transactions model\n   */\n  interface shopping_coin_transactionsFieldRefs {\n    readonly id: FieldRef<\"shopping_coin_transactions\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_coin_transactions\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_coin_transactions\", 'String'>\n    readonly amount: FieldRef<\"shopping_coin_transactions\", 'Float'>\n    readonly transaction_type: FieldRef<\"shopping_coin_transactions\", 'String'>\n    readonly description: FieldRef<\"shopping_coin_transactions\", 'String'>\n    readonly created_at: FieldRef<\"shopping_coin_transactions\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_coin_transactions findUnique\n   */\n  export type shopping_coin_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coin_transactions to fetch.\n     */\n    where: shopping_coin_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coin_transactions findUniqueOrThrow\n   */\n  export type shopping_coin_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coin_transactions to fetch.\n     */\n    where: shopping_coin_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coin_transactions findFirst\n   */\n  export type shopping_coin_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coin_transactions to fetch.\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coin_transactions to fetch.\n     */\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coin_transactions.\n     */\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coin_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coin_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coin_transactions.\n     */\n    distinct?: Shopping_coin_transactionsScalarFieldEnum | Shopping_coin_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coin_transactions findFirstOrThrow\n   */\n  export type shopping_coin_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coin_transactions to fetch.\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coin_transactions to fetch.\n     */\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_coin_transactions.\n     */\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coin_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coin_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_coin_transactions.\n     */\n    distinct?: Shopping_coin_transactionsScalarFieldEnum | Shopping_coin_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coin_transactions findMany\n   */\n  export type shopping_coin_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_coin_transactions to fetch.\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_coin_transactions to fetch.\n     */\n    orderBy?: shopping_coin_transactionsOrderByWithRelationInput | shopping_coin_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_coin_transactions.\n     */\n    cursor?: shopping_coin_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_coin_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_coin_transactions.\n     */\n    skip?: number\n    distinct?: Shopping_coin_transactionsScalarFieldEnum | Shopping_coin_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_coin_transactions create\n   */\n  export type shopping_coin_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_coin_transactions.\n     */\n    data: XOR<shopping_coin_transactionsCreateInput, shopping_coin_transactionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_coin_transactions createMany\n   */\n  export type shopping_coin_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_coin_transactions.\n     */\n    data: shopping_coin_transactionsCreateManyInput | shopping_coin_transactionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_coin_transactions createManyAndReturn\n   */\n  export type shopping_coin_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_coin_transactions.\n     */\n    data: shopping_coin_transactionsCreateManyInput | shopping_coin_transactionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coin_transactions update\n   */\n  export type shopping_coin_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_coin_transactions.\n     */\n    data: XOR<shopping_coin_transactionsUpdateInput, shopping_coin_transactionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_coin_transactions to update.\n     */\n    where: shopping_coin_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coin_transactions updateMany\n   */\n  export type shopping_coin_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_coin_transactions.\n     */\n    data: XOR<shopping_coin_transactionsUpdateManyMutationInput, shopping_coin_transactionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coin_transactions to update\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * Limit how many shopping_coin_transactions to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coin_transactions updateManyAndReturn\n   */\n  export type shopping_coin_transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_coin_transactions.\n     */\n    data: XOR<shopping_coin_transactionsUpdateManyMutationInput, shopping_coin_transactionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_coin_transactions to update\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * Limit how many shopping_coin_transactions to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_coin_transactions upsert\n   */\n  export type shopping_coin_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_coin_transactions to update in case it exists.\n     */\n    where: shopping_coin_transactionsWhereUniqueInput\n    /**\n     * In case the shopping_coin_transactions found by the `where` argument doesn't exist, create a new shopping_coin_transactions with this data.\n     */\n    create: XOR<shopping_coin_transactionsCreateInput, shopping_coin_transactionsUncheckedCreateInput>\n    /**\n     * In case the shopping_coin_transactions was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_coin_transactionsUpdateInput, shopping_coin_transactionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_coin_transactions delete\n   */\n  export type shopping_coin_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_coin_transactions to delete.\n     */\n    where: shopping_coin_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_coin_transactions deleteMany\n   */\n  export type shopping_coin_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_coin_transactions to delete\n     */\n    where?: shopping_coin_transactionsWhereInput\n    /**\n     * Limit how many shopping_coin_transactions to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_coin_transactions.order\n   */\n  export type shopping_coin_transactions$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    where?: shopping_ordersWhereInput\n  }\n\n  /**\n   * shopping_coin_transactions without action\n   */\n  export type shopping_coin_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_coin_transactions\n     */\n    select?: shopping_coin_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_coin_transactions\n     */\n    omit?: shopping_coin_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_coin_transactionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_inquiries\n   */\n\n  export type AggregateShopping_inquiries = {\n    _count: Shopping_inquiriesCountAggregateOutputType | null\n    _min: Shopping_inquiriesMinAggregateOutputType | null\n    _max: Shopping_inquiriesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_inquiriesMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    title: string | null\n    content: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_inquiriesMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    title: string | null\n    content: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_inquiriesCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    title: number\n    content: number\n    status: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_inquiriesMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_inquiriesMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_inquiriesCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_inquiriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inquiries to aggregate.\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiries to fetch.\n     */\n    orderBy?: shopping_inquiriesOrderByWithRelationInput | shopping_inquiriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_inquiriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_inquiries\n    **/\n    _count?: true | Shopping_inquiriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_inquiriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_inquiriesMaxAggregateInputType\n  }\n\n  export type GetShopping_inquiriesAggregateType<T extends Shopping_inquiriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_inquiries]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_inquiries[P]>\n      : GetScalarType<T[P], AggregateShopping_inquiries[P]>\n  }\n\n\n\n\n  export type shopping_inquiriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inquiriesWhereInput\n    orderBy?: shopping_inquiriesOrderByWithAggregationInput | shopping_inquiriesOrderByWithAggregationInput[]\n    by: Shopping_inquiriesScalarFieldEnum[] | Shopping_inquiriesScalarFieldEnum\n    having?: shopping_inquiriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_inquiriesCountAggregateInputType | true\n    _min?: Shopping_inquiriesMinAggregateInputType\n    _max?: Shopping_inquiriesMaxAggregateInputType\n  }\n\n  export type Shopping_inquiriesGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_inquiriesCountAggregateOutputType | null\n    _min: Shopping_inquiriesMinAggregateOutputType | null\n    _max: Shopping_inquiriesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_inquiriesGroupByPayload<T extends shopping_inquiriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_inquiriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_inquiriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_inquiriesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_inquiriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_inquiriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_inquiry_responses?: boolean | shopping_inquiries$shopping_inquiry_responsesArgs<ExtArgs>\n    _count?: boolean | Shopping_inquiriesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiries\"]>\n\n  export type shopping_inquiriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiries\"]>\n\n  export type shopping_inquiriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiries\"]>\n\n  export type shopping_inquiriesSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_inquiriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"title\" | \"content\" | \"status\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_inquiries\"]>\n  export type shopping_inquiriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_inquiry_responses?: boolean | shopping_inquiries$shopping_inquiry_responsesArgs<ExtArgs>\n    _count?: boolean | Shopping_inquiriesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_inquiriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_inquiriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_inquiriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_inquiries\"\n    objects: {\n      customer: Prisma.$shopping_mall_memberPayload<ExtArgs>\n      shopping_inquiry_responses: Prisma.$shopping_inquiry_responsesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Customer who created the inquiry. {@link shopping_mall_member.id}\n       */\n      shopping_mall_member_id: string\n      /**\n       * Title of the inquiry.\n       */\n      title: string\n      /**\n       * Detailed content of the inquiry.\n       */\n      content: string\n      /**\n       * Current status of the inquiry (e.g., 'open', 'in-progress', 'resolved').\n       */\n      status: string\n      /**\n       * When the inquiry was created.\n       */\n      created_at: Date\n      /**\n       * When the inquiry was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the inquiry was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_inquiries\"]>\n    composites: {}\n  }\n\n  type shopping_inquiriesGetPayload<S extends boolean | null | undefined | shopping_inquiriesDefaultArgs> = $Result.GetResult<Prisma.$shopping_inquiriesPayload, S>\n\n  type shopping_inquiriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_inquiriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_inquiriesCountAggregateInputType | true\n    }\n\n  export interface shopping_inquiriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_inquiries'], meta: { name: 'shopping_inquiries' } }\n    /**\n     * Find zero or one Shopping_inquiries that matches the filter.\n     * @param {shopping_inquiriesFindUniqueArgs} args - Arguments to find a Shopping_inquiries\n     * @example\n     * // Get one Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_inquiriesFindUniqueArgs>(args: SelectSubset<T, shopping_inquiriesFindUniqueArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_inquiries that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_inquiriesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_inquiries\n     * @example\n     * // Get one Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_inquiriesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_inquiriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inquiries that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesFindFirstArgs} args - Arguments to find a Shopping_inquiries\n     * @example\n     * // Get one Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_inquiriesFindFirstArgs>(args?: SelectSubset<T, shopping_inquiriesFindFirstArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inquiries that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesFindFirstOrThrowArgs} args - Arguments to find a Shopping_inquiries\n     * @example\n     * // Get one Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_inquiriesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_inquiriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_inquiries that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findMany()\n     * \n     * // Get first 10 Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_inquiriesWithIdOnly = await prisma.shopping_inquiries.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_inquiriesFindManyArgs>(args?: SelectSubset<T, shopping_inquiriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_inquiries.\n     * @param {shopping_inquiriesCreateArgs} args - Arguments to create a Shopping_inquiries.\n     * @example\n     * // Create one Shopping_inquiries\n     * const Shopping_inquiries = await prisma.shopping_inquiries.create({\n     *   data: {\n     *     // ... data to create a Shopping_inquiries\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_inquiriesCreateArgs>(args: SelectSubset<T, shopping_inquiriesCreateArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_inquiries.\n     * @param {shopping_inquiriesCreateManyArgs} args - Arguments to create many Shopping_inquiries.\n     * @example\n     * // Create many Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_inquiriesCreateManyArgs>(args?: SelectSubset<T, shopping_inquiriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_inquiries and returns the data saved in the database.\n     * @param {shopping_inquiriesCreateManyAndReturnArgs} args - Arguments to create many Shopping_inquiries.\n     * @example\n     * // Create many Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_inquiries and only return the `id`\n     * const shopping_inquiriesWithIdOnly = await prisma.shopping_inquiries.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_inquiriesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_inquiriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_inquiries.\n     * @param {shopping_inquiriesDeleteArgs} args - Arguments to delete one Shopping_inquiries.\n     * @example\n     * // Delete one Shopping_inquiries\n     * const Shopping_inquiries = await prisma.shopping_inquiries.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_inquiries\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_inquiriesDeleteArgs>(args: SelectSubset<T, shopping_inquiriesDeleteArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_inquiries.\n     * @param {shopping_inquiriesUpdateArgs} args - Arguments to update one Shopping_inquiries.\n     * @example\n     * // Update one Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_inquiriesUpdateArgs>(args: SelectSubset<T, shopping_inquiriesUpdateArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_inquiries.\n     * @param {shopping_inquiriesDeleteManyArgs} args - Arguments to filter Shopping_inquiries to delete.\n     * @example\n     * // Delete a few Shopping_inquiries\n     * const { count } = await prisma.shopping_inquiries.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_inquiriesDeleteManyArgs>(args?: SelectSubset<T, shopping_inquiriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inquiries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_inquiriesUpdateManyArgs>(args: SelectSubset<T, shopping_inquiriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inquiries and returns the data updated in the database.\n     * @param {shopping_inquiriesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_inquiries.\n     * @example\n     * // Update many Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_inquiries and only return the `id`\n     * const shopping_inquiriesWithIdOnly = await prisma.shopping_inquiries.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_inquiriesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_inquiriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_inquiries.\n     * @param {shopping_inquiriesUpsertArgs} args - Arguments to update or create a Shopping_inquiries.\n     * @example\n     * // Update or create a Shopping_inquiries\n     * const shopping_inquiries = await prisma.shopping_inquiries.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_inquiries\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_inquiries we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_inquiriesUpsertArgs>(args: SelectSubset<T, shopping_inquiriesUpsertArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_inquiries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesCountArgs} args - Arguments to filter Shopping_inquiries to count.\n     * @example\n     * // Count the number of Shopping_inquiries\n     * const count = await prisma.shopping_inquiries.count({\n     *   where: {\n     *     // ... the filter for the Shopping_inquiries we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_inquiriesCountArgs>(\n      args?: Subset<T, shopping_inquiriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_inquiriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_inquiries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_inquiriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_inquiriesAggregateArgs>(args: Subset<T, Shopping_inquiriesAggregateArgs>): Prisma.PrismaPromise<GetShopping_inquiriesAggregateType<T>>\n\n    /**\n     * Group by Shopping_inquiries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_inquiriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_inquiriesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_inquiriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_inquiriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_inquiriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_inquiries model\n   */\n  readonly fields: shopping_inquiriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_inquiries.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_inquiriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    customer<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_inquiry_responses<T extends shopping_inquiries$shopping_inquiry_responsesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_inquiries$shopping_inquiry_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_inquiries model\n   */\n  interface shopping_inquiriesFieldRefs {\n    readonly id: FieldRef<\"shopping_inquiries\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_inquiries\", 'String'>\n    readonly title: FieldRef<\"shopping_inquiries\", 'String'>\n    readonly content: FieldRef<\"shopping_inquiries\", 'String'>\n    readonly status: FieldRef<\"shopping_inquiries\", 'String'>\n    readonly created_at: FieldRef<\"shopping_inquiries\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_inquiries\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_inquiries\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_inquiries findUnique\n   */\n  export type shopping_inquiriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiries to fetch.\n     */\n    where: shopping_inquiriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiries findUniqueOrThrow\n   */\n  export type shopping_inquiriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiries to fetch.\n     */\n    where: shopping_inquiriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiries findFirst\n   */\n  export type shopping_inquiriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiries to fetch.\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiries to fetch.\n     */\n    orderBy?: shopping_inquiriesOrderByWithRelationInput | shopping_inquiriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inquiries.\n     */\n    cursor?: shopping_inquiriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inquiries.\n     */\n    distinct?: Shopping_inquiriesScalarFieldEnum | Shopping_inquiriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiries findFirstOrThrow\n   */\n  export type shopping_inquiriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiries to fetch.\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiries to fetch.\n     */\n    orderBy?: shopping_inquiriesOrderByWithRelationInput | shopping_inquiriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inquiries.\n     */\n    cursor?: shopping_inquiriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inquiries.\n     */\n    distinct?: Shopping_inquiriesScalarFieldEnum | Shopping_inquiriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiries findMany\n   */\n  export type shopping_inquiriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiries to fetch.\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiries to fetch.\n     */\n    orderBy?: shopping_inquiriesOrderByWithRelationInput | shopping_inquiriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_inquiries.\n     */\n    cursor?: shopping_inquiriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiries.\n     */\n    skip?: number\n    distinct?: Shopping_inquiriesScalarFieldEnum | Shopping_inquiriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiries create\n   */\n  export type shopping_inquiriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_inquiries.\n     */\n    data: XOR<shopping_inquiriesCreateInput, shopping_inquiriesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_inquiries createMany\n   */\n  export type shopping_inquiriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_inquiries.\n     */\n    data: shopping_inquiriesCreateManyInput | shopping_inquiriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_inquiries createManyAndReturn\n   */\n  export type shopping_inquiriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_inquiries.\n     */\n    data: shopping_inquiriesCreateManyInput | shopping_inquiriesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inquiries update\n   */\n  export type shopping_inquiriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_inquiries.\n     */\n    data: XOR<shopping_inquiriesUpdateInput, shopping_inquiriesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_inquiries to update.\n     */\n    where: shopping_inquiriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiries updateMany\n   */\n  export type shopping_inquiriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_inquiries.\n     */\n    data: XOR<shopping_inquiriesUpdateManyMutationInput, shopping_inquiriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inquiries to update\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * Limit how many shopping_inquiries to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inquiries updateManyAndReturn\n   */\n  export type shopping_inquiriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_inquiries.\n     */\n    data: XOR<shopping_inquiriesUpdateManyMutationInput, shopping_inquiriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inquiries to update\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * Limit how many shopping_inquiries to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inquiries upsert\n   */\n  export type shopping_inquiriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_inquiries to update in case it exists.\n     */\n    where: shopping_inquiriesWhereUniqueInput\n    /**\n     * In case the shopping_inquiries found by the `where` argument doesn't exist, create a new shopping_inquiries with this data.\n     */\n    create: XOR<shopping_inquiriesCreateInput, shopping_inquiriesUncheckedCreateInput>\n    /**\n     * In case the shopping_inquiries was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_inquiriesUpdateInput, shopping_inquiriesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_inquiries delete\n   */\n  export type shopping_inquiriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_inquiries to delete.\n     */\n    where: shopping_inquiriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiries deleteMany\n   */\n  export type shopping_inquiriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inquiries to delete\n     */\n    where?: shopping_inquiriesWhereInput\n    /**\n     * Limit how many shopping_inquiries to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inquiries.shopping_inquiry_responses\n   */\n  export type shopping_inquiries$shopping_inquiry_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    where?: shopping_inquiry_responsesWhereInput\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_inquiry_responsesScalarFieldEnum | Shopping_inquiry_responsesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiries without action\n   */\n  export type shopping_inquiriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiries\n     */\n    select?: shopping_inquiriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiries\n     */\n    omit?: shopping_inquiriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_inquiry_responses\n   */\n\n  export type AggregateShopping_inquiry_responses = {\n    _count: Shopping_inquiry_responsesCountAggregateOutputType | null\n    _min: Shopping_inquiry_responsesMinAggregateOutputType | null\n    _max: Shopping_inquiry_responsesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_inquiry_responsesMinAggregateOutputType = {\n    id: string | null\n    shopping_inquiry_id: string | null\n    shopping_mall_admin_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_inquiry_responsesMaxAggregateOutputType = {\n    id: string | null\n    shopping_inquiry_id: string | null\n    shopping_mall_admin_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_inquiry_responsesCountAggregateOutputType = {\n    id: number\n    shopping_inquiry_id: number\n    shopping_mall_admin_id: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_inquiry_responsesMinAggregateInputType = {\n    id?: true\n    shopping_inquiry_id?: true\n    shopping_mall_admin_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_inquiry_responsesMaxAggregateInputType = {\n    id?: true\n    shopping_inquiry_id?: true\n    shopping_mall_admin_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_inquiry_responsesCountAggregateInputType = {\n    id?: true\n    shopping_inquiry_id?: true\n    shopping_mall_admin_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_inquiry_responsesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inquiry_responses to aggregate.\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiry_responses to fetch.\n     */\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiry_responses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiry_responses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_inquiry_responses\n    **/\n    _count?: true | Shopping_inquiry_responsesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_inquiry_responsesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_inquiry_responsesMaxAggregateInputType\n  }\n\n  export type GetShopping_inquiry_responsesAggregateType<T extends Shopping_inquiry_responsesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_inquiry_responses]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_inquiry_responses[P]>\n      : GetScalarType<T[P], AggregateShopping_inquiry_responses[P]>\n  }\n\n\n\n\n  export type shopping_inquiry_responsesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inquiry_responsesWhereInput\n    orderBy?: shopping_inquiry_responsesOrderByWithAggregationInput | shopping_inquiry_responsesOrderByWithAggregationInput[]\n    by: Shopping_inquiry_responsesScalarFieldEnum[] | Shopping_inquiry_responsesScalarFieldEnum\n    having?: shopping_inquiry_responsesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_inquiry_responsesCountAggregateInputType | true\n    _min?: Shopping_inquiry_responsesMinAggregateInputType\n    _max?: Shopping_inquiry_responsesMaxAggregateInputType\n  }\n\n  export type Shopping_inquiry_responsesGroupByOutputType = {\n    id: string\n    shopping_inquiry_id: string\n    shopping_mall_admin_id: string\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_inquiry_responsesCountAggregateOutputType | null\n    _min: Shopping_inquiry_responsesMinAggregateOutputType | null\n    _max: Shopping_inquiry_responsesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_inquiry_responsesGroupByPayload<T extends shopping_inquiry_responsesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_inquiry_responsesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_inquiry_responsesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_inquiry_responsesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_inquiry_responsesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_inquiry_responsesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_inquiry_id?: boolean\n    shopping_mall_admin_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiry_responses\"]>\n\n  export type shopping_inquiry_responsesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_inquiry_id?: boolean\n    shopping_mall_admin_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiry_responses\"]>\n\n  export type shopping_inquiry_responsesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_inquiry_id?: boolean\n    shopping_mall_admin_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inquiry_responses\"]>\n\n  export type shopping_inquiry_responsesSelectScalar = {\n    id?: boolean\n    shopping_inquiry_id?: boolean\n    shopping_mall_admin_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_inquiry_responsesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_inquiry_id\" | \"shopping_mall_admin_id\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_inquiry_responses\"]>\n  export type shopping_inquiry_responsesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }\n  export type shopping_inquiry_responsesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }\n  export type shopping_inquiry_responsesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    inquiry?: boolean | shopping_inquiriesDefaultArgs<ExtArgs>\n    admin?: boolean | shopping_mall_adminDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_inquiry_responsesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_inquiry_responses\"\n    objects: {\n      inquiry: Prisma.$shopping_inquiriesPayload<ExtArgs>\n      admin: Prisma.$shopping_mall_adminPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Inquiry being responded to. {@link shopping_inquiries.id}\n       */\n      shopping_inquiry_id: string\n      /**\n       * Admin who created the response. {@link shopping_mall_admin.id}\n       */\n      shopping_mall_admin_id: string\n      /**\n       * Content of the response.\n       */\n      content: string\n      /**\n       * When the response was created.\n       */\n      created_at: Date\n      /**\n       * When the response was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the response was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_inquiry_responses\"]>\n    composites: {}\n  }\n\n  type shopping_inquiry_responsesGetPayload<S extends boolean | null | undefined | shopping_inquiry_responsesDefaultArgs> = $Result.GetResult<Prisma.$shopping_inquiry_responsesPayload, S>\n\n  type shopping_inquiry_responsesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_inquiry_responsesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_inquiry_responsesCountAggregateInputType | true\n    }\n\n  export interface shopping_inquiry_responsesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_inquiry_responses'], meta: { name: 'shopping_inquiry_responses' } }\n    /**\n     * Find zero or one Shopping_inquiry_responses that matches the filter.\n     * @param {shopping_inquiry_responsesFindUniqueArgs} args - Arguments to find a Shopping_inquiry_responses\n     * @example\n     * // Get one Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_inquiry_responsesFindUniqueArgs>(args: SelectSubset<T, shopping_inquiry_responsesFindUniqueArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_inquiry_responses that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_inquiry_responsesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_inquiry_responses\n     * @example\n     * // Get one Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_inquiry_responsesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_inquiry_responsesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inquiry_responses that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesFindFirstArgs} args - Arguments to find a Shopping_inquiry_responses\n     * @example\n     * // Get one Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_inquiry_responsesFindFirstArgs>(args?: SelectSubset<T, shopping_inquiry_responsesFindFirstArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inquiry_responses that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesFindFirstOrThrowArgs} args - Arguments to find a Shopping_inquiry_responses\n     * @example\n     * // Get one Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_inquiry_responsesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_inquiry_responsesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_inquiry_responses that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findMany()\n     * \n     * // Get first 10 Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_inquiry_responsesWithIdOnly = await prisma.shopping_inquiry_responses.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_inquiry_responsesFindManyArgs>(args?: SelectSubset<T, shopping_inquiry_responsesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesCreateArgs} args - Arguments to create a Shopping_inquiry_responses.\n     * @example\n     * // Create one Shopping_inquiry_responses\n     * const Shopping_inquiry_responses = await prisma.shopping_inquiry_responses.create({\n     *   data: {\n     *     // ... data to create a Shopping_inquiry_responses\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_inquiry_responsesCreateArgs>(args: SelectSubset<T, shopping_inquiry_responsesCreateArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesCreateManyArgs} args - Arguments to create many Shopping_inquiry_responses.\n     * @example\n     * // Create many Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_inquiry_responsesCreateManyArgs>(args?: SelectSubset<T, shopping_inquiry_responsesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_inquiry_responses and returns the data saved in the database.\n     * @param {shopping_inquiry_responsesCreateManyAndReturnArgs} args - Arguments to create many Shopping_inquiry_responses.\n     * @example\n     * // Create many Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_inquiry_responses and only return the `id`\n     * const shopping_inquiry_responsesWithIdOnly = await prisma.shopping_inquiry_responses.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_inquiry_responsesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_inquiry_responsesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesDeleteArgs} args - Arguments to delete one Shopping_inquiry_responses.\n     * @example\n     * // Delete one Shopping_inquiry_responses\n     * const Shopping_inquiry_responses = await prisma.shopping_inquiry_responses.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_inquiry_responses\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_inquiry_responsesDeleteArgs>(args: SelectSubset<T, shopping_inquiry_responsesDeleteArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesUpdateArgs} args - Arguments to update one Shopping_inquiry_responses.\n     * @example\n     * // Update one Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_inquiry_responsesUpdateArgs>(args: SelectSubset<T, shopping_inquiry_responsesUpdateArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesDeleteManyArgs} args - Arguments to filter Shopping_inquiry_responses to delete.\n     * @example\n     * // Delete a few Shopping_inquiry_responses\n     * const { count } = await prisma.shopping_inquiry_responses.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_inquiry_responsesDeleteManyArgs>(args?: SelectSubset<T, shopping_inquiry_responsesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inquiry_responses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_inquiry_responsesUpdateManyArgs>(args: SelectSubset<T, shopping_inquiry_responsesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inquiry_responses and returns the data updated in the database.\n     * @param {shopping_inquiry_responsesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_inquiry_responses.\n     * @example\n     * // Update many Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_inquiry_responses and only return the `id`\n     * const shopping_inquiry_responsesWithIdOnly = await prisma.shopping_inquiry_responses.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_inquiry_responsesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_inquiry_responsesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_inquiry_responses.\n     * @param {shopping_inquiry_responsesUpsertArgs} args - Arguments to update or create a Shopping_inquiry_responses.\n     * @example\n     * // Update or create a Shopping_inquiry_responses\n     * const shopping_inquiry_responses = await prisma.shopping_inquiry_responses.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_inquiry_responses\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_inquiry_responses we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_inquiry_responsesUpsertArgs>(args: SelectSubset<T, shopping_inquiry_responsesUpsertArgs<ExtArgs>>): Prisma__shopping_inquiry_responsesClient<$Result.GetResult<Prisma.$shopping_inquiry_responsesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_inquiry_responses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesCountArgs} args - Arguments to filter Shopping_inquiry_responses to count.\n     * @example\n     * // Count the number of Shopping_inquiry_responses\n     * const count = await prisma.shopping_inquiry_responses.count({\n     *   where: {\n     *     // ... the filter for the Shopping_inquiry_responses we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_inquiry_responsesCountArgs>(\n      args?: Subset<T, shopping_inquiry_responsesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_inquiry_responsesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_inquiry_responses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_inquiry_responsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_inquiry_responsesAggregateArgs>(args: Subset<T, Shopping_inquiry_responsesAggregateArgs>): Prisma.PrismaPromise<GetShopping_inquiry_responsesAggregateType<T>>\n\n    /**\n     * Group by Shopping_inquiry_responses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inquiry_responsesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_inquiry_responsesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_inquiry_responsesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_inquiry_responsesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_inquiry_responsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_inquiry_responsesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_inquiry_responses model\n   */\n  readonly fields: shopping_inquiry_responsesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_inquiry_responses.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_inquiry_responsesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    inquiry<T extends shopping_inquiriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_inquiriesDefaultArgs<ExtArgs>>): Prisma__shopping_inquiriesClient<$Result.GetResult<Prisma.$shopping_inquiriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    admin<T extends shopping_mall_adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_adminDefaultArgs<ExtArgs>>): Prisma__shopping_mall_adminClient<$Result.GetResult<Prisma.$shopping_mall_adminPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_inquiry_responses model\n   */\n  interface shopping_inquiry_responsesFieldRefs {\n    readonly id: FieldRef<\"shopping_inquiry_responses\", 'String'>\n    readonly shopping_inquiry_id: FieldRef<\"shopping_inquiry_responses\", 'String'>\n    readonly shopping_mall_admin_id: FieldRef<\"shopping_inquiry_responses\", 'String'>\n    readonly content: FieldRef<\"shopping_inquiry_responses\", 'String'>\n    readonly created_at: FieldRef<\"shopping_inquiry_responses\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_inquiry_responses\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_inquiry_responses\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_inquiry_responses findUnique\n   */\n  export type shopping_inquiry_responsesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiry_responses to fetch.\n     */\n    where: shopping_inquiry_responsesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiry_responses findUniqueOrThrow\n   */\n  export type shopping_inquiry_responsesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiry_responses to fetch.\n     */\n    where: shopping_inquiry_responsesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiry_responses findFirst\n   */\n  export type shopping_inquiry_responsesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiry_responses to fetch.\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiry_responses to fetch.\n     */\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inquiry_responses.\n     */\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiry_responses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiry_responses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inquiry_responses.\n     */\n    distinct?: Shopping_inquiry_responsesScalarFieldEnum | Shopping_inquiry_responsesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiry_responses findFirstOrThrow\n   */\n  export type shopping_inquiry_responsesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiry_responses to fetch.\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiry_responses to fetch.\n     */\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inquiry_responses.\n     */\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiry_responses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiry_responses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inquiry_responses.\n     */\n    distinct?: Shopping_inquiry_responsesScalarFieldEnum | Shopping_inquiry_responsesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiry_responses findMany\n   */\n  export type shopping_inquiry_responsesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inquiry_responses to fetch.\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inquiry_responses to fetch.\n     */\n    orderBy?: shopping_inquiry_responsesOrderByWithRelationInput | shopping_inquiry_responsesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_inquiry_responses.\n     */\n    cursor?: shopping_inquiry_responsesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inquiry_responses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inquiry_responses.\n     */\n    skip?: number\n    distinct?: Shopping_inquiry_responsesScalarFieldEnum | Shopping_inquiry_responsesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inquiry_responses create\n   */\n  export type shopping_inquiry_responsesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_inquiry_responses.\n     */\n    data: XOR<shopping_inquiry_responsesCreateInput, shopping_inquiry_responsesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_inquiry_responses createMany\n   */\n  export type shopping_inquiry_responsesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_inquiry_responses.\n     */\n    data: shopping_inquiry_responsesCreateManyInput | shopping_inquiry_responsesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_inquiry_responses createManyAndReturn\n   */\n  export type shopping_inquiry_responsesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_inquiry_responses.\n     */\n    data: shopping_inquiry_responsesCreateManyInput | shopping_inquiry_responsesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inquiry_responses update\n   */\n  export type shopping_inquiry_responsesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_inquiry_responses.\n     */\n    data: XOR<shopping_inquiry_responsesUpdateInput, shopping_inquiry_responsesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_inquiry_responses to update.\n     */\n    where: shopping_inquiry_responsesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiry_responses updateMany\n   */\n  export type shopping_inquiry_responsesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_inquiry_responses.\n     */\n    data: XOR<shopping_inquiry_responsesUpdateManyMutationInput, shopping_inquiry_responsesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inquiry_responses to update\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * Limit how many shopping_inquiry_responses to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inquiry_responses updateManyAndReturn\n   */\n  export type shopping_inquiry_responsesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_inquiry_responses.\n     */\n    data: XOR<shopping_inquiry_responsesUpdateManyMutationInput, shopping_inquiry_responsesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inquiry_responses to update\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * Limit how many shopping_inquiry_responses to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inquiry_responses upsert\n   */\n  export type shopping_inquiry_responsesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_inquiry_responses to update in case it exists.\n     */\n    where: shopping_inquiry_responsesWhereUniqueInput\n    /**\n     * In case the shopping_inquiry_responses found by the `where` argument doesn't exist, create a new shopping_inquiry_responses with this data.\n     */\n    create: XOR<shopping_inquiry_responsesCreateInput, shopping_inquiry_responsesUncheckedCreateInput>\n    /**\n     * In case the shopping_inquiry_responses was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_inquiry_responsesUpdateInput, shopping_inquiry_responsesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_inquiry_responses delete\n   */\n  export type shopping_inquiry_responsesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_inquiry_responses to delete.\n     */\n    where: shopping_inquiry_responsesWhereUniqueInput\n  }\n\n  /**\n   * shopping_inquiry_responses deleteMany\n   */\n  export type shopping_inquiry_responsesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inquiry_responses to delete\n     */\n    where?: shopping_inquiry_responsesWhereInput\n    /**\n     * Limit how many shopping_inquiry_responses to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inquiry_responses without action\n   */\n  export type shopping_inquiry_responsesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inquiry_responses\n     */\n    select?: shopping_inquiry_responsesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inquiry_responses\n     */\n    omit?: shopping_inquiry_responsesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inquiry_responsesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_favorites\n   */\n\n  export type AggregateShopping_favorites = {\n    _count: Shopping_favoritesCountAggregateOutputType | null\n    _min: Shopping_favoritesMinAggregateOutputType | null\n    _max: Shopping_favoritesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_favoritesMinAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_favoritesMaxAggregateOutputType = {\n    id: string | null\n    shopping_mall_member_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_favoritesCountAggregateOutputType = {\n    id: number\n    shopping_mall_member_id: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_favoritesMinAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_favoritesMaxAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_favoritesCountAggregateInputType = {\n    id?: true\n    shopping_mall_member_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_favoritesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_favorites to aggregate.\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorites to fetch.\n     */\n    orderBy?: shopping_favoritesOrderByWithRelationInput | shopping_favoritesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_favoritesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorites from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorites.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_favorites\n    **/\n    _count?: true | Shopping_favoritesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_favoritesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_favoritesMaxAggregateInputType\n  }\n\n  export type GetShopping_favoritesAggregateType<T extends Shopping_favoritesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_favorites]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_favorites[P]>\n      : GetScalarType<T[P], AggregateShopping_favorites[P]>\n  }\n\n\n\n\n  export type shopping_favoritesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_favoritesWhereInput\n    orderBy?: shopping_favoritesOrderByWithAggregationInput | shopping_favoritesOrderByWithAggregationInput[]\n    by: Shopping_favoritesScalarFieldEnum[] | Shopping_favoritesScalarFieldEnum\n    having?: shopping_favoritesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_favoritesCountAggregateInputType | true\n    _min?: Shopping_favoritesMinAggregateInputType\n    _max?: Shopping_favoritesMaxAggregateInputType\n  }\n\n  export type Shopping_favoritesGroupByOutputType = {\n    id: string\n    shopping_mall_member_id: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_favoritesCountAggregateOutputType | null\n    _min: Shopping_favoritesMinAggregateOutputType | null\n    _max: Shopping_favoritesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_favoritesGroupByPayload<T extends shopping_favoritesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_favoritesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_favoritesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_favoritesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_favoritesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_favoritesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_favorite_items?: boolean | shopping_favorites$shopping_favorite_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_favoritesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorites\"]>\n\n  export type shopping_favoritesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorites\"]>\n\n  export type shopping_favoritesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorites\"]>\n\n  export type shopping_favoritesSelectScalar = {\n    id?: boolean\n    shopping_mall_member_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_favoritesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_mall_member_id\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_favorites\"]>\n  export type shopping_favoritesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n    shopping_favorite_items?: boolean | shopping_favorites$shopping_favorite_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_favoritesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_favoritesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_favoritesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_favoritesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_favorites\"\n    objects: {\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n      shopping_favorite_items: Prisma.$shopping_favorite_itemsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged member's {@link shopping_mall_member.id}\n       */\n      shopping_mall_member_id: string\n      /**\n       * Name of the favorite collection.\n       */\n      name: string\n      /**\n       * Description of the favorite collection.\n       */\n      description: string | null\n      /**\n       * When the favorite collection was created.\n       */\n      created_at: Date\n      /**\n       * When the favorite collection was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the favorite collection was deleted (soft delete).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_favorites\"]>\n    composites: {}\n  }\n\n  type shopping_favoritesGetPayload<S extends boolean | null | undefined | shopping_favoritesDefaultArgs> = $Result.GetResult<Prisma.$shopping_favoritesPayload, S>\n\n  type shopping_favoritesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_favoritesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_favoritesCountAggregateInputType | true\n    }\n\n  export interface shopping_favoritesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_favorites'], meta: { name: 'shopping_favorites' } }\n    /**\n     * Find zero or one Shopping_favorites that matches the filter.\n     * @param {shopping_favoritesFindUniqueArgs} args - Arguments to find a Shopping_favorites\n     * @example\n     * // Get one Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_favoritesFindUniqueArgs>(args: SelectSubset<T, shopping_favoritesFindUniqueArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_favorites that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_favoritesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_favorites\n     * @example\n     * // Get one Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_favoritesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_favoritesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_favorites that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesFindFirstArgs} args - Arguments to find a Shopping_favorites\n     * @example\n     * // Get one Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_favoritesFindFirstArgs>(args?: SelectSubset<T, shopping_favoritesFindFirstArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_favorites that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesFindFirstOrThrowArgs} args - Arguments to find a Shopping_favorites\n     * @example\n     * // Get one Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_favoritesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_favoritesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_favorites that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findMany()\n     * \n     * // Get first 10 Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_favoritesWithIdOnly = await prisma.shopping_favorites.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_favoritesFindManyArgs>(args?: SelectSubset<T, shopping_favoritesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_favorites.\n     * @param {shopping_favoritesCreateArgs} args - Arguments to create a Shopping_favorites.\n     * @example\n     * // Create one Shopping_favorites\n     * const Shopping_favorites = await prisma.shopping_favorites.create({\n     *   data: {\n     *     // ... data to create a Shopping_favorites\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_favoritesCreateArgs>(args: SelectSubset<T, shopping_favoritesCreateArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_favorites.\n     * @param {shopping_favoritesCreateManyArgs} args - Arguments to create many Shopping_favorites.\n     * @example\n     * // Create many Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_favoritesCreateManyArgs>(args?: SelectSubset<T, shopping_favoritesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_favorites and returns the data saved in the database.\n     * @param {shopping_favoritesCreateManyAndReturnArgs} args - Arguments to create many Shopping_favorites.\n     * @example\n     * // Create many Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_favorites and only return the `id`\n     * const shopping_favoritesWithIdOnly = await prisma.shopping_favorites.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_favoritesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_favoritesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_favorites.\n     * @param {shopping_favoritesDeleteArgs} args - Arguments to delete one Shopping_favorites.\n     * @example\n     * // Delete one Shopping_favorites\n     * const Shopping_favorites = await prisma.shopping_favorites.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_favorites\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_favoritesDeleteArgs>(args: SelectSubset<T, shopping_favoritesDeleteArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_favorites.\n     * @param {shopping_favoritesUpdateArgs} args - Arguments to update one Shopping_favorites.\n     * @example\n     * // Update one Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_favoritesUpdateArgs>(args: SelectSubset<T, shopping_favoritesUpdateArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_favorites.\n     * @param {shopping_favoritesDeleteManyArgs} args - Arguments to filter Shopping_favorites to delete.\n     * @example\n     * // Delete a few Shopping_favorites\n     * const { count } = await prisma.shopping_favorites.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_favoritesDeleteManyArgs>(args?: SelectSubset<T, shopping_favoritesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_favorites.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_favoritesUpdateManyArgs>(args: SelectSubset<T, shopping_favoritesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_favorites and returns the data updated in the database.\n     * @param {shopping_favoritesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_favorites.\n     * @example\n     * // Update many Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_favorites and only return the `id`\n     * const shopping_favoritesWithIdOnly = await prisma.shopping_favorites.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_favoritesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_favoritesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_favorites.\n     * @param {shopping_favoritesUpsertArgs} args - Arguments to update or create a Shopping_favorites.\n     * @example\n     * // Update or create a Shopping_favorites\n     * const shopping_favorites = await prisma.shopping_favorites.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_favorites\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_favorites we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_favoritesUpsertArgs>(args: SelectSubset<T, shopping_favoritesUpsertArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_favorites.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesCountArgs} args - Arguments to filter Shopping_favorites to count.\n     * @example\n     * // Count the number of Shopping_favorites\n     * const count = await prisma.shopping_favorites.count({\n     *   where: {\n     *     // ... the filter for the Shopping_favorites we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_favoritesCountArgs>(\n      args?: Subset<T, shopping_favoritesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_favoritesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_favorites.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_favoritesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_favoritesAggregateArgs>(args: Subset<T, Shopping_favoritesAggregateArgs>): Prisma.PrismaPromise<GetShopping_favoritesAggregateType<T>>\n\n    /**\n     * Group by Shopping_favorites.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favoritesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_favoritesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_favoritesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_favoritesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_favoritesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_favoritesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_favorites model\n   */\n  readonly fields: shopping_favoritesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_favorites.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_favoritesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_favorite_items<T extends shopping_favorites$shopping_favorite_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_favorites$shopping_favorite_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_favorites model\n   */\n  interface shopping_favoritesFieldRefs {\n    readonly id: FieldRef<\"shopping_favorites\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_favorites\", 'String'>\n    readonly name: FieldRef<\"shopping_favorites\", 'String'>\n    readonly description: FieldRef<\"shopping_favorites\", 'String'>\n    readonly created_at: FieldRef<\"shopping_favorites\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_favorites\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_favorites\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_favorites findUnique\n   */\n  export type shopping_favoritesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorites to fetch.\n     */\n    where: shopping_favoritesWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorites findUniqueOrThrow\n   */\n  export type shopping_favoritesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorites to fetch.\n     */\n    where: shopping_favoritesWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorites findFirst\n   */\n  export type shopping_favoritesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorites to fetch.\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorites to fetch.\n     */\n    orderBy?: shopping_favoritesOrderByWithRelationInput | shopping_favoritesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_favorites.\n     */\n    cursor?: shopping_favoritesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorites from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorites.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_favorites.\n     */\n    distinct?: Shopping_favoritesScalarFieldEnum | Shopping_favoritesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorites findFirstOrThrow\n   */\n  export type shopping_favoritesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorites to fetch.\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorites to fetch.\n     */\n    orderBy?: shopping_favoritesOrderByWithRelationInput | shopping_favoritesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_favorites.\n     */\n    cursor?: shopping_favoritesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorites from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorites.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_favorites.\n     */\n    distinct?: Shopping_favoritesScalarFieldEnum | Shopping_favoritesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorites findMany\n   */\n  export type shopping_favoritesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorites to fetch.\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorites to fetch.\n     */\n    orderBy?: shopping_favoritesOrderByWithRelationInput | shopping_favoritesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_favorites.\n     */\n    cursor?: shopping_favoritesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorites from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorites.\n     */\n    skip?: number\n    distinct?: Shopping_favoritesScalarFieldEnum | Shopping_favoritesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorites create\n   */\n  export type shopping_favoritesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_favorites.\n     */\n    data: XOR<shopping_favoritesCreateInput, shopping_favoritesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_favorites createMany\n   */\n  export type shopping_favoritesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_favorites.\n     */\n    data: shopping_favoritesCreateManyInput | shopping_favoritesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_favorites createManyAndReturn\n   */\n  export type shopping_favoritesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_favorites.\n     */\n    data: shopping_favoritesCreateManyInput | shopping_favoritesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_favorites update\n   */\n  export type shopping_favoritesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_favorites.\n     */\n    data: XOR<shopping_favoritesUpdateInput, shopping_favoritesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_favorites to update.\n     */\n    where: shopping_favoritesWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorites updateMany\n   */\n  export type shopping_favoritesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_favorites.\n     */\n    data: XOR<shopping_favoritesUpdateManyMutationInput, shopping_favoritesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_favorites to update\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * Limit how many shopping_favorites to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_favorites updateManyAndReturn\n   */\n  export type shopping_favoritesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_favorites.\n     */\n    data: XOR<shopping_favoritesUpdateManyMutationInput, shopping_favoritesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_favorites to update\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * Limit how many shopping_favorites to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_favorites upsert\n   */\n  export type shopping_favoritesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_favorites to update in case it exists.\n     */\n    where: shopping_favoritesWhereUniqueInput\n    /**\n     * In case the shopping_favorites found by the `where` argument doesn't exist, create a new shopping_favorites with this data.\n     */\n    create: XOR<shopping_favoritesCreateInput, shopping_favoritesUncheckedCreateInput>\n    /**\n     * In case the shopping_favorites was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_favoritesUpdateInput, shopping_favoritesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_favorites delete\n   */\n  export type shopping_favoritesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_favorites to delete.\n     */\n    where: shopping_favoritesWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorites deleteMany\n   */\n  export type shopping_favoritesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_favorites to delete\n     */\n    where?: shopping_favoritesWhereInput\n    /**\n     * Limit how many shopping_favorites to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_favorites.shopping_favorite_items\n   */\n  export type shopping_favorites$shopping_favorite_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    where?: shopping_favorite_itemsWhereInput\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_favorite_itemsScalarFieldEnum | Shopping_favorite_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorites without action\n   */\n  export type shopping_favoritesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorites\n     */\n    select?: shopping_favoritesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorites\n     */\n    omit?: shopping_favoritesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favoritesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_favorite_items\n   */\n\n  export type AggregateShopping_favorite_items = {\n    _count: Shopping_favorite_itemsCountAggregateOutputType | null\n    _min: Shopping_favorite_itemsMinAggregateOutputType | null\n    _max: Shopping_favorite_itemsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_favorite_itemsMinAggregateOutputType = {\n    id: string | null\n    shopping_favorite_id: string | null\n    shopping_sale_unit_id: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_favorite_itemsMaxAggregateOutputType = {\n    id: string | null\n    shopping_favorite_id: string | null\n    shopping_sale_unit_id: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_favorite_itemsCountAggregateOutputType = {\n    id: number\n    shopping_favorite_id: number\n    shopping_sale_unit_id: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_favorite_itemsMinAggregateInputType = {\n    id?: true\n    shopping_favorite_id?: true\n    shopping_sale_unit_id?: true\n    created_at?: true\n  }\n\n  export type Shopping_favorite_itemsMaxAggregateInputType = {\n    id?: true\n    shopping_favorite_id?: true\n    shopping_sale_unit_id?: true\n    created_at?: true\n  }\n\n  export type Shopping_favorite_itemsCountAggregateInputType = {\n    id?: true\n    shopping_favorite_id?: true\n    shopping_sale_unit_id?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_favorite_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_favorite_items to aggregate.\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorite_items to fetch.\n     */\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorite_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorite_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_favorite_items\n    **/\n    _count?: true | Shopping_favorite_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_favorite_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_favorite_itemsMaxAggregateInputType\n  }\n\n  export type GetShopping_favorite_itemsAggregateType<T extends Shopping_favorite_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_favorite_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_favorite_items[P]>\n      : GetScalarType<T[P], AggregateShopping_favorite_items[P]>\n  }\n\n\n\n\n  export type shopping_favorite_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_favorite_itemsWhereInput\n    orderBy?: shopping_favorite_itemsOrderByWithAggregationInput | shopping_favorite_itemsOrderByWithAggregationInput[]\n    by: Shopping_favorite_itemsScalarFieldEnum[] | Shopping_favorite_itemsScalarFieldEnum\n    having?: shopping_favorite_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_favorite_itemsCountAggregateInputType | true\n    _min?: Shopping_favorite_itemsMinAggregateInputType\n    _max?: Shopping_favorite_itemsMaxAggregateInputType\n  }\n\n  export type Shopping_favorite_itemsGroupByOutputType = {\n    id: string\n    shopping_favorite_id: string\n    shopping_sale_unit_id: string\n    created_at: Date\n    _count: Shopping_favorite_itemsCountAggregateOutputType | null\n    _min: Shopping_favorite_itemsMinAggregateOutputType | null\n    _max: Shopping_favorite_itemsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_favorite_itemsGroupByPayload<T extends shopping_favorite_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_favorite_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_favorite_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_favorite_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_favorite_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_favorite_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_favorite_id?: boolean\n    shopping_sale_unit_id?: boolean\n    created_at?: boolean\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorite_items\"]>\n\n  export type shopping_favorite_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_favorite_id?: boolean\n    shopping_sale_unit_id?: boolean\n    created_at?: boolean\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorite_items\"]>\n\n  export type shopping_favorite_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_favorite_id?: boolean\n    shopping_sale_unit_id?: boolean\n    created_at?: boolean\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_favorite_items\"]>\n\n  export type shopping_favorite_itemsSelectScalar = {\n    id?: boolean\n    shopping_favorite_id?: boolean\n    shopping_sale_unit_id?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_favorite_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_favorite_id\" | \"shopping_sale_unit_id\" | \"created_at\", ExtArgs[\"result\"][\"shopping_favorite_items\"]>\n  export type shopping_favorite_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_favorite_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n  export type shopping_favorite_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    favorite?: boolean | shopping_favoritesDefaultArgs<ExtArgs>\n    saleUnit?: boolean | shopping_sale_unitsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_favorite_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_favorite_items\"\n    objects: {\n      favorite: Prisma.$shopping_favoritesPayload<ExtArgs>\n      saleUnit: Prisma.$shopping_sale_unitsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged favorite collection's {@link shopping_favorites.id}\n       */\n      shopping_favorite_id: string\n      /**\n       * Belonged sale unit's {@link shopping_sale_units.id}\n       */\n      shopping_sale_unit_id: string\n      /**\n       * When the favorite item was added to the collection.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_favorite_items\"]>\n    composites: {}\n  }\n\n  type shopping_favorite_itemsGetPayload<S extends boolean | null | undefined | shopping_favorite_itemsDefaultArgs> = $Result.GetResult<Prisma.$shopping_favorite_itemsPayload, S>\n\n  type shopping_favorite_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_favorite_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_favorite_itemsCountAggregateInputType | true\n    }\n\n  export interface shopping_favorite_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_favorite_items'], meta: { name: 'shopping_favorite_items' } }\n    /**\n     * Find zero or one Shopping_favorite_items that matches the filter.\n     * @param {shopping_favorite_itemsFindUniqueArgs} args - Arguments to find a Shopping_favorite_items\n     * @example\n     * // Get one Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_favorite_itemsFindUniqueArgs>(args: SelectSubset<T, shopping_favorite_itemsFindUniqueArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_favorite_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_favorite_itemsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_favorite_items\n     * @example\n     * // Get one Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_favorite_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_favorite_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_favorite_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsFindFirstArgs} args - Arguments to find a Shopping_favorite_items\n     * @example\n     * // Get one Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_favorite_itemsFindFirstArgs>(args?: SelectSubset<T, shopping_favorite_itemsFindFirstArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_favorite_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsFindFirstOrThrowArgs} args - Arguments to find a Shopping_favorite_items\n     * @example\n     * // Get one Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_favorite_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_favorite_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_favorite_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findMany()\n     * \n     * // Get first 10 Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_favorite_itemsWithIdOnly = await prisma.shopping_favorite_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_favorite_itemsFindManyArgs>(args?: SelectSubset<T, shopping_favorite_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_favorite_items.\n     * @param {shopping_favorite_itemsCreateArgs} args - Arguments to create a Shopping_favorite_items.\n     * @example\n     * // Create one Shopping_favorite_items\n     * const Shopping_favorite_items = await prisma.shopping_favorite_items.create({\n     *   data: {\n     *     // ... data to create a Shopping_favorite_items\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_favorite_itemsCreateArgs>(args: SelectSubset<T, shopping_favorite_itemsCreateArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_favorite_items.\n     * @param {shopping_favorite_itemsCreateManyArgs} args - Arguments to create many Shopping_favorite_items.\n     * @example\n     * // Create many Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_favorite_itemsCreateManyArgs>(args?: SelectSubset<T, shopping_favorite_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_favorite_items and returns the data saved in the database.\n     * @param {shopping_favorite_itemsCreateManyAndReturnArgs} args - Arguments to create many Shopping_favorite_items.\n     * @example\n     * // Create many Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_favorite_items and only return the `id`\n     * const shopping_favorite_itemsWithIdOnly = await prisma.shopping_favorite_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_favorite_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_favorite_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_favorite_items.\n     * @param {shopping_favorite_itemsDeleteArgs} args - Arguments to delete one Shopping_favorite_items.\n     * @example\n     * // Delete one Shopping_favorite_items\n     * const Shopping_favorite_items = await prisma.shopping_favorite_items.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_favorite_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_favorite_itemsDeleteArgs>(args: SelectSubset<T, shopping_favorite_itemsDeleteArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_favorite_items.\n     * @param {shopping_favorite_itemsUpdateArgs} args - Arguments to update one Shopping_favorite_items.\n     * @example\n     * // Update one Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_favorite_itemsUpdateArgs>(args: SelectSubset<T, shopping_favorite_itemsUpdateArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_favorite_items.\n     * @param {shopping_favorite_itemsDeleteManyArgs} args - Arguments to filter Shopping_favorite_items to delete.\n     * @example\n     * // Delete a few Shopping_favorite_items\n     * const { count } = await prisma.shopping_favorite_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_favorite_itemsDeleteManyArgs>(args?: SelectSubset<T, shopping_favorite_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_favorite_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_favorite_itemsUpdateManyArgs>(args: SelectSubset<T, shopping_favorite_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_favorite_items and returns the data updated in the database.\n     * @param {shopping_favorite_itemsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_favorite_items.\n     * @example\n     * // Update many Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_favorite_items and only return the `id`\n     * const shopping_favorite_itemsWithIdOnly = await prisma.shopping_favorite_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_favorite_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_favorite_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_favorite_items.\n     * @param {shopping_favorite_itemsUpsertArgs} args - Arguments to update or create a Shopping_favorite_items.\n     * @example\n     * // Update or create a Shopping_favorite_items\n     * const shopping_favorite_items = await prisma.shopping_favorite_items.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_favorite_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_favorite_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_favorite_itemsUpsertArgs>(args: SelectSubset<T, shopping_favorite_itemsUpsertArgs<ExtArgs>>): Prisma__shopping_favorite_itemsClient<$Result.GetResult<Prisma.$shopping_favorite_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_favorite_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsCountArgs} args - Arguments to filter Shopping_favorite_items to count.\n     * @example\n     * // Count the number of Shopping_favorite_items\n     * const count = await prisma.shopping_favorite_items.count({\n     *   where: {\n     *     // ... the filter for the Shopping_favorite_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_favorite_itemsCountArgs>(\n      args?: Subset<T, shopping_favorite_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_favorite_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_favorite_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_favorite_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_favorite_itemsAggregateArgs>(args: Subset<T, Shopping_favorite_itemsAggregateArgs>): Prisma.PrismaPromise<GetShopping_favorite_itemsAggregateType<T>>\n\n    /**\n     * Group by Shopping_favorite_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_favorite_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_favorite_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_favorite_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_favorite_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_favorite_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_favorite_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_favorite_items model\n   */\n  readonly fields: shopping_favorite_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_favorite_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_favorite_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    favorite<T extends shopping_favoritesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_favoritesDefaultArgs<ExtArgs>>): Prisma__shopping_favoritesClient<$Result.GetResult<Prisma.$shopping_favoritesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    saleUnit<T extends shopping_sale_unitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sale_unitsDefaultArgs<ExtArgs>>): Prisma__shopping_sale_unitsClient<$Result.GetResult<Prisma.$shopping_sale_unitsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_favorite_items model\n   */\n  interface shopping_favorite_itemsFieldRefs {\n    readonly id: FieldRef<\"shopping_favorite_items\", 'String'>\n    readonly shopping_favorite_id: FieldRef<\"shopping_favorite_items\", 'String'>\n    readonly shopping_sale_unit_id: FieldRef<\"shopping_favorite_items\", 'String'>\n    readonly created_at: FieldRef<\"shopping_favorite_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_favorite_items findUnique\n   */\n  export type shopping_favorite_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorite_items to fetch.\n     */\n    where: shopping_favorite_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorite_items findUniqueOrThrow\n   */\n  export type shopping_favorite_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorite_items to fetch.\n     */\n    where: shopping_favorite_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorite_items findFirst\n   */\n  export type shopping_favorite_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorite_items to fetch.\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorite_items to fetch.\n     */\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_favorite_items.\n     */\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorite_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorite_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_favorite_items.\n     */\n    distinct?: Shopping_favorite_itemsScalarFieldEnum | Shopping_favorite_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorite_items findFirstOrThrow\n   */\n  export type shopping_favorite_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorite_items to fetch.\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorite_items to fetch.\n     */\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_favorite_items.\n     */\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorite_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorite_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_favorite_items.\n     */\n    distinct?: Shopping_favorite_itemsScalarFieldEnum | Shopping_favorite_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorite_items findMany\n   */\n  export type shopping_favorite_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_favorite_items to fetch.\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_favorite_items to fetch.\n     */\n    orderBy?: shopping_favorite_itemsOrderByWithRelationInput | shopping_favorite_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_favorite_items.\n     */\n    cursor?: shopping_favorite_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_favorite_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_favorite_items.\n     */\n    skip?: number\n    distinct?: Shopping_favorite_itemsScalarFieldEnum | Shopping_favorite_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_favorite_items create\n   */\n  export type shopping_favorite_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_favorite_items.\n     */\n    data: XOR<shopping_favorite_itemsCreateInput, shopping_favorite_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_favorite_items createMany\n   */\n  export type shopping_favorite_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_favorite_items.\n     */\n    data: shopping_favorite_itemsCreateManyInput | shopping_favorite_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_favorite_items createManyAndReturn\n   */\n  export type shopping_favorite_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_favorite_items.\n     */\n    data: shopping_favorite_itemsCreateManyInput | shopping_favorite_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_favorite_items update\n   */\n  export type shopping_favorite_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_favorite_items.\n     */\n    data: XOR<shopping_favorite_itemsUpdateInput, shopping_favorite_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_favorite_items to update.\n     */\n    where: shopping_favorite_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorite_items updateMany\n   */\n  export type shopping_favorite_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_favorite_items.\n     */\n    data: XOR<shopping_favorite_itemsUpdateManyMutationInput, shopping_favorite_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_favorite_items to update\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * Limit how many shopping_favorite_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_favorite_items updateManyAndReturn\n   */\n  export type shopping_favorite_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_favorite_items.\n     */\n    data: XOR<shopping_favorite_itemsUpdateManyMutationInput, shopping_favorite_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_favorite_items to update\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * Limit how many shopping_favorite_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_favorite_items upsert\n   */\n  export type shopping_favorite_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_favorite_items to update in case it exists.\n     */\n    where: shopping_favorite_itemsWhereUniqueInput\n    /**\n     * In case the shopping_favorite_items found by the `where` argument doesn't exist, create a new shopping_favorite_items with this data.\n     */\n    create: XOR<shopping_favorite_itemsCreateInput, shopping_favorite_itemsUncheckedCreateInput>\n    /**\n     * In case the shopping_favorite_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_favorite_itemsUpdateInput, shopping_favorite_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_favorite_items delete\n   */\n  export type shopping_favorite_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_favorite_items to delete.\n     */\n    where: shopping_favorite_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_favorite_items deleteMany\n   */\n  export type shopping_favorite_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_favorite_items to delete\n     */\n    where?: shopping_favorite_itemsWhereInput\n    /**\n     * Limit how many shopping_favorite_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_favorite_items without action\n   */\n  export type shopping_favorite_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_favorite_items\n     */\n    select?: shopping_favorite_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_favorite_items\n     */\n    omit?: shopping_favorite_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_favorite_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_articles\n   */\n\n  export type AggregateShopping_articles = {\n    _count: Shopping_articlesCountAggregateOutputType | null\n    _min: Shopping_articlesMinAggregateOutputType | null\n    _max: Shopping_articlesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_articlesMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    code: string | null\n    title: string | null\n    content: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_articlesMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    code: string | null\n    title: string | null\n    content: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_articlesCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    shopping_section_id: number\n    code: number\n    title: number\n    content: number\n    status: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_articlesMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_articlesMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_articlesCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    code?: true\n    title?: true\n    content?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_articlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_articles to aggregate.\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_articles to fetch.\n     */\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_articlesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_articles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_articles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_articles\n    **/\n    _count?: true | Shopping_articlesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_articlesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_articlesMaxAggregateInputType\n  }\n\n  export type GetShopping_articlesAggregateType<T extends Shopping_articlesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_articles]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_articles[P]>\n      : GetScalarType<T[P], AggregateShopping_articles[P]>\n  }\n\n\n\n\n  export type shopping_articlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_articlesWhereInput\n    orderBy?: shopping_articlesOrderByWithAggregationInput | shopping_articlesOrderByWithAggregationInput[]\n    by: Shopping_articlesScalarFieldEnum[] | Shopping_articlesScalarFieldEnum\n    having?: shopping_articlesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_articlesCountAggregateInputType | true\n    _min?: Shopping_articlesMinAggregateInputType\n    _max?: Shopping_articlesMaxAggregateInputType\n  }\n\n  export type Shopping_articlesGroupByOutputType = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_articlesCountAggregateOutputType | null\n    _min: Shopping_articlesMinAggregateOutputType | null\n    _max: Shopping_articlesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_articlesGroupByPayload<T extends shopping_articlesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_articlesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_articlesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_articlesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_articlesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_articlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n    shopping_article_comments?: boolean | shopping_articles$shopping_article_commentsArgs<ExtArgs>\n    _count?: boolean | Shopping_articlesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_articles\"]>\n\n  export type shopping_articlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_articles\"]>\n\n  export type shopping_articlesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_articles\"]>\n\n  export type shopping_articlesSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    code?: boolean\n    title?: boolean\n    content?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_articlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"shopping_section_id\" | \"code\" | \"title\" | \"content\" | \"status\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_articles\"]>\n  export type shopping_articlesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n    shopping_article_comments?: boolean | shopping_articles$shopping_article_commentsArgs<ExtArgs>\n    _count?: boolean | Shopping_articlesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_articlesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n  export type shopping_articlesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_articlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_articles\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs>\n      section: Prisma.$shopping_sectionsPayload<ExtArgs>\n      shopping_article_comments: Prisma.$shopping_article_commentsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged channel's {@link shopping_channels.id}.\n       */\n      shopping_channel_id: string\n      /**\n       * Belonged section's {@link shopping_sections.id}.\n       */\n      shopping_section_id: string\n      /**\n       * Article code.\n       */\n      code: string\n      /**\n       * Article title.\n       */\n      title: string\n      /**\n       * Article content.\n       */\n      content: string\n      /**\n       * Article status.\n       */\n      status: string\n      /**\n       * When the article was created.\n       */\n      created_at: Date\n      /**\n       * When the article was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the article was deleted.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_articles\"]>\n    composites: {}\n  }\n\n  type shopping_articlesGetPayload<S extends boolean | null | undefined | shopping_articlesDefaultArgs> = $Result.GetResult<Prisma.$shopping_articlesPayload, S>\n\n  type shopping_articlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_articlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_articlesCountAggregateInputType | true\n    }\n\n  export interface shopping_articlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_articles'], meta: { name: 'shopping_articles' } }\n    /**\n     * Find zero or one Shopping_articles that matches the filter.\n     * @param {shopping_articlesFindUniqueArgs} args - Arguments to find a Shopping_articles\n     * @example\n     * // Get one Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_articlesFindUniqueArgs>(args: SelectSubset<T, shopping_articlesFindUniqueArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_articles that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_articlesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_articles\n     * @example\n     * // Get one Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_articlesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_articlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_articles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesFindFirstArgs} args - Arguments to find a Shopping_articles\n     * @example\n     * // Get one Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_articlesFindFirstArgs>(args?: SelectSubset<T, shopping_articlesFindFirstArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_articles that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesFindFirstOrThrowArgs} args - Arguments to find a Shopping_articles\n     * @example\n     * // Get one Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_articlesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_articlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_articles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findMany()\n     * \n     * // Get first 10 Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_articlesWithIdOnly = await prisma.shopping_articles.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_articlesFindManyArgs>(args?: SelectSubset<T, shopping_articlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_articles.\n     * @param {shopping_articlesCreateArgs} args - Arguments to create a Shopping_articles.\n     * @example\n     * // Create one Shopping_articles\n     * const Shopping_articles = await prisma.shopping_articles.create({\n     *   data: {\n     *     // ... data to create a Shopping_articles\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_articlesCreateArgs>(args: SelectSubset<T, shopping_articlesCreateArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_articles.\n     * @param {shopping_articlesCreateManyArgs} args - Arguments to create many Shopping_articles.\n     * @example\n     * // Create many Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_articlesCreateManyArgs>(args?: SelectSubset<T, shopping_articlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_articles and returns the data saved in the database.\n     * @param {shopping_articlesCreateManyAndReturnArgs} args - Arguments to create many Shopping_articles.\n     * @example\n     * // Create many Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_articles and only return the `id`\n     * const shopping_articlesWithIdOnly = await prisma.shopping_articles.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_articlesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_articlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_articles.\n     * @param {shopping_articlesDeleteArgs} args - Arguments to delete one Shopping_articles.\n     * @example\n     * // Delete one Shopping_articles\n     * const Shopping_articles = await prisma.shopping_articles.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_articles\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_articlesDeleteArgs>(args: SelectSubset<T, shopping_articlesDeleteArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_articles.\n     * @param {shopping_articlesUpdateArgs} args - Arguments to update one Shopping_articles.\n     * @example\n     * // Update one Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_articlesUpdateArgs>(args: SelectSubset<T, shopping_articlesUpdateArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_articles.\n     * @param {shopping_articlesDeleteManyArgs} args - Arguments to filter Shopping_articles to delete.\n     * @example\n     * // Delete a few Shopping_articles\n     * const { count } = await prisma.shopping_articles.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_articlesDeleteManyArgs>(args?: SelectSubset<T, shopping_articlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_articles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_articlesUpdateManyArgs>(args: SelectSubset<T, shopping_articlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_articles and returns the data updated in the database.\n     * @param {shopping_articlesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_articles.\n     * @example\n     * // Update many Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_articles and only return the `id`\n     * const shopping_articlesWithIdOnly = await prisma.shopping_articles.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_articlesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_articlesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_articles.\n     * @param {shopping_articlesUpsertArgs} args - Arguments to update or create a Shopping_articles.\n     * @example\n     * // Update or create a Shopping_articles\n     * const shopping_articles = await prisma.shopping_articles.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_articles\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_articles we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_articlesUpsertArgs>(args: SelectSubset<T, shopping_articlesUpsertArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_articles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesCountArgs} args - Arguments to filter Shopping_articles to count.\n     * @example\n     * // Count the number of Shopping_articles\n     * const count = await prisma.shopping_articles.count({\n     *   where: {\n     *     // ... the filter for the Shopping_articles we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_articlesCountArgs>(\n      args?: Subset<T, shopping_articlesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_articlesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_articles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_articlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_articlesAggregateArgs>(args: Subset<T, Shopping_articlesAggregateArgs>): Prisma.PrismaPromise<GetShopping_articlesAggregateType<T>>\n\n    /**\n     * Group by Shopping_articles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_articlesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_articlesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_articlesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_articlesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_articlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_articlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_articles model\n   */\n  readonly fields: shopping_articlesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_articles.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_articlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channelsDefaultArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    section<T extends shopping_sectionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sectionsDefaultArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_article_comments<T extends shopping_articles$shopping_article_commentsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_articles$shopping_article_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_articles model\n   */\n  interface shopping_articlesFieldRefs {\n    readonly id: FieldRef<\"shopping_articles\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_articles\", 'String'>\n    readonly shopping_section_id: FieldRef<\"shopping_articles\", 'String'>\n    readonly code: FieldRef<\"shopping_articles\", 'String'>\n    readonly title: FieldRef<\"shopping_articles\", 'String'>\n    readonly content: FieldRef<\"shopping_articles\", 'String'>\n    readonly status: FieldRef<\"shopping_articles\", 'String'>\n    readonly created_at: FieldRef<\"shopping_articles\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_articles\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_articles\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_articles findUnique\n   */\n  export type shopping_articlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_articles to fetch.\n     */\n    where: shopping_articlesWhereUniqueInput\n  }\n\n  /**\n   * shopping_articles findUniqueOrThrow\n   */\n  export type shopping_articlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_articles to fetch.\n     */\n    where: shopping_articlesWhereUniqueInput\n  }\n\n  /**\n   * shopping_articles findFirst\n   */\n  export type shopping_articlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_articles to fetch.\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_articles to fetch.\n     */\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_articles.\n     */\n    cursor?: shopping_articlesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_articles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_articles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_articles.\n     */\n    distinct?: Shopping_articlesScalarFieldEnum | Shopping_articlesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_articles findFirstOrThrow\n   */\n  export type shopping_articlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_articles to fetch.\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_articles to fetch.\n     */\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_articles.\n     */\n    cursor?: shopping_articlesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_articles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_articles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_articles.\n     */\n    distinct?: Shopping_articlesScalarFieldEnum | Shopping_articlesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_articles findMany\n   */\n  export type shopping_articlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_articles to fetch.\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_articles to fetch.\n     */\n    orderBy?: shopping_articlesOrderByWithRelationInput | shopping_articlesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_articles.\n     */\n    cursor?: shopping_articlesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_articles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_articles.\n     */\n    skip?: number\n    distinct?: Shopping_articlesScalarFieldEnum | Shopping_articlesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_articles create\n   */\n  export type shopping_articlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_articles.\n     */\n    data: XOR<shopping_articlesCreateInput, shopping_articlesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_articles createMany\n   */\n  export type shopping_articlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_articles.\n     */\n    data: shopping_articlesCreateManyInput | shopping_articlesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_articles createManyAndReturn\n   */\n  export type shopping_articlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_articles.\n     */\n    data: shopping_articlesCreateManyInput | shopping_articlesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_articles update\n   */\n  export type shopping_articlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_articles.\n     */\n    data: XOR<shopping_articlesUpdateInput, shopping_articlesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_articles to update.\n     */\n    where: shopping_articlesWhereUniqueInput\n  }\n\n  /**\n   * shopping_articles updateMany\n   */\n  export type shopping_articlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_articles.\n     */\n    data: XOR<shopping_articlesUpdateManyMutationInput, shopping_articlesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_articles to update\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * Limit how many shopping_articles to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_articles updateManyAndReturn\n   */\n  export type shopping_articlesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_articles.\n     */\n    data: XOR<shopping_articlesUpdateManyMutationInput, shopping_articlesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_articles to update\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * Limit how many shopping_articles to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_articles upsert\n   */\n  export type shopping_articlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_articles to update in case it exists.\n     */\n    where: shopping_articlesWhereUniqueInput\n    /**\n     * In case the shopping_articles found by the `where` argument doesn't exist, create a new shopping_articles with this data.\n     */\n    create: XOR<shopping_articlesCreateInput, shopping_articlesUncheckedCreateInput>\n    /**\n     * In case the shopping_articles was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_articlesUpdateInput, shopping_articlesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_articles delete\n   */\n  export type shopping_articlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_articles to delete.\n     */\n    where: shopping_articlesWhereUniqueInput\n  }\n\n  /**\n   * shopping_articles deleteMany\n   */\n  export type shopping_articlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_articles to delete\n     */\n    where?: shopping_articlesWhereInput\n    /**\n     * Limit how many shopping_articles to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_articles.shopping_article_comments\n   */\n  export type shopping_articles$shopping_article_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    where?: shopping_article_commentsWhereInput\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    cursor?: shopping_article_commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_article_commentsScalarFieldEnum | Shopping_article_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_articles without action\n   */\n  export type shopping_articlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_articles\n     */\n    select?: shopping_articlesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_articles\n     */\n    omit?: shopping_articlesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_articlesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_article_comments\n   */\n\n  export type AggregateShopping_article_comments = {\n    _count: Shopping_article_commentsCountAggregateOutputType | null\n    _min: Shopping_article_commentsMinAggregateOutputType | null\n    _max: Shopping_article_commentsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_article_commentsMinAggregateOutputType = {\n    id: string | null\n    shopping_article_id: string | null\n    shopping_mall_member_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_article_commentsMaxAggregateOutputType = {\n    id: string | null\n    shopping_article_id: string | null\n    shopping_mall_member_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_article_commentsCountAggregateOutputType = {\n    id: number\n    shopping_article_id: number\n    shopping_mall_member_id: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_article_commentsMinAggregateInputType = {\n    id?: true\n    shopping_article_id?: true\n    shopping_mall_member_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_article_commentsMaxAggregateInputType = {\n    id?: true\n    shopping_article_id?: true\n    shopping_mall_member_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_article_commentsCountAggregateInputType = {\n    id?: true\n    shopping_article_id?: true\n    shopping_mall_member_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_article_commentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_article_comments to aggregate.\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_article_comments to fetch.\n     */\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_article_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_article_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_article_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_article_comments\n    **/\n    _count?: true | Shopping_article_commentsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_article_commentsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_article_commentsMaxAggregateInputType\n  }\n\n  export type GetShopping_article_commentsAggregateType<T extends Shopping_article_commentsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_article_comments]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_article_comments[P]>\n      : GetScalarType<T[P], AggregateShopping_article_comments[P]>\n  }\n\n\n\n\n  export type shopping_article_commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_article_commentsWhereInput\n    orderBy?: shopping_article_commentsOrderByWithAggregationInput | shopping_article_commentsOrderByWithAggregationInput[]\n    by: Shopping_article_commentsScalarFieldEnum[] | Shopping_article_commentsScalarFieldEnum\n    having?: shopping_article_commentsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_article_commentsCountAggregateInputType | true\n    _min?: Shopping_article_commentsMinAggregateInputType\n    _max?: Shopping_article_commentsMaxAggregateInputType\n  }\n\n  export type Shopping_article_commentsGroupByOutputType = {\n    id: string\n    shopping_article_id: string\n    shopping_mall_member_id: string\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_article_commentsCountAggregateOutputType | null\n    _min: Shopping_article_commentsMinAggregateOutputType | null\n    _max: Shopping_article_commentsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_article_commentsGroupByPayload<T extends shopping_article_commentsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_article_commentsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_article_commentsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_article_commentsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_article_commentsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_article_commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_article_id?: boolean\n    shopping_mall_member_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_article_comments\"]>\n\n  export type shopping_article_commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_article_id?: boolean\n    shopping_mall_member_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_article_comments\"]>\n\n  export type shopping_article_commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_article_id?: boolean\n    shopping_mall_member_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_article_comments\"]>\n\n  export type shopping_article_commentsSelectScalar = {\n    id?: boolean\n    shopping_article_id?: boolean\n    shopping_mall_member_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_article_commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_article_id\" | \"shopping_mall_member_id\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_article_comments\"]>\n  export type shopping_article_commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_article_commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n  export type shopping_article_commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    article?: boolean | shopping_articlesDefaultArgs<ExtArgs>\n    member?: boolean | shopping_mall_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_article_commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_article_comments\"\n    objects: {\n      article: Prisma.$shopping_articlesPayload<ExtArgs>\n      member: Prisma.$shopping_mall_memberPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged article's {@link shopping_articles.id}.\n       */\n      shopping_article_id: string\n      /**\n       * Belonged member's {@link shopping_mall_member.id}.\n       */\n      shopping_mall_member_id: string\n      /**\n       * Comment content.\n       */\n      content: string\n      /**\n       * When the comment was created.\n       */\n      created_at: Date\n      /**\n       * When the comment was last updated.\n       */\n      updated_at: Date\n      /**\n       * When the comment was deleted.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_article_comments\"]>\n    composites: {}\n  }\n\n  type shopping_article_commentsGetPayload<S extends boolean | null | undefined | shopping_article_commentsDefaultArgs> = $Result.GetResult<Prisma.$shopping_article_commentsPayload, S>\n\n  type shopping_article_commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_article_commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_article_commentsCountAggregateInputType | true\n    }\n\n  export interface shopping_article_commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_article_comments'], meta: { name: 'shopping_article_comments' } }\n    /**\n     * Find zero or one Shopping_article_comments that matches the filter.\n     * @param {shopping_article_commentsFindUniqueArgs} args - Arguments to find a Shopping_article_comments\n     * @example\n     * // Get one Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_article_commentsFindUniqueArgs>(args: SelectSubset<T, shopping_article_commentsFindUniqueArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_article_comments that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_article_commentsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_article_comments\n     * @example\n     * // Get one Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_article_commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_article_commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_article_comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsFindFirstArgs} args - Arguments to find a Shopping_article_comments\n     * @example\n     * // Get one Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_article_commentsFindFirstArgs>(args?: SelectSubset<T, shopping_article_commentsFindFirstArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_article_comments that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsFindFirstOrThrowArgs} args - Arguments to find a Shopping_article_comments\n     * @example\n     * // Get one Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_article_commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_article_commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_article_comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findMany()\n     * \n     * // Get first 10 Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_article_commentsWithIdOnly = await prisma.shopping_article_comments.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_article_commentsFindManyArgs>(args?: SelectSubset<T, shopping_article_commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_article_comments.\n     * @param {shopping_article_commentsCreateArgs} args - Arguments to create a Shopping_article_comments.\n     * @example\n     * // Create one Shopping_article_comments\n     * const Shopping_article_comments = await prisma.shopping_article_comments.create({\n     *   data: {\n     *     // ... data to create a Shopping_article_comments\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_article_commentsCreateArgs>(args: SelectSubset<T, shopping_article_commentsCreateArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_article_comments.\n     * @param {shopping_article_commentsCreateManyArgs} args - Arguments to create many Shopping_article_comments.\n     * @example\n     * // Create many Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_article_commentsCreateManyArgs>(args?: SelectSubset<T, shopping_article_commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_article_comments and returns the data saved in the database.\n     * @param {shopping_article_commentsCreateManyAndReturnArgs} args - Arguments to create many Shopping_article_comments.\n     * @example\n     * // Create many Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_article_comments and only return the `id`\n     * const shopping_article_commentsWithIdOnly = await prisma.shopping_article_comments.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_article_commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_article_commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_article_comments.\n     * @param {shopping_article_commentsDeleteArgs} args - Arguments to delete one Shopping_article_comments.\n     * @example\n     * // Delete one Shopping_article_comments\n     * const Shopping_article_comments = await prisma.shopping_article_comments.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_article_comments\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_article_commentsDeleteArgs>(args: SelectSubset<T, shopping_article_commentsDeleteArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_article_comments.\n     * @param {shopping_article_commentsUpdateArgs} args - Arguments to update one Shopping_article_comments.\n     * @example\n     * // Update one Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_article_commentsUpdateArgs>(args: SelectSubset<T, shopping_article_commentsUpdateArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_article_comments.\n     * @param {shopping_article_commentsDeleteManyArgs} args - Arguments to filter Shopping_article_comments to delete.\n     * @example\n     * // Delete a few Shopping_article_comments\n     * const { count } = await prisma.shopping_article_comments.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_article_commentsDeleteManyArgs>(args?: SelectSubset<T, shopping_article_commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_article_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_article_commentsUpdateManyArgs>(args: SelectSubset<T, shopping_article_commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_article_comments and returns the data updated in the database.\n     * @param {shopping_article_commentsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_article_comments.\n     * @example\n     * // Update many Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_article_comments and only return the `id`\n     * const shopping_article_commentsWithIdOnly = await prisma.shopping_article_comments.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_article_commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_article_commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_article_comments.\n     * @param {shopping_article_commentsUpsertArgs} args - Arguments to update or create a Shopping_article_comments.\n     * @example\n     * // Update or create a Shopping_article_comments\n     * const shopping_article_comments = await prisma.shopping_article_comments.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_article_comments\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_article_comments we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_article_commentsUpsertArgs>(args: SelectSubset<T, shopping_article_commentsUpsertArgs<ExtArgs>>): Prisma__shopping_article_commentsClient<$Result.GetResult<Prisma.$shopping_article_commentsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_article_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsCountArgs} args - Arguments to filter Shopping_article_comments to count.\n     * @example\n     * // Count the number of Shopping_article_comments\n     * const count = await prisma.shopping_article_comments.count({\n     *   where: {\n     *     // ... the filter for the Shopping_article_comments we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_article_commentsCountArgs>(\n      args?: Subset<T, shopping_article_commentsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_article_commentsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_article_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_article_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_article_commentsAggregateArgs>(args: Subset<T, Shopping_article_commentsAggregateArgs>): Prisma.PrismaPromise<GetShopping_article_commentsAggregateType<T>>\n\n    /**\n     * Group by Shopping_article_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_article_commentsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_article_commentsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_article_commentsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_article_commentsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_article_commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_article_commentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_article_comments model\n   */\n  readonly fields: shopping_article_commentsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_article_comments.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_article_commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    article<T extends shopping_articlesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_articlesDefaultArgs<ExtArgs>>): Prisma__shopping_articlesClient<$Result.GetResult<Prisma.$shopping_articlesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    member<T extends shopping_mall_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_mall_memberDefaultArgs<ExtArgs>>): Prisma__shopping_mall_memberClient<$Result.GetResult<Prisma.$shopping_mall_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_article_comments model\n   */\n  interface shopping_article_commentsFieldRefs {\n    readonly id: FieldRef<\"shopping_article_comments\", 'String'>\n    readonly shopping_article_id: FieldRef<\"shopping_article_comments\", 'String'>\n    readonly shopping_mall_member_id: FieldRef<\"shopping_article_comments\", 'String'>\n    readonly content: FieldRef<\"shopping_article_comments\", 'String'>\n    readonly created_at: FieldRef<\"shopping_article_comments\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_article_comments\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_article_comments\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_article_comments findUnique\n   */\n  export type shopping_article_commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_article_comments to fetch.\n     */\n    where: shopping_article_commentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_article_comments findUniqueOrThrow\n   */\n  export type shopping_article_commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_article_comments to fetch.\n     */\n    where: shopping_article_commentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_article_comments findFirst\n   */\n  export type shopping_article_commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_article_comments to fetch.\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_article_comments to fetch.\n     */\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_article_comments.\n     */\n    cursor?: shopping_article_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_article_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_article_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_article_comments.\n     */\n    distinct?: Shopping_article_commentsScalarFieldEnum | Shopping_article_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_article_comments findFirstOrThrow\n   */\n  export type shopping_article_commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_article_comments to fetch.\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_article_comments to fetch.\n     */\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_article_comments.\n     */\n    cursor?: shopping_article_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_article_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_article_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_article_comments.\n     */\n    distinct?: Shopping_article_commentsScalarFieldEnum | Shopping_article_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_article_comments findMany\n   */\n  export type shopping_article_commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_article_comments to fetch.\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_article_comments to fetch.\n     */\n    orderBy?: shopping_article_commentsOrderByWithRelationInput | shopping_article_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_article_comments.\n     */\n    cursor?: shopping_article_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_article_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_article_comments.\n     */\n    skip?: number\n    distinct?: Shopping_article_commentsScalarFieldEnum | Shopping_article_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_article_comments create\n   */\n  export type shopping_article_commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_article_comments.\n     */\n    data: XOR<shopping_article_commentsCreateInput, shopping_article_commentsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_article_comments createMany\n   */\n  export type shopping_article_commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_article_comments.\n     */\n    data: shopping_article_commentsCreateManyInput | shopping_article_commentsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_article_comments createManyAndReturn\n   */\n  export type shopping_article_commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_article_comments.\n     */\n    data: shopping_article_commentsCreateManyInput | shopping_article_commentsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_article_comments update\n   */\n  export type shopping_article_commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_article_comments.\n     */\n    data: XOR<shopping_article_commentsUpdateInput, shopping_article_commentsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_article_comments to update.\n     */\n    where: shopping_article_commentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_article_comments updateMany\n   */\n  export type shopping_article_commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_article_comments.\n     */\n    data: XOR<shopping_article_commentsUpdateManyMutationInput, shopping_article_commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_article_comments to update\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * Limit how many shopping_article_comments to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_article_comments updateManyAndReturn\n   */\n  export type shopping_article_commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_article_comments.\n     */\n    data: XOR<shopping_article_commentsUpdateManyMutationInput, shopping_article_commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_article_comments to update\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * Limit how many shopping_article_comments to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_article_comments upsert\n   */\n  export type shopping_article_commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_article_comments to update in case it exists.\n     */\n    where: shopping_article_commentsWhereUniqueInput\n    /**\n     * In case the shopping_article_comments found by the `where` argument doesn't exist, create a new shopping_article_comments with this data.\n     */\n    create: XOR<shopping_article_commentsCreateInput, shopping_article_commentsUncheckedCreateInput>\n    /**\n     * In case the shopping_article_comments was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_article_commentsUpdateInput, shopping_article_commentsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_article_comments delete\n   */\n  export type shopping_article_commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_article_comments to delete.\n     */\n    where: shopping_article_commentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_article_comments deleteMany\n   */\n  export type shopping_article_commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_article_comments to delete\n     */\n    where?: shopping_article_commentsWhereInput\n    /**\n     * Limit how many shopping_article_comments to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_article_comments without action\n   */\n  export type shopping_article_commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_article_comments\n     */\n    select?: shopping_article_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_article_comments\n     */\n    omit?: shopping_article_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_article_commentsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Shopping_channelsScalarFieldEnum: {\n    id: 'id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_channelsScalarFieldEnum = (typeof Shopping_channelsScalarFieldEnum)[keyof typeof Shopping_channelsScalarFieldEnum]\n\n\n  export const Shopping_sectionsScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_sectionsScalarFieldEnum = (typeof Shopping_sectionsScalarFieldEnum)[keyof typeof Shopping_sectionsScalarFieldEnum]\n\n\n  export const Shopping_configurationsScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    shopping_section_id: 'shopping_section_id',\n    key: 'key',\n    value: 'value',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_configurationsScalarFieldEnum = (typeof Shopping_configurationsScalarFieldEnum)[keyof typeof Shopping_configurationsScalarFieldEnum]\n\n\n  export const Shopping_mall_guestScalarFieldEnum: {\n    id: 'id',\n    session_id: 'session_id',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_mall_guestScalarFieldEnum = (typeof Shopping_mall_guestScalarFieldEnum)[keyof typeof Shopping_mall_guestScalarFieldEnum]\n\n\n  export const Shopping_mall_memberScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    phone: 'phone',\n    address: 'address',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_mall_memberScalarFieldEnum = (typeof Shopping_mall_memberScalarFieldEnum)[keyof typeof Shopping_mall_memberScalarFieldEnum]\n\n\n  export const Shopping_mall_sellerScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    phone: 'phone',\n    business_name: 'business_name',\n    business_address: 'business_address',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_mall_sellerScalarFieldEnum = (typeof Shopping_mall_sellerScalarFieldEnum)[keyof typeof Shopping_mall_sellerScalarFieldEnum]\n\n\n  export const Shopping_mall_adminScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    phone: 'phone',\n    role: 'role',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_mall_adminScalarFieldEnum = (typeof Shopping_mall_adminScalarFieldEnum)[keyof typeof Shopping_mall_adminScalarFieldEnum]\n\n\n  export const Shopping_salesScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    shopping_section_id: 'shopping_section_id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    price: 'price',\n    stock: 'stock',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_salesScalarFieldEnum = (typeof Shopping_salesScalarFieldEnum)[keyof typeof Shopping_salesScalarFieldEnum]\n\n\n  export const Shopping_sale_snapshotsScalarFieldEnum: {\n    id: 'id',\n    shopping_sale_id: 'shopping_sale_id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    price: 'price',\n    stock: 'stock',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_sale_snapshotsScalarFieldEnum = (typeof Shopping_sale_snapshotsScalarFieldEnum)[keyof typeof Shopping_sale_snapshotsScalarFieldEnum]\n\n\n  export const Shopping_sale_unitsScalarFieldEnum: {\n    id: 'id',\n    shopping_sale_id: 'shopping_sale_id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    price: 'price',\n    stock: 'stock',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_sale_unitsScalarFieldEnum = (typeof Shopping_sale_unitsScalarFieldEnum)[keyof typeof Shopping_sale_unitsScalarFieldEnum]\n\n\n  export const Shopping_sale_unit_optionsScalarFieldEnum: {\n    id: 'id',\n    shopping_sale_unit_id: 'shopping_sale_unit_id',\n    code: 'code',\n    name: 'name',\n    description: 'description',\n    price: 'price',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_sale_unit_optionsScalarFieldEnum = (typeof Shopping_sale_unit_optionsScalarFieldEnum)[keyof typeof Shopping_sale_unit_optionsScalarFieldEnum]\n\n\n  export const Shopping_cartsScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    status: 'status',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_cartsScalarFieldEnum = (typeof Shopping_cartsScalarFieldEnum)[keyof typeof Shopping_cartsScalarFieldEnum]\n\n\n  export const Shopping_cart_itemsScalarFieldEnum: {\n    id: 'id',\n    shopping_cart_id: 'shopping_cart_id',\n    shopping_sale_unit_id: 'shopping_sale_unit_id',\n    quantity: 'quantity',\n    price: 'price',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_cart_itemsScalarFieldEnum = (typeof Shopping_cart_itemsScalarFieldEnum)[keyof typeof Shopping_cart_itemsScalarFieldEnum]\n\n\n  export const Shopping_ordersScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    code: 'code',\n    status: 'status',\n    total_amount: 'total_amount',\n    shipping_address: 'shipping_address',\n    payment_method: 'payment_method',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_ordersScalarFieldEnum = (typeof Shopping_ordersScalarFieldEnum)[keyof typeof Shopping_ordersScalarFieldEnum]\n\n\n  export const Shopping_order_snapshotsScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    code: 'code',\n    status: 'status',\n    total_amount: 'total_amount',\n    shipping_address: 'shipping_address',\n    payment_method: 'payment_method',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_order_snapshotsScalarFieldEnum = (typeof Shopping_order_snapshotsScalarFieldEnum)[keyof typeof Shopping_order_snapshotsScalarFieldEnum]\n\n\n  export const Shopping_order_itemsScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    product_id: 'product_id',\n    quantity: 'quantity',\n    price: 'price',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_order_itemsScalarFieldEnum = (typeof Shopping_order_itemsScalarFieldEnum)[keyof typeof Shopping_order_itemsScalarFieldEnum]\n\n\n  export const Shopping_couponsScalarFieldEnum: {\n    id: 'id',\n    code: 'code',\n    discount_type: 'discount_type',\n    value: 'value',\n    valid_from: 'valid_from',\n    valid_until: 'valid_until',\n    max_uses: 'max_uses',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_couponsScalarFieldEnum = (typeof Shopping_couponsScalarFieldEnum)[keyof typeof Shopping_couponsScalarFieldEnum]\n\n\n  export const Shopping_coupon_usageScalarFieldEnum: {\n    id: 'id',\n    shopping_coupon_id: 'shopping_coupon_id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    order_id: 'order_id',\n    used_at: 'used_at',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_coupon_usageScalarFieldEnum = (typeof Shopping_coupon_usageScalarFieldEnum)[keyof typeof Shopping_coupon_usageScalarFieldEnum]\n\n\n  export const Shopping_coinsScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    balance: 'balance',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_coinsScalarFieldEnum = (typeof Shopping_coinsScalarFieldEnum)[keyof typeof Shopping_coinsScalarFieldEnum]\n\n\n  export const Shopping_coin_transactionsScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    shopping_order_id: 'shopping_order_id',\n    amount: 'amount',\n    transaction_type: 'transaction_type',\n    description: 'description',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_coin_transactionsScalarFieldEnum = (typeof Shopping_coin_transactionsScalarFieldEnum)[keyof typeof Shopping_coin_transactionsScalarFieldEnum]\n\n\n  export const Shopping_inquiriesScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    title: 'title',\n    content: 'content',\n    status: 'status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_inquiriesScalarFieldEnum = (typeof Shopping_inquiriesScalarFieldEnum)[keyof typeof Shopping_inquiriesScalarFieldEnum]\n\n\n  export const Shopping_inquiry_responsesScalarFieldEnum: {\n    id: 'id',\n    shopping_inquiry_id: 'shopping_inquiry_id',\n    shopping_mall_admin_id: 'shopping_mall_admin_id',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_inquiry_responsesScalarFieldEnum = (typeof Shopping_inquiry_responsesScalarFieldEnum)[keyof typeof Shopping_inquiry_responsesScalarFieldEnum]\n\n\n  export const Shopping_favoritesScalarFieldEnum: {\n    id: 'id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_favoritesScalarFieldEnum = (typeof Shopping_favoritesScalarFieldEnum)[keyof typeof Shopping_favoritesScalarFieldEnum]\n\n\n  export const Shopping_favorite_itemsScalarFieldEnum: {\n    id: 'id',\n    shopping_favorite_id: 'shopping_favorite_id',\n    shopping_sale_unit_id: 'shopping_sale_unit_id',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_favorite_itemsScalarFieldEnum = (typeof Shopping_favorite_itemsScalarFieldEnum)[keyof typeof Shopping_favorite_itemsScalarFieldEnum]\n\n\n  export const Shopping_articlesScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    shopping_section_id: 'shopping_section_id',\n    code: 'code',\n    title: 'title',\n    content: 'content',\n    status: 'status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_articlesScalarFieldEnum = (typeof Shopping_articlesScalarFieldEnum)[keyof typeof Shopping_articlesScalarFieldEnum]\n\n\n  export const Shopping_article_commentsScalarFieldEnum: {\n    id: 'id',\n    shopping_article_id: 'shopping_article_id',\n    shopping_mall_member_id: 'shopping_mall_member_id',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_article_commentsScalarFieldEnum = (typeof Shopping_article_commentsScalarFieldEnum)[keyof typeof Shopping_article_commentsScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type shopping_channelsWhereInput = {\n    AND?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    OR?: shopping_channelsWhereInput[]\n    NOT?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    id?: UuidFilter<\"shopping_channels\"> | string\n    code?: StringFilter<\"shopping_channels\"> | string\n    name?: StringFilter<\"shopping_channels\"> | string\n    description?: StringNullableFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channels\"> | Date | string | null\n    shopping_sections?: Shopping_sectionsListRelationFilter\n    shopping_configurations?: Shopping_configurationsListRelationFilter\n    shopping_sales?: Shopping_salesListRelationFilter\n    shopping_articles?: Shopping_articlesListRelationFilter\n  }\n\n  export type shopping_channelsOrderByWithRelationInput = {\n    id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    shopping_sections?: shopping_sectionsOrderByRelationAggregateInput\n    shopping_configurations?: shopping_configurationsOrderByRelationAggregateInput\n    shopping_sales?: shopping_salesOrderByRelationAggregateInput\n    shopping_articles?: shopping_articlesOrderByRelationAggregateInput\n  }\n\n  export type shopping_channelsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    OR?: shopping_channelsWhereInput[]\n    NOT?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    name?: StringFilter<\"shopping_channels\"> | string\n    description?: StringNullableFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channels\"> | Date | string | null\n    shopping_sections?: Shopping_sectionsListRelationFilter\n    shopping_configurations?: Shopping_configurationsListRelationFilter\n    shopping_sales?: Shopping_salesListRelationFilter\n    shopping_articles?: Shopping_articlesListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_channelsOrderByWithAggregationInput = {\n    id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_channelsCountOrderByAggregateInput\n    _max?: shopping_channelsMaxOrderByAggregateInput\n    _min?: shopping_channelsMinOrderByAggregateInput\n  }\n\n  export type shopping_channelsScalarWhereWithAggregatesInput = {\n    AND?: shopping_channelsScalarWhereWithAggregatesInput | shopping_channelsScalarWhereWithAggregatesInput[]\n    OR?: shopping_channelsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_channelsScalarWhereWithAggregatesInput | shopping_channelsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_channels\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_channels\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_channels\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_channels\"> | Date | string | null\n  }\n\n  export type shopping_sectionsWhereInput = {\n    AND?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    OR?: shopping_sectionsWhereInput[]\n    NOT?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    id?: UuidFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    code?: StringFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    shopping_configurations?: Shopping_configurationsListRelationFilter\n    shopping_sales?: Shopping_salesListRelationFilter\n    shopping_articles?: Shopping_articlesListRelationFilter\n  }\n\n  export type shopping_sectionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    shopping_configurations?: shopping_configurationsOrderByRelationAggregateInput\n    shopping_sales?: shopping_salesOrderByRelationAggregateInput\n    shopping_articles?: shopping_articlesOrderByRelationAggregateInput\n  }\n\n  export type shopping_sectionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_channel_id_code?: shopping_sectionsShopping_channel_idCodeCompoundUniqueInput\n    AND?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    OR?: shopping_sectionsWhereInput[]\n    NOT?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    code?: StringFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    shopping_configurations?: Shopping_configurationsListRelationFilter\n    shopping_sales?: Shopping_salesListRelationFilter\n    shopping_articles?: Shopping_articlesListRelationFilter\n  }, \"id\" | \"shopping_channel_id_code\">\n\n  export type shopping_sectionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_sectionsCountOrderByAggregateInput\n    _max?: shopping_sectionsMaxOrderByAggregateInput\n    _min?: shopping_sectionsMinOrderByAggregateInput\n  }\n\n  export type shopping_sectionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_sectionsScalarWhereWithAggregatesInput | shopping_sectionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_sectionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sectionsScalarWhereWithAggregatesInput | shopping_sectionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidWithAggregatesFilter<\"shopping_sections\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_sections\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sections\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_sections\"> | Date | string | null\n  }\n\n  export type shopping_configurationsWhereInput = {\n    AND?: shopping_configurationsWhereInput | shopping_configurationsWhereInput[]\n    OR?: shopping_configurationsWhereInput[]\n    NOT?: shopping_configurationsWhereInput | shopping_configurationsWhereInput[]\n    id?: UuidFilter<\"shopping_configurations\"> | string\n    shopping_channel_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    shopping_section_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    key?: StringFilter<\"shopping_configurations\"> | string\n    value?: StringFilter<\"shopping_configurations\"> | string\n    description?: StringNullableFilter<\"shopping_configurations\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_configurations\"> | Date | string | null\n    channel?: XOR<Shopping_channelsNullableScalarRelationFilter, shopping_channelsWhereInput> | null\n    section?: XOR<Shopping_sectionsNullableScalarRelationFilter, shopping_sectionsWhereInput> | null\n  }\n\n  export type shopping_configurationsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrderInput | SortOrder\n    shopping_section_id?: SortOrderInput | SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    section?: shopping_sectionsOrderByWithRelationInput\n  }\n\n  export type shopping_configurationsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_channel_id_key?: shopping_configurationsShopping_channel_idKeyCompoundUniqueInput\n    shopping_section_id_key?: shopping_configurationsShopping_section_idKeyCompoundUniqueInput\n    AND?: shopping_configurationsWhereInput | shopping_configurationsWhereInput[]\n    OR?: shopping_configurationsWhereInput[]\n    NOT?: shopping_configurationsWhereInput | shopping_configurationsWhereInput[]\n    shopping_channel_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    shopping_section_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    key?: StringFilter<\"shopping_configurations\"> | string\n    value?: StringFilter<\"shopping_configurations\"> | string\n    description?: StringNullableFilter<\"shopping_configurations\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_configurations\"> | Date | string | null\n    channel?: XOR<Shopping_channelsNullableScalarRelationFilter, shopping_channelsWhereInput> | null\n    section?: XOR<Shopping_sectionsNullableScalarRelationFilter, shopping_sectionsWhereInput> | null\n  }, \"id\" | \"shopping_channel_id_key\" | \"shopping_section_id_key\">\n\n  export type shopping_configurationsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrderInput | SortOrder\n    shopping_section_id?: SortOrderInput | SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_configurationsCountOrderByAggregateInput\n    _max?: shopping_configurationsMaxOrderByAggregateInput\n    _min?: shopping_configurationsMinOrderByAggregateInput\n  }\n\n  export type shopping_configurationsScalarWhereWithAggregatesInput = {\n    AND?: shopping_configurationsScalarWhereWithAggregatesInput | shopping_configurationsScalarWhereWithAggregatesInput[]\n    OR?: shopping_configurationsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_configurationsScalarWhereWithAggregatesInput | shopping_configurationsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_configurations\"> | string\n    shopping_channel_id?: UuidNullableWithAggregatesFilter<\"shopping_configurations\"> | string | null\n    shopping_section_id?: UuidNullableWithAggregatesFilter<\"shopping_configurations\"> | string | null\n    key?: StringWithAggregatesFilter<\"shopping_configurations\"> | string\n    value?: StringWithAggregatesFilter<\"shopping_configurations\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_configurations\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_configurations\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_configurations\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_configurations\"> | Date | string | null\n  }\n\n  export type shopping_mall_guestWhereInput = {\n    AND?: shopping_mall_guestWhereInput | shopping_mall_guestWhereInput[]\n    OR?: shopping_mall_guestWhereInput[]\n    NOT?: shopping_mall_guestWhereInput | shopping_mall_guestWhereInput[]\n    id?: UuidFilter<\"shopping_mall_guest\"> | string\n    session_id?: UuidFilter<\"shopping_mall_guest\"> | string\n    created_at?: DateTimeFilter<\"shopping_mall_guest\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_guest\"> | Date | string\n  }\n\n  export type shopping_mall_guestOrderByWithRelationInput = {\n    id?: SortOrder\n    session_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_mall_guestWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    session_id?: string\n    AND?: shopping_mall_guestWhereInput | shopping_mall_guestWhereInput[]\n    OR?: shopping_mall_guestWhereInput[]\n    NOT?: shopping_mall_guestWhereInput | shopping_mall_guestWhereInput[]\n    created_at?: DateTimeFilter<\"shopping_mall_guest\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_guest\"> | Date | string\n  }, \"id\" | \"session_id\">\n\n  export type shopping_mall_guestOrderByWithAggregationInput = {\n    id?: SortOrder\n    session_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_mall_guestCountOrderByAggregateInput\n    _max?: shopping_mall_guestMaxOrderByAggregateInput\n    _min?: shopping_mall_guestMinOrderByAggregateInput\n  }\n\n  export type shopping_mall_guestScalarWhereWithAggregatesInput = {\n    AND?: shopping_mall_guestScalarWhereWithAggregatesInput | shopping_mall_guestScalarWhereWithAggregatesInput[]\n    OR?: shopping_mall_guestScalarWhereWithAggregatesInput[]\n    NOT?: shopping_mall_guestScalarWhereWithAggregatesInput | shopping_mall_guestScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_mall_guest\"> | string\n    session_id?: UuidWithAggregatesFilter<\"shopping_mall_guest\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_mall_guest\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_mall_guest\"> | Date | string\n  }\n\n  export type shopping_mall_memberWhereInput = {\n    AND?: shopping_mall_memberWhereInput | shopping_mall_memberWhereInput[]\n    OR?: shopping_mall_memberWhereInput[]\n    NOT?: shopping_mall_memberWhereInput | shopping_mall_memberWhereInput[]\n    id?: UuidFilter<\"shopping_mall_member\"> | string\n    email?: StringFilter<\"shopping_mall_member\"> | string\n    password_hash?: StringFilter<\"shopping_mall_member\"> | string\n    name?: StringFilter<\"shopping_mall_member\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_member\"> | string | null\n    address?: StringNullableFilter<\"shopping_mall_member\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_mall_member\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_member\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_member\"> | Date | string | null\n    shopping_carts?: Shopping_cartsListRelationFilter\n    shopping_orders?: Shopping_ordersListRelationFilter\n    shopping_coupon_usage?: Shopping_coupon_usageListRelationFilter\n    shopping_coins?: XOR<Shopping_coinsNullableScalarRelationFilter, shopping_coinsWhereInput> | null\n    shopping_coin_transactions?: Shopping_coin_transactionsListRelationFilter\n    shopping_inquiries?: Shopping_inquiriesListRelationFilter\n    shopping_favorites?: Shopping_favoritesListRelationFilter\n    shopping_article_comments?: Shopping_article_commentsListRelationFilter\n  }\n\n  export type shopping_mall_memberOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    shopping_carts?: shopping_cartsOrderByRelationAggregateInput\n    shopping_orders?: shopping_ordersOrderByRelationAggregateInput\n    shopping_coupon_usage?: shopping_coupon_usageOrderByRelationAggregateInput\n    shopping_coins?: shopping_coinsOrderByWithRelationInput\n    shopping_coin_transactions?: shopping_coin_transactionsOrderByRelationAggregateInput\n    shopping_inquiries?: shopping_inquiriesOrderByRelationAggregateInput\n    shopping_favorites?: shopping_favoritesOrderByRelationAggregateInput\n    shopping_article_comments?: shopping_article_commentsOrderByRelationAggregateInput\n  }\n\n  export type shopping_mall_memberWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: shopping_mall_memberWhereInput | shopping_mall_memberWhereInput[]\n    OR?: shopping_mall_memberWhereInput[]\n    NOT?: shopping_mall_memberWhereInput | shopping_mall_memberWhereInput[]\n    password_hash?: StringFilter<\"shopping_mall_member\"> | string\n    name?: StringFilter<\"shopping_mall_member\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_member\"> | string | null\n    address?: StringNullableFilter<\"shopping_mall_member\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_mall_member\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_member\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_member\"> | Date | string | null\n    shopping_carts?: Shopping_cartsListRelationFilter\n    shopping_orders?: Shopping_ordersListRelationFilter\n    shopping_coupon_usage?: Shopping_coupon_usageListRelationFilter\n    shopping_coins?: XOR<Shopping_coinsNullableScalarRelationFilter, shopping_coinsWhereInput> | null\n    shopping_coin_transactions?: Shopping_coin_transactionsListRelationFilter\n    shopping_inquiries?: Shopping_inquiriesListRelationFilter\n    shopping_favorites?: Shopping_favoritesListRelationFilter\n    shopping_article_comments?: Shopping_article_commentsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type shopping_mall_memberOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_mall_memberCountOrderByAggregateInput\n    _max?: shopping_mall_memberMaxOrderByAggregateInput\n    _min?: shopping_mall_memberMinOrderByAggregateInput\n  }\n\n  export type shopping_mall_memberScalarWhereWithAggregatesInput = {\n    AND?: shopping_mall_memberScalarWhereWithAggregatesInput | shopping_mall_memberScalarWhereWithAggregatesInput[]\n    OR?: shopping_mall_memberScalarWhereWithAggregatesInput[]\n    NOT?: shopping_mall_memberScalarWhereWithAggregatesInput | shopping_mall_memberScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_mall_member\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_mall_member\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_mall_member\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_mall_member\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_mall_member\"> | string | null\n    address?: StringNullableWithAggregatesFilter<\"shopping_mall_member\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_mall_member\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_mall_member\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_mall_member\"> | Date | string | null\n  }\n\n  export type shopping_mall_sellerWhereInput = {\n    AND?: shopping_mall_sellerWhereInput | shopping_mall_sellerWhereInput[]\n    OR?: shopping_mall_sellerWhereInput[]\n    NOT?: shopping_mall_sellerWhereInput | shopping_mall_sellerWhereInput[]\n    id?: UuidFilter<\"shopping_mall_seller\"> | string\n    email?: StringFilter<\"shopping_mall_seller\"> | string\n    password_hash?: StringFilter<\"shopping_mall_seller\"> | string\n    name?: StringFilter<\"shopping_mall_seller\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_seller\"> | string | null\n    business_name?: StringFilter<\"shopping_mall_seller\"> | string\n    business_address?: StringFilter<\"shopping_mall_seller\"> | string\n    created_at?: DateTimeFilter<\"shopping_mall_seller\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_seller\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_seller\"> | Date | string | null\n  }\n\n  export type shopping_mall_sellerOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    business_name?: SortOrder\n    business_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n  }\n\n  export type shopping_mall_sellerWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: shopping_mall_sellerWhereInput | shopping_mall_sellerWhereInput[]\n    OR?: shopping_mall_sellerWhereInput[]\n    NOT?: shopping_mall_sellerWhereInput | shopping_mall_sellerWhereInput[]\n    password_hash?: StringFilter<\"shopping_mall_seller\"> | string\n    name?: StringFilter<\"shopping_mall_seller\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_seller\"> | string | null\n    business_name?: StringFilter<\"shopping_mall_seller\"> | string\n    business_address?: StringFilter<\"shopping_mall_seller\"> | string\n    created_at?: DateTimeFilter<\"shopping_mall_seller\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_seller\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_seller\"> | Date | string | null\n  }, \"id\" | \"email\">\n\n  export type shopping_mall_sellerOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    business_name?: SortOrder\n    business_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_mall_sellerCountOrderByAggregateInput\n    _max?: shopping_mall_sellerMaxOrderByAggregateInput\n    _min?: shopping_mall_sellerMinOrderByAggregateInput\n  }\n\n  export type shopping_mall_sellerScalarWhereWithAggregatesInput = {\n    AND?: shopping_mall_sellerScalarWhereWithAggregatesInput | shopping_mall_sellerScalarWhereWithAggregatesInput[]\n    OR?: shopping_mall_sellerScalarWhereWithAggregatesInput[]\n    NOT?: shopping_mall_sellerScalarWhereWithAggregatesInput | shopping_mall_sellerScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_mall_seller\"> | string | null\n    business_name?: StringWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    business_address?: StringWithAggregatesFilter<\"shopping_mall_seller\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_mall_seller\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_mall_seller\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_mall_seller\"> | Date | string | null\n  }\n\n  export type shopping_mall_adminWhereInput = {\n    AND?: shopping_mall_adminWhereInput | shopping_mall_adminWhereInput[]\n    OR?: shopping_mall_adminWhereInput[]\n    NOT?: shopping_mall_adminWhereInput | shopping_mall_adminWhereInput[]\n    id?: UuidFilter<\"shopping_mall_admin\"> | string\n    email?: StringFilter<\"shopping_mall_admin\"> | string\n    password_hash?: StringFilter<\"shopping_mall_admin\"> | string\n    name?: StringFilter<\"shopping_mall_admin\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_admin\"> | string | null\n    role?: StringFilter<\"shopping_mall_admin\"> | string\n    created_at?: DateTimeFilter<\"shopping_mall_admin\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_admin\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_admin\"> | Date | string | null\n    shopping_inquiry_responses?: Shopping_inquiry_responsesListRelationFilter\n  }\n\n  export type shopping_mall_adminOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    role?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    shopping_inquiry_responses?: shopping_inquiry_responsesOrderByRelationAggregateInput\n  }\n\n  export type shopping_mall_adminWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: shopping_mall_adminWhereInput | shopping_mall_adminWhereInput[]\n    OR?: shopping_mall_adminWhereInput[]\n    NOT?: shopping_mall_adminWhereInput | shopping_mall_adminWhereInput[]\n    password_hash?: StringFilter<\"shopping_mall_admin\"> | string\n    name?: StringFilter<\"shopping_mall_admin\"> | string\n    phone?: StringNullableFilter<\"shopping_mall_admin\"> | string | null\n    role?: StringFilter<\"shopping_mall_admin\"> | string\n    created_at?: DateTimeFilter<\"shopping_mall_admin\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_mall_admin\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_mall_admin\"> | Date | string | null\n    shopping_inquiry_responses?: Shopping_inquiry_responsesListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type shopping_mall_adminOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    role?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_mall_adminCountOrderByAggregateInput\n    _max?: shopping_mall_adminMaxOrderByAggregateInput\n    _min?: shopping_mall_adminMinOrderByAggregateInput\n  }\n\n  export type shopping_mall_adminScalarWhereWithAggregatesInput = {\n    AND?: shopping_mall_adminScalarWhereWithAggregatesInput | shopping_mall_adminScalarWhereWithAggregatesInput[]\n    OR?: shopping_mall_adminScalarWhereWithAggregatesInput[]\n    NOT?: shopping_mall_adminScalarWhereWithAggregatesInput | shopping_mall_adminScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_mall_admin\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_mall_admin\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_mall_admin\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_mall_admin\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_mall_admin\"> | string | null\n    role?: StringWithAggregatesFilter<\"shopping_mall_admin\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_mall_admin\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_mall_admin\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_mall_admin\"> | Date | string | null\n  }\n\n  export type shopping_salesWhereInput = {\n    AND?: shopping_salesWhereInput | shopping_salesWhereInput[]\n    OR?: shopping_salesWhereInput[]\n    NOT?: shopping_salesWhereInput | shopping_salesWhereInput[]\n    id?: UuidFilter<\"shopping_sales\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sales\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_sales\"> | string\n    code?: StringFilter<\"shopping_sales\"> | string\n    name?: StringFilter<\"shopping_sales\"> | string\n    description?: StringNullableFilter<\"shopping_sales\"> | string | null\n    price?: FloatFilter<\"shopping_sales\"> | number\n    stock?: IntFilter<\"shopping_sales\"> | number\n    created_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sales\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n    shopping_sale_snapshots?: Shopping_sale_snapshotsListRelationFilter\n    shopping_sale_units?: Shopping_sale_unitsListRelationFilter\n  }\n\n  export type shopping_salesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    section?: shopping_sectionsOrderByWithRelationInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsOrderByRelationAggregateInput\n    shopping_sale_units?: shopping_sale_unitsOrderByRelationAggregateInput\n  }\n\n  export type shopping_salesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_salesWhereInput | shopping_salesWhereInput[]\n    OR?: shopping_salesWhereInput[]\n    NOT?: shopping_salesWhereInput | shopping_salesWhereInput[]\n    shopping_channel_id?: UuidFilter<\"shopping_sales\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_sales\"> | string\n    name?: StringFilter<\"shopping_sales\"> | string\n    description?: StringNullableFilter<\"shopping_sales\"> | string | null\n    price?: FloatFilter<\"shopping_sales\"> | number\n    stock?: IntFilter<\"shopping_sales\"> | number\n    created_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sales\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n    shopping_sale_snapshots?: Shopping_sale_snapshotsListRelationFilter\n    shopping_sale_units?: Shopping_sale_unitsListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_salesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_salesCountOrderByAggregateInput\n    _avg?: shopping_salesAvgOrderByAggregateInput\n    _max?: shopping_salesMaxOrderByAggregateInput\n    _min?: shopping_salesMinOrderByAggregateInput\n    _sum?: shopping_salesSumOrderByAggregateInput\n  }\n\n  export type shopping_salesScalarWhereWithAggregatesInput = {\n    AND?: shopping_salesScalarWhereWithAggregatesInput | shopping_salesScalarWhereWithAggregatesInput[]\n    OR?: shopping_salesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_salesScalarWhereWithAggregatesInput | shopping_salesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sales\"> | string\n    shopping_channel_id?: UuidWithAggregatesFilter<\"shopping_sales\"> | string\n    shopping_section_id?: UuidWithAggregatesFilter<\"shopping_sales\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_sales\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sales\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sales\"> | string | null\n    price?: FloatWithAggregatesFilter<\"shopping_sales\"> | number\n    stock?: IntWithAggregatesFilter<\"shopping_sales\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sales\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_sales\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_sales\"> | Date | string | null\n  }\n\n  export type shopping_sale_snapshotsWhereInput = {\n    AND?: shopping_sale_snapshotsWhereInput | shopping_sale_snapshotsWhereInput[]\n    OR?: shopping_sale_snapshotsWhereInput[]\n    NOT?: shopping_sale_snapshotsWhereInput | shopping_sale_snapshotsWhereInput[]\n    id?: UuidFilter<\"shopping_sale_snapshots\"> | string\n    shopping_sale_id?: UuidFilter<\"shopping_sale_snapshots\"> | string\n    code?: StringFilter<\"shopping_sale_snapshots\"> | string\n    name?: StringFilter<\"shopping_sale_snapshots\"> | string\n    description?: StringNullableFilter<\"shopping_sale_snapshots\"> | string | null\n    price?: FloatFilter<\"shopping_sale_snapshots\"> | number\n    stock?: IntFilter<\"shopping_sale_snapshots\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_snapshots\"> | Date | string\n    sale?: XOR<Shopping_salesScalarRelationFilter, shopping_salesWhereInput>\n  }\n\n  export type shopping_sale_snapshotsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    sale?: shopping_salesOrderByWithRelationInput\n  }\n\n  export type shopping_sale_snapshotsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_sale_snapshotsWhereInput | shopping_sale_snapshotsWhereInput[]\n    OR?: shopping_sale_snapshotsWhereInput[]\n    NOT?: shopping_sale_snapshotsWhereInput | shopping_sale_snapshotsWhereInput[]\n    shopping_sale_id?: UuidFilter<\"shopping_sale_snapshots\"> | string\n    code?: StringFilter<\"shopping_sale_snapshots\"> | string\n    name?: StringFilter<\"shopping_sale_snapshots\"> | string\n    description?: StringNullableFilter<\"shopping_sale_snapshots\"> | string | null\n    price?: FloatFilter<\"shopping_sale_snapshots\"> | number\n    stock?: IntFilter<\"shopping_sale_snapshots\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_snapshots\"> | Date | string\n    sale?: XOR<Shopping_salesScalarRelationFilter, shopping_salesWhereInput>\n  }, \"id\">\n\n  export type shopping_sale_snapshotsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_sale_snapshotsCountOrderByAggregateInput\n    _avg?: shopping_sale_snapshotsAvgOrderByAggregateInput\n    _max?: shopping_sale_snapshotsMaxOrderByAggregateInput\n    _min?: shopping_sale_snapshotsMinOrderByAggregateInput\n    _sum?: shopping_sale_snapshotsSumOrderByAggregateInput\n  }\n\n  export type shopping_sale_snapshotsScalarWhereWithAggregatesInput = {\n    AND?: shopping_sale_snapshotsScalarWhereWithAggregatesInput | shopping_sale_snapshotsScalarWhereWithAggregatesInput[]\n    OR?: shopping_sale_snapshotsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sale_snapshotsScalarWhereWithAggregatesInput | shopping_sale_snapshotsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sale_snapshots\"> | string\n    shopping_sale_id?: UuidWithAggregatesFilter<\"shopping_sale_snapshots\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_sale_snapshots\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sale_snapshots\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sale_snapshots\"> | string | null\n    price?: FloatWithAggregatesFilter<\"shopping_sale_snapshots\"> | number\n    stock?: IntWithAggregatesFilter<\"shopping_sale_snapshots\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sale_snapshots\"> | Date | string\n  }\n\n  export type shopping_sale_unitsWhereInput = {\n    AND?: shopping_sale_unitsWhereInput | shopping_sale_unitsWhereInput[]\n    OR?: shopping_sale_unitsWhereInput[]\n    NOT?: shopping_sale_unitsWhereInput | shopping_sale_unitsWhereInput[]\n    id?: UuidFilter<\"shopping_sale_units\"> | string\n    shopping_sale_id?: UuidFilter<\"shopping_sale_units\"> | string\n    code?: StringFilter<\"shopping_sale_units\"> | string\n    name?: StringFilter<\"shopping_sale_units\"> | string\n    description?: StringNullableFilter<\"shopping_sale_units\"> | string | null\n    price?: FloatFilter<\"shopping_sale_units\"> | number\n    stock?: IntFilter<\"shopping_sale_units\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_units\"> | Date | string | null\n    sale?: XOR<Shopping_salesScalarRelationFilter, shopping_salesWhereInput>\n    shopping_sale_unit_options?: Shopping_sale_unit_optionsListRelationFilter\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n    shopping_favorite_items?: Shopping_favorite_itemsListRelationFilter\n  }\n\n  export type shopping_sale_unitsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    sale?: shopping_salesOrderByWithRelationInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsOrderByRelationAggregateInput\n    shopping_cart_items?: shopping_cart_itemsOrderByRelationAggregateInput\n    shopping_favorite_items?: shopping_favorite_itemsOrderByRelationAggregateInput\n  }\n\n  export type shopping_sale_unitsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_sale_id_code?: shopping_sale_unitsShopping_sale_idCodeCompoundUniqueInput\n    AND?: shopping_sale_unitsWhereInput | shopping_sale_unitsWhereInput[]\n    OR?: shopping_sale_unitsWhereInput[]\n    NOT?: shopping_sale_unitsWhereInput | shopping_sale_unitsWhereInput[]\n    shopping_sale_id?: UuidFilter<\"shopping_sale_units\"> | string\n    code?: StringFilter<\"shopping_sale_units\"> | string\n    name?: StringFilter<\"shopping_sale_units\"> | string\n    description?: StringNullableFilter<\"shopping_sale_units\"> | string | null\n    price?: FloatFilter<\"shopping_sale_units\"> | number\n    stock?: IntFilter<\"shopping_sale_units\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_units\"> | Date | string | null\n    sale?: XOR<Shopping_salesScalarRelationFilter, shopping_salesWhereInput>\n    shopping_sale_unit_options?: Shopping_sale_unit_optionsListRelationFilter\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n    shopping_favorite_items?: Shopping_favorite_itemsListRelationFilter\n  }, \"id\" | \"shopping_sale_id_code\">\n\n  export type shopping_sale_unitsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_sale_unitsCountOrderByAggregateInput\n    _avg?: shopping_sale_unitsAvgOrderByAggregateInput\n    _max?: shopping_sale_unitsMaxOrderByAggregateInput\n    _min?: shopping_sale_unitsMinOrderByAggregateInput\n    _sum?: shopping_sale_unitsSumOrderByAggregateInput\n  }\n\n  export type shopping_sale_unitsScalarWhereWithAggregatesInput = {\n    AND?: shopping_sale_unitsScalarWhereWithAggregatesInput | shopping_sale_unitsScalarWhereWithAggregatesInput[]\n    OR?: shopping_sale_unitsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sale_unitsScalarWhereWithAggregatesInput | shopping_sale_unitsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sale_units\"> | string\n    shopping_sale_id?: UuidWithAggregatesFilter<\"shopping_sale_units\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_sale_units\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sale_units\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sale_units\"> | string | null\n    price?: FloatWithAggregatesFilter<\"shopping_sale_units\"> | number\n    stock?: IntWithAggregatesFilter<\"shopping_sale_units\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sale_units\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_sale_units\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_sale_units\"> | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsWhereInput = {\n    AND?: shopping_sale_unit_optionsWhereInput | shopping_sale_unit_optionsWhereInput[]\n    OR?: shopping_sale_unit_optionsWhereInput[]\n    NOT?: shopping_sale_unit_optionsWhereInput | shopping_sale_unit_optionsWhereInput[]\n    id?: UuidFilter<\"shopping_sale_unit_options\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_sale_unit_options\"> | string\n    code?: StringFilter<\"shopping_sale_unit_options\"> | string\n    name?: StringFilter<\"shopping_sale_unit_options\"> | string\n    description?: StringNullableFilter<\"shopping_sale_unit_options\"> | string | null\n    price?: FloatFilter<\"shopping_sale_unit_options\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_unit_options\"> | Date | string | null\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }\n\n  export type shopping_sale_unit_optionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    saleUnit?: shopping_sale_unitsOrderByWithRelationInput\n  }\n\n  export type shopping_sale_unit_optionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_sale_unit_id_code?: shopping_sale_unit_optionsShopping_sale_unit_idCodeCompoundUniqueInput\n    AND?: shopping_sale_unit_optionsWhereInput | shopping_sale_unit_optionsWhereInput[]\n    OR?: shopping_sale_unit_optionsWhereInput[]\n    NOT?: shopping_sale_unit_optionsWhereInput | shopping_sale_unit_optionsWhereInput[]\n    shopping_sale_unit_id?: UuidFilter<\"shopping_sale_unit_options\"> | string\n    code?: StringFilter<\"shopping_sale_unit_options\"> | string\n    name?: StringFilter<\"shopping_sale_unit_options\"> | string\n    description?: StringNullableFilter<\"shopping_sale_unit_options\"> | string | null\n    price?: FloatFilter<\"shopping_sale_unit_options\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_unit_options\"> | Date | string | null\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }, \"id\" | \"shopping_sale_unit_id_code\">\n\n  export type shopping_sale_unit_optionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_sale_unit_optionsCountOrderByAggregateInput\n    _avg?: shopping_sale_unit_optionsAvgOrderByAggregateInput\n    _max?: shopping_sale_unit_optionsMaxOrderByAggregateInput\n    _min?: shopping_sale_unit_optionsMinOrderByAggregateInput\n    _sum?: shopping_sale_unit_optionsSumOrderByAggregateInput\n  }\n\n  export type shopping_sale_unit_optionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_sale_unit_optionsScalarWhereWithAggregatesInput | shopping_sale_unit_optionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_sale_unit_optionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sale_unit_optionsScalarWhereWithAggregatesInput | shopping_sale_unit_optionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sale_unit_options\"> | string\n    shopping_sale_unit_id?: UuidWithAggregatesFilter<\"shopping_sale_unit_options\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_sale_unit_options\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sale_unit_options\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sale_unit_options\"> | string | null\n    price?: FloatWithAggregatesFilter<\"shopping_sale_unit_options\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sale_unit_options\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_sale_unit_options\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_sale_unit_options\"> | Date | string | null\n  }\n\n  export type shopping_cartsWhereInput = {\n    AND?: shopping_cartsWhereInput | shopping_cartsWhereInput[]\n    OR?: shopping_cartsWhereInput[]\n    NOT?: shopping_cartsWhereInput | shopping_cartsWhereInput[]\n    id?: UuidFilter<\"shopping_carts\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_carts\"> | string\n    status?: StringFilter<\"shopping_carts\"> | string\n    created_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n  }\n\n  export type shopping_cartsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    member?: shopping_mall_memberOrderByWithRelationInput\n    shopping_cart_items?: shopping_cart_itemsOrderByRelationAggregateInput\n  }\n\n  export type shopping_cartsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_cartsWhereInput | shopping_cartsWhereInput[]\n    OR?: shopping_cartsWhereInput[]\n    NOT?: shopping_cartsWhereInput | shopping_cartsWhereInput[]\n    shopping_mall_member_id?: UuidFilter<\"shopping_carts\"> | string\n    status?: StringFilter<\"shopping_carts\"> | string\n    created_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n  }, \"id\">\n\n  export type shopping_cartsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_cartsCountOrderByAggregateInput\n    _max?: shopping_cartsMaxOrderByAggregateInput\n    _min?: shopping_cartsMinOrderByAggregateInput\n  }\n\n  export type shopping_cartsScalarWhereWithAggregatesInput = {\n    AND?: shopping_cartsScalarWhereWithAggregatesInput | shopping_cartsScalarWhereWithAggregatesInput[]\n    OR?: shopping_cartsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_cartsScalarWhereWithAggregatesInput | shopping_cartsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_carts\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_carts\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_carts\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_carts\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_carts\"> | Date | string\n  }\n\n  export type shopping_cart_itemsWhereInput = {\n    AND?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    OR?: shopping_cart_itemsWhereInput[]\n    NOT?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    cart?: XOR<Shopping_cartsScalarRelationFilter, shopping_cartsWhereInput>\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }\n\n  export type shopping_cart_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_cart_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    cart?: shopping_cartsOrderByWithRelationInput\n    saleUnit?: shopping_sale_unitsOrderByWithRelationInput\n  }\n\n  export type shopping_cart_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    OR?: shopping_cart_itemsWhereInput[]\n    NOT?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    cart?: XOR<Shopping_cartsScalarRelationFilter, shopping_cartsWhereInput>\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }, \"id\">\n\n  export type shopping_cart_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_cart_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_cart_itemsCountOrderByAggregateInput\n    _avg?: shopping_cart_itemsAvgOrderByAggregateInput\n    _max?: shopping_cart_itemsMaxOrderByAggregateInput\n    _min?: shopping_cart_itemsMinOrderByAggregateInput\n    _sum?: shopping_cart_itemsSumOrderByAggregateInput\n  }\n\n  export type shopping_cart_itemsScalarWhereWithAggregatesInput = {\n    AND?: shopping_cart_itemsScalarWhereWithAggregatesInput | shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    OR?: shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_cart_itemsScalarWhereWithAggregatesInput | shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    shopping_cart_id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    shopping_sale_unit_id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    quantity?: IntWithAggregatesFilter<\"shopping_cart_items\"> | number\n    price?: FloatWithAggregatesFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_cart_items\"> | Date | string\n  }\n\n  export type shopping_ordersWhereInput = {\n    AND?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    OR?: shopping_ordersWhereInput[]\n    NOT?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    id?: UuidFilter<\"shopping_orders\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_orders\"> | string\n    code?: StringFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_order_snapshots?: Shopping_order_snapshotsListRelationFilter\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_coin_transactions?: Shopping_coin_transactionsListRelationFilter\n  }\n\n  export type shopping_ordersOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    member?: shopping_mall_memberOrderByWithRelationInput\n    shopping_order_snapshots?: shopping_order_snapshotsOrderByRelationAggregateInput\n    shopping_order_items?: shopping_order_itemsOrderByRelationAggregateInput\n    shopping_coin_transactions?: shopping_coin_transactionsOrderByRelationAggregateInput\n  }\n\n  export type shopping_ordersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    OR?: shopping_ordersWhereInput[]\n    NOT?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    shopping_mall_member_id?: UuidFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_order_snapshots?: Shopping_order_snapshotsListRelationFilter\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_coin_transactions?: Shopping_coin_transactionsListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_ordersOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_ordersCountOrderByAggregateInput\n    _avg?: shopping_ordersAvgOrderByAggregateInput\n    _max?: shopping_ordersMaxOrderByAggregateInput\n    _min?: shopping_ordersMinOrderByAggregateInput\n    _sum?: shopping_ordersSumOrderByAggregateInput\n  }\n\n  export type shopping_ordersScalarWhereWithAggregatesInput = {\n    AND?: shopping_ordersScalarWhereWithAggregatesInput | shopping_ordersScalarWhereWithAggregatesInput[]\n    OR?: shopping_ordersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_ordersScalarWhereWithAggregatesInput | shopping_ordersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_orders\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_orders\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    total_amount?: FloatWithAggregatesFilter<\"shopping_orders\"> | number\n    shipping_address?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    payment_method?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_orders\"> | Date | string | null\n  }\n\n  export type shopping_order_snapshotsWhereInput = {\n    AND?: shopping_order_snapshotsWhereInput | shopping_order_snapshotsWhereInput[]\n    OR?: shopping_order_snapshotsWhereInput[]\n    NOT?: shopping_order_snapshotsWhereInput | shopping_order_snapshotsWhereInput[]\n    id?: UuidFilter<\"shopping_order_snapshots\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_snapshots\"> | string\n    code?: StringFilter<\"shopping_order_snapshots\"> | string\n    status?: StringFilter<\"shopping_order_snapshots\"> | string\n    total_amount?: FloatFilter<\"shopping_order_snapshots\"> | number\n    shipping_address?: StringFilter<\"shopping_order_snapshots\"> | string\n    payment_method?: StringFilter<\"shopping_order_snapshots\"> | string\n    created_at?: DateTimeFilter<\"shopping_order_snapshots\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }\n\n  export type shopping_order_snapshotsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_order_snapshotsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_order_snapshotsWhereInput | shopping_order_snapshotsWhereInput[]\n    OR?: shopping_order_snapshotsWhereInput[]\n    NOT?: shopping_order_snapshotsWhereInput | shopping_order_snapshotsWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_order_snapshots\"> | string\n    code?: StringFilter<\"shopping_order_snapshots\"> | string\n    status?: StringFilter<\"shopping_order_snapshots\"> | string\n    total_amount?: FloatFilter<\"shopping_order_snapshots\"> | number\n    shipping_address?: StringFilter<\"shopping_order_snapshots\"> | string\n    payment_method?: StringFilter<\"shopping_order_snapshots\"> | string\n    created_at?: DateTimeFilter<\"shopping_order_snapshots\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }, \"id\">\n\n  export type shopping_order_snapshotsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_order_snapshotsCountOrderByAggregateInput\n    _avg?: shopping_order_snapshotsAvgOrderByAggregateInput\n    _max?: shopping_order_snapshotsMaxOrderByAggregateInput\n    _min?: shopping_order_snapshotsMinOrderByAggregateInput\n    _sum?: shopping_order_snapshotsSumOrderByAggregateInput\n  }\n\n  export type shopping_order_snapshotsScalarWhereWithAggregatesInput = {\n    AND?: shopping_order_snapshotsScalarWhereWithAggregatesInput | shopping_order_snapshotsScalarWhereWithAggregatesInput[]\n    OR?: shopping_order_snapshotsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_order_snapshotsScalarWhereWithAggregatesInput | shopping_order_snapshotsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    total_amount?: FloatWithAggregatesFilter<\"shopping_order_snapshots\"> | number\n    shipping_address?: StringWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    payment_method?: StringWithAggregatesFilter<\"shopping_order_snapshots\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_order_snapshots\"> | Date | string\n  }\n\n  export type shopping_order_itemsWhereInput = {\n    AND?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    OR?: shopping_order_itemsWhereInput[]\n    NOT?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    product_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }\n\n  export type shopping_order_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    product_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_order_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    OR?: shopping_order_itemsWhereInput[]\n    NOT?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    product_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }, \"id\">\n\n  export type shopping_order_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    product_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_order_itemsCountOrderByAggregateInput\n    _avg?: shopping_order_itemsAvgOrderByAggregateInput\n    _max?: shopping_order_itemsMaxOrderByAggregateInput\n    _min?: shopping_order_itemsMinOrderByAggregateInput\n    _sum?: shopping_order_itemsSumOrderByAggregateInput\n  }\n\n  export type shopping_order_itemsScalarWhereWithAggregatesInput = {\n    AND?: shopping_order_itemsScalarWhereWithAggregatesInput | shopping_order_itemsScalarWhereWithAggregatesInput[]\n    OR?: shopping_order_itemsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_order_itemsScalarWhereWithAggregatesInput | shopping_order_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    product_id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    quantity?: IntWithAggregatesFilter<\"shopping_order_items\"> | number\n    price?: FloatWithAggregatesFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_order_items\"> | Date | string\n  }\n\n  export type shopping_couponsWhereInput = {\n    AND?: shopping_couponsWhereInput | shopping_couponsWhereInput[]\n    OR?: shopping_couponsWhereInput[]\n    NOT?: shopping_couponsWhereInput | shopping_couponsWhereInput[]\n    id?: UuidFilter<\"shopping_coupons\"> | string\n    code?: StringFilter<\"shopping_coupons\"> | string\n    discount_type?: StringFilter<\"shopping_coupons\"> | string\n    value?: FloatFilter<\"shopping_coupons\"> | number\n    valid_from?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    valid_until?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    max_uses?: IntNullableFilter<\"shopping_coupons\"> | number | null\n    created_at?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    shopping_coupon_usage?: Shopping_coupon_usageListRelationFilter\n  }\n\n  export type shopping_couponsOrderByWithRelationInput = {\n    id?: SortOrder\n    code?: SortOrder\n    discount_type?: SortOrder\n    value?: SortOrder\n    valid_from?: SortOrder\n    valid_until?: SortOrder\n    max_uses?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    shopping_coupon_usage?: shopping_coupon_usageOrderByRelationAggregateInput\n  }\n\n  export type shopping_couponsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_couponsWhereInput | shopping_couponsWhereInput[]\n    OR?: shopping_couponsWhereInput[]\n    NOT?: shopping_couponsWhereInput | shopping_couponsWhereInput[]\n    discount_type?: StringFilter<\"shopping_coupons\"> | string\n    value?: FloatFilter<\"shopping_coupons\"> | number\n    valid_from?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    valid_until?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    max_uses?: IntNullableFilter<\"shopping_coupons\"> | number | null\n    created_at?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coupons\"> | Date | string\n    shopping_coupon_usage?: Shopping_coupon_usageListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_couponsOrderByWithAggregationInput = {\n    id?: SortOrder\n    code?: SortOrder\n    discount_type?: SortOrder\n    value?: SortOrder\n    valid_from?: SortOrder\n    valid_until?: SortOrder\n    max_uses?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_couponsCountOrderByAggregateInput\n    _avg?: shopping_couponsAvgOrderByAggregateInput\n    _max?: shopping_couponsMaxOrderByAggregateInput\n    _min?: shopping_couponsMinOrderByAggregateInput\n    _sum?: shopping_couponsSumOrderByAggregateInput\n  }\n\n  export type shopping_couponsScalarWhereWithAggregatesInput = {\n    AND?: shopping_couponsScalarWhereWithAggregatesInput | shopping_couponsScalarWhereWithAggregatesInput[]\n    OR?: shopping_couponsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_couponsScalarWhereWithAggregatesInput | shopping_couponsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_coupons\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_coupons\"> | string\n    discount_type?: StringWithAggregatesFilter<\"shopping_coupons\"> | string\n    value?: FloatWithAggregatesFilter<\"shopping_coupons\"> | number\n    valid_from?: DateTimeWithAggregatesFilter<\"shopping_coupons\"> | Date | string\n    valid_until?: DateTimeWithAggregatesFilter<\"shopping_coupons\"> | Date | string\n    max_uses?: IntNullableWithAggregatesFilter<\"shopping_coupons\"> | number | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_coupons\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_coupons\"> | Date | string\n  }\n\n  export type shopping_coupon_usageWhereInput = {\n    AND?: shopping_coupon_usageWhereInput | shopping_coupon_usageWhereInput[]\n    OR?: shopping_coupon_usageWhereInput[]\n    NOT?: shopping_coupon_usageWhereInput | shopping_coupon_usageWhereInput[]\n    id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    shopping_coupon_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    order_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    used_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    coupon?: XOR<Shopping_couponsScalarRelationFilter, shopping_couponsWhereInput>\n    user?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }\n\n  export type shopping_coupon_usageOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_coupon_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    order_id?: SortOrder\n    used_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    coupon?: shopping_couponsOrderByWithRelationInput\n    user?: shopping_mall_memberOrderByWithRelationInput\n  }\n\n  export type shopping_coupon_usageWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_coupon_usageWhereInput | shopping_coupon_usageWhereInput[]\n    OR?: shopping_coupon_usageWhereInput[]\n    NOT?: shopping_coupon_usageWhereInput | shopping_coupon_usageWhereInput[]\n    shopping_coupon_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    order_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    used_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    coupon?: XOR<Shopping_couponsScalarRelationFilter, shopping_couponsWhereInput>\n    user?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }, \"id\">\n\n  export type shopping_coupon_usageOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_coupon_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    order_id?: SortOrder\n    used_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_coupon_usageCountOrderByAggregateInput\n    _max?: shopping_coupon_usageMaxOrderByAggregateInput\n    _min?: shopping_coupon_usageMinOrderByAggregateInput\n  }\n\n  export type shopping_coupon_usageScalarWhereWithAggregatesInput = {\n    AND?: shopping_coupon_usageScalarWhereWithAggregatesInput | shopping_coupon_usageScalarWhereWithAggregatesInput[]\n    OR?: shopping_coupon_usageScalarWhereWithAggregatesInput[]\n    NOT?: shopping_coupon_usageScalarWhereWithAggregatesInput | shopping_coupon_usageScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_coupon_usage\"> | string\n    shopping_coupon_id?: UuidWithAggregatesFilter<\"shopping_coupon_usage\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_coupon_usage\"> | string\n    order_id?: UuidWithAggregatesFilter<\"shopping_coupon_usage\"> | string\n    used_at?: DateTimeWithAggregatesFilter<\"shopping_coupon_usage\"> | Date | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_coupon_usage\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_coupon_usage\"> | Date | string\n  }\n\n  export type shopping_coinsWhereInput = {\n    AND?: shopping_coinsWhereInput | shopping_coinsWhereInput[]\n    OR?: shopping_coinsWhereInput[]\n    NOT?: shopping_coinsWhereInput | shopping_coinsWhereInput[]\n    id?: UuidFilter<\"shopping_coins\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coins\"> | string\n    balance?: FloatFilter<\"shopping_coins\"> | number\n    created_at?: DateTimeFilter<\"shopping_coins\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coins\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_coins\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }\n\n  export type shopping_coinsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    balance?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    member?: shopping_mall_memberOrderByWithRelationInput\n  }\n\n  export type shopping_coinsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_mall_member_id?: string\n    AND?: shopping_coinsWhereInput | shopping_coinsWhereInput[]\n    OR?: shopping_coinsWhereInput[]\n    NOT?: shopping_coinsWhereInput | shopping_coinsWhereInput[]\n    balance?: FloatFilter<\"shopping_coins\"> | number\n    created_at?: DateTimeFilter<\"shopping_coins\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coins\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_coins\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }, \"id\" | \"shopping_mall_member_id\">\n\n  export type shopping_coinsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    balance?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_coinsCountOrderByAggregateInput\n    _avg?: shopping_coinsAvgOrderByAggregateInput\n    _max?: shopping_coinsMaxOrderByAggregateInput\n    _min?: shopping_coinsMinOrderByAggregateInput\n    _sum?: shopping_coinsSumOrderByAggregateInput\n  }\n\n  export type shopping_coinsScalarWhereWithAggregatesInput = {\n    AND?: shopping_coinsScalarWhereWithAggregatesInput | shopping_coinsScalarWhereWithAggregatesInput[]\n    OR?: shopping_coinsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_coinsScalarWhereWithAggregatesInput | shopping_coinsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_coins\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_coins\"> | string\n    balance?: FloatWithAggregatesFilter<\"shopping_coins\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_coins\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_coins\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_coins\"> | Date | string | null\n  }\n\n  export type shopping_coin_transactionsWhereInput = {\n    AND?: shopping_coin_transactionsWhereInput | shopping_coin_transactionsWhereInput[]\n    OR?: shopping_coin_transactionsWhereInput[]\n    NOT?: shopping_coin_transactionsWhereInput | shopping_coin_transactionsWhereInput[]\n    id?: UuidFilter<\"shopping_coin_transactions\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coin_transactions\"> | string\n    shopping_order_id?: UuidNullableFilter<\"shopping_coin_transactions\"> | string | null\n    amount?: FloatFilter<\"shopping_coin_transactions\"> | number\n    transaction_type?: StringFilter<\"shopping_coin_transactions\"> | string\n    description?: StringNullableFilter<\"shopping_coin_transactions\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_coin_transactions\"> | Date | string\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    order?: XOR<Shopping_ordersNullableScalarRelationFilter, shopping_ordersWhereInput> | null\n  }\n\n  export type shopping_coin_transactionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    shopping_order_id?: SortOrderInput | SortOrder\n    amount?: SortOrder\n    transaction_type?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    member?: shopping_mall_memberOrderByWithRelationInput\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_coin_transactionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_coin_transactionsWhereInput | shopping_coin_transactionsWhereInput[]\n    OR?: shopping_coin_transactionsWhereInput[]\n    NOT?: shopping_coin_transactionsWhereInput | shopping_coin_transactionsWhereInput[]\n    shopping_mall_member_id?: UuidFilter<\"shopping_coin_transactions\"> | string\n    shopping_order_id?: UuidNullableFilter<\"shopping_coin_transactions\"> | string | null\n    amount?: FloatFilter<\"shopping_coin_transactions\"> | number\n    transaction_type?: StringFilter<\"shopping_coin_transactions\"> | string\n    description?: StringNullableFilter<\"shopping_coin_transactions\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_coin_transactions\"> | Date | string\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    order?: XOR<Shopping_ordersNullableScalarRelationFilter, shopping_ordersWhereInput> | null\n  }, \"id\">\n\n  export type shopping_coin_transactionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    shopping_order_id?: SortOrderInput | SortOrder\n    amount?: SortOrder\n    transaction_type?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    _count?: shopping_coin_transactionsCountOrderByAggregateInput\n    _avg?: shopping_coin_transactionsAvgOrderByAggregateInput\n    _max?: shopping_coin_transactionsMaxOrderByAggregateInput\n    _min?: shopping_coin_transactionsMinOrderByAggregateInput\n    _sum?: shopping_coin_transactionsSumOrderByAggregateInput\n  }\n\n  export type shopping_coin_transactionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_coin_transactionsScalarWhereWithAggregatesInput | shopping_coin_transactionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_coin_transactionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_coin_transactionsScalarWhereWithAggregatesInput | shopping_coin_transactionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_coin_transactions\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_coin_transactions\"> | string\n    shopping_order_id?: UuidNullableWithAggregatesFilter<\"shopping_coin_transactions\"> | string | null\n    amount?: FloatWithAggregatesFilter<\"shopping_coin_transactions\"> | number\n    transaction_type?: StringWithAggregatesFilter<\"shopping_coin_transactions\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_coin_transactions\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_coin_transactions\"> | Date | string\n  }\n\n  export type shopping_inquiriesWhereInput = {\n    AND?: shopping_inquiriesWhereInput | shopping_inquiriesWhereInput[]\n    OR?: shopping_inquiriesWhereInput[]\n    NOT?: shopping_inquiriesWhereInput | shopping_inquiriesWhereInput[]\n    id?: UuidFilter<\"shopping_inquiries\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_inquiries\"> | string\n    title?: StringFilter<\"shopping_inquiries\"> | string\n    content?: StringFilter<\"shopping_inquiries\"> | string\n    status?: StringFilter<\"shopping_inquiries\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiries\"> | Date | string | null\n    customer?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_inquiry_responses?: Shopping_inquiry_responsesListRelationFilter\n  }\n\n  export type shopping_inquiriesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    customer?: shopping_mall_memberOrderByWithRelationInput\n    shopping_inquiry_responses?: shopping_inquiry_responsesOrderByRelationAggregateInput\n  }\n\n  export type shopping_inquiriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_inquiriesWhereInput | shopping_inquiriesWhereInput[]\n    OR?: shopping_inquiriesWhereInput[]\n    NOT?: shopping_inquiriesWhereInput | shopping_inquiriesWhereInput[]\n    shopping_mall_member_id?: UuidFilter<\"shopping_inquiries\"> | string\n    title?: StringFilter<\"shopping_inquiries\"> | string\n    content?: StringFilter<\"shopping_inquiries\"> | string\n    status?: StringFilter<\"shopping_inquiries\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiries\"> | Date | string | null\n    customer?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_inquiry_responses?: Shopping_inquiry_responsesListRelationFilter\n  }, \"id\">\n\n  export type shopping_inquiriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_inquiriesCountOrderByAggregateInput\n    _max?: shopping_inquiriesMaxOrderByAggregateInput\n    _min?: shopping_inquiriesMinOrderByAggregateInput\n  }\n\n  export type shopping_inquiriesScalarWhereWithAggregatesInput = {\n    AND?: shopping_inquiriesScalarWhereWithAggregatesInput | shopping_inquiriesScalarWhereWithAggregatesInput[]\n    OR?: shopping_inquiriesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_inquiriesScalarWhereWithAggregatesInput | shopping_inquiriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_inquiries\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_inquiries\"> | string\n    title?: StringWithAggregatesFilter<\"shopping_inquiries\"> | string\n    content?: StringWithAggregatesFilter<\"shopping_inquiries\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_inquiries\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_inquiries\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_inquiries\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_inquiries\"> | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesWhereInput = {\n    AND?: shopping_inquiry_responsesWhereInput | shopping_inquiry_responsesWhereInput[]\n    OR?: shopping_inquiry_responsesWhereInput[]\n    NOT?: shopping_inquiry_responsesWhereInput | shopping_inquiry_responsesWhereInput[]\n    id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    shopping_inquiry_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    shopping_mall_admin_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    content?: StringFilter<\"shopping_inquiry_responses\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiry_responses\"> | Date | string | null\n    inquiry?: XOR<Shopping_inquiriesScalarRelationFilter, shopping_inquiriesWhereInput>\n    admin?: XOR<Shopping_mall_adminScalarRelationFilter, shopping_mall_adminWhereInput>\n  }\n\n  export type shopping_inquiry_responsesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_inquiry_id?: SortOrder\n    shopping_mall_admin_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    inquiry?: shopping_inquiriesOrderByWithRelationInput\n    admin?: shopping_mall_adminOrderByWithRelationInput\n  }\n\n  export type shopping_inquiry_responsesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_inquiry_responsesWhereInput | shopping_inquiry_responsesWhereInput[]\n    OR?: shopping_inquiry_responsesWhereInput[]\n    NOT?: shopping_inquiry_responsesWhereInput | shopping_inquiry_responsesWhereInput[]\n    shopping_inquiry_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    shopping_mall_admin_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    content?: StringFilter<\"shopping_inquiry_responses\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiry_responses\"> | Date | string | null\n    inquiry?: XOR<Shopping_inquiriesScalarRelationFilter, shopping_inquiriesWhereInput>\n    admin?: XOR<Shopping_mall_adminScalarRelationFilter, shopping_mall_adminWhereInput>\n  }, \"id\">\n\n  export type shopping_inquiry_responsesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_inquiry_id?: SortOrder\n    shopping_mall_admin_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_inquiry_responsesCountOrderByAggregateInput\n    _max?: shopping_inquiry_responsesMaxOrderByAggregateInput\n    _min?: shopping_inquiry_responsesMinOrderByAggregateInput\n  }\n\n  export type shopping_inquiry_responsesScalarWhereWithAggregatesInput = {\n    AND?: shopping_inquiry_responsesScalarWhereWithAggregatesInput | shopping_inquiry_responsesScalarWhereWithAggregatesInput[]\n    OR?: shopping_inquiry_responsesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_inquiry_responsesScalarWhereWithAggregatesInput | shopping_inquiry_responsesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_inquiry_responses\"> | string\n    shopping_inquiry_id?: UuidWithAggregatesFilter<\"shopping_inquiry_responses\"> | string\n    shopping_mall_admin_id?: UuidWithAggregatesFilter<\"shopping_inquiry_responses\"> | string\n    content?: StringWithAggregatesFilter<\"shopping_inquiry_responses\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_inquiry_responses\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_inquiry_responses\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_inquiry_responses\"> | Date | string | null\n  }\n\n  export type shopping_favoritesWhereInput = {\n    AND?: shopping_favoritesWhereInput | shopping_favoritesWhereInput[]\n    OR?: shopping_favoritesWhereInput[]\n    NOT?: shopping_favoritesWhereInput | shopping_favoritesWhereInput[]\n    id?: UuidFilter<\"shopping_favorites\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_favorites\"> | string\n    name?: StringFilter<\"shopping_favorites\"> | string\n    description?: StringNullableFilter<\"shopping_favorites\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_favorites\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_favorite_items?: Shopping_favorite_itemsListRelationFilter\n  }\n\n  export type shopping_favoritesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    member?: shopping_mall_memberOrderByWithRelationInput\n    shopping_favorite_items?: shopping_favorite_itemsOrderByRelationAggregateInput\n  }\n\n  export type shopping_favoritesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_mall_member_id_name?: shopping_favoritesShopping_mall_member_idNameCompoundUniqueInput\n    AND?: shopping_favoritesWhereInput | shopping_favoritesWhereInput[]\n    OR?: shopping_favoritesWhereInput[]\n    NOT?: shopping_favoritesWhereInput | shopping_favoritesWhereInput[]\n    shopping_mall_member_id?: UuidFilter<\"shopping_favorites\"> | string\n    name?: StringFilter<\"shopping_favorites\"> | string\n    description?: StringNullableFilter<\"shopping_favorites\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_favorites\"> | Date | string | null\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n    shopping_favorite_items?: Shopping_favorite_itemsListRelationFilter\n  }, \"id\" | \"shopping_mall_member_id_name\">\n\n  export type shopping_favoritesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_favoritesCountOrderByAggregateInput\n    _max?: shopping_favoritesMaxOrderByAggregateInput\n    _min?: shopping_favoritesMinOrderByAggregateInput\n  }\n\n  export type shopping_favoritesScalarWhereWithAggregatesInput = {\n    AND?: shopping_favoritesScalarWhereWithAggregatesInput | shopping_favoritesScalarWhereWithAggregatesInput[]\n    OR?: shopping_favoritesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_favoritesScalarWhereWithAggregatesInput | shopping_favoritesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_favorites\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_favorites\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_favorites\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_favorites\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_favorites\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_favorites\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_favorites\"> | Date | string | null\n  }\n\n  export type shopping_favorite_itemsWhereInput = {\n    AND?: shopping_favorite_itemsWhereInput | shopping_favorite_itemsWhereInput[]\n    OR?: shopping_favorite_itemsWhereInput[]\n    NOT?: shopping_favorite_itemsWhereInput | shopping_favorite_itemsWhereInput[]\n    id?: UuidFilter<\"shopping_favorite_items\"> | string\n    shopping_favorite_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    created_at?: DateTimeFilter<\"shopping_favorite_items\"> | Date | string\n    favorite?: XOR<Shopping_favoritesScalarRelationFilter, shopping_favoritesWhereInput>\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }\n\n  export type shopping_favorite_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_favorite_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    created_at?: SortOrder\n    favorite?: shopping_favoritesOrderByWithRelationInput\n    saleUnit?: shopping_sale_unitsOrderByWithRelationInput\n  }\n\n  export type shopping_favorite_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_favorite_id_shopping_sale_unit_id?: shopping_favorite_itemsShopping_favorite_idShopping_sale_unit_idCompoundUniqueInput\n    AND?: shopping_favorite_itemsWhereInput | shopping_favorite_itemsWhereInput[]\n    OR?: shopping_favorite_itemsWhereInput[]\n    NOT?: shopping_favorite_itemsWhereInput | shopping_favorite_itemsWhereInput[]\n    shopping_favorite_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    created_at?: DateTimeFilter<\"shopping_favorite_items\"> | Date | string\n    favorite?: XOR<Shopping_favoritesScalarRelationFilter, shopping_favoritesWhereInput>\n    saleUnit?: XOR<Shopping_sale_unitsScalarRelationFilter, shopping_sale_unitsWhereInput>\n  }, \"id\" | \"shopping_favorite_id_shopping_sale_unit_id\">\n\n  export type shopping_favorite_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_favorite_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_favorite_itemsCountOrderByAggregateInput\n    _max?: shopping_favorite_itemsMaxOrderByAggregateInput\n    _min?: shopping_favorite_itemsMinOrderByAggregateInput\n  }\n\n  export type shopping_favorite_itemsScalarWhereWithAggregatesInput = {\n    AND?: shopping_favorite_itemsScalarWhereWithAggregatesInput | shopping_favorite_itemsScalarWhereWithAggregatesInput[]\n    OR?: shopping_favorite_itemsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_favorite_itemsScalarWhereWithAggregatesInput | shopping_favorite_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_favorite_items\"> | string\n    shopping_favorite_id?: UuidWithAggregatesFilter<\"shopping_favorite_items\"> | string\n    shopping_sale_unit_id?: UuidWithAggregatesFilter<\"shopping_favorite_items\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_favorite_items\"> | Date | string\n  }\n\n  export type shopping_articlesWhereInput = {\n    AND?: shopping_articlesWhereInput | shopping_articlesWhereInput[]\n    OR?: shopping_articlesWhereInput[]\n    NOT?: shopping_articlesWhereInput | shopping_articlesWhereInput[]\n    id?: UuidFilter<\"shopping_articles\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_articles\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_articles\"> | string\n    code?: StringFilter<\"shopping_articles\"> | string\n    title?: StringFilter<\"shopping_articles\"> | string\n    content?: StringFilter<\"shopping_articles\"> | string\n    status?: StringFilter<\"shopping_articles\"> | string\n    created_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_articles\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n    shopping_article_comments?: Shopping_article_commentsListRelationFilter\n  }\n\n  export type shopping_articlesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    section?: shopping_sectionsOrderByWithRelationInput\n    shopping_article_comments?: shopping_article_commentsOrderByRelationAggregateInput\n  }\n\n  export type shopping_articlesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_articlesWhereInput | shopping_articlesWhereInput[]\n    OR?: shopping_articlesWhereInput[]\n    NOT?: shopping_articlesWhereInput | shopping_articlesWhereInput[]\n    shopping_channel_id?: UuidFilter<\"shopping_articles\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_articles\"> | string\n    title?: StringFilter<\"shopping_articles\"> | string\n    content?: StringFilter<\"shopping_articles\"> | string\n    status?: StringFilter<\"shopping_articles\"> | string\n    created_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_articles\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n    shopping_article_comments?: Shopping_article_commentsListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_articlesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_articlesCountOrderByAggregateInput\n    _max?: shopping_articlesMaxOrderByAggregateInput\n    _min?: shopping_articlesMinOrderByAggregateInput\n  }\n\n  export type shopping_articlesScalarWhereWithAggregatesInput = {\n    AND?: shopping_articlesScalarWhereWithAggregatesInput | shopping_articlesScalarWhereWithAggregatesInput[]\n    OR?: shopping_articlesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_articlesScalarWhereWithAggregatesInput | shopping_articlesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_articles\"> | string\n    shopping_channel_id?: UuidWithAggregatesFilter<\"shopping_articles\"> | string\n    shopping_section_id?: UuidWithAggregatesFilter<\"shopping_articles\"> | string\n    code?: StringWithAggregatesFilter<\"shopping_articles\"> | string\n    title?: StringWithAggregatesFilter<\"shopping_articles\"> | string\n    content?: StringWithAggregatesFilter<\"shopping_articles\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_articles\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_articles\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_articles\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_articles\"> | Date | string | null\n  }\n\n  export type shopping_article_commentsWhereInput = {\n    AND?: shopping_article_commentsWhereInput | shopping_article_commentsWhereInput[]\n    OR?: shopping_article_commentsWhereInput[]\n    NOT?: shopping_article_commentsWhereInput | shopping_article_commentsWhereInput[]\n    id?: UuidFilter<\"shopping_article_comments\"> | string\n    shopping_article_id?: UuidFilter<\"shopping_article_comments\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_article_comments\"> | string\n    content?: StringFilter<\"shopping_article_comments\"> | string\n    created_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_article_comments\"> | Date | string | null\n    article?: XOR<Shopping_articlesScalarRelationFilter, shopping_articlesWhereInput>\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }\n\n  export type shopping_article_commentsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_article_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    article?: shopping_articlesOrderByWithRelationInput\n    member?: shopping_mall_memberOrderByWithRelationInput\n  }\n\n  export type shopping_article_commentsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_article_commentsWhereInput | shopping_article_commentsWhereInput[]\n    OR?: shopping_article_commentsWhereInput[]\n    NOT?: shopping_article_commentsWhereInput | shopping_article_commentsWhereInput[]\n    shopping_article_id?: UuidFilter<\"shopping_article_comments\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_article_comments\"> | string\n    content?: StringFilter<\"shopping_article_comments\"> | string\n    created_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_article_comments\"> | Date | string | null\n    article?: XOR<Shopping_articlesScalarRelationFilter, shopping_articlesWhereInput>\n    member?: XOR<Shopping_mall_memberScalarRelationFilter, shopping_mall_memberWhereInput>\n  }, \"id\">\n\n  export type shopping_article_commentsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_article_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_article_commentsCountOrderByAggregateInput\n    _max?: shopping_article_commentsMaxOrderByAggregateInput\n    _min?: shopping_article_commentsMinOrderByAggregateInput\n  }\n\n  export type shopping_article_commentsScalarWhereWithAggregatesInput = {\n    AND?: shopping_article_commentsScalarWhereWithAggregatesInput | shopping_article_commentsScalarWhereWithAggregatesInput[]\n    OR?: shopping_article_commentsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_article_commentsScalarWhereWithAggregatesInput | shopping_article_commentsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_article_comments\"> | string\n    shopping_article_id?: UuidWithAggregatesFilter<\"shopping_article_comments\"> | string\n    shopping_mall_member_id?: UuidWithAggregatesFilter<\"shopping_article_comments\"> | string\n    content?: StringWithAggregatesFilter<\"shopping_article_comments\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_article_comments\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_article_comments\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_article_comments\"> | Date | string | null\n  }\n\n  export type shopping_channelsCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsCreateManyInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channelsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channelsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sectionsCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsCreateManyInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsCreateInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel?: shopping_channelsCreateNestedOneWithoutShopping_configurationsInput\n    section?: shopping_sectionsCreateNestedOneWithoutShopping_configurationsInput\n  }\n\n  export type shopping_configurationsUncheckedCreateInput = {\n    id: string\n    shopping_channel_id?: string | null\n    shopping_section_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneWithoutShopping_configurationsNestedInput\n    section?: shopping_sectionsUpdateOneWithoutShopping_configurationsNestedInput\n  }\n\n  export type shopping_configurationsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_section_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsCreateManyInput = {\n    id: string\n    shopping_channel_id?: string | null\n    shopping_section_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_section_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_guestCreateInput = {\n    id: string\n    session_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_mall_guestUncheckedCreateInput = {\n    id: string\n    session_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_mall_guestUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    session_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_mall_guestUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    session_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_mall_guestCreateManyInput = {\n    id: string\n    session_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_mall_guestUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    session_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_mall_guestUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    session_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_mall_memberCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_memberUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_memberUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_sellerCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    business_name: string\n    business_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_sellerUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    business_name: string\n    business_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_sellerUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    business_name?: StringFieldUpdateOperationsInput | string\n    business_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_sellerUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    business_name?: StringFieldUpdateOperationsInput | string\n    business_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_sellerCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    business_name: string\n    business_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_sellerUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    business_name?: StringFieldUpdateOperationsInput | string\n    business_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_sellerUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    business_name?: StringFieldUpdateOperationsInput | string\n    business_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_adminCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesCreateNestedManyWithoutAdminInput\n  }\n\n  export type shopping_mall_adminUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedCreateNestedManyWithoutAdminInput\n  }\n\n  export type shopping_mall_adminUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUpdateManyWithoutAdminNestedInput\n  }\n\n  export type shopping_mall_adminUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedUpdateManyWithoutAdminNestedInput\n  }\n\n  export type shopping_mall_adminCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_adminUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_adminUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_salesCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_salesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_salesInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUncheckedCreateInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_salesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_salesNestedInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesCreateManyInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_salesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_salesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_snapshotsCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    sale: shopping_salesCreateNestedOneWithoutShopping_sale_snapshotsInput\n  }\n\n  export type shopping_sale_snapshotsUncheckedCreateInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n  }\n\n  export type shopping_sale_snapshotsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    sale?: shopping_salesUpdateOneRequiredWithoutShopping_sale_snapshotsNestedInput\n  }\n\n  export type shopping_sale_snapshotsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_snapshotsCreateManyInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n  }\n\n  export type shopping_sale_snapshotsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_snapshotsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_unitsCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sale: shopping_salesCreateNestedOneWithoutShopping_sale_unitsInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUncheckedCreateInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sale?: shopping_salesUpdateOneRequiredWithoutShopping_sale_unitsNestedInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsCreateManyInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_unitsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsCreateInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    saleUnit: shopping_sale_unitsCreateNestedOneWithoutShopping_sale_unit_optionsInput\n  }\n\n  export type shopping_sale_unit_optionsUncheckedCreateInput = {\n    id: string\n    shopping_sale_unit_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    saleUnit?: shopping_sale_unitsUpdateOneRequiredWithoutShopping_sale_unit_optionsNestedInput\n  }\n\n  export type shopping_sale_unit_optionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsCreateManyInput = {\n    id: string\n    shopping_sale_unit_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_cartsCreateInput = {\n    id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_cartsInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_cartsUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_cartsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_cartsNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_cartsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_cartsCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cartsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cartsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    cart: shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput\n    saleUnit: shopping_sale_unitsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateInput = {\n    id: string\n    shopping_cart_id: string\n    shopping_sale_unit_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    cart?: shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n    saleUnit?: shopping_sale_unitsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateManyInput = {\n    id: string\n    shopping_cart_id: string\n    shopping_sale_unit_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_ordersCreateInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_snapshots?: shopping_order_snapshotsCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_snapshots?: shopping_order_snapshotsUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_ordersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_ordersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_order_snapshotsCreateInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_snapshotsInput\n  }\n\n  export type shopping_order_snapshotsUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n  }\n\n  export type shopping_order_snapshotsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_snapshotsNestedInput\n  }\n\n  export type shopping_order_snapshotsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_snapshotsCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n  }\n\n  export type shopping_order_snapshotsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_snapshotsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsCreateInput = {\n    id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_itemsInput\n  }\n\n  export type shopping_order_itemsUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_itemsNestedInput\n  }\n\n  export type shopping_order_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_couponsCreateInput = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date | string\n    valid_until: Date | string\n    max_uses?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutCouponInput\n  }\n\n  export type shopping_couponsUncheckedCreateInput = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date | string\n    valid_until: Date | string\n    max_uses?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutCouponInput\n  }\n\n  export type shopping_couponsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutCouponNestedInput\n  }\n\n  export type shopping_couponsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutCouponNestedInput\n  }\n\n  export type shopping_couponsCreateManyInput = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date | string\n    valid_until: Date | string\n    max_uses?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_couponsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_couponsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageCreateInput = {\n    id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    coupon: shopping_couponsCreateNestedOneWithoutShopping_coupon_usageInput\n    user: shopping_mall_memberCreateNestedOneWithoutShopping_coupon_usageInput\n  }\n\n  export type shopping_coupon_usageUncheckedCreateInput = {\n    id: string\n    shopping_coupon_id: string\n    shopping_mall_member_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coupon_usageUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    coupon?: shopping_couponsUpdateOneRequiredWithoutShopping_coupon_usageNestedInput\n    user?: shopping_mall_memberUpdateOneRequiredWithoutShopping_coupon_usageNestedInput\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_coupon_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageCreateManyInput = {\n    id: string\n    shopping_coupon_id: string\n    shopping_mall_member_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coupon_usageUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_coupon_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coinsCreateInput = {\n    id: string\n    balance: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_coinsInput\n  }\n\n  export type shopping_coinsUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    balance: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_coinsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_coinsNestedInput\n  }\n\n  export type shopping_coinsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coinsCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    balance: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_coinsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coinsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coin_transactionsCreateInput = {\n    id: string\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_coin_transactionsInput\n    order?: shopping_ordersCreateNestedOneWithoutShopping_coin_transactionsInput\n  }\n\n  export type shopping_coin_transactionsUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    shopping_order_id?: string | null\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_coin_transactionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_coin_transactionsNestedInput\n    order?: shopping_ordersUpdateOneWithoutShopping_coin_transactionsNestedInput\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: NullableStringFieldUpdateOperationsInput | string | null\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    shopping_order_id?: string | null\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_coin_transactionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: NullableStringFieldUpdateOperationsInput | string | null\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_inquiriesCreateInput = {\n    id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_mall_memberCreateNestedOneWithoutShopping_inquiriesInput\n    shopping_inquiry_responses?: shopping_inquiry_responsesCreateNestedManyWithoutInquiryInput\n  }\n\n  export type shopping_inquiriesUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedCreateNestedManyWithoutInquiryInput\n  }\n\n  export type shopping_inquiriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_mall_memberUpdateOneRequiredWithoutShopping_inquiriesNestedInput\n    shopping_inquiry_responses?: shopping_inquiry_responsesUpdateManyWithoutInquiryNestedInput\n  }\n\n  export type shopping_inquiriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedUpdateManyWithoutInquiryNestedInput\n  }\n\n  export type shopping_inquiriesCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    inquiry: shopping_inquiriesCreateNestedOneWithoutShopping_inquiry_responsesInput\n    admin: shopping_mall_adminCreateNestedOneWithoutShopping_inquiry_responsesInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedCreateInput = {\n    id: string\n    shopping_inquiry_id: string\n    shopping_mall_admin_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    inquiry?: shopping_inquiriesUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput\n    admin?: shopping_mall_adminUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_inquiry_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_admin_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateManyInput = {\n    id: string\n    shopping_inquiry_id: string\n    shopping_mall_admin_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_inquiry_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_admin_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_favoritesCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_favoritesInput\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutFavoriteInput\n  }\n\n  export type shopping_favoritesUncheckedCreateInput = {\n    id: string\n    shopping_mall_member_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutFavoriteInput\n  }\n\n  export type shopping_favoritesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_favoritesNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutFavoriteNestedInput\n  }\n\n  export type shopping_favoritesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutFavoriteNestedInput\n  }\n\n  export type shopping_favoritesCreateManyInput = {\n    id: string\n    shopping_mall_member_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_favoritesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_favoritesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_favorite_itemsCreateInput = {\n    id: string\n    created_at: Date | string\n    favorite: shopping_favoritesCreateNestedOneWithoutShopping_favorite_itemsInput\n    saleUnit: shopping_sale_unitsCreateNestedOneWithoutShopping_favorite_itemsInput\n  }\n\n  export type shopping_favorite_itemsUncheckedCreateInput = {\n    id: string\n    shopping_favorite_id: string\n    shopping_sale_unit_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_favorite_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    favorite?: shopping_favoritesUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput\n    saleUnit?: shopping_sale_unitsUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_favorite_id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_favorite_itemsCreateManyInput = {\n    id: string\n    shopping_favorite_id: string\n    shopping_sale_unit_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_favorite_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_favorite_id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_articlesCreateInput = {\n    id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_articlesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_articlesInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesUncheckedCreateInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_articlesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_articlesNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesCreateManyInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_articlesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_articlesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsCreateInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    article: shopping_articlesCreateNestedOneWithoutShopping_article_commentsInput\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_article_commentsInput\n  }\n\n  export type shopping_article_commentsUncheckedCreateInput = {\n    id: string\n    shopping_article_id: string\n    shopping_mall_member_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    article?: shopping_articlesUpdateOneRequiredWithoutShopping_article_commentsNestedInput\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_article_commentsNestedInput\n  }\n\n  export type shopping_article_commentsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_article_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsCreateManyInput = {\n    id: string\n    shopping_article_id: string\n    shopping_mall_member_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_article_id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type Shopping_sectionsListRelationFilter = {\n    every?: shopping_sectionsWhereInput\n    some?: shopping_sectionsWhereInput\n    none?: shopping_sectionsWhereInput\n  }\n\n  export type Shopping_configurationsListRelationFilter = {\n    every?: shopping_configurationsWhereInput\n    some?: shopping_configurationsWhereInput\n    none?: shopping_configurationsWhereInput\n  }\n\n  export type Shopping_salesListRelationFilter = {\n    every?: shopping_salesWhereInput\n    some?: shopping_salesWhereInput\n    none?: shopping_salesWhereInput\n  }\n\n  export type Shopping_articlesListRelationFilter = {\n    every?: shopping_articlesWhereInput\n    some?: shopping_articlesWhereInput\n    none?: shopping_articlesWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type shopping_sectionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_configurationsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_salesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_articlesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_channelsCountOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channelsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channelsMinOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type Shopping_channelsScalarRelationFilter = {\n    is?: shopping_channelsWhereInput\n    isNot?: shopping_channelsWhereInput\n  }\n\n  export type shopping_sectionsShopping_channel_idCodeCompoundUniqueInput = {\n    shopping_channel_id: string\n    code: string\n  }\n\n  export type shopping_sectionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sectionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sectionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type Shopping_channelsNullableScalarRelationFilter = {\n    is?: shopping_channelsWhereInput | null\n    isNot?: shopping_channelsWhereInput | null\n  }\n\n  export type Shopping_sectionsNullableScalarRelationFilter = {\n    is?: shopping_sectionsWhereInput | null\n    isNot?: shopping_sectionsWhereInput | null\n  }\n\n  export type shopping_configurationsShopping_channel_idKeyCompoundUniqueInput = {\n    shopping_channel_id: string\n    key: string\n  }\n\n  export type shopping_configurationsShopping_section_idKeyCompoundUniqueInput = {\n    shopping_section_id: string\n    key: string\n  }\n\n  export type shopping_configurationsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_configurationsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_configurationsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type shopping_mall_guestCountOrderByAggregateInput = {\n    id?: SortOrder\n    session_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_mall_guestMaxOrderByAggregateInput = {\n    id?: SortOrder\n    session_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_mall_guestMinOrderByAggregateInput = {\n    id?: SortOrder\n    session_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type Shopping_cartsListRelationFilter = {\n    every?: shopping_cartsWhereInput\n    some?: shopping_cartsWhereInput\n    none?: shopping_cartsWhereInput\n  }\n\n  export type Shopping_ordersListRelationFilter = {\n    every?: shopping_ordersWhereInput\n    some?: shopping_ordersWhereInput\n    none?: shopping_ordersWhereInput\n  }\n\n  export type Shopping_coupon_usageListRelationFilter = {\n    every?: shopping_coupon_usageWhereInput\n    some?: shopping_coupon_usageWhereInput\n    none?: shopping_coupon_usageWhereInput\n  }\n\n  export type Shopping_coinsNullableScalarRelationFilter = {\n    is?: shopping_coinsWhereInput | null\n    isNot?: shopping_coinsWhereInput | null\n  }\n\n  export type Shopping_coin_transactionsListRelationFilter = {\n    every?: shopping_coin_transactionsWhereInput\n    some?: shopping_coin_transactionsWhereInput\n    none?: shopping_coin_transactionsWhereInput\n  }\n\n  export type Shopping_inquiriesListRelationFilter = {\n    every?: shopping_inquiriesWhereInput\n    some?: shopping_inquiriesWhereInput\n    none?: shopping_inquiriesWhereInput\n  }\n\n  export type Shopping_favoritesListRelationFilter = {\n    every?: shopping_favoritesWhereInput\n    some?: shopping_favoritesWhereInput\n    none?: shopping_favoritesWhereInput\n  }\n\n  export type Shopping_article_commentsListRelationFilter = {\n    every?: shopping_article_commentsWhereInput\n    some?: shopping_article_commentsWhereInput\n    none?: shopping_article_commentsWhereInput\n  }\n\n  export type shopping_cartsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_ordersOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_coupon_usageOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_coin_transactionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_inquiriesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_favoritesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_article_commentsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_mall_memberCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_memberMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_memberMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_sellerCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    business_name?: SortOrder\n    business_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_sellerMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    business_name?: SortOrder\n    business_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_sellerMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    business_name?: SortOrder\n    business_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_inquiry_responsesListRelationFilter = {\n    every?: shopping_inquiry_responsesWhereInput\n    some?: shopping_inquiry_responsesWhereInput\n    none?: shopping_inquiry_responsesWhereInput\n  }\n\n  export type shopping_inquiry_responsesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_mall_adminCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_adminMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_mall_adminMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type FloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type IntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type Shopping_sectionsScalarRelationFilter = {\n    is?: shopping_sectionsWhereInput\n    isNot?: shopping_sectionsWhereInput\n  }\n\n  export type Shopping_sale_snapshotsListRelationFilter = {\n    every?: shopping_sale_snapshotsWhereInput\n    some?: shopping_sale_snapshotsWhereInput\n    none?: shopping_sale_snapshotsWhereInput\n  }\n\n  export type Shopping_sale_unitsListRelationFilter = {\n    every?: shopping_sale_unitsWhereInput\n    some?: shopping_sale_unitsWhereInput\n    none?: shopping_sale_unitsWhereInput\n  }\n\n  export type shopping_sale_snapshotsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_sale_unitsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_salesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_salesAvgOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type shopping_salesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_salesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_salesSumOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type FloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type IntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type Shopping_salesScalarRelationFilter = {\n    is?: shopping_salesWhereInput\n    isNot?: shopping_salesWhereInput\n  }\n\n  export type shopping_sale_snapshotsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_sale_snapshotsAvgOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type shopping_sale_snapshotsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_sale_snapshotsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_sale_snapshotsSumOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type Shopping_sale_unit_optionsListRelationFilter = {\n    every?: shopping_sale_unit_optionsWhereInput\n    some?: shopping_sale_unit_optionsWhereInput\n    none?: shopping_sale_unit_optionsWhereInput\n  }\n\n  export type Shopping_cart_itemsListRelationFilter = {\n    every?: shopping_cart_itemsWhereInput\n    some?: shopping_cart_itemsWhereInput\n    none?: shopping_cart_itemsWhereInput\n  }\n\n  export type Shopping_favorite_itemsListRelationFilter = {\n    every?: shopping_favorite_itemsWhereInput\n    some?: shopping_favorite_itemsWhereInput\n    none?: shopping_favorite_itemsWhereInput\n  }\n\n  export type shopping_sale_unit_optionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_cart_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_favorite_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_sale_unitsShopping_sale_idCodeCompoundUniqueInput = {\n    shopping_sale_id: string\n    code: string\n  }\n\n  export type shopping_sale_unitsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unitsAvgOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type shopping_sale_unitsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unitsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    stock?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unitsSumOrderByAggregateInput = {\n    price?: SortOrder\n    stock?: SortOrder\n  }\n\n  export type Shopping_sale_unitsScalarRelationFilter = {\n    is?: shopping_sale_unitsWhereInput\n    isNot?: shopping_sale_unitsWhereInput\n  }\n\n  export type shopping_sale_unit_optionsShopping_sale_unit_idCodeCompoundUniqueInput = {\n    shopping_sale_unit_id: string\n    code: string\n  }\n\n  export type shopping_sale_unit_optionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unit_optionsAvgOrderByAggregateInput = {\n    price?: SortOrder\n  }\n\n  export type shopping_sale_unit_optionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unit_optionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    code?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sale_unit_optionsSumOrderByAggregateInput = {\n    price?: SortOrder\n  }\n\n  export type Shopping_mall_memberScalarRelationFilter = {\n    is?: shopping_mall_memberWhereInput\n    isNot?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_cartsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cartsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cartsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type Shopping_cartsScalarRelationFilter = {\n    is?: shopping_cartsWhereInput\n    isNot?: shopping_cartsWhereInput\n  }\n\n  export type shopping_cart_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_cart_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsAvgOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type shopping_cart_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_cart_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_cart_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsSumOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type Shopping_order_snapshotsListRelationFilter = {\n    every?: shopping_order_snapshotsWhereInput\n    some?: shopping_order_snapshotsWhereInput\n    none?: shopping_order_snapshotsWhereInput\n  }\n\n  export type Shopping_order_itemsListRelationFilter = {\n    every?: shopping_order_itemsWhereInput\n    some?: shopping_order_itemsWhereInput\n    none?: shopping_order_itemsWhereInput\n  }\n\n  export type shopping_order_snapshotsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_order_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_ordersCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersAvgOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type shopping_ordersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersSumOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type Shopping_ordersScalarRelationFilter = {\n    is?: shopping_ordersWhereInput\n    isNot?: shopping_ordersWhereInput\n  }\n\n  export type shopping_order_snapshotsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_order_snapshotsAvgOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type shopping_order_snapshotsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_order_snapshotsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    code?: SortOrder\n    status?: SortOrder\n    total_amount?: SortOrder\n    shipping_address?: SortOrder\n    payment_method?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_order_snapshotsSumOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type shopping_order_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    product_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsAvgOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type shopping_order_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    product_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    product_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsSumOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type IntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type shopping_couponsCountOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    discount_type?: SortOrder\n    value?: SortOrder\n    valid_from?: SortOrder\n    valid_until?: SortOrder\n    max_uses?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_couponsAvgOrderByAggregateInput = {\n    value?: SortOrder\n    max_uses?: SortOrder\n  }\n\n  export type shopping_couponsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    discount_type?: SortOrder\n    value?: SortOrder\n    valid_from?: SortOrder\n    valid_until?: SortOrder\n    max_uses?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_couponsMinOrderByAggregateInput = {\n    id?: SortOrder\n    code?: SortOrder\n    discount_type?: SortOrder\n    value?: SortOrder\n    valid_from?: SortOrder\n    valid_until?: SortOrder\n    max_uses?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_couponsSumOrderByAggregateInput = {\n    value?: SortOrder\n    max_uses?: SortOrder\n  }\n\n  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type Shopping_couponsScalarRelationFilter = {\n    is?: shopping_couponsWhereInput\n    isNot?: shopping_couponsWhereInput\n  }\n\n  export type shopping_coupon_usageCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_coupon_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    order_id?: SortOrder\n    used_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_coupon_usageMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_coupon_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    order_id?: SortOrder\n    used_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_coupon_usageMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_coupon_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    order_id?: SortOrder\n    used_at?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_coinsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    balance?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_coinsAvgOrderByAggregateInput = {\n    balance?: SortOrder\n  }\n\n  export type shopping_coinsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    balance?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_coinsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    balance?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_coinsSumOrderByAggregateInput = {\n    balance?: SortOrder\n  }\n\n  export type Shopping_ordersNullableScalarRelationFilter = {\n    is?: shopping_ordersWhereInput | null\n    isNot?: shopping_ordersWhereInput | null\n  }\n\n  export type shopping_coin_transactionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    shopping_order_id?: SortOrder\n    amount?: SortOrder\n    transaction_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_coin_transactionsAvgOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type shopping_coin_transactionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    shopping_order_id?: SortOrder\n    amount?: SortOrder\n    transaction_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_coin_transactionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    shopping_order_id?: SortOrder\n    amount?: SortOrder\n    transaction_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_coin_transactionsSumOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type shopping_inquiriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_inquiriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_inquiriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_inquiriesScalarRelationFilter = {\n    is?: shopping_inquiriesWhereInput\n    isNot?: shopping_inquiriesWhereInput\n  }\n\n  export type Shopping_mall_adminScalarRelationFilter = {\n    is?: shopping_mall_adminWhereInput\n    isNot?: shopping_mall_adminWhereInput\n  }\n\n  export type shopping_inquiry_responsesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_inquiry_id?: SortOrder\n    shopping_mall_admin_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_inquiry_responsesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_inquiry_id?: SortOrder\n    shopping_mall_admin_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_inquiry_responsesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_inquiry_id?: SortOrder\n    shopping_mall_admin_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_favoritesShopping_mall_member_idNameCompoundUniqueInput = {\n    shopping_mall_member_id: string\n    name: string\n  }\n\n  export type shopping_favoritesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_favoritesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_favoritesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_favoritesScalarRelationFilter = {\n    is?: shopping_favoritesWhereInput\n    isNot?: shopping_favoritesWhereInput\n  }\n\n  export type shopping_favorite_itemsShopping_favorite_idShopping_sale_unit_idCompoundUniqueInput = {\n    shopping_favorite_id: string\n    shopping_sale_unit_id: string\n  }\n\n  export type shopping_favorite_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_favorite_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_favorite_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_favorite_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_favorite_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_favorite_id?: SortOrder\n    shopping_sale_unit_id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_articlesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_articlesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_articlesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    code?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_articlesScalarRelationFilter = {\n    is?: shopping_articlesWhereInput\n    isNot?: shopping_articlesWhereInput\n  }\n\n  export type shopping_article_commentsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_article_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_article_commentsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_article_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_article_commentsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_article_id?: SortOrder\n    shopping_mall_member_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sectionsCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n  }\n\n  export type shopping_configurationsCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput> | shopping_configurationsCreateWithoutChannelInput[] | shopping_configurationsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutChannelInput | shopping_configurationsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_configurationsCreateManyChannelInputEnvelope\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n  }\n\n  export type shopping_salesCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput> | shopping_salesCreateWithoutChannelInput[] | shopping_salesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutChannelInput | shopping_salesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_salesCreateManyChannelInputEnvelope\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n  }\n\n  export type shopping_articlesCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput> | shopping_articlesCreateWithoutChannelInput[] | shopping_articlesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutChannelInput | shopping_articlesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_articlesCreateManyChannelInputEnvelope\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n  }\n\n  export type shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n  }\n\n  export type shopping_configurationsUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput> | shopping_configurationsCreateWithoutChannelInput[] | shopping_configurationsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutChannelInput | shopping_configurationsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_configurationsCreateManyChannelInputEnvelope\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n  }\n\n  export type shopping_salesUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput> | shopping_salesCreateWithoutChannelInput[] | shopping_salesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutChannelInput | shopping_salesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_salesCreateManyChannelInputEnvelope\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n  }\n\n  export type shopping_articlesUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput> | shopping_articlesCreateWithoutChannelInput[] | shopping_articlesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutChannelInput | shopping_articlesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_articlesCreateManyChannelInputEnvelope\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput | shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    set?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    disconnect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    delete?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    update?: shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput | shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_sectionsUpdateManyWithWhereWithoutChannelInput | shopping_sectionsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n  }\n\n  export type shopping_configurationsUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput> | shopping_configurationsCreateWithoutChannelInput[] | shopping_configurationsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutChannelInput | shopping_configurationsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_configurationsUpsertWithWhereUniqueWithoutChannelInput | shopping_configurationsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_configurationsCreateManyChannelInputEnvelope\n    set?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    disconnect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    delete?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    update?: shopping_configurationsUpdateWithWhereUniqueWithoutChannelInput | shopping_configurationsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_configurationsUpdateManyWithWhereWithoutChannelInput | shopping_configurationsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n  }\n\n  export type shopping_salesUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput> | shopping_salesCreateWithoutChannelInput[] | shopping_salesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutChannelInput | shopping_salesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_salesUpsertWithWhereUniqueWithoutChannelInput | shopping_salesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_salesCreateManyChannelInputEnvelope\n    set?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    disconnect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    delete?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    update?: shopping_salesUpdateWithWhereUniqueWithoutChannelInput | shopping_salesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_salesUpdateManyWithWhereWithoutChannelInput | shopping_salesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n  }\n\n  export type shopping_articlesUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput> | shopping_articlesCreateWithoutChannelInput[] | shopping_articlesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutChannelInput | shopping_articlesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_articlesUpsertWithWhereUniqueWithoutChannelInput | shopping_articlesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_articlesCreateManyChannelInputEnvelope\n    set?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    disconnect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    delete?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    update?: shopping_articlesUpdateWithWhereUniqueWithoutChannelInput | shopping_articlesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_articlesUpdateManyWithWhereWithoutChannelInput | shopping_articlesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput | shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    set?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    disconnect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    delete?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    update?: shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput | shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_sectionsUpdateManyWithWhereWithoutChannelInput | shopping_sectionsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n  }\n\n  export type shopping_configurationsUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput> | shopping_configurationsCreateWithoutChannelInput[] | shopping_configurationsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutChannelInput | shopping_configurationsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_configurationsUpsertWithWhereUniqueWithoutChannelInput | shopping_configurationsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_configurationsCreateManyChannelInputEnvelope\n    set?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    disconnect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    delete?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    update?: shopping_configurationsUpdateWithWhereUniqueWithoutChannelInput | shopping_configurationsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_configurationsUpdateManyWithWhereWithoutChannelInput | shopping_configurationsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n  }\n\n  export type shopping_salesUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput> | shopping_salesCreateWithoutChannelInput[] | shopping_salesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutChannelInput | shopping_salesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_salesUpsertWithWhereUniqueWithoutChannelInput | shopping_salesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_salesCreateManyChannelInputEnvelope\n    set?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    disconnect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    delete?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    update?: shopping_salesUpdateWithWhereUniqueWithoutChannelInput | shopping_salesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_salesUpdateManyWithWhereWithoutChannelInput | shopping_salesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n  }\n\n  export type shopping_articlesUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput> | shopping_articlesCreateWithoutChannelInput[] | shopping_articlesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutChannelInput | shopping_articlesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_articlesUpsertWithWhereUniqueWithoutChannelInput | shopping_articlesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_articlesCreateManyChannelInputEnvelope\n    set?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    disconnect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    delete?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    update?: shopping_articlesUpdateWithWhereUniqueWithoutChannelInput | shopping_articlesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_articlesUpdateManyWithWhereWithoutChannelInput | shopping_articlesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_sectionsInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_sectionsInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_configurationsCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput> | shopping_configurationsCreateWithoutSectionInput[] | shopping_configurationsUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutSectionInput | shopping_configurationsCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_configurationsCreateManySectionInputEnvelope\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n  }\n\n  export type shopping_salesCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput> | shopping_salesCreateWithoutSectionInput[] | shopping_salesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutSectionInput | shopping_salesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_salesCreateManySectionInputEnvelope\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n  }\n\n  export type shopping_articlesCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput> | shopping_articlesCreateWithoutSectionInput[] | shopping_articlesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutSectionInput | shopping_articlesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_articlesCreateManySectionInputEnvelope\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n  }\n\n  export type shopping_configurationsUncheckedCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput> | shopping_configurationsCreateWithoutSectionInput[] | shopping_configurationsUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutSectionInput | shopping_configurationsCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_configurationsCreateManySectionInputEnvelope\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n  }\n\n  export type shopping_salesUncheckedCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput> | shopping_salesCreateWithoutSectionInput[] | shopping_salesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutSectionInput | shopping_salesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_salesCreateManySectionInputEnvelope\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n  }\n\n  export type shopping_articlesUncheckedCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput> | shopping_articlesCreateWithoutSectionInput[] | shopping_articlesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutSectionInput | shopping_articlesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_articlesCreateManySectionInputEnvelope\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n  }\n\n  export type shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_sectionsInput\n    upsert?: shopping_channelsUpsertWithoutShopping_sectionsInput\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_sectionsInput, shopping_channelsUpdateWithoutShopping_sectionsInput>, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_configurationsUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput> | shopping_configurationsCreateWithoutSectionInput[] | shopping_configurationsUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutSectionInput | shopping_configurationsCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_configurationsUpsertWithWhereUniqueWithoutSectionInput | shopping_configurationsUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_configurationsCreateManySectionInputEnvelope\n    set?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    disconnect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    delete?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    update?: shopping_configurationsUpdateWithWhereUniqueWithoutSectionInput | shopping_configurationsUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_configurationsUpdateManyWithWhereWithoutSectionInput | shopping_configurationsUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n  }\n\n  export type shopping_salesUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput> | shopping_salesCreateWithoutSectionInput[] | shopping_salesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutSectionInput | shopping_salesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_salesUpsertWithWhereUniqueWithoutSectionInput | shopping_salesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_salesCreateManySectionInputEnvelope\n    set?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    disconnect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    delete?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    update?: shopping_salesUpdateWithWhereUniqueWithoutSectionInput | shopping_salesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_salesUpdateManyWithWhereWithoutSectionInput | shopping_salesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n  }\n\n  export type shopping_articlesUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput> | shopping_articlesCreateWithoutSectionInput[] | shopping_articlesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutSectionInput | shopping_articlesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_articlesUpsertWithWhereUniqueWithoutSectionInput | shopping_articlesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_articlesCreateManySectionInputEnvelope\n    set?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    disconnect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    delete?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    update?: shopping_articlesUpdateWithWhereUniqueWithoutSectionInput | shopping_articlesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_articlesUpdateManyWithWhereWithoutSectionInput | shopping_articlesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n  }\n\n  export type shopping_configurationsUncheckedUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput> | shopping_configurationsCreateWithoutSectionInput[] | shopping_configurationsUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_configurationsCreateOrConnectWithoutSectionInput | shopping_configurationsCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_configurationsUpsertWithWhereUniqueWithoutSectionInput | shopping_configurationsUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_configurationsCreateManySectionInputEnvelope\n    set?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    disconnect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    delete?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    connect?: shopping_configurationsWhereUniqueInput | shopping_configurationsWhereUniqueInput[]\n    update?: shopping_configurationsUpdateWithWhereUniqueWithoutSectionInput | shopping_configurationsUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_configurationsUpdateManyWithWhereWithoutSectionInput | shopping_configurationsUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n  }\n\n  export type shopping_salesUncheckedUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput> | shopping_salesCreateWithoutSectionInput[] | shopping_salesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutSectionInput | shopping_salesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_salesUpsertWithWhereUniqueWithoutSectionInput | shopping_salesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_salesCreateManySectionInputEnvelope\n    set?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    disconnect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    delete?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    connect?: shopping_salesWhereUniqueInput | shopping_salesWhereUniqueInput[]\n    update?: shopping_salesUpdateWithWhereUniqueWithoutSectionInput | shopping_salesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_salesUpdateManyWithWhereWithoutSectionInput | shopping_salesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n  }\n\n  export type shopping_articlesUncheckedUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput> | shopping_articlesCreateWithoutSectionInput[] | shopping_articlesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutSectionInput | shopping_articlesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_articlesUpsertWithWhereUniqueWithoutSectionInput | shopping_articlesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_articlesCreateManySectionInputEnvelope\n    set?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    disconnect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    delete?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    connect?: shopping_articlesWhereUniqueInput | shopping_articlesWhereUniqueInput[]\n    update?: shopping_articlesUpdateWithWhereUniqueWithoutSectionInput | shopping_articlesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_articlesUpdateManyWithWhereWithoutSectionInput | shopping_articlesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_configurationsInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_configurationsInput, shopping_channelsUncheckedCreateWithoutShopping_configurationsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_configurationsInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_sectionsCreateNestedOneWithoutShopping_configurationsInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_configurationsInput, shopping_sectionsUncheckedCreateWithoutShopping_configurationsInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_configurationsInput\n    connect?: shopping_sectionsWhereUniqueInput\n  }\n\n  export type shopping_channelsUpdateOneWithoutShopping_configurationsNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_configurationsInput, shopping_channelsUncheckedCreateWithoutShopping_configurationsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_configurationsInput\n    upsert?: shopping_channelsUpsertWithoutShopping_configurationsInput\n    disconnect?: shopping_channelsWhereInput | boolean\n    delete?: shopping_channelsWhereInput | boolean\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_configurationsInput, shopping_channelsUpdateWithoutShopping_configurationsInput>, shopping_channelsUncheckedUpdateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_sectionsUpdateOneWithoutShopping_configurationsNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_configurationsInput, shopping_sectionsUncheckedCreateWithoutShopping_configurationsInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_configurationsInput\n    upsert?: shopping_sectionsUpsertWithoutShopping_configurationsInput\n    disconnect?: shopping_sectionsWhereInput | boolean\n    delete?: shopping_sectionsWhereInput | boolean\n    connect?: shopping_sectionsWhereUniqueInput\n    update?: XOR<XOR<shopping_sectionsUpdateToOneWithWhereWithoutShopping_configurationsInput, shopping_sectionsUpdateWithoutShopping_configurationsInput>, shopping_sectionsUncheckedUpdateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_cartsCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput> | shopping_cartsCreateWithoutMemberInput[] | shopping_cartsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutMemberInput | shopping_cartsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_cartsCreateManyMemberInputEnvelope\n    connect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n  }\n\n  export type shopping_ordersCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput> | shopping_ordersCreateWithoutMemberInput[] | shopping_ordersUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutMemberInput | shopping_ordersCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_ordersCreateManyMemberInputEnvelope\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_coupon_usageCreateNestedManyWithoutUserInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput> | shopping_coupon_usageCreateWithoutUserInput[] | shopping_coupon_usageUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutUserInput | shopping_coupon_usageCreateOrConnectWithoutUserInput[]\n    createMany?: shopping_coupon_usageCreateManyUserInputEnvelope\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n  }\n\n  export type shopping_coinsCreateNestedOneWithoutMemberInput = {\n    create?: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n    connectOrCreate?: shopping_coinsCreateOrConnectWithoutMemberInput\n    connect?: shopping_coinsWhereUniqueInput\n  }\n\n  export type shopping_coin_transactionsCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput> | shopping_coin_transactionsCreateWithoutMemberInput[] | shopping_coin_transactionsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutMemberInput | shopping_coin_transactionsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_coin_transactionsCreateManyMemberInputEnvelope\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_inquiriesCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput> | shopping_inquiriesCreateWithoutCustomerInput[] | shopping_inquiriesUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutCustomerInput | shopping_inquiriesCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_inquiriesCreateManyCustomerInputEnvelope\n    connect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n  }\n\n  export type shopping_favoritesCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput> | shopping_favoritesCreateWithoutMemberInput[] | shopping_favoritesUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutMemberInput | shopping_favoritesCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_favoritesCreateManyMemberInputEnvelope\n    connect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n  }\n\n  export type shopping_article_commentsCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput> | shopping_article_commentsCreateWithoutMemberInput[] | shopping_article_commentsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutMemberInput | shopping_article_commentsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_article_commentsCreateManyMemberInputEnvelope\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n  }\n\n  export type shopping_cartsUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput> | shopping_cartsCreateWithoutMemberInput[] | shopping_cartsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutMemberInput | shopping_cartsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_cartsCreateManyMemberInputEnvelope\n    connect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n  }\n\n  export type shopping_ordersUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput> | shopping_ordersCreateWithoutMemberInput[] | shopping_ordersUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutMemberInput | shopping_ordersCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_ordersCreateManyMemberInputEnvelope\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput> | shopping_coupon_usageCreateWithoutUserInput[] | shopping_coupon_usageUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutUserInput | shopping_coupon_usageCreateOrConnectWithoutUserInput[]\n    createMany?: shopping_coupon_usageCreateManyUserInputEnvelope\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n  }\n\n  export type shopping_coinsUncheckedCreateNestedOneWithoutMemberInput = {\n    create?: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n    connectOrCreate?: shopping_coinsCreateOrConnectWithoutMemberInput\n    connect?: shopping_coinsWhereUniqueInput\n  }\n\n  export type shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput> | shopping_coin_transactionsCreateWithoutMemberInput[] | shopping_coin_transactionsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutMemberInput | shopping_coin_transactionsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_coin_transactionsCreateManyMemberInputEnvelope\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput> | shopping_inquiriesCreateWithoutCustomerInput[] | shopping_inquiriesUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutCustomerInput | shopping_inquiriesCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_inquiriesCreateManyCustomerInputEnvelope\n    connect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n  }\n\n  export type shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput> | shopping_favoritesCreateWithoutMemberInput[] | shopping_favoritesUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutMemberInput | shopping_favoritesCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_favoritesCreateManyMemberInputEnvelope\n    connect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n  }\n\n  export type shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput> | shopping_article_commentsCreateWithoutMemberInput[] | shopping_article_commentsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutMemberInput | shopping_article_commentsCreateOrConnectWithoutMemberInput[]\n    createMany?: shopping_article_commentsCreateManyMemberInputEnvelope\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n  }\n\n  export type shopping_cartsUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput> | shopping_cartsCreateWithoutMemberInput[] | shopping_cartsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutMemberInput | shopping_cartsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_cartsUpsertWithWhereUniqueWithoutMemberInput | shopping_cartsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_cartsCreateManyMemberInputEnvelope\n    set?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    disconnect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    delete?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    connect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    update?: shopping_cartsUpdateWithWhereUniqueWithoutMemberInput | shopping_cartsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_cartsUpdateManyWithWhereWithoutMemberInput | shopping_cartsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_cartsScalarWhereInput | shopping_cartsScalarWhereInput[]\n  }\n\n  export type shopping_ordersUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput> | shopping_ordersCreateWithoutMemberInput[] | shopping_ordersUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutMemberInput | shopping_ordersCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_ordersUpsertWithWhereUniqueWithoutMemberInput | shopping_ordersUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_ordersCreateManyMemberInputEnvelope\n    set?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    disconnect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    delete?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    update?: shopping_ordersUpdateWithWhereUniqueWithoutMemberInput | shopping_ordersUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_ordersUpdateManyWithWhereWithoutMemberInput | shopping_ordersUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n  }\n\n  export type shopping_coupon_usageUpdateManyWithoutUserNestedInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput> | shopping_coupon_usageCreateWithoutUserInput[] | shopping_coupon_usageUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutUserInput | shopping_coupon_usageCreateOrConnectWithoutUserInput[]\n    upsert?: shopping_coupon_usageUpsertWithWhereUniqueWithoutUserInput | shopping_coupon_usageUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: shopping_coupon_usageCreateManyUserInputEnvelope\n    set?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    disconnect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    delete?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    update?: shopping_coupon_usageUpdateWithWhereUniqueWithoutUserInput | shopping_coupon_usageUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: shopping_coupon_usageUpdateManyWithWhereWithoutUserInput | shopping_coupon_usageUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n  }\n\n  export type shopping_coinsUpdateOneWithoutMemberNestedInput = {\n    create?: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n    connectOrCreate?: shopping_coinsCreateOrConnectWithoutMemberInput\n    upsert?: shopping_coinsUpsertWithoutMemberInput\n    disconnect?: shopping_coinsWhereInput | boolean\n    delete?: shopping_coinsWhereInput | boolean\n    connect?: shopping_coinsWhereUniqueInput\n    update?: XOR<XOR<shopping_coinsUpdateToOneWithWhereWithoutMemberInput, shopping_coinsUpdateWithoutMemberInput>, shopping_coinsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput> | shopping_coin_transactionsCreateWithoutMemberInput[] | shopping_coin_transactionsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutMemberInput | shopping_coin_transactionsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_coin_transactionsUpsertWithWhereUniqueWithoutMemberInput | shopping_coin_transactionsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_coin_transactionsCreateManyMemberInputEnvelope\n    set?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    disconnect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    delete?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    update?: shopping_coin_transactionsUpdateWithWhereUniqueWithoutMemberInput | shopping_coin_transactionsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_coin_transactionsUpdateManyWithWhereWithoutMemberInput | shopping_coin_transactionsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n  }\n\n  export type shopping_inquiriesUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput> | shopping_inquiriesCreateWithoutCustomerInput[] | shopping_inquiriesUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutCustomerInput | shopping_inquiriesCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_inquiriesUpsertWithWhereUniqueWithoutCustomerInput | shopping_inquiriesUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_inquiriesCreateManyCustomerInputEnvelope\n    set?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    disconnect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    delete?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    connect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    update?: shopping_inquiriesUpdateWithWhereUniqueWithoutCustomerInput | shopping_inquiriesUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_inquiriesUpdateManyWithWhereWithoutCustomerInput | shopping_inquiriesUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_inquiriesScalarWhereInput | shopping_inquiriesScalarWhereInput[]\n  }\n\n  export type shopping_favoritesUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput> | shopping_favoritesCreateWithoutMemberInput[] | shopping_favoritesUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutMemberInput | shopping_favoritesCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_favoritesUpsertWithWhereUniqueWithoutMemberInput | shopping_favoritesUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_favoritesCreateManyMemberInputEnvelope\n    set?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    disconnect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    delete?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    connect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    update?: shopping_favoritesUpdateWithWhereUniqueWithoutMemberInput | shopping_favoritesUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_favoritesUpdateManyWithWhereWithoutMemberInput | shopping_favoritesUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_favoritesScalarWhereInput | shopping_favoritesScalarWhereInput[]\n  }\n\n  export type shopping_article_commentsUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput> | shopping_article_commentsCreateWithoutMemberInput[] | shopping_article_commentsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutMemberInput | shopping_article_commentsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_article_commentsUpsertWithWhereUniqueWithoutMemberInput | shopping_article_commentsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_article_commentsCreateManyMemberInputEnvelope\n    set?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    disconnect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    delete?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    update?: shopping_article_commentsUpdateWithWhereUniqueWithoutMemberInput | shopping_article_commentsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_article_commentsUpdateManyWithWhereWithoutMemberInput | shopping_article_commentsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n  }\n\n  export type shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput> | shopping_cartsCreateWithoutMemberInput[] | shopping_cartsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutMemberInput | shopping_cartsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_cartsUpsertWithWhereUniqueWithoutMemberInput | shopping_cartsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_cartsCreateManyMemberInputEnvelope\n    set?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    disconnect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    delete?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    connect?: shopping_cartsWhereUniqueInput | shopping_cartsWhereUniqueInput[]\n    update?: shopping_cartsUpdateWithWhereUniqueWithoutMemberInput | shopping_cartsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_cartsUpdateManyWithWhereWithoutMemberInput | shopping_cartsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_cartsScalarWhereInput | shopping_cartsScalarWhereInput[]\n  }\n\n  export type shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput> | shopping_ordersCreateWithoutMemberInput[] | shopping_ordersUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutMemberInput | shopping_ordersCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_ordersUpsertWithWhereUniqueWithoutMemberInput | shopping_ordersUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_ordersCreateManyMemberInputEnvelope\n    set?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    disconnect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    delete?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    update?: shopping_ordersUpdateWithWhereUniqueWithoutMemberInput | shopping_ordersUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_ordersUpdateManyWithWhereWithoutMemberInput | shopping_ordersUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput> | shopping_coupon_usageCreateWithoutUserInput[] | shopping_coupon_usageUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutUserInput | shopping_coupon_usageCreateOrConnectWithoutUserInput[]\n    upsert?: shopping_coupon_usageUpsertWithWhereUniqueWithoutUserInput | shopping_coupon_usageUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: shopping_coupon_usageCreateManyUserInputEnvelope\n    set?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    disconnect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    delete?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    update?: shopping_coupon_usageUpdateWithWhereUniqueWithoutUserInput | shopping_coupon_usageUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: shopping_coupon_usageUpdateManyWithWhereWithoutUserInput | shopping_coupon_usageUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n  }\n\n  export type shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput = {\n    create?: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n    connectOrCreate?: shopping_coinsCreateOrConnectWithoutMemberInput\n    upsert?: shopping_coinsUpsertWithoutMemberInput\n    disconnect?: shopping_coinsWhereInput | boolean\n    delete?: shopping_coinsWhereInput | boolean\n    connect?: shopping_coinsWhereUniqueInput\n    update?: XOR<XOR<shopping_coinsUpdateToOneWithWhereWithoutMemberInput, shopping_coinsUpdateWithoutMemberInput>, shopping_coinsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput> | shopping_coin_transactionsCreateWithoutMemberInput[] | shopping_coin_transactionsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutMemberInput | shopping_coin_transactionsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_coin_transactionsUpsertWithWhereUniqueWithoutMemberInput | shopping_coin_transactionsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_coin_transactionsCreateManyMemberInputEnvelope\n    set?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    disconnect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    delete?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    update?: shopping_coin_transactionsUpdateWithWhereUniqueWithoutMemberInput | shopping_coin_transactionsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_coin_transactionsUpdateManyWithWhereWithoutMemberInput | shopping_coin_transactionsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n  }\n\n  export type shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput> | shopping_inquiriesCreateWithoutCustomerInput[] | shopping_inquiriesUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutCustomerInput | shopping_inquiriesCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_inquiriesUpsertWithWhereUniqueWithoutCustomerInput | shopping_inquiriesUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_inquiriesCreateManyCustomerInputEnvelope\n    set?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    disconnect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    delete?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    connect?: shopping_inquiriesWhereUniqueInput | shopping_inquiriesWhereUniqueInput[]\n    update?: shopping_inquiriesUpdateWithWhereUniqueWithoutCustomerInput | shopping_inquiriesUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_inquiriesUpdateManyWithWhereWithoutCustomerInput | shopping_inquiriesUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_inquiriesScalarWhereInput | shopping_inquiriesScalarWhereInput[]\n  }\n\n  export type shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput> | shopping_favoritesCreateWithoutMemberInput[] | shopping_favoritesUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutMemberInput | shopping_favoritesCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_favoritesUpsertWithWhereUniqueWithoutMemberInput | shopping_favoritesUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_favoritesCreateManyMemberInputEnvelope\n    set?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    disconnect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    delete?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    connect?: shopping_favoritesWhereUniqueInput | shopping_favoritesWhereUniqueInput[]\n    update?: shopping_favoritesUpdateWithWhereUniqueWithoutMemberInput | shopping_favoritesUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_favoritesUpdateManyWithWhereWithoutMemberInput | shopping_favoritesUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_favoritesScalarWhereInput | shopping_favoritesScalarWhereInput[]\n  }\n\n  export type shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput> | shopping_article_commentsCreateWithoutMemberInput[] | shopping_article_commentsUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutMemberInput | shopping_article_commentsCreateOrConnectWithoutMemberInput[]\n    upsert?: shopping_article_commentsUpsertWithWhereUniqueWithoutMemberInput | shopping_article_commentsUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: shopping_article_commentsCreateManyMemberInputEnvelope\n    set?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    disconnect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    delete?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    update?: shopping_article_commentsUpdateWithWhereUniqueWithoutMemberInput | shopping_article_commentsUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: shopping_article_commentsUpdateManyWithWhereWithoutMemberInput | shopping_article_commentsUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n  }\n\n  export type shopping_inquiry_responsesCreateNestedManyWithoutAdminInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput> | shopping_inquiry_responsesCreateWithoutAdminInput[] | shopping_inquiry_responsesUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutAdminInput | shopping_inquiry_responsesCreateOrConnectWithoutAdminInput[]\n    createMany?: shopping_inquiry_responsesCreateManyAdminInputEnvelope\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n  }\n\n  export type shopping_inquiry_responsesUncheckedCreateNestedManyWithoutAdminInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput> | shopping_inquiry_responsesCreateWithoutAdminInput[] | shopping_inquiry_responsesUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutAdminInput | shopping_inquiry_responsesCreateOrConnectWithoutAdminInput[]\n    createMany?: shopping_inquiry_responsesCreateManyAdminInputEnvelope\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n  }\n\n  export type shopping_inquiry_responsesUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput> | shopping_inquiry_responsesCreateWithoutAdminInput[] | shopping_inquiry_responsesUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutAdminInput | shopping_inquiry_responsesCreateOrConnectWithoutAdminInput[]\n    upsert?: shopping_inquiry_responsesUpsertWithWhereUniqueWithoutAdminInput | shopping_inquiry_responsesUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: shopping_inquiry_responsesCreateManyAdminInputEnvelope\n    set?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    disconnect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    delete?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    update?: shopping_inquiry_responsesUpdateWithWhereUniqueWithoutAdminInput | shopping_inquiry_responsesUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: shopping_inquiry_responsesUpdateManyWithWhereWithoutAdminInput | shopping_inquiry_responsesUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput> | shopping_inquiry_responsesCreateWithoutAdminInput[] | shopping_inquiry_responsesUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutAdminInput | shopping_inquiry_responsesCreateOrConnectWithoutAdminInput[]\n    upsert?: shopping_inquiry_responsesUpsertWithWhereUniqueWithoutAdminInput | shopping_inquiry_responsesUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: shopping_inquiry_responsesCreateManyAdminInputEnvelope\n    set?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    disconnect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    delete?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    update?: shopping_inquiry_responsesUpdateWithWhereUniqueWithoutAdminInput | shopping_inquiry_responsesUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: shopping_inquiry_responsesUpdateManyWithWhereWithoutAdminInput | shopping_inquiry_responsesUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_salesInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_salesInput, shopping_channelsUncheckedCreateWithoutShopping_salesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_salesInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_sectionsCreateNestedOneWithoutShopping_salesInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_salesInput, shopping_sectionsUncheckedCreateWithoutShopping_salesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_salesInput\n    connect?: shopping_sectionsWhereUniqueInput\n  }\n\n  export type shopping_sale_snapshotsCreateNestedManyWithoutSaleInput = {\n    create?: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput> | shopping_sale_snapshotsCreateWithoutSaleInput[] | shopping_sale_snapshotsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_snapshotsCreateOrConnectWithoutSaleInput | shopping_sale_snapshotsCreateOrConnectWithoutSaleInput[]\n    createMany?: shopping_sale_snapshotsCreateManySaleInputEnvelope\n    connect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n  }\n\n  export type shopping_sale_unitsCreateNestedManyWithoutSaleInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput> | shopping_sale_unitsCreateWithoutSaleInput[] | shopping_sale_unitsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutSaleInput | shopping_sale_unitsCreateOrConnectWithoutSaleInput[]\n    createMany?: shopping_sale_unitsCreateManySaleInputEnvelope\n    connect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n  }\n\n  export type shopping_sale_snapshotsUncheckedCreateNestedManyWithoutSaleInput = {\n    create?: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput> | shopping_sale_snapshotsCreateWithoutSaleInput[] | shopping_sale_snapshotsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_snapshotsCreateOrConnectWithoutSaleInput | shopping_sale_snapshotsCreateOrConnectWithoutSaleInput[]\n    createMany?: shopping_sale_snapshotsCreateManySaleInputEnvelope\n    connect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n  }\n\n  export type shopping_sale_unitsUncheckedCreateNestedManyWithoutSaleInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput> | shopping_sale_unitsCreateWithoutSaleInput[] | shopping_sale_unitsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutSaleInput | shopping_sale_unitsCreateOrConnectWithoutSaleInput[]\n    createMany?: shopping_sale_unitsCreateManySaleInputEnvelope\n    connect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n  }\n\n  export type FloatFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type shopping_channelsUpdateOneRequiredWithoutShopping_salesNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_salesInput, shopping_channelsUncheckedCreateWithoutShopping_salesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_salesInput\n    upsert?: shopping_channelsUpsertWithoutShopping_salesInput\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_salesInput, shopping_channelsUpdateWithoutShopping_salesInput>, shopping_channelsUncheckedUpdateWithoutShopping_salesInput>\n  }\n\n  export type shopping_sectionsUpdateOneRequiredWithoutShopping_salesNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_salesInput, shopping_sectionsUncheckedCreateWithoutShopping_salesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_salesInput\n    upsert?: shopping_sectionsUpsertWithoutShopping_salesInput\n    connect?: shopping_sectionsWhereUniqueInput\n    update?: XOR<XOR<shopping_sectionsUpdateToOneWithWhereWithoutShopping_salesInput, shopping_sectionsUpdateWithoutShopping_salesInput>, shopping_sectionsUncheckedUpdateWithoutShopping_salesInput>\n  }\n\n  export type shopping_sale_snapshotsUpdateManyWithoutSaleNestedInput = {\n    create?: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput> | shopping_sale_snapshotsCreateWithoutSaleInput[] | shopping_sale_snapshotsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_snapshotsCreateOrConnectWithoutSaleInput | shopping_sale_snapshotsCreateOrConnectWithoutSaleInput[]\n    upsert?: shopping_sale_snapshotsUpsertWithWhereUniqueWithoutSaleInput | shopping_sale_snapshotsUpsertWithWhereUniqueWithoutSaleInput[]\n    createMany?: shopping_sale_snapshotsCreateManySaleInputEnvelope\n    set?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    disconnect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    delete?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    connect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    update?: shopping_sale_snapshotsUpdateWithWhereUniqueWithoutSaleInput | shopping_sale_snapshotsUpdateWithWhereUniqueWithoutSaleInput[]\n    updateMany?: shopping_sale_snapshotsUpdateManyWithWhereWithoutSaleInput | shopping_sale_snapshotsUpdateManyWithWhereWithoutSaleInput[]\n    deleteMany?: shopping_sale_snapshotsScalarWhereInput | shopping_sale_snapshotsScalarWhereInput[]\n  }\n\n  export type shopping_sale_unitsUpdateManyWithoutSaleNestedInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput> | shopping_sale_unitsCreateWithoutSaleInput[] | shopping_sale_unitsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutSaleInput | shopping_sale_unitsCreateOrConnectWithoutSaleInput[]\n    upsert?: shopping_sale_unitsUpsertWithWhereUniqueWithoutSaleInput | shopping_sale_unitsUpsertWithWhereUniqueWithoutSaleInput[]\n    createMany?: shopping_sale_unitsCreateManySaleInputEnvelope\n    set?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    disconnect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    delete?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    connect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    update?: shopping_sale_unitsUpdateWithWhereUniqueWithoutSaleInput | shopping_sale_unitsUpdateWithWhereUniqueWithoutSaleInput[]\n    updateMany?: shopping_sale_unitsUpdateManyWithWhereWithoutSaleInput | shopping_sale_unitsUpdateManyWithWhereWithoutSaleInput[]\n    deleteMany?: shopping_sale_unitsScalarWhereInput | shopping_sale_unitsScalarWhereInput[]\n  }\n\n  export type shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleNestedInput = {\n    create?: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput> | shopping_sale_snapshotsCreateWithoutSaleInput[] | shopping_sale_snapshotsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_snapshotsCreateOrConnectWithoutSaleInput | shopping_sale_snapshotsCreateOrConnectWithoutSaleInput[]\n    upsert?: shopping_sale_snapshotsUpsertWithWhereUniqueWithoutSaleInput | shopping_sale_snapshotsUpsertWithWhereUniqueWithoutSaleInput[]\n    createMany?: shopping_sale_snapshotsCreateManySaleInputEnvelope\n    set?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    disconnect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    delete?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    connect?: shopping_sale_snapshotsWhereUniqueInput | shopping_sale_snapshotsWhereUniqueInput[]\n    update?: shopping_sale_snapshotsUpdateWithWhereUniqueWithoutSaleInput | shopping_sale_snapshotsUpdateWithWhereUniqueWithoutSaleInput[]\n    updateMany?: shopping_sale_snapshotsUpdateManyWithWhereWithoutSaleInput | shopping_sale_snapshotsUpdateManyWithWhereWithoutSaleInput[]\n    deleteMany?: shopping_sale_snapshotsScalarWhereInput | shopping_sale_snapshotsScalarWhereInput[]\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateManyWithoutSaleNestedInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput> | shopping_sale_unitsCreateWithoutSaleInput[] | shopping_sale_unitsUncheckedCreateWithoutSaleInput[]\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutSaleInput | shopping_sale_unitsCreateOrConnectWithoutSaleInput[]\n    upsert?: shopping_sale_unitsUpsertWithWhereUniqueWithoutSaleInput | shopping_sale_unitsUpsertWithWhereUniqueWithoutSaleInput[]\n    createMany?: shopping_sale_unitsCreateManySaleInputEnvelope\n    set?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    disconnect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    delete?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    connect?: shopping_sale_unitsWhereUniqueInput | shopping_sale_unitsWhereUniqueInput[]\n    update?: shopping_sale_unitsUpdateWithWhereUniqueWithoutSaleInput | shopping_sale_unitsUpdateWithWhereUniqueWithoutSaleInput[]\n    updateMany?: shopping_sale_unitsUpdateManyWithWhereWithoutSaleInput | shopping_sale_unitsUpdateManyWithWhereWithoutSaleInput[]\n    deleteMany?: shopping_sale_unitsScalarWhereInput | shopping_sale_unitsScalarWhereInput[]\n  }\n\n  export type shopping_salesCreateNestedOneWithoutShopping_sale_snapshotsInput = {\n    create?: XOR<shopping_salesCreateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedCreateWithoutShopping_sale_snapshotsInput>\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutShopping_sale_snapshotsInput\n    connect?: shopping_salesWhereUniqueInput\n  }\n\n  export type shopping_salesUpdateOneRequiredWithoutShopping_sale_snapshotsNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedCreateWithoutShopping_sale_snapshotsInput>\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutShopping_sale_snapshotsInput\n    upsert?: shopping_salesUpsertWithoutShopping_sale_snapshotsInput\n    connect?: shopping_salesWhereUniqueInput\n    update?: XOR<XOR<shopping_salesUpdateToOneWithWhereWithoutShopping_sale_snapshotsInput, shopping_salesUpdateWithoutShopping_sale_snapshotsInput>, shopping_salesUncheckedUpdateWithoutShopping_sale_snapshotsInput>\n  }\n\n  export type shopping_salesCreateNestedOneWithoutShopping_sale_unitsInput = {\n    create?: XOR<shopping_salesCreateWithoutShopping_sale_unitsInput, shopping_salesUncheckedCreateWithoutShopping_sale_unitsInput>\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutShopping_sale_unitsInput\n    connect?: shopping_salesWhereUniqueInput\n  }\n\n  export type shopping_sale_unit_optionsCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput> | shopping_sale_unit_optionsCreateWithoutSaleUnitInput[] | shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput | shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_sale_unit_optionsCreateManySaleUnitInputEnvelope\n    connect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_cart_itemsCreateWithoutSaleUnitInput[] | shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput | shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_cart_itemsCreateManySaleUnitInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_favorite_itemsCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_favorite_itemsCreateWithoutSaleUnitInput[] | shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput | shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_favorite_itemsCreateManySaleUnitInputEnvelope\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_sale_unit_optionsUncheckedCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput> | shopping_sale_unit_optionsCreateWithoutSaleUnitInput[] | shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput | shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_sale_unit_optionsCreateManySaleUnitInputEnvelope\n    connect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_cart_itemsCreateWithoutSaleUnitInput[] | shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput | shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_cart_itemsCreateManySaleUnitInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_favorite_itemsUncheckedCreateNestedManyWithoutSaleUnitInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_favorite_itemsCreateWithoutSaleUnitInput[] | shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput | shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput[]\n    createMany?: shopping_favorite_itemsCreateManySaleUnitInputEnvelope\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_salesUpdateOneRequiredWithoutShopping_sale_unitsNestedInput = {\n    create?: XOR<shopping_salesCreateWithoutShopping_sale_unitsInput, shopping_salesUncheckedCreateWithoutShopping_sale_unitsInput>\n    connectOrCreate?: shopping_salesCreateOrConnectWithoutShopping_sale_unitsInput\n    upsert?: shopping_salesUpsertWithoutShopping_sale_unitsInput\n    connect?: shopping_salesWhereUniqueInput\n    update?: XOR<XOR<shopping_salesUpdateToOneWithWhereWithoutShopping_sale_unitsInput, shopping_salesUpdateWithoutShopping_sale_unitsInput>, shopping_salesUncheckedUpdateWithoutShopping_sale_unitsInput>\n  }\n\n  export type shopping_sale_unit_optionsUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput> | shopping_sale_unit_optionsCreateWithoutSaleUnitInput[] | shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput | shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_sale_unit_optionsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_sale_unit_optionsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_sale_unit_optionsCreateManySaleUnitInputEnvelope\n    set?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    disconnect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    delete?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    connect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    update?: shopping_sale_unit_optionsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_sale_unit_optionsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_sale_unit_optionsUpdateManyWithWhereWithoutSaleUnitInput | shopping_sale_unit_optionsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_sale_unit_optionsScalarWhereInput | shopping_sale_unit_optionsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_cart_itemsCreateWithoutSaleUnitInput[] | shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput | shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_cart_itemsCreateManySaleUnitInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutSaleUnitInput | shopping_cart_itemsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_favorite_itemsUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_favorite_itemsCreateWithoutSaleUnitInput[] | shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput | shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_favorite_itemsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_favorite_itemsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_favorite_itemsCreateManySaleUnitInputEnvelope\n    set?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    disconnect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    delete?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    update?: shopping_favorite_itemsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_favorite_itemsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_favorite_itemsUpdateManyWithWhereWithoutSaleUnitInput | shopping_favorite_itemsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n  }\n\n  export type shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput> | shopping_sale_unit_optionsCreateWithoutSaleUnitInput[] | shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput | shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_sale_unit_optionsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_sale_unit_optionsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_sale_unit_optionsCreateManySaleUnitInputEnvelope\n    set?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    disconnect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    delete?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    connect?: shopping_sale_unit_optionsWhereUniqueInput | shopping_sale_unit_optionsWhereUniqueInput[]\n    update?: shopping_sale_unit_optionsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_sale_unit_optionsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_sale_unit_optionsUpdateManyWithWhereWithoutSaleUnitInput | shopping_sale_unit_optionsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_sale_unit_optionsScalarWhereInput | shopping_sale_unit_optionsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_cart_itemsCreateWithoutSaleUnitInput[] | shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput | shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_cart_itemsCreateManySaleUnitInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutSaleUnitInput | shopping_cart_itemsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput> | shopping_favorite_itemsCreateWithoutSaleUnitInput[] | shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput | shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput[]\n    upsert?: shopping_favorite_itemsUpsertWithWhereUniqueWithoutSaleUnitInput | shopping_favorite_itemsUpsertWithWhereUniqueWithoutSaleUnitInput[]\n    createMany?: shopping_favorite_itemsCreateManySaleUnitInputEnvelope\n    set?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    disconnect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    delete?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    update?: shopping_favorite_itemsUpdateWithWhereUniqueWithoutSaleUnitInput | shopping_favorite_itemsUpdateWithWhereUniqueWithoutSaleUnitInput[]\n    updateMany?: shopping_favorite_itemsUpdateManyWithWhereWithoutSaleUnitInput | shopping_favorite_itemsUpdateManyWithWhereWithoutSaleUnitInput[]\n    deleteMany?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n  }\n\n  export type shopping_sale_unitsCreateNestedOneWithoutShopping_sale_unit_optionsInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_sale_unit_optionsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_sale_unit_optionsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n  }\n\n  export type shopping_sale_unitsUpdateOneRequiredWithoutShopping_sale_unit_optionsNestedInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_sale_unit_optionsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_sale_unit_optionsInput\n    upsert?: shopping_sale_unitsUpsertWithoutShopping_sale_unit_optionsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n    update?: XOR<XOR<shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUpdateWithoutShopping_sale_unit_optionsInput>, shopping_sale_unitsUncheckedUpdateWithoutShopping_sale_unit_optionsInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_cartsInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_cartsInput, shopping_mall_memberUncheckedCreateWithoutShopping_cartsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_cartsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_cart_itemsCreateNestedManyWithoutCartInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_cartsNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_cartsInput, shopping_mall_memberUncheckedCreateWithoutShopping_cartsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_cartsInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_cartsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_cartsInput, shopping_mall_memberUpdateWithoutShopping_cartsInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_cartsInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithoutCartNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutCartInput | shopping_cart_itemsUpdateManyWithWhereWithoutCartInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutCartInput | shopping_cart_itemsUpdateManyWithWhereWithoutCartInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput = {\n    create?: XOR<shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput\n    connect?: shopping_cartsWhereUniqueInput\n  }\n\n  export type shopping_sale_unitsCreateNestedOneWithoutShopping_cart_itemsInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_cart_itemsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n  }\n\n  export type shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput = {\n    create?: XOR<shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput\n    upsert?: shopping_cartsUpsertWithoutShopping_cart_itemsInput\n    connect?: shopping_cartsWhereUniqueInput\n    update?: XOR<XOR<shopping_cartsUpdateToOneWithWhereWithoutShopping_cart_itemsInput, shopping_cartsUpdateWithoutShopping_cart_itemsInput>, shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_sale_unitsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_cart_itemsInput\n    upsert?: shopping_sale_unitsUpsertWithoutShopping_cart_itemsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n    update?: XOR<XOR<shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_cart_itemsInput, shopping_sale_unitsUpdateWithoutShopping_cart_itemsInput>, shopping_sale_unitsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_ordersInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_ordersInput, shopping_mall_memberUncheckedCreateWithoutShopping_ordersInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_ordersInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_order_snapshotsCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput> | shopping_order_snapshotsCreateWithoutOrderInput[] | shopping_order_snapshotsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_snapshotsCreateOrConnectWithoutOrderInput | shopping_order_snapshotsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_snapshotsCreateManyOrderInputEnvelope\n    connect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n  }\n\n  export type shopping_order_itemsCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_coin_transactionsCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput> | shopping_coin_transactionsCreateWithoutOrderInput[] | shopping_coin_transactionsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutOrderInput | shopping_coin_transactionsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_coin_transactionsCreateManyOrderInputEnvelope\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_order_snapshotsUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput> | shopping_order_snapshotsCreateWithoutOrderInput[] | shopping_order_snapshotsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_snapshotsCreateOrConnectWithoutOrderInput | shopping_order_snapshotsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_snapshotsCreateManyOrderInputEnvelope\n    connect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n  }\n\n  export type shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_coin_transactionsUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput> | shopping_coin_transactionsCreateWithoutOrderInput[] | shopping_coin_transactionsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutOrderInput | shopping_coin_transactionsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_coin_transactionsCreateManyOrderInputEnvelope\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_ordersNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_ordersInput, shopping_mall_memberUncheckedCreateWithoutShopping_ordersInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_ordersInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_ordersInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_ordersInput, shopping_mall_memberUpdateWithoutShopping_ordersInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_order_snapshotsUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput> | shopping_order_snapshotsCreateWithoutOrderInput[] | shopping_order_snapshotsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_snapshotsCreateOrConnectWithoutOrderInput | shopping_order_snapshotsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_snapshotsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_snapshotsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_snapshotsCreateManyOrderInputEnvelope\n    set?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    disconnect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    delete?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    connect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    update?: shopping_order_snapshotsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_snapshotsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_snapshotsUpdateManyWithWhereWithoutOrderInput | shopping_order_snapshotsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_snapshotsScalarWhereInput | shopping_order_snapshotsScalarWhereInput[]\n  }\n\n  export type shopping_order_itemsUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutOrderInput | shopping_order_itemsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_coin_transactionsUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput> | shopping_coin_transactionsCreateWithoutOrderInput[] | shopping_coin_transactionsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutOrderInput | shopping_coin_transactionsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_coin_transactionsUpsertWithWhereUniqueWithoutOrderInput | shopping_coin_transactionsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_coin_transactionsCreateManyOrderInputEnvelope\n    set?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    disconnect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    delete?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    update?: shopping_coin_transactionsUpdateWithWhereUniqueWithoutOrderInput | shopping_coin_transactionsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_coin_transactionsUpdateManyWithWhereWithoutOrderInput | shopping_coin_transactionsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n  }\n\n  export type shopping_order_snapshotsUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput> | shopping_order_snapshotsCreateWithoutOrderInput[] | shopping_order_snapshotsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_snapshotsCreateOrConnectWithoutOrderInput | shopping_order_snapshotsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_snapshotsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_snapshotsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_snapshotsCreateManyOrderInputEnvelope\n    set?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    disconnect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    delete?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    connect?: shopping_order_snapshotsWhereUniqueInput | shopping_order_snapshotsWhereUniqueInput[]\n    update?: shopping_order_snapshotsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_snapshotsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_snapshotsUpdateManyWithWhereWithoutOrderInput | shopping_order_snapshotsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_snapshotsScalarWhereInput | shopping_order_snapshotsScalarWhereInput[]\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutOrderInput | shopping_order_itemsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput> | shopping_coin_transactionsCreateWithoutOrderInput[] | shopping_coin_transactionsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_coin_transactionsCreateOrConnectWithoutOrderInput | shopping_coin_transactionsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_coin_transactionsUpsertWithWhereUniqueWithoutOrderInput | shopping_coin_transactionsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_coin_transactionsCreateManyOrderInputEnvelope\n    set?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    disconnect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    delete?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    connect?: shopping_coin_transactionsWhereUniqueInput | shopping_coin_transactionsWhereUniqueInput[]\n    update?: shopping_coin_transactionsUpdateWithWhereUniqueWithoutOrderInput | shopping_coin_transactionsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_coin_transactionsUpdateManyWithWhereWithoutOrderInput | shopping_coin_transactionsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_order_snapshotsInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedCreateWithoutShopping_order_snapshotsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_snapshotsInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_order_snapshotsNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedCreateWithoutShopping_order_snapshotsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_snapshotsInput\n    upsert?: shopping_ordersUpsertWithoutShopping_order_snapshotsInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_order_snapshotsInput, shopping_ordersUpdateWithoutShopping_order_snapshotsInput>, shopping_ordersUncheckedUpdateWithoutShopping_order_snapshotsInput>\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_order_itemsInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_order_itemsNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput\n    upsert?: shopping_ordersUpsertWithoutShopping_order_itemsInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_order_itemsInput, shopping_ordersUpdateWithoutShopping_order_itemsInput>, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_coupon_usageCreateNestedManyWithoutCouponInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput> | shopping_coupon_usageCreateWithoutCouponInput[] | shopping_coupon_usageUncheckedCreateWithoutCouponInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutCouponInput | shopping_coupon_usageCreateOrConnectWithoutCouponInput[]\n    createMany?: shopping_coupon_usageCreateManyCouponInputEnvelope\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n  }\n\n  export type shopping_coupon_usageUncheckedCreateNestedManyWithoutCouponInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput> | shopping_coupon_usageCreateWithoutCouponInput[] | shopping_coupon_usageUncheckedCreateWithoutCouponInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutCouponInput | shopping_coupon_usageCreateOrConnectWithoutCouponInput[]\n    createMany?: shopping_coupon_usageCreateManyCouponInputEnvelope\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n  }\n\n  export type NullableIntFieldUpdateOperationsInput = {\n    set?: number | null\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type shopping_coupon_usageUpdateManyWithoutCouponNestedInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput> | shopping_coupon_usageCreateWithoutCouponInput[] | shopping_coupon_usageUncheckedCreateWithoutCouponInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutCouponInput | shopping_coupon_usageCreateOrConnectWithoutCouponInput[]\n    upsert?: shopping_coupon_usageUpsertWithWhereUniqueWithoutCouponInput | shopping_coupon_usageUpsertWithWhereUniqueWithoutCouponInput[]\n    createMany?: shopping_coupon_usageCreateManyCouponInputEnvelope\n    set?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    disconnect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    delete?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    update?: shopping_coupon_usageUpdateWithWhereUniqueWithoutCouponInput | shopping_coupon_usageUpdateWithWhereUniqueWithoutCouponInput[]\n    updateMany?: shopping_coupon_usageUpdateManyWithWhereWithoutCouponInput | shopping_coupon_usageUpdateManyWithWhereWithoutCouponInput[]\n    deleteMany?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateManyWithoutCouponNestedInput = {\n    create?: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput> | shopping_coupon_usageCreateWithoutCouponInput[] | shopping_coupon_usageUncheckedCreateWithoutCouponInput[]\n    connectOrCreate?: shopping_coupon_usageCreateOrConnectWithoutCouponInput | shopping_coupon_usageCreateOrConnectWithoutCouponInput[]\n    upsert?: shopping_coupon_usageUpsertWithWhereUniqueWithoutCouponInput | shopping_coupon_usageUpsertWithWhereUniqueWithoutCouponInput[]\n    createMany?: shopping_coupon_usageCreateManyCouponInputEnvelope\n    set?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    disconnect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    delete?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    connect?: shopping_coupon_usageWhereUniqueInput | shopping_coupon_usageWhereUniqueInput[]\n    update?: shopping_coupon_usageUpdateWithWhereUniqueWithoutCouponInput | shopping_coupon_usageUpdateWithWhereUniqueWithoutCouponInput[]\n    updateMany?: shopping_coupon_usageUpdateManyWithWhereWithoutCouponInput | shopping_coupon_usageUpdateManyWithWhereWithoutCouponInput[]\n    deleteMany?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n  }\n\n  export type shopping_couponsCreateNestedOneWithoutShopping_coupon_usageInput = {\n    create?: XOR<shopping_couponsCreateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedCreateWithoutShopping_coupon_usageInput>\n    connectOrCreate?: shopping_couponsCreateOrConnectWithoutShopping_coupon_usageInput\n    connect?: shopping_couponsWhereUniqueInput\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_coupon_usageInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedCreateWithoutShopping_coupon_usageInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coupon_usageInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_couponsUpdateOneRequiredWithoutShopping_coupon_usageNestedInput = {\n    create?: XOR<shopping_couponsCreateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedCreateWithoutShopping_coupon_usageInput>\n    connectOrCreate?: shopping_couponsCreateOrConnectWithoutShopping_coupon_usageInput\n    upsert?: shopping_couponsUpsertWithoutShopping_coupon_usageInput\n    connect?: shopping_couponsWhereUniqueInput\n    update?: XOR<XOR<shopping_couponsUpdateToOneWithWhereWithoutShopping_coupon_usageInput, shopping_couponsUpdateWithoutShopping_coupon_usageInput>, shopping_couponsUncheckedUpdateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_coupon_usageNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedCreateWithoutShopping_coupon_usageInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coupon_usageInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_coupon_usageInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coupon_usageInput, shopping_mall_memberUpdateWithoutShopping_coupon_usageInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_coinsInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coinsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coinsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coinsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_coinsNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coinsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coinsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coinsInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_coinsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coinsInput, shopping_mall_memberUpdateWithoutShopping_coinsInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_coinsInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_coin_transactionsInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coin_transactionsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coin_transactionsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_coin_transactionsInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedCreateWithoutShopping_coin_transactionsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_coin_transactionsInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_coin_transactionsNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coin_transactionsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_coin_transactionsInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_coin_transactionsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coin_transactionsInput, shopping_mall_memberUpdateWithoutShopping_coin_transactionsInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_ordersUpdateOneWithoutShopping_coin_transactionsNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedCreateWithoutShopping_coin_transactionsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_coin_transactionsInput\n    upsert?: shopping_ordersUpsertWithoutShopping_coin_transactionsInput\n    disconnect?: shopping_ordersWhereInput | boolean\n    delete?: shopping_ordersWhereInput | boolean\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_coin_transactionsInput, shopping_ordersUpdateWithoutShopping_coin_transactionsInput>, shopping_ordersUncheckedUpdateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_inquiriesInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedCreateWithoutShopping_inquiriesInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_inquiriesInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_inquiry_responsesCreateNestedManyWithoutInquiryInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput> | shopping_inquiry_responsesCreateWithoutInquiryInput[] | shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput | shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput[]\n    createMany?: shopping_inquiry_responsesCreateManyInquiryInputEnvelope\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n  }\n\n  export type shopping_inquiry_responsesUncheckedCreateNestedManyWithoutInquiryInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput> | shopping_inquiry_responsesCreateWithoutInquiryInput[] | shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput | shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput[]\n    createMany?: shopping_inquiry_responsesCreateManyInquiryInputEnvelope\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_inquiriesNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedCreateWithoutShopping_inquiriesInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_inquiriesInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_inquiriesInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_inquiriesInput, shopping_mall_memberUpdateWithoutShopping_inquiriesInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_inquiriesInput>\n  }\n\n  export type shopping_inquiry_responsesUpdateManyWithoutInquiryNestedInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput> | shopping_inquiry_responsesCreateWithoutInquiryInput[] | shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput | shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput[]\n    upsert?: shopping_inquiry_responsesUpsertWithWhereUniqueWithoutInquiryInput | shopping_inquiry_responsesUpsertWithWhereUniqueWithoutInquiryInput[]\n    createMany?: shopping_inquiry_responsesCreateManyInquiryInputEnvelope\n    set?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    disconnect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    delete?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    update?: shopping_inquiry_responsesUpdateWithWhereUniqueWithoutInquiryInput | shopping_inquiry_responsesUpdateWithWhereUniqueWithoutInquiryInput[]\n    updateMany?: shopping_inquiry_responsesUpdateManyWithWhereWithoutInquiryInput | shopping_inquiry_responsesUpdateManyWithWhereWithoutInquiryInput[]\n    deleteMany?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateManyWithoutInquiryNestedInput = {\n    create?: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput> | shopping_inquiry_responsesCreateWithoutInquiryInput[] | shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput[]\n    connectOrCreate?: shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput | shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput[]\n    upsert?: shopping_inquiry_responsesUpsertWithWhereUniqueWithoutInquiryInput | shopping_inquiry_responsesUpsertWithWhereUniqueWithoutInquiryInput[]\n    createMany?: shopping_inquiry_responsesCreateManyInquiryInputEnvelope\n    set?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    disconnect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    delete?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    connect?: shopping_inquiry_responsesWhereUniqueInput | shopping_inquiry_responsesWhereUniqueInput[]\n    update?: shopping_inquiry_responsesUpdateWithWhereUniqueWithoutInquiryInput | shopping_inquiry_responsesUpdateWithWhereUniqueWithoutInquiryInput[]\n    updateMany?: shopping_inquiry_responsesUpdateManyWithWhereWithoutInquiryInput | shopping_inquiry_responsesUpdateManyWithWhereWithoutInquiryInput[]\n    deleteMany?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n  }\n\n  export type shopping_inquiriesCreateNestedOneWithoutShopping_inquiry_responsesInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutShopping_inquiry_responsesInput\n    connect?: shopping_inquiriesWhereUniqueInput\n  }\n\n  export type shopping_mall_adminCreateNestedOneWithoutShopping_inquiry_responsesInput = {\n    create?: XOR<shopping_mall_adminCreateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    connectOrCreate?: shopping_mall_adminCreateOrConnectWithoutShopping_inquiry_responsesInput\n    connect?: shopping_mall_adminWhereUniqueInput\n  }\n\n  export type shopping_inquiriesUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput = {\n    create?: XOR<shopping_inquiriesCreateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    connectOrCreate?: shopping_inquiriesCreateOrConnectWithoutShopping_inquiry_responsesInput\n    upsert?: shopping_inquiriesUpsertWithoutShopping_inquiry_responsesInput\n    connect?: shopping_inquiriesWhereUniqueInput\n    update?: XOR<XOR<shopping_inquiriesUpdateToOneWithWhereWithoutShopping_inquiry_responsesInput, shopping_inquiriesUpdateWithoutShopping_inquiry_responsesInput>, shopping_inquiriesUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_mall_adminUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput = {\n    create?: XOR<shopping_mall_adminCreateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    connectOrCreate?: shopping_mall_adminCreateOrConnectWithoutShopping_inquiry_responsesInput\n    upsert?: shopping_mall_adminUpsertWithoutShopping_inquiry_responsesInput\n    connect?: shopping_mall_adminWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_adminUpdateToOneWithWhereWithoutShopping_inquiry_responsesInput, shopping_mall_adminUpdateWithoutShopping_inquiry_responsesInput>, shopping_mall_adminUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_favoritesInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedCreateWithoutShopping_favoritesInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_favoritesInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_favorite_itemsCreateNestedManyWithoutFavoriteInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput> | shopping_favorite_itemsCreateWithoutFavoriteInput[] | shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput | shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput[]\n    createMany?: shopping_favorite_itemsCreateManyFavoriteInputEnvelope\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_favorite_itemsUncheckedCreateNestedManyWithoutFavoriteInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput> | shopping_favorite_itemsCreateWithoutFavoriteInput[] | shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput | shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput[]\n    createMany?: shopping_favorite_itemsCreateManyFavoriteInputEnvelope\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_favoritesNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedCreateWithoutShopping_favoritesInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_favoritesInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_favoritesInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_favoritesInput, shopping_mall_memberUpdateWithoutShopping_favoritesInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_favoritesInput>\n  }\n\n  export type shopping_favorite_itemsUpdateManyWithoutFavoriteNestedInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput> | shopping_favorite_itemsCreateWithoutFavoriteInput[] | shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput | shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput[]\n    upsert?: shopping_favorite_itemsUpsertWithWhereUniqueWithoutFavoriteInput | shopping_favorite_itemsUpsertWithWhereUniqueWithoutFavoriteInput[]\n    createMany?: shopping_favorite_itemsCreateManyFavoriteInputEnvelope\n    set?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    disconnect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    delete?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    update?: shopping_favorite_itemsUpdateWithWhereUniqueWithoutFavoriteInput | shopping_favorite_itemsUpdateWithWhereUniqueWithoutFavoriteInput[]\n    updateMany?: shopping_favorite_itemsUpdateManyWithWhereWithoutFavoriteInput | shopping_favorite_itemsUpdateManyWithWhereWithoutFavoriteInput[]\n    deleteMany?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateManyWithoutFavoriteNestedInput = {\n    create?: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput> | shopping_favorite_itemsCreateWithoutFavoriteInput[] | shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput[]\n    connectOrCreate?: shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput | shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput[]\n    upsert?: shopping_favorite_itemsUpsertWithWhereUniqueWithoutFavoriteInput | shopping_favorite_itemsUpsertWithWhereUniqueWithoutFavoriteInput[]\n    createMany?: shopping_favorite_itemsCreateManyFavoriteInputEnvelope\n    set?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    disconnect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    delete?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    connect?: shopping_favorite_itemsWhereUniqueInput | shopping_favorite_itemsWhereUniqueInput[]\n    update?: shopping_favorite_itemsUpdateWithWhereUniqueWithoutFavoriteInput | shopping_favorite_itemsUpdateWithWhereUniqueWithoutFavoriteInput[]\n    updateMany?: shopping_favorite_itemsUpdateManyWithWhereWithoutFavoriteInput | shopping_favorite_itemsUpdateManyWithWhereWithoutFavoriteInput[]\n    deleteMany?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n  }\n\n  export type shopping_favoritesCreateNestedOneWithoutShopping_favorite_itemsInput = {\n    create?: XOR<shopping_favoritesCreateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedCreateWithoutShopping_favorite_itemsInput>\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutShopping_favorite_itemsInput\n    connect?: shopping_favoritesWhereUniqueInput\n  }\n\n  export type shopping_sale_unitsCreateNestedOneWithoutShopping_favorite_itemsInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_favorite_itemsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_favorite_itemsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n  }\n\n  export type shopping_favoritesUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput = {\n    create?: XOR<shopping_favoritesCreateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedCreateWithoutShopping_favorite_itemsInput>\n    connectOrCreate?: shopping_favoritesCreateOrConnectWithoutShopping_favorite_itemsInput\n    upsert?: shopping_favoritesUpsertWithoutShopping_favorite_itemsInput\n    connect?: shopping_favoritesWhereUniqueInput\n    update?: XOR<XOR<shopping_favoritesUpdateToOneWithWhereWithoutShopping_favorite_itemsInput, shopping_favoritesUpdateWithoutShopping_favorite_itemsInput>, shopping_favoritesUncheckedUpdateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_sale_unitsUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput = {\n    create?: XOR<shopping_sale_unitsCreateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_favorite_itemsInput>\n    connectOrCreate?: shopping_sale_unitsCreateOrConnectWithoutShopping_favorite_itemsInput\n    upsert?: shopping_sale_unitsUpsertWithoutShopping_favorite_itemsInput\n    connect?: shopping_sale_unitsWhereUniqueInput\n    update?: XOR<XOR<shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_favorite_itemsInput, shopping_sale_unitsUpdateWithoutShopping_favorite_itemsInput>, shopping_sale_unitsUncheckedUpdateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_articlesInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_articlesInput, shopping_channelsUncheckedCreateWithoutShopping_articlesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_articlesInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_sectionsCreateNestedOneWithoutShopping_articlesInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_articlesInput, shopping_sectionsUncheckedCreateWithoutShopping_articlesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_articlesInput\n    connect?: shopping_sectionsWhereUniqueInput\n  }\n\n  export type shopping_article_commentsCreateNestedManyWithoutArticleInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput> | shopping_article_commentsCreateWithoutArticleInput[] | shopping_article_commentsUncheckedCreateWithoutArticleInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutArticleInput | shopping_article_commentsCreateOrConnectWithoutArticleInput[]\n    createMany?: shopping_article_commentsCreateManyArticleInputEnvelope\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n  }\n\n  export type shopping_article_commentsUncheckedCreateNestedManyWithoutArticleInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput> | shopping_article_commentsCreateWithoutArticleInput[] | shopping_article_commentsUncheckedCreateWithoutArticleInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutArticleInput | shopping_article_commentsCreateOrConnectWithoutArticleInput[]\n    createMany?: shopping_article_commentsCreateManyArticleInputEnvelope\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n  }\n\n  export type shopping_channelsUpdateOneRequiredWithoutShopping_articlesNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_articlesInput, shopping_channelsUncheckedCreateWithoutShopping_articlesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_articlesInput\n    upsert?: shopping_channelsUpsertWithoutShopping_articlesInput\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_articlesInput, shopping_channelsUpdateWithoutShopping_articlesInput>, shopping_channelsUncheckedUpdateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_sectionsUpdateOneRequiredWithoutShopping_articlesNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_articlesInput, shopping_sectionsUncheckedCreateWithoutShopping_articlesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_articlesInput\n    upsert?: shopping_sectionsUpsertWithoutShopping_articlesInput\n    connect?: shopping_sectionsWhereUniqueInput\n    update?: XOR<XOR<shopping_sectionsUpdateToOneWithWhereWithoutShopping_articlesInput, shopping_sectionsUpdateWithoutShopping_articlesInput>, shopping_sectionsUncheckedUpdateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_article_commentsUpdateManyWithoutArticleNestedInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput> | shopping_article_commentsCreateWithoutArticleInput[] | shopping_article_commentsUncheckedCreateWithoutArticleInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutArticleInput | shopping_article_commentsCreateOrConnectWithoutArticleInput[]\n    upsert?: shopping_article_commentsUpsertWithWhereUniqueWithoutArticleInput | shopping_article_commentsUpsertWithWhereUniqueWithoutArticleInput[]\n    createMany?: shopping_article_commentsCreateManyArticleInputEnvelope\n    set?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    disconnect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    delete?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    update?: shopping_article_commentsUpdateWithWhereUniqueWithoutArticleInput | shopping_article_commentsUpdateWithWhereUniqueWithoutArticleInput[]\n    updateMany?: shopping_article_commentsUpdateManyWithWhereWithoutArticleInput | shopping_article_commentsUpdateManyWithWhereWithoutArticleInput[]\n    deleteMany?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n  }\n\n  export type shopping_article_commentsUncheckedUpdateManyWithoutArticleNestedInput = {\n    create?: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput> | shopping_article_commentsCreateWithoutArticleInput[] | shopping_article_commentsUncheckedCreateWithoutArticleInput[]\n    connectOrCreate?: shopping_article_commentsCreateOrConnectWithoutArticleInput | shopping_article_commentsCreateOrConnectWithoutArticleInput[]\n    upsert?: shopping_article_commentsUpsertWithWhereUniqueWithoutArticleInput | shopping_article_commentsUpsertWithWhereUniqueWithoutArticleInput[]\n    createMany?: shopping_article_commentsCreateManyArticleInputEnvelope\n    set?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    disconnect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    delete?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    connect?: shopping_article_commentsWhereUniqueInput | shopping_article_commentsWhereUniqueInput[]\n    update?: shopping_article_commentsUpdateWithWhereUniqueWithoutArticleInput | shopping_article_commentsUpdateWithWhereUniqueWithoutArticleInput[]\n    updateMany?: shopping_article_commentsUpdateManyWithWhereWithoutArticleInput | shopping_article_commentsUpdateManyWithWhereWithoutArticleInput[]\n    deleteMany?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n  }\n\n  export type shopping_articlesCreateNestedOneWithoutShopping_article_commentsInput = {\n    create?: XOR<shopping_articlesCreateWithoutShopping_article_commentsInput, shopping_articlesUncheckedCreateWithoutShopping_article_commentsInput>\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutShopping_article_commentsInput\n    connect?: shopping_articlesWhereUniqueInput\n  }\n\n  export type shopping_mall_memberCreateNestedOneWithoutShopping_article_commentsInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedCreateWithoutShopping_article_commentsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_article_commentsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n  }\n\n  export type shopping_articlesUpdateOneRequiredWithoutShopping_article_commentsNestedInput = {\n    create?: XOR<shopping_articlesCreateWithoutShopping_article_commentsInput, shopping_articlesUncheckedCreateWithoutShopping_article_commentsInput>\n    connectOrCreate?: shopping_articlesCreateOrConnectWithoutShopping_article_commentsInput\n    upsert?: shopping_articlesUpsertWithoutShopping_article_commentsInput\n    connect?: shopping_articlesWhereUniqueInput\n    update?: XOR<XOR<shopping_articlesUpdateToOneWithWhereWithoutShopping_article_commentsInput, shopping_articlesUpdateWithoutShopping_article_commentsInput>, shopping_articlesUncheckedUpdateWithoutShopping_article_commentsInput>\n  }\n\n  export type shopping_mall_memberUpdateOneRequiredWithoutShopping_article_commentsNestedInput = {\n    create?: XOR<shopping_mall_memberCreateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedCreateWithoutShopping_article_commentsInput>\n    connectOrCreate?: shopping_mall_memberCreateOrConnectWithoutShopping_article_commentsInput\n    upsert?: shopping_mall_memberUpsertWithoutShopping_article_commentsInput\n    connect?: shopping_mall_memberWhereUniqueInput\n    update?: XOR<XOR<shopping_mall_memberUpdateToOneWithWhereWithoutShopping_article_commentsInput, shopping_mall_memberUpdateWithoutShopping_article_commentsInput>, shopping_mall_memberUncheckedUpdateWithoutShopping_article_commentsInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type NestedFloatNullableFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type shopping_sectionsCreateWithoutChannelInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutChannelInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsCreateManyChannelInputEnvelope = {\n    data: shopping_sectionsCreateManyChannelInput | shopping_sectionsCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_configurationsCreateWithoutChannelInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    section?: shopping_sectionsCreateNestedOneWithoutShopping_configurationsInput\n  }\n\n  export type shopping_configurationsUncheckedCreateWithoutChannelInput = {\n    id: string\n    shopping_section_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsCreateOrConnectWithoutChannelInput = {\n    where: shopping_configurationsWhereUniqueInput\n    create: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_configurationsCreateManyChannelInputEnvelope = {\n    data: shopping_configurationsCreateManyChannelInput | shopping_configurationsCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_salesCreateWithoutChannelInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    section: shopping_sectionsCreateNestedOneWithoutShopping_salesInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUncheckedCreateWithoutChannelInput = {\n    id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesCreateOrConnectWithoutChannelInput = {\n    where: shopping_salesWhereUniqueInput\n    create: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_salesCreateManyChannelInputEnvelope = {\n    data: shopping_salesCreateManyChannelInput | shopping_salesCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_articlesCreateWithoutChannelInput = {\n    id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    section: shopping_sectionsCreateNestedOneWithoutShopping_articlesInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesUncheckedCreateWithoutChannelInput = {\n    id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesCreateOrConnectWithoutChannelInput = {\n    where: shopping_articlesWhereUniqueInput\n    create: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_articlesCreateManyChannelInputEnvelope = {\n    data: shopping_articlesCreateManyChannelInput | shopping_articlesCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    update: XOR<shopping_sectionsUpdateWithoutChannelInput, shopping_sectionsUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    data: XOR<shopping_sectionsUpdateWithoutChannelInput, shopping_sectionsUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_sectionsScalarWhereInput\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_sectionsScalarWhereInput = {\n    AND?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n    OR?: shopping_sectionsScalarWhereInput[]\n    NOT?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    code?: StringFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n  }\n\n  export type shopping_configurationsUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_configurationsWhereUniqueInput\n    update: XOR<shopping_configurationsUpdateWithoutChannelInput, shopping_configurationsUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_configurationsCreateWithoutChannelInput, shopping_configurationsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_configurationsUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_configurationsWhereUniqueInput\n    data: XOR<shopping_configurationsUpdateWithoutChannelInput, shopping_configurationsUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_configurationsUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_configurationsScalarWhereInput\n    data: XOR<shopping_configurationsUpdateManyMutationInput, shopping_configurationsUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_configurationsScalarWhereInput = {\n    AND?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n    OR?: shopping_configurationsScalarWhereInput[]\n    NOT?: shopping_configurationsScalarWhereInput | shopping_configurationsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_configurations\"> | string\n    shopping_channel_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    shopping_section_id?: UuidNullableFilter<\"shopping_configurations\"> | string | null\n    key?: StringFilter<\"shopping_configurations\"> | string\n    value?: StringFilter<\"shopping_configurations\"> | string\n    description?: StringNullableFilter<\"shopping_configurations\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_configurations\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_configurations\"> | Date | string | null\n  }\n\n  export type shopping_salesUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_salesWhereUniqueInput\n    update: XOR<shopping_salesUpdateWithoutChannelInput, shopping_salesUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_salesCreateWithoutChannelInput, shopping_salesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_salesUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_salesWhereUniqueInput\n    data: XOR<shopping_salesUpdateWithoutChannelInput, shopping_salesUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_salesUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_salesScalarWhereInput\n    data: XOR<shopping_salesUpdateManyMutationInput, shopping_salesUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_salesScalarWhereInput = {\n    AND?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n    OR?: shopping_salesScalarWhereInput[]\n    NOT?: shopping_salesScalarWhereInput | shopping_salesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sales\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sales\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_sales\"> | string\n    code?: StringFilter<\"shopping_sales\"> | string\n    name?: StringFilter<\"shopping_sales\"> | string\n    description?: StringNullableFilter<\"shopping_sales\"> | string | null\n    price?: FloatFilter<\"shopping_sales\"> | number\n    stock?: IntFilter<\"shopping_sales\"> | number\n    created_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sales\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sales\"> | Date | string | null\n  }\n\n  export type shopping_articlesUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_articlesWhereUniqueInput\n    update: XOR<shopping_articlesUpdateWithoutChannelInput, shopping_articlesUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_articlesCreateWithoutChannelInput, shopping_articlesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_articlesUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_articlesWhereUniqueInput\n    data: XOR<shopping_articlesUpdateWithoutChannelInput, shopping_articlesUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_articlesUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_articlesScalarWhereInput\n    data: XOR<shopping_articlesUpdateManyMutationInput, shopping_articlesUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_articlesScalarWhereInput = {\n    AND?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n    OR?: shopping_articlesScalarWhereInput[]\n    NOT?: shopping_articlesScalarWhereInput | shopping_articlesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_articles\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_articles\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_articles\"> | string\n    code?: StringFilter<\"shopping_articles\"> | string\n    title?: StringFilter<\"shopping_articles\"> | string\n    content?: StringFilter<\"shopping_articles\"> | string\n    status?: StringFilter<\"shopping_articles\"> | string\n    created_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_articles\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_articles\"> | Date | string | null\n  }\n\n  export type shopping_channelsCreateWithoutShopping_sectionsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_sectionsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_sectionsInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_configurationsCreateWithoutSectionInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel?: shopping_channelsCreateNestedOneWithoutShopping_configurationsInput\n  }\n\n  export type shopping_configurationsUncheckedCreateWithoutSectionInput = {\n    id: string\n    shopping_channel_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsCreateOrConnectWithoutSectionInput = {\n    where: shopping_configurationsWhereUniqueInput\n    create: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_configurationsCreateManySectionInputEnvelope = {\n    data: shopping_configurationsCreateManySectionInput | shopping_configurationsCreateManySectionInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_salesCreateWithoutSectionInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_salesInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUncheckedCreateWithoutSectionInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedCreateNestedManyWithoutSaleInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesCreateOrConnectWithoutSectionInput = {\n    where: shopping_salesWhereUniqueInput\n    create: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_salesCreateManySectionInputEnvelope = {\n    data: shopping_salesCreateManySectionInput | shopping_salesCreateManySectionInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_articlesCreateWithoutSectionInput = {\n    id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_articlesInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesUncheckedCreateWithoutSectionInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutArticleInput\n  }\n\n  export type shopping_articlesCreateOrConnectWithoutSectionInput = {\n    where: shopping_articlesWhereUniqueInput\n    create: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_articlesCreateManySectionInputEnvelope = {\n    data: shopping_articlesCreateManySectionInput | shopping_articlesCreateManySectionInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_sectionsInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_sectionsInput, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_sectionsInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_sectionsInput, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_sectionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_configurationsUpsertWithWhereUniqueWithoutSectionInput = {\n    where: shopping_configurationsWhereUniqueInput\n    update: XOR<shopping_configurationsUpdateWithoutSectionInput, shopping_configurationsUncheckedUpdateWithoutSectionInput>\n    create: XOR<shopping_configurationsCreateWithoutSectionInput, shopping_configurationsUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_configurationsUpdateWithWhereUniqueWithoutSectionInput = {\n    where: shopping_configurationsWhereUniqueInput\n    data: XOR<shopping_configurationsUpdateWithoutSectionInput, shopping_configurationsUncheckedUpdateWithoutSectionInput>\n  }\n\n  export type shopping_configurationsUpdateManyWithWhereWithoutSectionInput = {\n    where: shopping_configurationsScalarWhereInput\n    data: XOR<shopping_configurationsUpdateManyMutationInput, shopping_configurationsUncheckedUpdateManyWithoutSectionInput>\n  }\n\n  export type shopping_salesUpsertWithWhereUniqueWithoutSectionInput = {\n    where: shopping_salesWhereUniqueInput\n    update: XOR<shopping_salesUpdateWithoutSectionInput, shopping_salesUncheckedUpdateWithoutSectionInput>\n    create: XOR<shopping_salesCreateWithoutSectionInput, shopping_salesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_salesUpdateWithWhereUniqueWithoutSectionInput = {\n    where: shopping_salesWhereUniqueInput\n    data: XOR<shopping_salesUpdateWithoutSectionInput, shopping_salesUncheckedUpdateWithoutSectionInput>\n  }\n\n  export type shopping_salesUpdateManyWithWhereWithoutSectionInput = {\n    where: shopping_salesScalarWhereInput\n    data: XOR<shopping_salesUpdateManyMutationInput, shopping_salesUncheckedUpdateManyWithoutSectionInput>\n  }\n\n  export type shopping_articlesUpsertWithWhereUniqueWithoutSectionInput = {\n    where: shopping_articlesWhereUniqueInput\n    update: XOR<shopping_articlesUpdateWithoutSectionInput, shopping_articlesUncheckedUpdateWithoutSectionInput>\n    create: XOR<shopping_articlesCreateWithoutSectionInput, shopping_articlesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_articlesUpdateWithWhereUniqueWithoutSectionInput = {\n    where: shopping_articlesWhereUniqueInput\n    data: XOR<shopping_articlesUpdateWithoutSectionInput, shopping_articlesUncheckedUpdateWithoutSectionInput>\n  }\n\n  export type shopping_articlesUpdateManyWithWhereWithoutSectionInput = {\n    where: shopping_articlesScalarWhereInput\n    data: XOR<shopping_articlesUpdateManyMutationInput, shopping_articlesUncheckedUpdateManyWithoutSectionInput>\n  }\n\n  export type shopping_channelsCreateWithoutShopping_configurationsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_configurationsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_configurationsInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_configurationsInput, shopping_channelsUncheckedCreateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_sectionsCreateWithoutShopping_configurationsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutShopping_configurationsInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutShopping_configurationsInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutShopping_configurationsInput, shopping_sectionsUncheckedCreateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_configurationsInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_configurationsInput, shopping_channelsUncheckedUpdateWithoutShopping_configurationsInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_configurationsInput, shopping_channelsUncheckedCreateWithoutShopping_configurationsInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_configurationsInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_configurationsInput, shopping_channelsUncheckedUpdateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_configurationsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_configurationsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_sectionsUpsertWithoutShopping_configurationsInput = {\n    update: XOR<shopping_sectionsUpdateWithoutShopping_configurationsInput, shopping_sectionsUncheckedUpdateWithoutShopping_configurationsInput>\n    create: XOR<shopping_sectionsCreateWithoutShopping_configurationsInput, shopping_sectionsUncheckedCreateWithoutShopping_configurationsInput>\n    where?: shopping_sectionsWhereInput\n  }\n\n  export type shopping_sectionsUpdateToOneWithWhereWithoutShopping_configurationsInput = {\n    where?: shopping_sectionsWhereInput\n    data: XOR<shopping_sectionsUpdateWithoutShopping_configurationsInput, shopping_sectionsUncheckedUpdateWithoutShopping_configurationsInput>\n  }\n\n  export type shopping_sectionsUpdateWithoutShopping_configurationsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutShopping_configurationsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_cartsCreateWithoutMemberInput = {\n    id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_cartsUncheckedCreateWithoutMemberInput = {\n    id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_cartsCreateOrConnectWithoutMemberInput = {\n    where: shopping_cartsWhereUniqueInput\n    create: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_cartsCreateManyMemberInputEnvelope = {\n    data: shopping_cartsCreateManyMemberInput | shopping_cartsCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_ordersCreateWithoutMemberInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutMemberInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutMemberInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_ordersCreateManyMemberInputEnvelope = {\n    data: shopping_ordersCreateManyMemberInput | shopping_ordersCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_coupon_usageCreateWithoutUserInput = {\n    id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    coupon: shopping_couponsCreateNestedOneWithoutShopping_coupon_usageInput\n  }\n\n  export type shopping_coupon_usageUncheckedCreateWithoutUserInput = {\n    id: string\n    shopping_coupon_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coupon_usageCreateOrConnectWithoutUserInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    create: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput>\n  }\n\n  export type shopping_coupon_usageCreateManyUserInputEnvelope = {\n    data: shopping_coupon_usageCreateManyUserInput | shopping_coupon_usageCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_coinsCreateWithoutMemberInput = {\n    id: string\n    balance: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_coinsUncheckedCreateWithoutMemberInput = {\n    id: string\n    balance: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_coinsCreateOrConnectWithoutMemberInput = {\n    where: shopping_coinsWhereUniqueInput\n    create: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsCreateWithoutMemberInput = {\n    id: string\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n    order?: shopping_ordersCreateNestedOneWithoutShopping_coin_transactionsInput\n  }\n\n  export type shopping_coin_transactionsUncheckedCreateWithoutMemberInput = {\n    id: string\n    shopping_order_id?: string | null\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_coin_transactionsCreateOrConnectWithoutMemberInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    create: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsCreateManyMemberInputEnvelope = {\n    data: shopping_coin_transactionsCreateManyMemberInput | shopping_coin_transactionsCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_inquiriesCreateWithoutCustomerInput = {\n    id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesCreateNestedManyWithoutInquiryInput\n  }\n\n  export type shopping_inquiriesUncheckedCreateWithoutCustomerInput = {\n    id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedCreateNestedManyWithoutInquiryInput\n  }\n\n  export type shopping_inquiriesCreateOrConnectWithoutCustomerInput = {\n    where: shopping_inquiriesWhereUniqueInput\n    create: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_inquiriesCreateManyCustomerInputEnvelope = {\n    data: shopping_inquiriesCreateManyCustomerInput | shopping_inquiriesCreateManyCustomerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_favoritesCreateWithoutMemberInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutFavoriteInput\n  }\n\n  export type shopping_favoritesUncheckedCreateWithoutMemberInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutFavoriteInput\n  }\n\n  export type shopping_favoritesCreateOrConnectWithoutMemberInput = {\n    where: shopping_favoritesWhereUniqueInput\n    create: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_favoritesCreateManyMemberInputEnvelope = {\n    data: shopping_favoritesCreateManyMemberInput | shopping_favoritesCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_article_commentsCreateWithoutMemberInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    article: shopping_articlesCreateNestedOneWithoutShopping_article_commentsInput\n  }\n\n  export type shopping_article_commentsUncheckedCreateWithoutMemberInput = {\n    id: string\n    shopping_article_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsCreateOrConnectWithoutMemberInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    create: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_article_commentsCreateManyMemberInputEnvelope = {\n    data: shopping_article_commentsCreateManyMemberInput | shopping_article_commentsCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_cartsUpsertWithWhereUniqueWithoutMemberInput = {\n    where: shopping_cartsWhereUniqueInput\n    update: XOR<shopping_cartsUpdateWithoutMemberInput, shopping_cartsUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_cartsCreateWithoutMemberInput, shopping_cartsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_cartsUpdateWithWhereUniqueWithoutMemberInput = {\n    where: shopping_cartsWhereUniqueInput\n    data: XOR<shopping_cartsUpdateWithoutMemberInput, shopping_cartsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_cartsUpdateManyWithWhereWithoutMemberInput = {\n    where: shopping_cartsScalarWhereInput\n    data: XOR<shopping_cartsUpdateManyMutationInput, shopping_cartsUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type shopping_cartsScalarWhereInput = {\n    AND?: shopping_cartsScalarWhereInput | shopping_cartsScalarWhereInput[]\n    OR?: shopping_cartsScalarWhereInput[]\n    NOT?: shopping_cartsScalarWhereInput | shopping_cartsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_carts\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_carts\"> | string\n    status?: StringFilter<\"shopping_carts\"> | string\n    created_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_carts\"> | Date | string\n  }\n\n  export type shopping_ordersUpsertWithWhereUniqueWithoutMemberInput = {\n    where: shopping_ordersWhereUniqueInput\n    update: XOR<shopping_ordersUpdateWithoutMemberInput, shopping_ordersUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_ordersCreateWithoutMemberInput, shopping_ordersUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_ordersUpdateWithWhereUniqueWithoutMemberInput = {\n    where: shopping_ordersWhereUniqueInput\n    data: XOR<shopping_ordersUpdateWithoutMemberInput, shopping_ordersUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_ordersUpdateManyWithWhereWithoutMemberInput = {\n    where: shopping_ordersScalarWhereInput\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type shopping_ordersScalarWhereInput = {\n    AND?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n    OR?: shopping_ordersScalarWhereInput[]\n    NOT?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n    id?: UuidFilter<\"shopping_orders\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_orders\"> | string\n    code?: StringFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n  }\n\n  export type shopping_coupon_usageUpsertWithWhereUniqueWithoutUserInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    update: XOR<shopping_coupon_usageUpdateWithoutUserInput, shopping_coupon_usageUncheckedUpdateWithoutUserInput>\n    create: XOR<shopping_coupon_usageCreateWithoutUserInput, shopping_coupon_usageUncheckedCreateWithoutUserInput>\n  }\n\n  export type shopping_coupon_usageUpdateWithWhereUniqueWithoutUserInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    data: XOR<shopping_coupon_usageUpdateWithoutUserInput, shopping_coupon_usageUncheckedUpdateWithoutUserInput>\n  }\n\n  export type shopping_coupon_usageUpdateManyWithWhereWithoutUserInput = {\n    where: shopping_coupon_usageScalarWhereInput\n    data: XOR<shopping_coupon_usageUpdateManyMutationInput, shopping_coupon_usageUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type shopping_coupon_usageScalarWhereInput = {\n    AND?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n    OR?: shopping_coupon_usageScalarWhereInput[]\n    NOT?: shopping_coupon_usageScalarWhereInput | shopping_coupon_usageScalarWhereInput[]\n    id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    shopping_coupon_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    order_id?: UuidFilter<\"shopping_coupon_usage\"> | string\n    used_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_coupon_usage\"> | Date | string\n  }\n\n  export type shopping_coinsUpsertWithoutMemberInput = {\n    update: XOR<shopping_coinsUpdateWithoutMemberInput, shopping_coinsUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_coinsCreateWithoutMemberInput, shopping_coinsUncheckedCreateWithoutMemberInput>\n    where?: shopping_coinsWhereInput\n  }\n\n  export type shopping_coinsUpdateToOneWithWhereWithoutMemberInput = {\n    where?: shopping_coinsWhereInput\n    data: XOR<shopping_coinsUpdateWithoutMemberInput, shopping_coinsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_coinsUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coinsUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    balance?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coin_transactionsUpsertWithWhereUniqueWithoutMemberInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    update: XOR<shopping_coin_transactionsUpdateWithoutMemberInput, shopping_coin_transactionsUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_coin_transactionsCreateWithoutMemberInput, shopping_coin_transactionsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsUpdateWithWhereUniqueWithoutMemberInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    data: XOR<shopping_coin_transactionsUpdateWithoutMemberInput, shopping_coin_transactionsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsUpdateManyWithWhereWithoutMemberInput = {\n    where: shopping_coin_transactionsScalarWhereInput\n    data: XOR<shopping_coin_transactionsUpdateManyMutationInput, shopping_coin_transactionsUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type shopping_coin_transactionsScalarWhereInput = {\n    AND?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n    OR?: shopping_coin_transactionsScalarWhereInput[]\n    NOT?: shopping_coin_transactionsScalarWhereInput | shopping_coin_transactionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_coin_transactions\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_coin_transactions\"> | string\n    shopping_order_id?: UuidNullableFilter<\"shopping_coin_transactions\"> | string | null\n    amount?: FloatFilter<\"shopping_coin_transactions\"> | number\n    transaction_type?: StringFilter<\"shopping_coin_transactions\"> | string\n    description?: StringNullableFilter<\"shopping_coin_transactions\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_coin_transactions\"> | Date | string\n  }\n\n  export type shopping_inquiriesUpsertWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_inquiriesWhereUniqueInput\n    update: XOR<shopping_inquiriesUpdateWithoutCustomerInput, shopping_inquiriesUncheckedUpdateWithoutCustomerInput>\n    create: XOR<shopping_inquiriesCreateWithoutCustomerInput, shopping_inquiriesUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_inquiriesUpdateWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_inquiriesWhereUniqueInput\n    data: XOR<shopping_inquiriesUpdateWithoutCustomerInput, shopping_inquiriesUncheckedUpdateWithoutCustomerInput>\n  }\n\n  export type shopping_inquiriesUpdateManyWithWhereWithoutCustomerInput = {\n    where: shopping_inquiriesScalarWhereInput\n    data: XOR<shopping_inquiriesUpdateManyMutationInput, shopping_inquiriesUncheckedUpdateManyWithoutCustomerInput>\n  }\n\n  export type shopping_inquiriesScalarWhereInput = {\n    AND?: shopping_inquiriesScalarWhereInput | shopping_inquiriesScalarWhereInput[]\n    OR?: shopping_inquiriesScalarWhereInput[]\n    NOT?: shopping_inquiriesScalarWhereInput | shopping_inquiriesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_inquiries\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_inquiries\"> | string\n    title?: StringFilter<\"shopping_inquiries\"> | string\n    content?: StringFilter<\"shopping_inquiries\"> | string\n    status?: StringFilter<\"shopping_inquiries\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiries\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiries\"> | Date | string | null\n  }\n\n  export type shopping_favoritesUpsertWithWhereUniqueWithoutMemberInput = {\n    where: shopping_favoritesWhereUniqueInput\n    update: XOR<shopping_favoritesUpdateWithoutMemberInput, shopping_favoritesUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_favoritesCreateWithoutMemberInput, shopping_favoritesUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_favoritesUpdateWithWhereUniqueWithoutMemberInput = {\n    where: shopping_favoritesWhereUniqueInput\n    data: XOR<shopping_favoritesUpdateWithoutMemberInput, shopping_favoritesUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_favoritesUpdateManyWithWhereWithoutMemberInput = {\n    where: shopping_favoritesScalarWhereInput\n    data: XOR<shopping_favoritesUpdateManyMutationInput, shopping_favoritesUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type shopping_favoritesScalarWhereInput = {\n    AND?: shopping_favoritesScalarWhereInput | shopping_favoritesScalarWhereInput[]\n    OR?: shopping_favoritesScalarWhereInput[]\n    NOT?: shopping_favoritesScalarWhereInput | shopping_favoritesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_favorites\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_favorites\"> | string\n    name?: StringFilter<\"shopping_favorites\"> | string\n    description?: StringNullableFilter<\"shopping_favorites\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_favorites\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_favorites\"> | Date | string | null\n  }\n\n  export type shopping_article_commentsUpsertWithWhereUniqueWithoutMemberInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    update: XOR<shopping_article_commentsUpdateWithoutMemberInput, shopping_article_commentsUncheckedUpdateWithoutMemberInput>\n    create: XOR<shopping_article_commentsCreateWithoutMemberInput, shopping_article_commentsUncheckedCreateWithoutMemberInput>\n  }\n\n  export type shopping_article_commentsUpdateWithWhereUniqueWithoutMemberInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    data: XOR<shopping_article_commentsUpdateWithoutMemberInput, shopping_article_commentsUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type shopping_article_commentsUpdateManyWithWhereWithoutMemberInput = {\n    where: shopping_article_commentsScalarWhereInput\n    data: XOR<shopping_article_commentsUpdateManyMutationInput, shopping_article_commentsUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type shopping_article_commentsScalarWhereInput = {\n    AND?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n    OR?: shopping_article_commentsScalarWhereInput[]\n    NOT?: shopping_article_commentsScalarWhereInput | shopping_article_commentsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_article_comments\"> | string\n    shopping_article_id?: UuidFilter<\"shopping_article_comments\"> | string\n    shopping_mall_member_id?: UuidFilter<\"shopping_article_comments\"> | string\n    content?: StringFilter<\"shopping_article_comments\"> | string\n    created_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_article_comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_article_comments\"> | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateWithoutAdminInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    inquiry: shopping_inquiriesCreateNestedOneWithoutShopping_inquiry_responsesInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedCreateWithoutAdminInput = {\n    id: string\n    shopping_inquiry_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateOrConnectWithoutAdminInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    create: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput>\n  }\n\n  export type shopping_inquiry_responsesCreateManyAdminInputEnvelope = {\n    data: shopping_inquiry_responsesCreateManyAdminInput | shopping_inquiry_responsesCreateManyAdminInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_inquiry_responsesUpsertWithWhereUniqueWithoutAdminInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    update: XOR<shopping_inquiry_responsesUpdateWithoutAdminInput, shopping_inquiry_responsesUncheckedUpdateWithoutAdminInput>\n    create: XOR<shopping_inquiry_responsesCreateWithoutAdminInput, shopping_inquiry_responsesUncheckedCreateWithoutAdminInput>\n  }\n\n  export type shopping_inquiry_responsesUpdateWithWhereUniqueWithoutAdminInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    data: XOR<shopping_inquiry_responsesUpdateWithoutAdminInput, shopping_inquiry_responsesUncheckedUpdateWithoutAdminInput>\n  }\n\n  export type shopping_inquiry_responsesUpdateManyWithWhereWithoutAdminInput = {\n    where: shopping_inquiry_responsesScalarWhereInput\n    data: XOR<shopping_inquiry_responsesUpdateManyMutationInput, shopping_inquiry_responsesUncheckedUpdateManyWithoutAdminInput>\n  }\n\n  export type shopping_inquiry_responsesScalarWhereInput = {\n    AND?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n    OR?: shopping_inquiry_responsesScalarWhereInput[]\n    NOT?: shopping_inquiry_responsesScalarWhereInput | shopping_inquiry_responsesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    shopping_inquiry_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    shopping_mall_admin_id?: UuidFilter<\"shopping_inquiry_responses\"> | string\n    content?: StringFilter<\"shopping_inquiry_responses\"> | string\n    created_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inquiry_responses\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_inquiry_responses\"> | Date | string | null\n  }\n\n  export type shopping_channelsCreateWithoutShopping_salesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_salesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_salesInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_salesInput, shopping_channelsUncheckedCreateWithoutShopping_salesInput>\n  }\n\n  export type shopping_sectionsCreateWithoutShopping_salesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutShopping_salesInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutSectionInput\n    shopping_articles?: shopping_articlesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutShopping_salesInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutShopping_salesInput, shopping_sectionsUncheckedCreateWithoutShopping_salesInput>\n  }\n\n  export type shopping_sale_snapshotsCreateWithoutSaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n  }\n\n  export type shopping_sale_snapshotsUncheckedCreateWithoutSaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n  }\n\n  export type shopping_sale_snapshotsCreateOrConnectWithoutSaleInput = {\n    where: shopping_sale_snapshotsWhereUniqueInput\n    create: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput>\n  }\n\n  export type shopping_sale_snapshotsCreateManySaleInputEnvelope = {\n    data: shopping_sale_snapshotsCreateManySaleInput | shopping_sale_snapshotsCreateManySaleInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_sale_unitsCreateWithoutSaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUncheckedCreateWithoutSaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsCreateOrConnectWithoutSaleInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    create: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput>\n  }\n\n  export type shopping_sale_unitsCreateManySaleInputEnvelope = {\n    data: shopping_sale_unitsCreateManySaleInput | shopping_sale_unitsCreateManySaleInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_salesInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_salesInput, shopping_channelsUncheckedUpdateWithoutShopping_salesInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_salesInput, shopping_channelsUncheckedCreateWithoutShopping_salesInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_salesInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_salesInput, shopping_channelsUncheckedUpdateWithoutShopping_salesInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_salesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_salesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_sectionsUpsertWithoutShopping_salesInput = {\n    update: XOR<shopping_sectionsUpdateWithoutShopping_salesInput, shopping_sectionsUncheckedUpdateWithoutShopping_salesInput>\n    create: XOR<shopping_sectionsCreateWithoutShopping_salesInput, shopping_sectionsUncheckedCreateWithoutShopping_salesInput>\n    where?: shopping_sectionsWhereInput\n  }\n\n  export type shopping_sectionsUpdateToOneWithWhereWithoutShopping_salesInput = {\n    where?: shopping_sectionsWhereInput\n    data: XOR<shopping_sectionsUpdateWithoutShopping_salesInput, shopping_sectionsUncheckedUpdateWithoutShopping_salesInput>\n  }\n\n  export type shopping_sectionsUpdateWithoutShopping_salesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutShopping_salesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sale_snapshotsUpsertWithWhereUniqueWithoutSaleInput = {\n    where: shopping_sale_snapshotsWhereUniqueInput\n    update: XOR<shopping_sale_snapshotsUpdateWithoutSaleInput, shopping_sale_snapshotsUncheckedUpdateWithoutSaleInput>\n    create: XOR<shopping_sale_snapshotsCreateWithoutSaleInput, shopping_sale_snapshotsUncheckedCreateWithoutSaleInput>\n  }\n\n  export type shopping_sale_snapshotsUpdateWithWhereUniqueWithoutSaleInput = {\n    where: shopping_sale_snapshotsWhereUniqueInput\n    data: XOR<shopping_sale_snapshotsUpdateWithoutSaleInput, shopping_sale_snapshotsUncheckedUpdateWithoutSaleInput>\n  }\n\n  export type shopping_sale_snapshotsUpdateManyWithWhereWithoutSaleInput = {\n    where: shopping_sale_snapshotsScalarWhereInput\n    data: XOR<shopping_sale_snapshotsUpdateManyMutationInput, shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleInput>\n  }\n\n  export type shopping_sale_snapshotsScalarWhereInput = {\n    AND?: shopping_sale_snapshotsScalarWhereInput | shopping_sale_snapshotsScalarWhereInput[]\n    OR?: shopping_sale_snapshotsScalarWhereInput[]\n    NOT?: shopping_sale_snapshotsScalarWhereInput | shopping_sale_snapshotsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sale_snapshots\"> | string\n    shopping_sale_id?: UuidFilter<\"shopping_sale_snapshots\"> | string\n    code?: StringFilter<\"shopping_sale_snapshots\"> | string\n    name?: StringFilter<\"shopping_sale_snapshots\"> | string\n    description?: StringNullableFilter<\"shopping_sale_snapshots\"> | string | null\n    price?: FloatFilter<\"shopping_sale_snapshots\"> | number\n    stock?: IntFilter<\"shopping_sale_snapshots\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_snapshots\"> | Date | string\n  }\n\n  export type shopping_sale_unitsUpsertWithWhereUniqueWithoutSaleInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    update: XOR<shopping_sale_unitsUpdateWithoutSaleInput, shopping_sale_unitsUncheckedUpdateWithoutSaleInput>\n    create: XOR<shopping_sale_unitsCreateWithoutSaleInput, shopping_sale_unitsUncheckedCreateWithoutSaleInput>\n  }\n\n  export type shopping_sale_unitsUpdateWithWhereUniqueWithoutSaleInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    data: XOR<shopping_sale_unitsUpdateWithoutSaleInput, shopping_sale_unitsUncheckedUpdateWithoutSaleInput>\n  }\n\n  export type shopping_sale_unitsUpdateManyWithWhereWithoutSaleInput = {\n    where: shopping_sale_unitsScalarWhereInput\n    data: XOR<shopping_sale_unitsUpdateManyMutationInput, shopping_sale_unitsUncheckedUpdateManyWithoutSaleInput>\n  }\n\n  export type shopping_sale_unitsScalarWhereInput = {\n    AND?: shopping_sale_unitsScalarWhereInput | shopping_sale_unitsScalarWhereInput[]\n    OR?: shopping_sale_unitsScalarWhereInput[]\n    NOT?: shopping_sale_unitsScalarWhereInput | shopping_sale_unitsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sale_units\"> | string\n    shopping_sale_id?: UuidFilter<\"shopping_sale_units\"> | string\n    code?: StringFilter<\"shopping_sale_units\"> | string\n    name?: StringFilter<\"shopping_sale_units\"> | string\n    description?: StringNullableFilter<\"shopping_sale_units\"> | string | null\n    price?: FloatFilter<\"shopping_sale_units\"> | number\n    stock?: IntFilter<\"shopping_sale_units\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_units\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_units\"> | Date | string | null\n  }\n\n  export type shopping_salesCreateWithoutShopping_sale_snapshotsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_salesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_salesInput\n    shopping_sale_units?: shopping_sale_unitsCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUncheckedCreateWithoutShopping_sale_snapshotsInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_units?: shopping_sale_unitsUncheckedCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesCreateOrConnectWithoutShopping_sale_snapshotsInput = {\n    where: shopping_salesWhereUniqueInput\n    create: XOR<shopping_salesCreateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedCreateWithoutShopping_sale_snapshotsInput>\n  }\n\n  export type shopping_salesUpsertWithoutShopping_sale_snapshotsInput = {\n    update: XOR<shopping_salesUpdateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedUpdateWithoutShopping_sale_snapshotsInput>\n    create: XOR<shopping_salesCreateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedCreateWithoutShopping_sale_snapshotsInput>\n    where?: shopping_salesWhereInput\n  }\n\n  export type shopping_salesUpdateToOneWithWhereWithoutShopping_sale_snapshotsInput = {\n    where?: shopping_salesWhereInput\n    data: XOR<shopping_salesUpdateWithoutShopping_sale_snapshotsInput, shopping_salesUncheckedUpdateWithoutShopping_sale_snapshotsInput>\n  }\n\n  export type shopping_salesUpdateWithoutShopping_sale_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_salesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_salesNestedInput\n    shopping_sale_units?: shopping_sale_unitsUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateWithoutShopping_sale_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_units?: shopping_sale_unitsUncheckedUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesCreateWithoutShopping_sale_unitsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_salesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_salesInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesUncheckedCreateWithoutShopping_sale_unitsInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedCreateNestedManyWithoutSaleInput\n  }\n\n  export type shopping_salesCreateOrConnectWithoutShopping_sale_unitsInput = {\n    where: shopping_salesWhereUniqueInput\n    create: XOR<shopping_salesCreateWithoutShopping_sale_unitsInput, shopping_salesUncheckedCreateWithoutShopping_sale_unitsInput>\n  }\n\n  export type shopping_sale_unit_optionsCreateWithoutSaleUnitInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsCreateOrConnectWithoutSaleUnitInput = {\n    where: shopping_sale_unit_optionsWhereUniqueInput\n    create: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_sale_unit_optionsCreateManySaleUnitInputEnvelope = {\n    data: shopping_sale_unit_optionsCreateManySaleUnitInput | shopping_sale_unit_optionsCreateManySaleUnitInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_cart_itemsCreateWithoutSaleUnitInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    cart: shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput = {\n    id: string\n    shopping_cart_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsCreateOrConnectWithoutSaleUnitInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    create: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_cart_itemsCreateManySaleUnitInputEnvelope = {\n    data: shopping_cart_itemsCreateManySaleUnitInput | shopping_cart_itemsCreateManySaleUnitInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_favorite_itemsCreateWithoutSaleUnitInput = {\n    id: string\n    created_at: Date | string\n    favorite: shopping_favoritesCreateNestedOneWithoutShopping_favorite_itemsInput\n  }\n\n  export type shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput = {\n    id: string\n    shopping_favorite_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_favorite_itemsCreateOrConnectWithoutSaleUnitInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    create: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_favorite_itemsCreateManySaleUnitInputEnvelope = {\n    data: shopping_favorite_itemsCreateManySaleUnitInput | shopping_favorite_itemsCreateManySaleUnitInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_salesUpsertWithoutShopping_sale_unitsInput = {\n    update: XOR<shopping_salesUpdateWithoutShopping_sale_unitsInput, shopping_salesUncheckedUpdateWithoutShopping_sale_unitsInput>\n    create: XOR<shopping_salesCreateWithoutShopping_sale_unitsInput, shopping_salesUncheckedCreateWithoutShopping_sale_unitsInput>\n    where?: shopping_salesWhereInput\n  }\n\n  export type shopping_salesUpdateToOneWithWhereWithoutShopping_sale_unitsInput = {\n    where?: shopping_salesWhereInput\n    data: XOR<shopping_salesUpdateWithoutShopping_sale_unitsInput, shopping_salesUncheckedUpdateWithoutShopping_sale_unitsInput>\n  }\n\n  export type shopping_salesUpdateWithoutShopping_sale_unitsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_salesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_salesNestedInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateWithoutShopping_sale_unitsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_sale_unit_optionsUpsertWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_sale_unit_optionsWhereUniqueInput\n    update: XOR<shopping_sale_unit_optionsUpdateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedUpdateWithoutSaleUnitInput>\n    create: XOR<shopping_sale_unit_optionsCreateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_sale_unit_optionsUpdateWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_sale_unit_optionsWhereUniqueInput\n    data: XOR<shopping_sale_unit_optionsUpdateWithoutSaleUnitInput, shopping_sale_unit_optionsUncheckedUpdateWithoutSaleUnitInput>\n  }\n\n  export type shopping_sale_unit_optionsUpdateManyWithWhereWithoutSaleUnitInput = {\n    where: shopping_sale_unit_optionsScalarWhereInput\n    data: XOR<shopping_sale_unit_optionsUpdateManyMutationInput, shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitInput>\n  }\n\n  export type shopping_sale_unit_optionsScalarWhereInput = {\n    AND?: shopping_sale_unit_optionsScalarWhereInput | shopping_sale_unit_optionsScalarWhereInput[]\n    OR?: shopping_sale_unit_optionsScalarWhereInput[]\n    NOT?: shopping_sale_unit_optionsScalarWhereInput | shopping_sale_unit_optionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sale_unit_options\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_sale_unit_options\"> | string\n    code?: StringFilter<\"shopping_sale_unit_options\"> | string\n    name?: StringFilter<\"shopping_sale_unit_options\"> | string\n    description?: StringNullableFilter<\"shopping_sale_unit_options\"> | string | null\n    price?: FloatFilter<\"shopping_sale_unit_options\"> | number\n    created_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sale_unit_options\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sale_unit_options\"> | Date | string | null\n  }\n\n  export type shopping_cart_itemsUpsertWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    update: XOR<shopping_cart_itemsUpdateWithoutSaleUnitInput, shopping_cart_itemsUncheckedUpdateWithoutSaleUnitInput>\n    create: XOR<shopping_cart_itemsCreateWithoutSaleUnitInput, shopping_cart_itemsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_cart_itemsUpdateWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    data: XOR<shopping_cart_itemsUpdateWithoutSaleUnitInput, shopping_cart_itemsUncheckedUpdateWithoutSaleUnitInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithWhereWithoutSaleUnitInput = {\n    where: shopping_cart_itemsScalarWhereInput\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitInput>\n  }\n\n  export type shopping_cart_itemsScalarWhereInput = {\n    AND?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n    OR?: shopping_cart_itemsScalarWhereInput[]\n    NOT?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n  }\n\n  export type shopping_favorite_itemsUpsertWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    update: XOR<shopping_favorite_itemsUpdateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedUpdateWithoutSaleUnitInput>\n    create: XOR<shopping_favorite_itemsCreateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedCreateWithoutSaleUnitInput>\n  }\n\n  export type shopping_favorite_itemsUpdateWithWhereUniqueWithoutSaleUnitInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    data: XOR<shopping_favorite_itemsUpdateWithoutSaleUnitInput, shopping_favorite_itemsUncheckedUpdateWithoutSaleUnitInput>\n  }\n\n  export type shopping_favorite_itemsUpdateManyWithWhereWithoutSaleUnitInput = {\n    where: shopping_favorite_itemsScalarWhereInput\n    data: XOR<shopping_favorite_itemsUpdateManyMutationInput, shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitInput>\n  }\n\n  export type shopping_favorite_itemsScalarWhereInput = {\n    AND?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n    OR?: shopping_favorite_itemsScalarWhereInput[]\n    NOT?: shopping_favorite_itemsScalarWhereInput | shopping_favorite_itemsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_favorite_items\"> | string\n    shopping_favorite_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    shopping_sale_unit_id?: UuidFilter<\"shopping_favorite_items\"> | string\n    created_at?: DateTimeFilter<\"shopping_favorite_items\"> | Date | string\n  }\n\n  export type shopping_sale_unitsCreateWithoutShopping_sale_unit_optionsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sale: shopping_salesCreateNestedOneWithoutShopping_sale_unitsInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUncheckedCreateWithoutShopping_sale_unit_optionsInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsCreateOrConnectWithoutShopping_sale_unit_optionsInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_sale_unit_optionsInput>\n  }\n\n  export type shopping_sale_unitsUpsertWithoutShopping_sale_unit_optionsInput = {\n    update: XOR<shopping_sale_unitsUpdateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_sale_unit_optionsInput>\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_sale_unit_optionsInput>\n    where?: shopping_sale_unitsWhereInput\n  }\n\n  export type shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_sale_unit_optionsInput = {\n    where?: shopping_sale_unitsWhereInput\n    data: XOR<shopping_sale_unitsUpdateWithoutShopping_sale_unit_optionsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_sale_unit_optionsInput>\n  }\n\n  export type shopping_sale_unitsUpdateWithoutShopping_sale_unit_optionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sale?: shopping_salesUpdateOneRequiredWithoutShopping_sale_unitsNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateWithoutShopping_sale_unit_optionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_cartsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_cartsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_cartsInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_cartsInput, shopping_mall_memberUncheckedCreateWithoutShopping_cartsInput>\n  }\n\n  export type shopping_cart_itemsCreateWithoutCartInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    saleUnit: shopping_sale_unitsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateWithoutCartInput = {\n    id: string\n    shopping_sale_unit_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsCreateOrConnectWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    create: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsCreateManyCartInputEnvelope = {\n    data: shopping_cart_itemsCreateManyCartInput | shopping_cart_itemsCreateManyCartInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_cartsInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_cartsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_cartsInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_cartsInput, shopping_mall_memberUncheckedCreateWithoutShopping_cartsInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_cartsInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_cartsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_cartsInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_cartsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_cartsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    update: XOR<shopping_cart_itemsUpdateWithoutCartInput, shopping_cart_itemsUncheckedUpdateWithoutCartInput>\n    create: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    data: XOR<shopping_cart_itemsUpdateWithoutCartInput, shopping_cart_itemsUncheckedUpdateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithWhereWithoutCartInput = {\n    where: shopping_cart_itemsScalarWhereInput\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyWithoutCartInput>\n  }\n\n  export type shopping_cartsCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_cartsInput\n  }\n\n  export type shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    shopping_mall_member_id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput = {\n    where: shopping_cartsWhereUniqueInput\n    create: XOR<shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_sale_unitsCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sale: shopping_salesCreateNestedOneWithoutShopping_sale_unitsInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUncheckedCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsCreateOrConnectWithoutShopping_cart_itemsInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_cartsUpsertWithoutShopping_cart_itemsInput = {\n    update: XOR<shopping_cartsUpdateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n    create: XOR<shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    where?: shopping_cartsWhereInput\n  }\n\n  export type shopping_cartsUpdateToOneWithWhereWithoutShopping_cart_itemsInput = {\n    where?: shopping_cartsWhereInput\n    data: XOR<shopping_cartsUpdateWithoutShopping_cart_itemsInput, shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_cartsUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_cartsNestedInput\n  }\n\n  export type shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_unitsUpsertWithoutShopping_cart_itemsInput = {\n    update: XOR<shopping_sale_unitsUpdateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_cart_itemsInput>\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_cart_itemsInput>\n    where?: shopping_sale_unitsWhereInput\n  }\n\n  export type shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_cart_itemsInput = {\n    where?: shopping_sale_unitsWhereInput\n    data: XOR<shopping_sale_unitsUpdateWithoutShopping_cart_itemsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_sale_unitsUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sale?: shopping_salesUpdateOneRequiredWithoutShopping_sale_unitsNestedInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_ordersInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_ordersInput, shopping_mall_memberUncheckedCreateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_order_snapshotsCreateWithoutOrderInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n  }\n\n  export type shopping_order_snapshotsUncheckedCreateWithoutOrderInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n  }\n\n  export type shopping_order_snapshotsCreateOrConnectWithoutOrderInput = {\n    where: shopping_order_snapshotsWhereUniqueInput\n    create: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_snapshotsCreateManyOrderInputEnvelope = {\n    data: shopping_order_snapshotsCreateManyOrderInput | shopping_order_snapshotsCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_order_itemsCreateWithoutOrderInput = {\n    id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUncheckedCreateWithoutOrderInput = {\n    id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsCreateOrConnectWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    create: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsCreateManyOrderInputEnvelope = {\n    data: shopping_order_itemsCreateManyOrderInput | shopping_order_itemsCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_coin_transactionsCreateWithoutOrderInput = {\n    id: string\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_coin_transactionsInput\n  }\n\n  export type shopping_coin_transactionsUncheckedCreateWithoutOrderInput = {\n    id: string\n    shopping_mall_member_id: string\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_coin_transactionsCreateOrConnectWithoutOrderInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    create: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_coin_transactionsCreateManyOrderInputEnvelope = {\n    data: shopping_coin_transactionsCreateManyOrderInput | shopping_coin_transactionsCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_ordersInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_ordersInput, shopping_mall_memberUncheckedUpdateWithoutShopping_ordersInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_ordersInput, shopping_mall_memberUncheckedCreateWithoutShopping_ordersInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_ordersInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_ordersInput, shopping_mall_memberUncheckedUpdateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_order_snapshotsUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_snapshotsWhereUniqueInput\n    update: XOR<shopping_order_snapshotsUpdateWithoutOrderInput, shopping_order_snapshotsUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_order_snapshotsCreateWithoutOrderInput, shopping_order_snapshotsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_snapshotsUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_snapshotsWhereUniqueInput\n    data: XOR<shopping_order_snapshotsUpdateWithoutOrderInput, shopping_order_snapshotsUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_order_snapshotsUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_order_snapshotsScalarWhereInput\n    data: XOR<shopping_order_snapshotsUpdateManyMutationInput, shopping_order_snapshotsUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_order_snapshotsScalarWhereInput = {\n    AND?: shopping_order_snapshotsScalarWhereInput | shopping_order_snapshotsScalarWhereInput[]\n    OR?: shopping_order_snapshotsScalarWhereInput[]\n    NOT?: shopping_order_snapshotsScalarWhereInput | shopping_order_snapshotsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_order_snapshots\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_snapshots\"> | string\n    code?: StringFilter<\"shopping_order_snapshots\"> | string\n    status?: StringFilter<\"shopping_order_snapshots\"> | string\n    total_amount?: FloatFilter<\"shopping_order_snapshots\"> | number\n    shipping_address?: StringFilter<\"shopping_order_snapshots\"> | string\n    payment_method?: StringFilter<\"shopping_order_snapshots\"> | string\n    created_at?: DateTimeFilter<\"shopping_order_snapshots\"> | Date | string\n  }\n\n  export type shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    update: XOR<shopping_order_itemsUpdateWithoutOrderInput, shopping_order_itemsUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    data: XOR<shopping_order_itemsUpdateWithoutOrderInput, shopping_order_itemsUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_order_itemsScalarWhereInput\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsScalarWhereInput = {\n    AND?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n    OR?: shopping_order_itemsScalarWhereInput[]\n    NOT?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    product_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n  }\n\n  export type shopping_coin_transactionsUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    update: XOR<shopping_coin_transactionsUpdateWithoutOrderInput, shopping_coin_transactionsUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_coin_transactionsCreateWithoutOrderInput, shopping_coin_transactionsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_coin_transactionsUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_coin_transactionsWhereUniqueInput\n    data: XOR<shopping_coin_transactionsUpdateWithoutOrderInput, shopping_coin_transactionsUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_coin_transactionsUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_coin_transactionsScalarWhereInput\n    data: XOR<shopping_coin_transactionsUpdateManyMutationInput, shopping_coin_transactionsUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_ordersCreateWithoutShopping_order_snapshotsInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_order_snapshotsInput = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_order_snapshotsInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedCreateWithoutShopping_order_snapshotsInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_order_snapshotsInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_snapshotsInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedCreateWithoutShopping_order_snapshotsInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_order_snapshotsInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_order_snapshotsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_snapshotsInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_order_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_order_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersCreateWithoutShopping_order_itemsInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_snapshots?: shopping_order_snapshotsCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_order_itemsInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_order_itemsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_order_itemsInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_order_itemsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_snapshots?: shopping_order_snapshotsUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_coupon_usageCreateWithoutCouponInput = {\n    id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    user: shopping_mall_memberCreateNestedOneWithoutShopping_coupon_usageInput\n  }\n\n  export type shopping_coupon_usageUncheckedCreateWithoutCouponInput = {\n    id: string\n    shopping_mall_member_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coupon_usageCreateOrConnectWithoutCouponInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    create: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput>\n  }\n\n  export type shopping_coupon_usageCreateManyCouponInputEnvelope = {\n    data: shopping_coupon_usageCreateManyCouponInput | shopping_coupon_usageCreateManyCouponInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_coupon_usageUpsertWithWhereUniqueWithoutCouponInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    update: XOR<shopping_coupon_usageUpdateWithoutCouponInput, shopping_coupon_usageUncheckedUpdateWithoutCouponInput>\n    create: XOR<shopping_coupon_usageCreateWithoutCouponInput, shopping_coupon_usageUncheckedCreateWithoutCouponInput>\n  }\n\n  export type shopping_coupon_usageUpdateWithWhereUniqueWithoutCouponInput = {\n    where: shopping_coupon_usageWhereUniqueInput\n    data: XOR<shopping_coupon_usageUpdateWithoutCouponInput, shopping_coupon_usageUncheckedUpdateWithoutCouponInput>\n  }\n\n  export type shopping_coupon_usageUpdateManyWithWhereWithoutCouponInput = {\n    where: shopping_coupon_usageScalarWhereInput\n    data: XOR<shopping_coupon_usageUpdateManyMutationInput, shopping_coupon_usageUncheckedUpdateManyWithoutCouponInput>\n  }\n\n  export type shopping_couponsCreateWithoutShopping_coupon_usageInput = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date | string\n    valid_until: Date | string\n    max_uses?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_couponsUncheckedCreateWithoutShopping_coupon_usageInput = {\n    id: string\n    code: string\n    discount_type: string\n    value: number\n    valid_from: Date | string\n    valid_until: Date | string\n    max_uses?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_couponsCreateOrConnectWithoutShopping_coupon_usageInput = {\n    where: shopping_couponsWhereUniqueInput\n    create: XOR<shopping_couponsCreateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedCreateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_coupon_usageInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_coupon_usageInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_coupon_usageInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedCreateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_couponsUpsertWithoutShopping_coupon_usageInput = {\n    update: XOR<shopping_couponsUpdateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedUpdateWithoutShopping_coupon_usageInput>\n    create: XOR<shopping_couponsCreateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedCreateWithoutShopping_coupon_usageInput>\n    where?: shopping_couponsWhereInput\n  }\n\n  export type shopping_couponsUpdateToOneWithWhereWithoutShopping_coupon_usageInput = {\n    where?: shopping_couponsWhereInput\n    data: XOR<shopping_couponsUpdateWithoutShopping_coupon_usageInput, shopping_couponsUncheckedUpdateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_couponsUpdateWithoutShopping_coupon_usageInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_couponsUncheckedUpdateWithoutShopping_coupon_usageInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    discount_type?: StringFieldUpdateOperationsInput | string\n    value?: FloatFieldUpdateOperationsInput | number\n    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string\n    valid_until?: DateTimeFieldUpdateOperationsInput | Date | string\n    max_uses?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_coupon_usageInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coupon_usageInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedCreateWithoutShopping_coupon_usageInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coupon_usageInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_coupon_usageInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coupon_usageInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_coupon_usageInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_coupon_usageInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_coinsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_coinsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_coinsInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coinsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coinsInput>\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_coinsInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_coinsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coinsInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coinsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coinsInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coinsInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_coinsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coinsInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_coinsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_coinsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_coin_transactionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_coin_transactionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_coin_transactionsInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_ordersCreateWithoutShopping_coin_transactionsInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_snapshots?: shopping_order_snapshotsCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_coin_transactionsInput = {\n    id: string\n    shopping_mall_member_id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_coin_transactionsInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedCreateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_coin_transactionsInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coin_transactionsInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedCreateWithoutShopping_coin_transactionsInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_coin_transactionsInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_coin_transactionsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_coin_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_coin_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_coin_transactionsInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedUpdateWithoutShopping_coin_transactionsInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedCreateWithoutShopping_coin_transactionsInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_coin_transactionsInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_coin_transactionsInput, shopping_ordersUncheckedUpdateWithoutShopping_coin_transactionsInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_coin_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_snapshots?: shopping_order_snapshotsUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_coin_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_inquiriesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_inquiriesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_inquiriesInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedCreateWithoutShopping_inquiriesInput>\n  }\n\n  export type shopping_inquiry_responsesCreateWithoutInquiryInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    admin: shopping_mall_adminCreateNestedOneWithoutShopping_inquiry_responsesInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput = {\n    id: string\n    shopping_mall_admin_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateOrConnectWithoutInquiryInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    create: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput>\n  }\n\n  export type shopping_inquiry_responsesCreateManyInquiryInputEnvelope = {\n    data: shopping_inquiry_responsesCreateManyInquiryInput | shopping_inquiry_responsesCreateManyInquiryInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_inquiriesInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedUpdateWithoutShopping_inquiriesInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedCreateWithoutShopping_inquiriesInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_inquiriesInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_inquiriesInput, shopping_mall_memberUncheckedUpdateWithoutShopping_inquiriesInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_inquiriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_inquiriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_inquiry_responsesUpsertWithWhereUniqueWithoutInquiryInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    update: XOR<shopping_inquiry_responsesUpdateWithoutInquiryInput, shopping_inquiry_responsesUncheckedUpdateWithoutInquiryInput>\n    create: XOR<shopping_inquiry_responsesCreateWithoutInquiryInput, shopping_inquiry_responsesUncheckedCreateWithoutInquiryInput>\n  }\n\n  export type shopping_inquiry_responsesUpdateWithWhereUniqueWithoutInquiryInput = {\n    where: shopping_inquiry_responsesWhereUniqueInput\n    data: XOR<shopping_inquiry_responsesUpdateWithoutInquiryInput, shopping_inquiry_responsesUncheckedUpdateWithoutInquiryInput>\n  }\n\n  export type shopping_inquiry_responsesUpdateManyWithWhereWithoutInquiryInput = {\n    where: shopping_inquiry_responsesScalarWhereInput\n    data: XOR<shopping_inquiry_responsesUpdateManyMutationInput, shopping_inquiry_responsesUncheckedUpdateManyWithoutInquiryInput>\n  }\n\n  export type shopping_inquiriesCreateWithoutShopping_inquiry_responsesInput = {\n    id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_mall_memberCreateNestedOneWithoutShopping_inquiriesInput\n  }\n\n  export type shopping_inquiriesUncheckedCreateWithoutShopping_inquiry_responsesInput = {\n    id: string\n    shopping_mall_member_id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiriesCreateOrConnectWithoutShopping_inquiry_responsesInput = {\n    where: shopping_inquiriesWhereUniqueInput\n    create: XOR<shopping_inquiriesCreateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedCreateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_mall_adminCreateWithoutShopping_inquiry_responsesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_adminUncheckedCreateWithoutShopping_inquiry_responsesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_mall_adminCreateOrConnectWithoutShopping_inquiry_responsesInput = {\n    where: shopping_mall_adminWhereUniqueInput\n    create: XOR<shopping_mall_adminCreateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedCreateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_inquiriesUpsertWithoutShopping_inquiry_responsesInput = {\n    update: XOR<shopping_inquiriesUpdateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n    create: XOR<shopping_inquiriesCreateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    where?: shopping_inquiriesWhereInput\n  }\n\n  export type shopping_inquiriesUpdateToOneWithWhereWithoutShopping_inquiry_responsesInput = {\n    where?: shopping_inquiriesWhereInput\n    data: XOR<shopping_inquiriesUpdateWithoutShopping_inquiry_responsesInput, shopping_inquiriesUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_inquiriesUpdateWithoutShopping_inquiry_responsesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_mall_memberUpdateOneRequiredWithoutShopping_inquiriesNestedInput\n  }\n\n  export type shopping_inquiriesUncheckedUpdateWithoutShopping_inquiry_responsesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_adminUpsertWithoutShopping_inquiry_responsesInput = {\n    update: XOR<shopping_mall_adminUpdateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n    create: XOR<shopping_mall_adminCreateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedCreateWithoutShopping_inquiry_responsesInput>\n    where?: shopping_mall_adminWhereInput\n  }\n\n  export type shopping_mall_adminUpdateToOneWithWhereWithoutShopping_inquiry_responsesInput = {\n    where?: shopping_mall_adminWhereInput\n    data: XOR<shopping_mall_adminUpdateWithoutShopping_inquiry_responsesInput, shopping_mall_adminUncheckedUpdateWithoutShopping_inquiry_responsesInput>\n  }\n\n  export type shopping_mall_adminUpdateWithoutShopping_inquiry_responsesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_adminUncheckedUpdateWithoutShopping_inquiry_responsesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_favoritesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_article_comments?: shopping_article_commentsCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_favoritesInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_article_comments?: shopping_article_commentsUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_favoritesInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedCreateWithoutShopping_favoritesInput>\n  }\n\n  export type shopping_favorite_itemsCreateWithoutFavoriteInput = {\n    id: string\n    created_at: Date | string\n    saleUnit: shopping_sale_unitsCreateNestedOneWithoutShopping_favorite_itemsInput\n  }\n\n  export type shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput = {\n    id: string\n    shopping_sale_unit_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_favorite_itemsCreateOrConnectWithoutFavoriteInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    create: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput>\n  }\n\n  export type shopping_favorite_itemsCreateManyFavoriteInputEnvelope = {\n    data: shopping_favorite_itemsCreateManyFavoriteInput | shopping_favorite_itemsCreateManyFavoriteInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_favoritesInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedUpdateWithoutShopping_favoritesInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedCreateWithoutShopping_favoritesInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_favoritesInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_favoritesInput, shopping_mall_memberUncheckedUpdateWithoutShopping_favoritesInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_favoritesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_favoritesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_favorite_itemsUpsertWithWhereUniqueWithoutFavoriteInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    update: XOR<shopping_favorite_itemsUpdateWithoutFavoriteInput, shopping_favorite_itemsUncheckedUpdateWithoutFavoriteInput>\n    create: XOR<shopping_favorite_itemsCreateWithoutFavoriteInput, shopping_favorite_itemsUncheckedCreateWithoutFavoriteInput>\n  }\n\n  export type shopping_favorite_itemsUpdateWithWhereUniqueWithoutFavoriteInput = {\n    where: shopping_favorite_itemsWhereUniqueInput\n    data: XOR<shopping_favorite_itemsUpdateWithoutFavoriteInput, shopping_favorite_itemsUncheckedUpdateWithoutFavoriteInput>\n  }\n\n  export type shopping_favorite_itemsUpdateManyWithWhereWithoutFavoriteInput = {\n    where: shopping_favorite_itemsScalarWhereInput\n    data: XOR<shopping_favorite_itemsUpdateManyMutationInput, shopping_favorite_itemsUncheckedUpdateManyWithoutFavoriteInput>\n  }\n\n  export type shopping_favoritesCreateWithoutShopping_favorite_itemsInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_favoritesInput\n  }\n\n  export type shopping_favoritesUncheckedCreateWithoutShopping_favorite_itemsInput = {\n    id: string\n    shopping_mall_member_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_favoritesCreateOrConnectWithoutShopping_favorite_itemsInput = {\n    where: shopping_favoritesWhereUniqueInput\n    create: XOR<shopping_favoritesCreateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedCreateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_sale_unitsCreateWithoutShopping_favorite_itemsInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sale: shopping_salesCreateNestedOneWithoutShopping_sale_unitsInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsUncheckedCreateWithoutShopping_favorite_itemsInput = {\n    id: string\n    shopping_sale_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedCreateNestedManyWithoutSaleUnitInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutSaleUnitInput\n  }\n\n  export type shopping_sale_unitsCreateOrConnectWithoutShopping_favorite_itemsInput = {\n    where: shopping_sale_unitsWhereUniqueInput\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_favoritesUpsertWithoutShopping_favorite_itemsInput = {\n    update: XOR<shopping_favoritesUpdateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedUpdateWithoutShopping_favorite_itemsInput>\n    create: XOR<shopping_favoritesCreateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedCreateWithoutShopping_favorite_itemsInput>\n    where?: shopping_favoritesWhereInput\n  }\n\n  export type shopping_favoritesUpdateToOneWithWhereWithoutShopping_favorite_itemsInput = {\n    where?: shopping_favoritesWhereInput\n    data: XOR<shopping_favoritesUpdateWithoutShopping_favorite_itemsInput, shopping_favoritesUncheckedUpdateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_favoritesUpdateWithoutShopping_favorite_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_favoritesNestedInput\n  }\n\n  export type shopping_favoritesUncheckedUpdateWithoutShopping_favorite_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unitsUpsertWithoutShopping_favorite_itemsInput = {\n    update: XOR<shopping_sale_unitsUpdateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_favorite_itemsInput>\n    create: XOR<shopping_sale_unitsCreateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedCreateWithoutShopping_favorite_itemsInput>\n    where?: shopping_sale_unitsWhereInput\n  }\n\n  export type shopping_sale_unitsUpdateToOneWithWhereWithoutShopping_favorite_itemsInput = {\n    where?: shopping_sale_unitsWhereInput\n    data: XOR<shopping_sale_unitsUpdateWithoutShopping_favorite_itemsInput, shopping_sale_unitsUncheckedUpdateWithoutShopping_favorite_itemsInput>\n  }\n\n  export type shopping_sale_unitsUpdateWithoutShopping_favorite_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sale?: shopping_salesUpdateOneRequiredWithoutShopping_sale_unitsNestedInput\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateWithoutShopping_favorite_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_channelsCreateWithoutShopping_articlesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_articlesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_articlesInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_articlesInput, shopping_channelsUncheckedCreateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_sectionsCreateWithoutShopping_articlesInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n    shopping_configurations?: shopping_configurationsCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutShopping_articlesInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedCreateNestedManyWithoutSectionInput\n    shopping_sales?: shopping_salesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutShopping_articlesInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutShopping_articlesInput, shopping_sectionsUncheckedCreateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_article_commentsCreateWithoutArticleInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    member: shopping_mall_memberCreateNestedOneWithoutShopping_article_commentsInput\n  }\n\n  export type shopping_article_commentsUncheckedCreateWithoutArticleInput = {\n    id: string\n    shopping_mall_member_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsCreateOrConnectWithoutArticleInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    create: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput>\n  }\n\n  export type shopping_article_commentsCreateManyArticleInputEnvelope = {\n    data: shopping_article_commentsCreateManyArticleInput | shopping_article_commentsCreateManyArticleInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_articlesInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_articlesInput, shopping_channelsUncheckedUpdateWithoutShopping_articlesInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_articlesInput, shopping_channelsUncheckedCreateWithoutShopping_articlesInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_articlesInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_articlesInput, shopping_channelsUncheckedUpdateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_articlesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_articlesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_sectionsUpsertWithoutShopping_articlesInput = {\n    update: XOR<shopping_sectionsUpdateWithoutShopping_articlesInput, shopping_sectionsUncheckedUpdateWithoutShopping_articlesInput>\n    create: XOR<shopping_sectionsCreateWithoutShopping_articlesInput, shopping_sectionsUncheckedCreateWithoutShopping_articlesInput>\n    where?: shopping_sectionsWhereInput\n  }\n\n  export type shopping_sectionsUpdateToOneWithWhereWithoutShopping_articlesInput = {\n    where?: shopping_sectionsWhereInput\n    data: XOR<shopping_sectionsUpdateWithoutShopping_articlesInput, shopping_sectionsUncheckedUpdateWithoutShopping_articlesInput>\n  }\n\n  export type shopping_sectionsUpdateWithoutShopping_articlesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutShopping_articlesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_article_commentsUpsertWithWhereUniqueWithoutArticleInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    update: XOR<shopping_article_commentsUpdateWithoutArticleInput, shopping_article_commentsUncheckedUpdateWithoutArticleInput>\n    create: XOR<shopping_article_commentsCreateWithoutArticleInput, shopping_article_commentsUncheckedCreateWithoutArticleInput>\n  }\n\n  export type shopping_article_commentsUpdateWithWhereUniqueWithoutArticleInput = {\n    where: shopping_article_commentsWhereUniqueInput\n    data: XOR<shopping_article_commentsUpdateWithoutArticleInput, shopping_article_commentsUncheckedUpdateWithoutArticleInput>\n  }\n\n  export type shopping_article_commentsUpdateManyWithWhereWithoutArticleInput = {\n    where: shopping_article_commentsScalarWhereInput\n    data: XOR<shopping_article_commentsUpdateManyMutationInput, shopping_article_commentsUncheckedUpdateManyWithoutArticleInput>\n  }\n\n  export type shopping_articlesCreateWithoutShopping_article_commentsInput = {\n    id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_articlesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_articlesInput\n  }\n\n  export type shopping_articlesUncheckedCreateWithoutShopping_article_commentsInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_articlesCreateOrConnectWithoutShopping_article_commentsInput = {\n    where: shopping_articlesWhereUniqueInput\n    create: XOR<shopping_articlesCreateWithoutShopping_article_commentsInput, shopping_articlesUncheckedCreateWithoutShopping_article_commentsInput>\n  }\n\n  export type shopping_mall_memberCreateWithoutShopping_article_commentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberUncheckedCreateWithoutShopping_article_commentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_carts?: shopping_cartsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutMemberInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedCreateNestedManyWithoutUserInput\n    shopping_coins?: shopping_coinsUncheckedCreateNestedOneWithoutMemberInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedCreateNestedManyWithoutMemberInput\n    shopping_inquiries?: shopping_inquiriesUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_favorites?: shopping_favoritesUncheckedCreateNestedManyWithoutMemberInput\n  }\n\n  export type shopping_mall_memberCreateOrConnectWithoutShopping_article_commentsInput = {\n    where: shopping_mall_memberWhereUniqueInput\n    create: XOR<shopping_mall_memberCreateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedCreateWithoutShopping_article_commentsInput>\n  }\n\n  export type shopping_articlesUpsertWithoutShopping_article_commentsInput = {\n    update: XOR<shopping_articlesUpdateWithoutShopping_article_commentsInput, shopping_articlesUncheckedUpdateWithoutShopping_article_commentsInput>\n    create: XOR<shopping_articlesCreateWithoutShopping_article_commentsInput, shopping_articlesUncheckedCreateWithoutShopping_article_commentsInput>\n    where?: shopping_articlesWhereInput\n  }\n\n  export type shopping_articlesUpdateToOneWithWhereWithoutShopping_article_commentsInput = {\n    where?: shopping_articlesWhereInput\n    data: XOR<shopping_articlesUpdateWithoutShopping_article_commentsInput, shopping_articlesUncheckedUpdateWithoutShopping_article_commentsInput>\n  }\n\n  export type shopping_articlesUpdateWithoutShopping_article_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_articlesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_articlesNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateWithoutShopping_article_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_mall_memberUpsertWithoutShopping_article_commentsInput = {\n    update: XOR<shopping_mall_memberUpdateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_article_commentsInput>\n    create: XOR<shopping_mall_memberCreateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedCreateWithoutShopping_article_commentsInput>\n    where?: shopping_mall_memberWhereInput\n  }\n\n  export type shopping_mall_memberUpdateToOneWithWhereWithoutShopping_article_commentsInput = {\n    where?: shopping_mall_memberWhereInput\n    data: XOR<shopping_mall_memberUpdateWithoutShopping_article_commentsInput, shopping_mall_memberUncheckedUpdateWithoutShopping_article_commentsInput>\n  }\n\n  export type shopping_mall_memberUpdateWithoutShopping_article_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_mall_memberUncheckedUpdateWithoutShopping_article_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_carts?: shopping_cartsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_coupon_usage?: shopping_coupon_usageUncheckedUpdateManyWithoutUserNestedInput\n    shopping_coins?: shopping_coinsUncheckedUpdateOneWithoutMemberNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutMemberNestedInput\n    shopping_inquiries?: shopping_inquiriesUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_favorites?: shopping_favoritesUncheckedUpdateManyWithoutMemberNestedInput\n  }\n\n  export type shopping_sectionsCreateManyChannelInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsCreateManyChannelInput = {\n    id: string\n    shopping_section_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_salesCreateManyChannelInput = {\n    id: string\n    shopping_section_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_articlesCreateManyChannelInput = {\n    id: string\n    shopping_section_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_configurations?: shopping_configurationsUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_sales?: shopping_salesUncheckedUpdateManyWithoutSectionNestedInput\n    shopping_articles?: shopping_articlesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    section?: shopping_sectionsUpdateOneWithoutShopping_configurationsNestedInput\n  }\n\n  export type shopping_configurationsUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_salesUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_salesNestedInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_articlesUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_articlesNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsCreateManySectionInput = {\n    id: string\n    shopping_channel_id?: string | null\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_salesCreateManySectionInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_articlesCreateManySectionInput = {\n    id: string\n    shopping_channel_id: string\n    code: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_configurationsUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneWithoutShopping_configurationsNestedInput\n  }\n\n  export type shopping_configurationsUncheckedUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_configurationsUncheckedUpdateManyWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: NullableStringFieldUpdateOperationsInput | string | null\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_salesUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_salesNestedInput\n    shopping_sale_snapshots?: shopping_sale_snapshotsUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_snapshots?: shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleNestedInput\n    shopping_sale_units?: shopping_sale_unitsUncheckedUpdateManyWithoutSaleNestedInput\n  }\n\n  export type shopping_salesUncheckedUpdateManyWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_articlesUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_articlesNestedInput\n    shopping_article_comments?: shopping_article_commentsUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_article_comments?: shopping_article_commentsUncheckedUpdateManyWithoutArticleNestedInput\n  }\n\n  export type shopping_articlesUncheckedUpdateManyWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_cartsCreateManyMemberInput = {\n    id: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_ordersCreateManyMemberInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_coupon_usageCreateManyUserInput = {\n    id: string\n    shopping_coupon_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coin_transactionsCreateManyMemberInput = {\n    id: string\n    shopping_order_id?: string | null\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_inquiriesCreateManyCustomerInput = {\n    id: string\n    title: string\n    content: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_favoritesCreateManyMemberInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsCreateManyMemberInput = {\n    id: string\n    shopping_article_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_cartsUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_cartsUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_cartsUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_ordersUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_snapshots?: shopping_order_snapshotsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_coin_transactions?: shopping_coin_transactionsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_coupon_usageUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    coupon?: shopping_couponsUpdateOneRequiredWithoutShopping_coupon_usageNestedInput\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_coupon_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_coupon_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneWithoutShopping_coin_transactionsNestedInput\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: NullableStringFieldUpdateOperationsInput | string | null\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: NullableStringFieldUpdateOperationsInput | string | null\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_inquiriesUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUpdateManyWithoutInquiryNestedInput\n  }\n\n  export type shopping_inquiriesUncheckedUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_inquiry_responses?: shopping_inquiry_responsesUncheckedUpdateManyWithoutInquiryNestedInput\n  }\n\n  export type shopping_inquiriesUncheckedUpdateManyWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_favoritesUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutFavoriteNestedInput\n  }\n\n  export type shopping_favoritesUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutFavoriteNestedInput\n  }\n\n  export type shopping_favoritesUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    article?: shopping_articlesUpdateOneRequiredWithoutShopping_article_commentsNestedInput\n  }\n\n  export type shopping_article_commentsUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_article_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_article_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesCreateManyAdminInput = {\n    id: string\n    shopping_inquiry_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    inquiry?: shopping_inquiriesUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_inquiry_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateManyWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_inquiry_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_snapshotsCreateManySaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n  }\n\n  export type shopping_sale_unitsCreateManySaleInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    stock: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sale_snapshotsUpdateWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_snapshotsUncheckedUpdateWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_snapshotsUncheckedUpdateManyWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sale_unitsUpdateWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sale_unit_options?: shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n    shopping_favorite_items?: shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitNestedInput\n  }\n\n  export type shopping_sale_unitsUncheckedUpdateManyWithoutSaleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    stock?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsCreateManySaleUnitInput = {\n    id: string\n    code: string\n    name: string\n    description?: string | null\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_cart_itemsCreateManySaleUnitInput = {\n    id: string\n    shopping_cart_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_favorite_itemsCreateManySaleUnitInput = {\n    id: string\n    shopping_favorite_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_sale_unit_optionsUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUncheckedUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sale_unit_optionsUncheckedUpdateManyWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_cart_itemsUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    cart?: shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_favorite_itemsUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    favorite?: shopping_favoritesUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_favorite_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateManyWithoutSaleUnitInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_favorite_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateManyCartInput = {\n    id: string\n    shopping_sale_unit_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    saleUnit?: shopping_sale_unitsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_snapshotsCreateManyOrderInput = {\n    id: string\n    code: string\n    status: string\n    total_amount: number\n    shipping_address: string\n    payment_method: string\n    created_at: Date | string\n  }\n\n  export type shopping_order_itemsCreateManyOrderInput = {\n    id: string\n    product_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coin_transactionsCreateManyOrderInput = {\n    id: string\n    shopping_mall_member_id: string\n    amount: number\n    transaction_type: string\n    description?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_order_snapshotsUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_snapshotsUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_snapshotsUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    code?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_coin_transactionsNestedInput\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coin_transactionsUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageCreateManyCouponInput = {\n    id: string\n    shopping_mall_member_id: string\n    order_id: string\n    used_at: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_coupon_usageUpdateWithoutCouponInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: shopping_mall_memberUpdateOneRequiredWithoutShopping_coupon_usageNestedInput\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateWithoutCouponInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_coupon_usageUncheckedUpdateManyWithoutCouponInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    order_id?: StringFieldUpdateOperationsInput | string\n    used_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_inquiry_responsesCreateManyInquiryInput = {\n    id: string\n    shopping_mall_admin_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUpdateWithoutInquiryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    admin?: shopping_mall_adminUpdateOneRequiredWithoutShopping_inquiry_responsesNestedInput\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateWithoutInquiryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_admin_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_inquiry_responsesUncheckedUpdateManyWithoutInquiryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_admin_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_favorite_itemsCreateManyFavoriteInput = {\n    id: string\n    shopping_sale_unit_id: string\n    created_at: Date | string\n  }\n\n  export type shopping_favorite_itemsUpdateWithoutFavoriteInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    saleUnit?: shopping_sale_unitsUpdateOneRequiredWithoutShopping_favorite_itemsNestedInput\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateWithoutFavoriteInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_favorite_itemsUncheckedUpdateManyWithoutFavoriteInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_sale_unit_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_article_commentsCreateManyArticleInput = {\n    id: string\n    shopping_mall_member_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_article_commentsUpdateWithoutArticleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    member?: shopping_mall_memberUpdateOneRequiredWithoutShopping_article_commentsNestedInput\n  }\n\n  export type shopping_article_commentsUncheckedUpdateWithoutArticleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_article_commentsUncheckedUpdateManyWithoutArticleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_mall_member_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Systematic](#systematic)\n- [Actors](#actors)\n- [Sales](#sales)\n- [Carts](#carts)\n- [Orders](#orders)\n- [Coupons](#coupons)\n- [Coins](#coins)\n- [Inquiries](#inquiries)\n- [Favorites](#favorites)\n- [Articles](#articles)\n\n## Systematic\n\n```mermaid\nerDiagram\n\"shopping_channels\" {\n  String id PK\n  String code UK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" {\n  String id PK\n  String shopping_channel_id FK\n  String code\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_configurations\" {\n  String id PK\n  String shopping_channel_id FK \"nullable\"\n  String shopping_section_id FK \"nullable\"\n  String key\n  String value\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" }o--|| \"shopping_channels\" : channel\n\"shopping_configurations\" }o--o| \"shopping_channels\" : channel\n\"shopping_configurations\" }o--o| \"shopping_sections\" : section\n```\n\n### `shopping_channels`\n\nRepresents the shopping channels available in the system. Each channel\nhas a unique code and name, and is associated with a specific mall.\nChannels are the top-level organizational units for products and\nservices.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `code`: Unique code identifying the channel.\n- `name`: Name of the channel.\n- `description`: Description of the channel.\n- `created_at`: Timestamp when the channel was created.\n- `updated_at`: Timestamp when the channel was last updated.\n- `deleted_at`: Timestamp when the channel was deleted (soft delete).\n\n### `shopping_sections`\n\nRepresents the sections within a shopping channel. Each section has a\nunique code and name, and is associated with a specific channel. Sections\nhelp organize products and services within a channel.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`: The channel to which this section belongs. [shopping_channels.id](#shopping_channels)\n- `code`: Unique code identifying the section.\n- `name`: Name of the section.\n- `description`: Description of the section.\n- `created_at`: Timestamp when the section was created.\n- `updated_at`: Timestamp when the section was last updated.\n- `deleted_at`: Timestamp when the section was deleted (soft delete).\n\n### `shopping_configurations`\n\nRepresents the configurations for a shopping channel or section. Each\nconfiguration has a unique key and value, and is associated with a\nspecific channel or section. Configurations define system behavior and\nsettings for different parts of the system.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`\n  > The channel to which this configuration belongs. {@link\n  > shopping_channels.id}\n- `shopping_section_id`\n  > The section to which this configuration belongs. {@link\n  > shopping_sections.id}\n- `key`: Unique key identifying the configuration.\n- `value`: Value of the configuration.\n- `description`: Description of the configuration.\n- `created_at`: Timestamp when the configuration was created.\n- `updated_at`: Timestamp when the configuration was last updated.\n- `deleted_at`: Timestamp when the configuration was deleted (soft delete).\n\n## Actors\n\n```mermaid\nerDiagram\n\"shopping_mall_guest\" {\n  String id PK\n  String session_id UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_mall_member\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String address \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_mall_seller\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String business_name\n  String business_address\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_mall_admin\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String role\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```\n\n### `shopping_mall_guest`\n\nRepresents unauthenticated users who can browse products and add items to\ncart.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `session_id`: Unique identifier for the guest session.\n- `created_at`: Timestamp when the guest record was created.\n- `updated_at`: Timestamp when the guest record was last updated.\n\n### `shopping_mall_member`\n\nRepresents authenticated users who can place orders, manage their\nprofile, and view order history.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Email address of the member.\n- `password_hash`: Hashed password for authentication.\n- `name`: Full name of the member.\n- `phone`: Phone number of the member.\n- `address`: Shipping address of the member.\n- `created_at`: Timestamp when the member record was created.\n- `updated_at`: Timestamp when the member record was last updated.\n- `deleted_at`: Timestamp when the member record was soft deleted.\n\n### `shopping_mall_seller`\n\nRepresents users who can manage their products, inventory, and view sales\nreports.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Email address of the seller.\n- `password_hash`: Hashed password for authentication.\n- `name`: Full name of the seller.\n- `phone`: Phone number of the seller.\n- `business_name`: Business name of the seller.\n- `business_address`: Business address of the seller.\n- `created_at`: Timestamp when the seller record was created.\n- `updated_at`: Timestamp when the seller record was last updated.\n- `deleted_at`: Timestamp when the seller record was soft deleted.\n\n### `shopping_mall_admin`\n\nRepresents system administrators who can manage all users, products,\norders, and system settings.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Email address of the admin.\n- `password_hash`: Hashed password for authentication.\n- `name`: Full name of the admin.\n- `phone`: Phone number of the admin.\n- `role`: Role of the admin (e.g., superadmin, moderator).\n- `created_at`: Timestamp when the admin record was created.\n- `updated_at`: Timestamp when the admin record was last updated.\n- `deleted_at`: Timestamp when the admin record was soft deleted.\n\n## Sales\n\n```mermaid\nerDiagram\n\"shopping_sales\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String code UK\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_snapshots\" {\n  String id PK\n  String shopping_sale_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n}\n\"shopping_sale_units\" {\n  String id PK\n  String shopping_sale_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_unit_options\" {\n  String id PK\n  String shopping_sale_unit_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_snapshots\" }o--|| \"shopping_sales\" : sale\n\"shopping_sale_units\" }o--|| \"shopping_sales\" : sale\n\"shopping_sale_unit_options\" }o--|| \"shopping_sale_units\" : saleUnit\n```\n\n### `shopping_sales`\n\nMain sales entity representing product offerings in the shopping mall.\nThis table captures all essential information about products available\nfor purchase, including pricing, availability, and basic attributes. It\nserves as the primary reference for all sales-related operations.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`: Belonged channel's [shopping_channels.id](#shopping_channels).\n- `shopping_section_id`: Belonged section's [shopping_sections.id](#shopping_sections).\n- `code`: Unique business identifier for the sale.\n- `name`: Display name of the sale.\n- `description`: Detailed description of the sale.\n- `price`: Current price of the sale.\n- `stock`: Current inventory stock level.\n- `created_at`: Timestamp when the sale was created.\n- `updated_at`: Timestamp when the sale was last updated.\n- `deleted_at`: Timestamp when the sale was deleted (soft delete).\n\n### `shopping_sale_snapshots`\n\nHistorical snapshots of shopping_sales for audit trails and version\ncontrol. This table captures point-in-time states of sales entities,\nallowing for complete historical tracking of all changes to product\nofferings. Each snapshot represents a complete state of a sale at a\nspecific moment in time.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_sale_id`: Belonged sale's [shopping_sales.id](#shopping_sales).\n- `code`: Unique business identifier for the sale at this snapshot.\n- `name`: Display name of the sale at this snapshot.\n- `description`: Detailed description of the sale at this snapshot.\n- `price`: Price of the sale at this snapshot.\n- `stock`: Inventory stock level at this snapshot.\n- `created_at`: Timestamp when this snapshot was created.\n\n### `shopping_sale_units`\n\nProduct variants for sales entities. This table represents different\nversions or options of a product offering, allowing for flexible product\nconfigurations and customization. Each unit belongs to a specific sale\nand has its own unique attributes and pricing.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_sale_id`: Belonged sale's [shopping_sales.id](#shopping_sales).\n- `code`: Unique business identifier for the sale unit.\n- `name`: Display name of the sale unit.\n- `description`: Detailed description of the sale unit.\n- `price`: Price of the sale unit.\n- `stock`: Inventory stock level of the sale unit.\n- `created_at`: Timestamp when the sale unit was created.\n- `updated_at`: Timestamp when the sale unit was last updated.\n- `deleted_at`: Timestamp when the sale unit was deleted (soft delete).\n\n### `shopping_sale_unit_options`\n\nCustomizable options for sale units. This table represents additional\nconfiguration choices that can be made for product variants, allowing\ncustomers to personalize their purchases. Each option belongs to a\nspecific sale unit and has its own unique attributes and pricing.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_sale_unit_id`: Belonged sale unit's [shopping_sale_units.id](#shopping_sale_units).\n- `code`: Unique business identifier for the sale unit option.\n- `name`: Display name of the sale unit option.\n- `description`: Detailed description of the sale unit option.\n- `price`: Price of the sale unit option.\n- `created_at`: Timestamp when the sale unit option was created.\n- `updated_at`: Timestamp when the sale unit option was last updated.\n- `deleted_at`: Timestamp when the sale unit option was deleted (soft delete).\n\n## Carts\n\n```mermaid\nerDiagram\n\"shopping_carts\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String status\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" {\n  String id PK\n  String shopping_cart_id FK\n  String shopping_sale_unit_id FK\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" }o--|| \"shopping_carts\" : cart\n```\n\n### `shopping_carts`\n\nShopping carts represent temporary holding areas for items that users\nintend to purchase. Each cart is associated with a specific user and\ncontains multiple cart items. The cart system supports session-based\ninteractions, allowing users to accumulate items before proceeding to\ncheckout. The cart maintains temporal fields for tracking creation and\nupdates, and includes a status field to manage its lifecycle.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`: Belonged member's [shopping_mall_member.id](#shopping_mall_member).\n- `status`: Status of the shopping cart.\n- `created_at`: Creation timestamp of the shopping cart.\n- `updated_at`: Last update timestamp of the shopping cart.\n\n### `shopping_cart_items`\n\nShopping cart items represent individual products or product variants\nthat users have added to their shopping carts. Each cart item is\nassociated with a specific cart and product variant, and includes details\nsuch as quantity and price. The cart item system supports session-based\ninteractions, allowing users to manage their selections before checkout.\nThe cart item maintains temporal fields for tracking creation and\nupdates.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_cart_id`: Belonged cart's [shopping_carts.id](#shopping_carts).\n- `shopping_sale_unit_id`: Belonged sale unit's [shopping_sale_units.id](#shopping_sale_units).\n- `quantity`: Quantity of the product variant in the cart.\n- `price`: Price of the product variant at the time of adding to the cart.\n- `created_at`: Creation timestamp of the cart item.\n- `updated_at`: Last update timestamp of the cart item.\n\n## Orders\n\n```mermaid\nerDiagram\n\"shopping_orders\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String code UK\n  String status\n  Float total_amount\n  String shipping_address\n  String payment_method\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_order_snapshots\" {\n  String id PK\n  String shopping_order_id FK\n  String code\n  String status\n  Float total_amount\n  String shipping_address\n  String payment_method\n  DateTime created_at\n}\n\"shopping_order_items\" {\n  String id PK\n  String shopping_order_id FK\n  String product_id\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_order_snapshots\" }o--|| \"shopping_orders\" : order\n\"shopping_order_items\" }o--|| \"shopping_orders\" : order\n```\n\n### `shopping_orders`\n\nPrimary table for managing customer orders. This table captures all\nessential order information including customer details, order status, and\ntotal amount. It serves as the central entity for order processing and\ntracking.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`\n  > Reference to the customer who placed the order. {@link\n  > shopping_mall_member.id}\n- `code`: Unique order code for tracking and reference purposes.\n- `status`\n  > Current status of the order (e.g., pending, processing, shipped,\n  > delivered).\n- `total_amount`: Total amount of the order including all items and taxes.\n- `shipping_address`: Shipping address for the order.\n- `payment_method`: Payment method used for the order (e.g., credit card, PayPal).\n- `created_at`: Timestamp when the order was created.\n- `updated_at`: Timestamp when the order was last updated.\n- `deleted_at`: Timestamp when the order was deleted (soft delete).\n\n### `shopping_order_snapshots`\n\nTable for capturing historical states of orders for audit trails and\nversion control. This table records all changes to order information over\ntime, allowing for comprehensive tracking and analysis.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: Reference to the order being snapshotted. [shopping_orders.id](#shopping_orders)\n- `code`: Unique order code for tracking and reference purposes.\n- `status`: Status of the order at the time of the snapshot.\n- `total_amount`: Total amount of the order including all items and taxes.\n- `shipping_address`: Shipping address for the order.\n- `payment_method`: Payment method used for the order.\n- `created_at`: Timestamp when the snapshot was created.\n\n### `shopping_order_items`\n\nTable for managing items within each order. This table captures detailed\ninformation about each item in the order, including quantity, price, and\nproduct details.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: Reference to the order that contains this item. [shopping_orders.id](#shopping_orders)\n- `product_id`: Unique identifier for the product.\n- `quantity`: Quantity of the product ordered.\n- `price`: Price of the product at the time of order.\n- `created_at`: Timestamp when the order item was created.\n- `updated_at`: Timestamp when the order item was last updated.\n\n## Coupons\n\n```mermaid\nerDiagram\n\"shopping_coupons\" {\n  String id PK\n  String code UK\n  String discount_type\n  Float value\n  DateTime valid_from\n  DateTime valid_until\n  Int max_uses \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_coupon_usage\" {\n  String id PK\n  String shopping_coupon_id FK\n  String shopping_mall_member_id FK\n  String order_id\n  DateTime used_at\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_coupon_usage\" }o--|| \"shopping_coupons\" : coupon\n```\n\n### `shopping_coupons`\n\nCoupon definitions for promotional discounts. Represents available\ncoupons that can be applied to orders.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `code`: Unique coupon code for redemption.\n- `discount_type`: Type of discount (percentage or fixed amount).\n- `value`: Discount value (percentage or fixed amount).\n- `valid_from`: Start date when the coupon becomes valid.\n- `valid_until`: End date when the coupon expires.\n- `max_uses`: Maximum number of times the coupon can be used.\n- `created_at`: Timestamp when the coupon was created.\n- `updated_at`: Timestamp when the coupon was last updated.\n\n### `shopping_coupon_usage`\n\nRecords of coupon usage by users. Tracks each application of a coupon to\nan order.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_coupon_id`: Coupon that was used. [shopping_coupons.id](#shopping_coupons)\n- `shopping_mall_member_id`: User who applied the coupon. [shopping_mall_member.id](#shopping_mall_member)\n- `order_id`: Order to which the coupon was applied.\n- `used_at`: Timestamp when the coupon was used.\n- `created_at`: Timestamp when the usage record was created.\n- `updated_at`: Timestamp when the usage record was last updated.\n\n## Coins\n\n```mermaid\nerDiagram\n\"shopping_coins\" {\n  String id PK\n  String shopping_mall_member_id FK,UK\n  Float balance\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_coin_transactions\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String shopping_order_id FK \"nullable\"\n  Float amount\n  String transaction_type\n  String description \"nullable\"\n  DateTime created_at\n}\n```\n\n### `shopping_coins`\n\nTracks user coin balances and financial information. Represents the\ncurrent state of a user's coin account.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`: Belonged member's [shopping_mall_member.id](#shopping_mall_member).\n- `balance`: Current coin balance.\n- `created_at`: When the coin account was created.\n- `updated_at`: When the coin account was last updated.\n- `deleted_at`: When the coin account was deleted (soft delete).\n\n### `shopping_coin_transactions`\n\nRecords all financial activities related to coin usage. Captures every\ntransaction for audit and tracking purposes.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`: Belonged member's [shopping_mall_member.id](#shopping_mall_member).\n- `shopping_order_id`: Belonged order's [shopping_orders.id](#shopping_orders).\n- `amount`: Amount of coins involved in the transaction.\n- `transaction_type`: Type of transaction (e.g., 'purchase', 'refund', 'earn').\n- `description`: Description of the transaction.\n- `created_at`: When the transaction occurred.\n\n## Inquiries\n\n```mermaid\nerDiagram\n\"shopping_inquiries\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String title\n  String content\n  String status\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_inquiry_responses\" {\n  String id PK\n  String shopping_inquiry_id FK\n  String shopping_mall_admin_id FK\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_inquiry_responses\" }o--|| \"shopping_inquiries\" : inquiry\n```\n\n### `shopping_inquiries`\n\nCustomer inquiries for support or information. Represents the initial\ncontact point for customer service interactions. {@link\nshopping_mall_member} for the customer who created the inquiry.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`: Customer who created the inquiry. [shopping_mall_member.id](#shopping_mall_member)\n- `title`: Title of the inquiry.\n- `content`: Detailed content of the inquiry.\n- `status`: Current status of the inquiry (e.g., 'open', 'in-progress', 'resolved').\n- `created_at`: When the inquiry was created.\n- `updated_at`: When the inquiry was last updated.\n- `deleted_at`: When the inquiry was deleted (soft delete).\n\n### `shopping_inquiry_responses`\n\nResponses to customer inquiries. Represents support activities and\nresolutions. [shopping_inquiries](#shopping_inquiries) for the inquiry being responded\nto. [shopping_mall_admin](#shopping_mall_admin) for the admin who responded.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_inquiry_id`: Inquiry being responded to. [shopping_inquiries.id](#shopping_inquiries)\n- `shopping_mall_admin_id`: Admin who created the response. [shopping_mall_admin.id](#shopping_mall_admin)\n- `content`: Content of the response.\n- `created_at`: When the response was created.\n- `updated_at`: When the response was last updated.\n- `deleted_at`: When the response was deleted (soft delete).\n\n## Favorites\n\n```mermaid\nerDiagram\n\"shopping_favorites\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_favorite_items\" {\n  String id PK\n  String shopping_favorite_id FK\n  String shopping_sale_unit_id FK\n  DateTime created_at\n}\n\"shopping_favorite_items\" }o--|| \"shopping_favorites\" : favorite\n```\n\n### `shopping_favorites`\n\nUser preference management for favorite items. Represents a user's\ncollection of favorite items across different products. {@link\nshopping_mall_member.id}\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_mall_member_id`: Belonged member's [shopping_mall_member.id](#shopping_mall_member)\n- `name`: Name of the favorite collection.\n- `description`: Description of the favorite collection.\n- `created_at`: When the favorite collection was created.\n- `updated_at`: When the favorite collection was last updated.\n- `deleted_at`: When the favorite collection was deleted (soft delete).\n\n### `shopping_favorite_items`\n\nFavorite items within a user's favorite collection. Represents individual\nitems that a user has marked as favorites within their collections.\n[shopping_favorites.id](#shopping_favorites) [shopping_sale_units.id](#shopping_sale_units)\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_favorite_id`: Belonged favorite collection's [shopping_favorites.id](#shopping_favorites)\n- `shopping_sale_unit_id`: Belonged sale unit's [shopping_sale_units.id](#shopping_sale_units)\n- `created_at`: When the favorite item was added to the collection.\n\n## Articles\n\n```mermaid\nerDiagram\n\"shopping_articles\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String code UK\n  String title\n  String content\n  String status\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_article_comments\" {\n  String id PK\n  String shopping_article_id FK\n  String shopping_mall_member_id FK\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_article_comments\" }o--|| \"shopping_articles\" : article\n```\n\n### `shopping_articles`\n\nRepresents articles in the shopping mall. This table stores information\nabout articles that are displayed in the shopping mall. The articles can\nbe categorized and have various attributes such as title, content, and\nstatus. The table also includes temporal fields for tracking creation,\nupdates, and deletion times.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`: Belonged channel's [shopping_channels.id](#shopping_channels).\n- `shopping_section_id`: Belonged section's [shopping_sections.id](#shopping_sections).\n- `code`: Article code.\n- `title`: Article title.\n- `content`: Article content.\n- `status`: Article status.\n- `created_at`: When the article was created.\n- `updated_at`: When the article was last updated.\n- `deleted_at`: When the article was deleted.\n\n### `shopping_article_comments`\n\nRepresents comments on articles in the shopping mall. This table stores\ninformation about comments made on articles. Each comment is associated\nwith a specific article and a user. The table includes temporal fields\nfor tracking creation, updates, and deletion times.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_article_id`: Belonged article's [shopping_articles.id](#shopping_articles).\n- `shopping_mall_member_id`: Belonged member's [shopping_mall_member.id](#shopping_mall_member).\n- `content`: Comment content.\n- `created_at`: When the comment was created.\n- `updated_at`: When the comment was last updated.\n- `deleted_at`: When the comment was deleted.\n","diagrams":{"Systematic":"```mermaid\nerDiagram\n\"shopping_channels\" {\n  String id PK\n  String code UK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" {\n  String id PK\n  String shopping_channel_id FK\n  String code\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_configurations\" {\n  String id PK\n  String shopping_channel_id FK \"nullable\"\n  String shopping_section_id FK \"nullable\"\n  String key\n  String value\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" }o--|| \"shopping_channels\" : channel\n\"shopping_configurations\" }o--o| \"shopping_channels\" : channel\n\"shopping_configurations\" }o--o| \"shopping_sections\" : section\n```","Actors":"```mermaid\nerDiagram\n\"shopping_mall_guest\" {\n  String id PK\n  String session_id UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_mall_member\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String address \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_mall_seller\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String business_name\n  String business_address\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_mall_admin\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String role\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```","Sales":"```mermaid\nerDiagram\n\"shopping_sales\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String code UK\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_snapshots\" {\n  String id PK\n  String shopping_sale_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n}\n\"shopping_sale_units\" {\n  String id PK\n  String shopping_sale_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  Int stock\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_unit_options\" {\n  String id PK\n  String shopping_sale_unit_id FK\n  String code\n  String name\n  String description \"nullable\"\n  Float price\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sale_snapshots\" }o--|| \"shopping_sales\" : sale\n\"shopping_sale_units\" }o--|| \"shopping_sales\" : sale\n\"shopping_sale_unit_options\" }o--|| \"shopping_sale_units\" : saleUnit\n```","Carts":"```mermaid\nerDiagram\n\"shopping_carts\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String status\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" {\n  String id PK\n  String shopping_cart_id FK\n  String shopping_sale_unit_id FK\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" }o--|| \"shopping_carts\" : cart\n```","Orders":"```mermaid\nerDiagram\n\"shopping_orders\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String code UK\n  String status\n  Float total_amount\n  String shipping_address\n  String payment_method\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_order_snapshots\" {\n  String id PK\n  String shopping_order_id FK\n  String code\n  String status\n  Float total_amount\n  String shipping_address\n  String payment_method\n  DateTime created_at\n}\n\"shopping_order_items\" {\n  String id PK\n  String shopping_order_id FK\n  String product_id\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_order_snapshots\" }o--|| \"shopping_orders\" : order\n\"shopping_order_items\" }o--|| \"shopping_orders\" : order\n```","Coupons":"```mermaid\nerDiagram\n\"shopping_coupons\" {\n  String id PK\n  String code UK\n  String discount_type\n  Float value\n  DateTime valid_from\n  DateTime valid_until\n  Int max_uses \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_coupon_usage\" {\n  String id PK\n  String shopping_coupon_id FK\n  String shopping_mall_member_id FK\n  String order_id\n  DateTime used_at\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_coupon_usage\" }o--|| \"shopping_coupons\" : coupon\n```","Coins":"```mermaid\nerDiagram\n\"shopping_coins\" {\n  String id PK\n  String shopping_mall_member_id FK,UK\n  Float balance\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_coin_transactions\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String shopping_order_id FK \"nullable\"\n  Float amount\n  String transaction_type\n  String description \"nullable\"\n  DateTime created_at\n}\n```","Inquiries":"```mermaid\nerDiagram\n\"shopping_inquiries\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String title\n  String content\n  String status\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_inquiry_responses\" {\n  String id PK\n  String shopping_inquiry_id FK\n  String shopping_mall_admin_id FK\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_inquiry_responses\" }o--|| \"shopping_inquiries\" : inquiry\n```","Favorites":"```mermaid\nerDiagram\n\"shopping_favorites\" {\n  String id PK\n  String shopping_mall_member_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_favorite_items\" {\n  String id PK\n  String shopping_favorite_id FK\n  String shopping_sale_unit_id FK\n  DateTime created_at\n}\n\"shopping_favorite_items\" }o--|| \"shopping_favorites\" : favorite\n```","Articles":"```mermaid\nerDiagram\n\"shopping_articles\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String code UK\n  String title\n  String content\n  String status\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_article_comments\" {\n  String id PK\n  String shopping_article_id FK\n  String shopping_mall_member_id FK\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_article_comments\" }o--|| \"shopping_articles\" : article\n```"}},"created_at":"2025-10-14T15:06:00.416Z","completed_at":"2025-10-14T15:07:00.073Z","step":0}]