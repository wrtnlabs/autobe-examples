[{"id":"0199e33c-0830-70db-919c-2a2acd8cff9a","type":"userMessage","contents":[{"type":"text","text":"I want to create an e-commerce shopping mall platform.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit.\r\n\r\nHere are the key features I want:\r\n- User registration and login with address management\r\n- Product catalog with categories and search\r\n- Product variants (SKU) with different colors, sizes, options\r\n- Shopping cart and wishlist\r\n- Order placement and payment processing\r\n- Order tracking and shipping status updates\r\n- Product reviews and ratings\r\n- Seller accounts to manage their products\r\n- Inventory management per SKU\r\n- Order history and cancellation/refund requests\r\n- Admin dashboard for order and product management"}],"created_at":"2025-10-14T14:59:46.352Z"},{"id":"0199e33c-0c40-7561-99eb-d0c2a5896c07","type":"assistantMessage","text":"I understand you want to create an e-commerce shopping mall platform. Let me help you gather the requirements and create a comprehensive analysis report. I'll start by asking some clarifying questions to ensure we capture all the necessary details.\n\n### Clarifying Questions\n\n1. **User Registration and Login**\n   - Should users be able to register using social media accounts (e.g., Google, Facebook)?\n   - What information should be collected during registration (e.g., name, email, phone number)?\n   - Should there be different user roles (e.g., buyer, seller, admin)?\n\n2. **Product Catalog**\n   - How should products be categorized (e.g., electronics, clothing, home goods)?\n   - Should there be a recommendation system for products?\n   - What search filters should be available (e.g., price range, brand, rating)?\n\n3. **Product Variants**\n   - How many variants should be supported per product (e.g., color, size, material)?\n   - Should each variant have its own SKU and inventory tracking?\n\n4. **Shopping Cart and Wishlist**\n   - Should the shopping cart support saving items for later purchase?\n   - Should the wishlist be shareable with others?\n\n5. **Order Placement and Payment Processing**\n   - What payment methods should be supported (e.g., credit card, PayPal, bank transfer)?\n   - Should there be a guest checkout option?\n\n6. **Order Tracking and Shipping**\n   - Should users receive notifications for order status updates?\n   - Should there be integration with shipping carriers for real-time tracking?\n\n7. **Product Reviews and Ratings**\n   - Should users be able to upload images or videos with their reviews?\n   - Should there be a moderation system for reviews?\n\n8. **Seller Accounts**\n   - What information should sellers provide when registering (e.g., business license, bank account)?\n   - Should sellers have analytics on their product performance?\n\n9. **Inventory Management**\n   - Should there be low stock alerts for sellers?\n   - Should inventory be updated in real-time?\n\n10. **Order History and Cancellation/Refund**\n    - What is the cancellation and refund policy?\n    - Should there be a system for handling disputes?\n\n11. **Admin Dashboard**\n    - What metrics should be displayed on the admin dashboard (e.g., sales, user growth, inventory levels)?\n    - Should admins have the ability to manage user accounts and permissions?\n\n### Next Steps\n\nBased on your responses, I will proceed to create a detailed requirements analysis report. This report will serve as the foundation for the subsequent development stages, including database schema design, API interface creation, testing, and implementation.\n\nWould you like to provide more details on any of the features, or should I proceed with the analysis based on the information provided so far?","created_at":"2025-10-14T14:59:47.392Z","completed_at":"2025-10-14T14:59:52.613Z"},{"id":"0199e33c-20ad-7647-beb3-db71ffc53b15","type":"userMessage","contents":[{"type":"text","text":"I'm not familiar with the analyze feature. Please determine everything by yourself, and just show me the analysis report."}],"created_at":"2025-10-14T14:59:52.621Z"},{"type":"analyze","id":"0199e35a-23cc-715e-a270-4a6499385ad0","instruction":"Focus on e-commerce shopping mall platform features with emphasis on user registration, product catalog, product variants, shopping cart, order placement, payment processing, order tracking, product reviews, seller accounts, inventory management, order history, and admin dashboard. User wants a comprehensive system with all standard e-commerce functionalities.","prefix":"shoppingMall","roles":[{"name":"customer","description":"Standard users who can browse products, add to cart, place orders, and manage their profile.","kind":"member"},{"name":"seller","description":"Users who can manage their own products, inventory, and orders.","kind":"member"},{"name":"admin","description":"System administrators who can manage all users, products, and orders.","kind":"admin"}],"files":[{"reason":"To provide an overview of the entire e-commerce shopping mall platform, including its purpose, key features, and business model.","filename":"00-toc.md","documentType":"service-overview","outline":["Table of Contents","Service Overview","Key Features","Business Model","User Roles","Documentation Structure"],"audience":"general","keyQuestions":["What is the purpose of this platform?","What are the main features?","Who are the target users?","What is the business model?","How is the documentation organized?"],"detailLevel":"moderate detail","relatedDocuments":[],"constraints":["Must include business model","Must define user roles","Must outline all key features"],"content":"# E-Commerce Shopping Mall Platform Requirements Analysis Report\n\n## Table of Contents\n\n1. [Service Overview](#service-overview)\n   - [Platform Purpose](#platform-purpose)\n   - [Key Features](#key-features)\n   - [Target Users](#target-users)\n2. [Business Model](#business-model)\n   - [Revenue Streams](#revenue-streams)\n   - [Value Proposition](#value-proposition)\n   - [Competitive Advantage](#competitive-advantage)\n3. [User Roles](#user-roles)\n   - [Customer](#customer)\n   - [Seller](#seller)\n   - [Admin](#admin)\n4. [Documentation Structure](#documentation-structure)\n   - [Overview of All Documents](#overview-of-all-documents)\n   - [Relationship Between Documents](#relationship-between-documents)\n\n## Service Overview\n\n### Platform Purpose\n\nThe E-Commerce Shopping Mall Platform is designed to provide a comprehensive online marketplace where customers can browse, purchase, and review products from various sellers. The platform aims to offer a seamless shopping experience with robust features for both buyers and sellers.\n\n### Key Features\n\n- **User Registration and Login**: Secure user authentication with address management.\n- **Product Catalog**: Comprehensive product listings with categories and search functionality.\n- **Product Variants**: Support for different colors, sizes, and options with SKU management.\n- **Shopping Cart and Wishlist**: Easy management of desired products.\n- **Order Placement and Payment Processing**: Secure and efficient transaction handling.\n- **Order Tracking and Shipping**: Real-time updates on order status.\n- **Product Reviews and Ratings**: User-generated content to build trust and engagement.\n- **Seller Accounts**: Tools for sellers to manage their products and orders.\n- **Inventory Management**: Per SKU tracking to ensure accurate stock levels.\n- **Order History and Cancellation/Refund**: Comprehensive order management for customers.\n- **Admin Dashboard**: Centralized control for managing the platform.\n\n### Target Users\n\n- **Customers**: Individuals looking to purchase products online.\n- **Sellers**: Businesses or individuals selling products on the platform.\n- **Admins**: Platform administrators managing users, products, and orders.\n\n## Business Model\n\n### Revenue Streams\n\n- **Commission Fees**: Charge sellers a percentage of each sale.\n- **Listing Fees**: Charge sellers for listing products on the platform.\n- **Featured Placements**: Offer premium placement for products in search results.\n- **Advertising**: Display targeted ads to customers.\n\n### Value Proposition\n\n- **Wide Product Selection**: Offer a diverse range of products from various sellers.\n- **Seamless Shopping Experience**: Provide an easy-to-use platform with secure transactions.\n- **Seller Tools**: Equip sellers with tools to manage their products and sales effectively.\n- **Customer Support**: Offer robust support for both buyers and sellers.\n\n### Competitive Advantage\n\n- **User-Friendly Interface**: Intuitive design for easy navigation.\n- **Robust Search and Filtering**: Advanced search capabilities to find products quickly.\n- **Secure Transactions**: Ensure all transactions are secure and reliable.\n- **Comprehensive Seller Tools**: Provide sellers with analytics and management tools.\n\n## User Roles\n\n### Customer\n\n- **Permissions**: Browse products, add to cart, place orders, manage profile, leave reviews.\n- **Responsibilities**: Provide accurate information during registration and checkout.\n\n### Seller\n\n- **Permissions**: Manage products, inventory, orders, view analytics.\n- **Responsibilities**: Maintain accurate product information and inventory levels.\n\n### Admin\n\n- **Permissions**: Manage all users, products, orders, view system analytics.\n- **Responsibilities**: Ensure platform security and smooth operation.\n\n## Documentation Structure\n\n### Overview of All Documents\n\n- **00-toc.md**: Table of Contents and Service Overview\n- **01-business-model.md**: Business Model and Value Proposition\n- **02-user-authentication.md**: User Registration, Login, and Profile Management\n- **03-product-catalog.md**: Product Catalog Structure and Search Functionality\n- **04-shopping-cart.md**: Shopping Cart and Wishlist Functionality\n- **05-order-placement.md**: Order Placement and Payment Processing\n- **06-order-tracking.md**: Order Tracking and Shipping Status Updates\n- **07-product-reviews.md**: Product Reviews and Ratings System\n- **08-seller-accounts.md**: Seller Account Functionality\n- **09-admin-dashboard.md**: Admin Dashboard Functionality\n- **10-user-flow.md**: Comprehensive User Flow Diagram\n- **11-technical-requirements.md**: Technical Requirements and Constraints\n\n### Relationship Between Documents\n\n- **00-toc.md** serves as the main overview and references all other documents.\n- **01-business-model.md** provides the business context for the platform.\n- **02-user-authentication.md** to **09-admin-dashboard.md** detail specific functionalities.\n- **10-user-flow.md** illustrates how users interact with the platform.\n- **11-technical-requirements.md** outlines the technical constraints and requirements.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the business model and value proposition of the e-commerce platform.","filename":"01-business-model.md","documentType":"business-model","outline":["Business Model","Value Proposition","Revenue Streams","Target Market","Competitive Advantage"],"audience":"business stakeholders","keyQuestions":["How will the platform generate revenue?","What is the unique value proposition?","Who is the target market?","What are the competitive advantages?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must include revenue streams","Must define target market","Must identify competitive advantages"],"content":"# E-Commerce Shopping Mall Platform Business Model Analysis\n\n## Business Model\n\n### Platform Overview\n\nThe e-commerce shopping mall platform is a comprehensive online marketplace that connects buyers and sellers, offering a wide range of products across various categories. The platform provides a seamless shopping experience with features such as user registration, product catalog, shopping cart, order placement, payment processing, order tracking, product reviews, seller accounts, inventory management, and admin dashboard.\n\n### Key Features\n\n- **User Registration and Login**: Secure user authentication with address management\n- **Product Catalog**: Organized product listings with categories and search functionality\n- **Product Variants**: Support for different colors, sizes, and options with SKU management\n- **Shopping Cart and Wishlist**: Item management for purchase and future consideration\n- **Order Placement and Payment**: Secure payment processing with multiple methods\n- **Order Tracking**: Real-time shipping status updates\n- **Product Reviews**: User-generated ratings and feedback\n- **Seller Accounts**: Product and inventory management for vendors\n- **Admin Dashboard**: Comprehensive system management and analytics\n\n### Business Strategy\n\nThe platform aims to provide a user-friendly, secure, and efficient shopping experience. By offering a wide range of products and robust features, the platform attracts both buyers and sellers, creating a thriving marketplace ecosystem.\n\n## Value Proposition\n\n### Unique Selling Points\n\n- **Comprehensive Product Range**: Wide variety of products across multiple categories\n- **User-Friendly Interface**: Intuitive design for easy navigation and shopping\n- **Secure Transactions**: Robust payment processing and data protection\n- **Seller Empowerment**: Tools for sellers to manage products and inventory effectively\n- **Customer Support**: Responsive service for order tracking and issue resolution\n\n### Customer Benefits\n\n- **Convenience**: Shop from anywhere at any time\n- **Choice**: Access to a wide range of products and sellers\n- **Security**: Safe transactions and data protection\n- **Support**: Assistance with orders and product information\n- **Personalization**: Tailored recommendations and user profiles\n\n### Market Differentiation\n\n- **Integrated Seller Tools**: Comprehensive management features for vendors\n- **Advanced Search and Filtering**: Efficient product discovery\n- **Real-Time Order Tracking**: Transparent shipping status updates\n- **Community Features**: Product reviews and ratings for informed decisions\n\n## Revenue Streams\n\n### Sales Commissions\n\n- **Transaction Fees**: Percentage of each sale charged to sellers\n- **Listing Fees**: Charges for product listings and promotions\n- **Featured Placements**: Premium positioning for higher visibility\n\n### Subscription Fees\n\n- **Seller Subscriptions**: Monthly or annual fees for advanced seller tools\n- **Premium Memberships**: Enhanced features for buyers (e.g., free shipping, exclusive deals)\n\n### Advertising Revenue\n\n- **Banner Ads**: Display advertisements from third-party brands\n- **Sponsored Products**: Promoted listings within search results\n- **Email Marketing**: Targeted promotions to registered users\n\n### Additional Services\n\n- **Shipping Services**: Integrated logistics and delivery options\n- **Payment Processing**: Transaction fees for payment gateway usage\n- **Data Analytics**: Insights and reports for sellers and partners\n\n## Target Market\n\n### Customer Segments\n\n- **Individual Consumers**: General public looking for everyday products\n- **Business Buyers**: Companies purchasing in bulk or for resale\n- **Sellers**: Individuals and businesses offering products for sale\n\n### Market Size and Growth\n\n- **Total Addressable Market**: Global e-commerce market valued at $4.9 trillion (2021)\n- **Growth Rate**: Projected CAGR of 14.7% from 2020 to 2027\n- **Target Regions**: North America, Europe, Asia-Pacific\n\n### Customer Personas\n\n- **Tech-Savvy Shoppers**: Age 18-35, frequent online buyers, value convenience\n- **Bargain Hunters**: Price-sensitive, look for deals and discounts\n- **Small Business Owners**: Sell products online, need management tools\n- **Corporate Buyers**: Purchase in bulk, require invoicing and support\n\n## Competitive Advantage\n\n### Technology and Innovation\n\n- **Advanced Search Algorithms**: Efficient product discovery\n- **AI-Driven Recommendations**: Personalized shopping experience\n- **Mobile Optimization**: Seamless shopping on all devices\n\n### Customer Experience\n\n- **Intuitive Interface**: Easy navigation and product browsing\n- **Responsive Support**: Quick resolution of customer inquiries\n- **Transparent Processes**: Clear order tracking and communication\n\n### Operational Efficiency\n\n- **Automated Inventory Management**: Real-time stock tracking\n- **Streamlined Order Processing**: Efficient fulfillment workflows\n- **Data-Driven Insights**: Analytics for continuous improvement\n\n### Strategic Partnerships\n\n- **Logistics Providers**: Reliable shipping and delivery services\n- **Payment Gateways**: Secure and diverse payment options\n- **Technology Partners**: Integration with leading e-commerce solutions\n\n## Market Analysis\n\n### Market Segmentation\n\n```mermaid\ngraph LR\n    A[\"Total Market\"] --> B[\"B2C E-Commerce\"]\n    A --> C[\"B2B E-Commerce\"]\n    B --> D[\"Electronics\"]\n    B --> E[\"Fashion\"]\n    B --> F[\"Home Goods\"]\n    C --> G[\"Wholesale\"]\n    C --> H[\"Business Supplies\"]\n```\n\n### Competitive Landscape\n\n| Competitor | Market Share | Strengths | Weaknesses |\n|-----------|--------------|-----------|------------|\n| Amazon | 38% | Wide selection, fast shipping | High competition among sellers |\n| eBay | 12% | Auction format, diverse products | Older interface, less mobile-friendly |\n| Walmart | 8% | Low prices, broad inventory | Limited marketplace features |\n| Etsy | 5% | Unique handmade items | Niche market, higher fees |\n\n### SWOT Analysis\n\n```mermaid\ngraph TD\n    A[\"SWOT Analysis\"] --> B[\"Strengths\"]\n    A --> C[\"Weaknesses\"]\n    A --> D[\"Opportunities\"]\n    A --> E[\"Threats\"]\n    B --> F[\"Comprehensive features\"]\n    B --> G[\"User-friendly interface\"]\n    C --> H[\"New entrant\"]\n    C --> I[\"Limited brand recognition\"]\n    D --> J[\"Growing e-commerce market\"]\n    D --> K[\"Expanding seller base\"]\n    E --> L[\"Established competitors\"]\n    E --> M[\"Market saturation\"]\n```\n\n## Financial Projections\n\n### Revenue Projections\n\n| Year | Total Revenue | Growth Rate |\n|------|---------------|-------------|\n| 2023 | $500,000 | - |\n| 2024 | $1,200,000 | 140% |\n| 2025 | $2,500,000 | 108% |\n| 2026 | $4,000,000 | 60% |\n\n### Cost Structure\n\n- **Technology Development**: Platform maintenance and updates\n- **Marketing and Advertising**: Customer acquisition and retention\n- **Operational Costs**: Customer support, logistics, and partnerships\n- **Compliance and Security**: Data protection and regulatory adherence\n\n## Implementation Roadmap\n\n### Phase 1: MVP Launch\n\n- **Core Features**: User registration, product catalog, shopping cart, order placement\n- **Initial Market**: Focus on tech-savvy shoppers and small business sellers\n- **Revenue Focus**: Transaction fees and basic subscriptions\n\n### Phase 2: Feature Expansion\n\n- **Enhanced Features**: Advanced search, seller analytics, mobile optimization\n- **Market Expansion**: Broader customer segments and geographic regions\n- **Revenue Diversification**: Advertising, premium services, and partnerships\n\n### Phase 3: Market Leadership\n\n- **Innovative Features**: AI recommendations, augmented reality shopping, voice search\n- **Global Reach**: International expansion and localization\n- **Sustainable Growth**: Balanced revenue streams and operational efficiency\n\n## Conclusion\n\nThe e-commerce shopping mall platform offers a comprehensive solution for online shopping, with a robust business model that includes multiple revenue streams, a clear value proposition, and strategic competitive advantages. By focusing on user experience, seller empowerment, and operational efficiency, the platform is well-positioned to capture a significant share of the growing e-commerce market.\n\n## References\n\n- [Service Overview Document](./00-toc.md)\n- [User Authentication Requirements](./02-user-authentication.md)\n- [Product Catalog Requirements](./03-product-catalog.md)\n- [Shopping Cart Requirements](./04-shopping-cart.md)\n- [Order Placement Requirements](./05-order-placement.md)\n- [Order Tracking Requirements](./06-order-tracking.md)\n- [Product Reviews Requirements](./07-product-reviews.md)\n- [Seller Accounts Requirements](./08-seller-accounts.md)\n- [Admin Dashboard Requirements](./09-admin-dashboard.md)\n- [User Flow Documentation](./10-user-flow.md)\n- [Technical Requirements](./11-technical-requirements.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To specify the functional requirements for user registration, authentication, and profile management.","filename":"02-user-authentication.md","documentType":"requirement","outline":["User Registration","User Login","Profile Management","Address Management","Authentication Security"],"audience":"development team","keyQuestions":["What information is required for registration?","What authentication methods are supported?","How is user profile information managed?","How are addresses stored and managed?","What security measures are in place?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must include registration requirements","Must specify authentication methods","Must define profile management","Must include security measures"],"content":"# User Authentication Requirements for Shopping Mall Platform\n\n## 1. Introduction\n\n### 1.1 Purpose\nThis document specifies the functional requirements for user registration, authentication, and profile management for the Shopping Mall e-commerce platform.\n\n### 1.2 Scope\nThis document covers all aspects of user authentication including registration, login, profile management, address management, and security measures.\n\n### 1.3 Definitions\n- **User**: Any individual who interacts with the platform\n- **Customer**: A user who purchases products\n- **Seller**: A user who sells products\n- **Admin**: A user who manages the platform\n- **Authentication**: The process of verifying user identity\n- **Authorization**: The process of granting access based on user roles\n\n## 2. User Roles and Permissions\n\n### 2.1 Customer\n- **Description**: Standard users who can browse products, add to cart, place orders, and manage their profile.\n- **Permissions**:\n  - Browse and search products\n  - Add items to cart and wishlist\n  - Place and track orders\n  - Manage profile and addresses\n  - Leave product reviews\n\n### 2.2 Seller\n- **Description**: Users who can manage their own products, inventory, and orders.\n- **Permissions**:\n  - All customer permissions\n  - Manage product listings\n  - Manage inventory\n  - Process orders\n  - View sales analytics\n\n### 2.3 Admin\n- **Description**: System administrators who can manage all users, products, and orders.\n- **Permissions**:\n  - All customer and seller permissions\n  - Manage all user accounts\n  - Manage all product listings\n  - Manage all orders\n  - Access system analytics\n  - Configure platform settings\n\n## 3. User Registration\n\n### 3.1 Registration Process\n\n```mermaid\ngraph LR\n  A[\"Start Registration\"] --> B[\"Enter Email\"]\n  B --> C[\"Verify Email Format\"]\n  C -->|Valid| D[\"Check Email Availability\"]\n  C -->|Invalid| E[\"Show Error\"]\n  D -->|Available| F[\"Enter Password\"]\n  D -->|Taken| G[\"Show Error\"]\n  F --> H[\"Confirm Password\"]\n  H --> I[\"Enter Name\"]\n  I --> J[\"Enter Address\"]\n  J --> K[\"Accept Terms\"]\n  K --> L[\"Submit Registration\"]\n  L --> M[\"Send Verification Email\"]\n  M --> N[\"Registration Complete\"]\n```\n\n### 3.2 Required Information\n- Email address (unique identifier)\n- Password (secure storage)\n- Full name\n- Primary address\n- Phone number (optional)\n- Date of birth (optional)\n\n### 3.3 Validation Rules\n- **Email**: Must be unique and valid format\n- **Password**: Minimum 8 characters, with uppercase, lowercase, number, and special character\n- **Name**: Must not contain numbers or special characters\n- **Address**: Must include street, city, state, zip code, and country\n- **Phone**: Must be valid format if provided\n\n## 4. User Login\n\n### 4.1 Authentication Methods\n- **Email and Password**: Standard login method\n- **Social Media**: Optional integration with Google, Facebook, etc.\n- **Two-Factor Authentication**: Optional for enhanced security\n\n### 4.2 Session Management\n- **Session Timeout**: 30 minutes of inactivity\n- **Persistent Login**: Optional \"Remember Me\" feature\n- **Concurrent Sessions**: Maximum of 5 active sessions per user\n\n### 4.3 Password Recovery\n- **Forgot Password**: Email-based reset link\n- **Account Lockout**: After 5 failed attempts, 15-minute lockout\n- **Password Reset**: Requires current password confirmation\n\n## 5. Profile Management\n\n### 5.1 Profile Information\n- **Basic Information**: Name, email, phone, date of birth\n- **Preferences**: Language, currency, notification settings\n- **Security**: Password, two-factor authentication settings\n\n### 5.2 Profile Editing\n- **WHEN** a user updates their profile, **THE** system **SHALL** validate all changes before saving.\n- **WHEN** a user changes their email, **THE** system **SHALL** send a verification email to the new address.\n- **WHEN** a user updates their password, **THE** system **SHALL** require current password confirmation.\n\n### 5.3 Profile Security\n- **WHEN** a user enables two-factor authentication, **THE** system **SHALL** require verification code for login.\n- **WHEN** a user attempts to access sensitive information, **THE** system **SHALL** require password re-entry.\n\n## 6. Address Management\n\n### 6.1 Address Storage\n- **WHEN** a user adds a new address, **THE** system **SHALL** validate the address format.\n- **WHEN** a user sets a default address, **THE** system **SHALL** use it for all future orders.\n\n### 6.2 Address Validation\n- **WHEN** a user enters an address, **THE** system **SHALL** verify it against a standard address format.\n- **WHEN** a user enters an invalid address, **THE** system **SHALL** display an error message.\n\n### 6.3 Address Usage\n- **WHEN** a user places an order, **THE** system **SHALL** use the default address unless specified otherwise.\n- **WHEN** a user updates their default address, **THE** system **SHALL** apply it to all future orders.\n\n## 7. Authentication Security\n\n### 7.1 Password Requirements\n- **WHEN** a user creates a password, **THE** system **SHALL** enforce minimum complexity rules.\n- **WHEN** a user changes their password, **THE** system **SHALL** require the current password.\n\n### 7.2 Account Protection\n- **WHEN** a user fails to log in 5 times, **THE** system **SHALL** lock the account for 15 minutes.\n- **WHEN** a user enables two-factor authentication, **THE** system **SHALL** require a verification code for login.\n\n### 7.3 Security Measures\n- **WHEN** a user is inactive for 30 minutes, **THE** system **SHALL** automatically log them out.\n- **WHEN** a user attempts to access sensitive information, **THE** system **SHALL** require password re-entry.\n\n## 8. Error Handling\n\n### 8.1 Common Error Scenarios\n- **WHEN** a user enters an invalid email format, **THE** system **SHALL** display an error message.\n- **WHEN** a user enters a weak password, **THE** system **SHALL** display password requirements.\n- **WHEN** a user enters an incorrect password, **THE** system **SHALL** display an error message.\n\n### 8.2 Error Recovery\n- **WHEN** a user fails to log in, **THE** system **SHALL** provide a password reset option.\n- **WHEN** a user encounters an error, **THE** system **SHALL** provide clear instructions for resolution.\n\n## 9. Performance Requirements\n\n### 9.1 Response Times\n- **WHEN** a user submits a registration form, **THE** system **SHALL** respond within 2 seconds.\n- **WHEN** a user logs in, **THE** system **SHALL** respond within 1 second.\n\n### 9.2 System Availability\n- **WHEN** a user attempts to access the platform, **THE** system **SHALL** be available 99.9% of the time.\n\n## 10. Compliance and Legal\n\n### 10.1 Data Protection\n- **WHEN** a user provides personal information, **THE** system **SHALL** store it securely.\n- **WHEN** a user requests data deletion, **THE** system **SHALL** comply within 30 days.\n\n### 10.2 Privacy Policies\n- **WHEN** a user registers, **THE** system **SHALL** require acceptance of privacy policies.\n- **WHEN** a user updates their profile, **THE** system **SHALL** require re-acceptance of privacy policies if they have changed.\n\n## Related Documents\n- [Service Overview](./00-toc.md)\n- [Business Model](./01-business-model.md)\n- [Product Catalog](./03-product-catalog.md)\n- [Shopping Cart](./04-shopping-cart.md)\n- [Order Placement](./05-order-placement.md)\n- [Order Tracking](./06-order-tracking.md)\n- [Product Reviews](./07-product-reviews.md)\n- [Seller Accounts](./08-seller-accounts.md)\n- [Admin Dashboard](./09-admin-dashboard.md)\n- [User Flow](./10-user-flow.md)\n- [Technical Requirements](./11-technical-requirements.md)"},{"reason":"To define the product catalog structure, including categories, search functionality, and product details.","filename":"03-product-catalog.md","documentType":"requirement","outline":["Product Categories","Product Search","Product Details","Product Variants","Inventory Management"],"audience":"development team","keyQuestions":["How are products categorized?","What search filters are available?","What information is included in product details?","How are product variants managed?","How is inventory tracked?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define product categories","Must specify search functionality","Must include product details","Must define inventory management"],"content":"# Product Catalog Requirements Specification\n\n## 1. Introduction\n\n### 1.1 Purpose\nThis document specifies the requirements for the product catalog system of the e-commerce shopping mall platform. It defines how products are categorized, searched, displayed, and managed within the system.\n\n### 1.2 Scope\nThis specification covers all aspects of product catalog functionality including:\n- Product categorization and hierarchy\n- Product search and filtering\n- Product detail display\n- Product variant management\n- Inventory tracking and management\n\n### 1.3 Definitions\n- **SKU**: Stock Keeping Unit - a unique identifier for each product variant\n- **Product Variant**: Different versions of the same product (e.g., different colors, sizes)\n- **Category**: A grouping of similar products\n- **Inventory**: The stock level of available products\n\n## 2. Product Categories\n\n### 2.1 Category Structure\n\n**EARS Requirement**: THE system SHALL support a hierarchical category structure with at least 3 levels (main category, subcategory, sub-subcategory).\n\n```mermaid\ngraph LR\n    A[\"Main Category\"] --> B[\"Subcategory\"]\n    B --> C[\"Sub-subcategory\"]\n    C --> D[\"Product\"]\n```\n\n### 2.2 Category Management\n\n**EARS Requirement**: WHEN an admin creates a new category, THE system SHALL validate that the category name is unique within its parent level.\n\n**EARS Requirement**: THE system SHALL allow admins to assign products to multiple categories.\n\n## 3. Product Search\n\n### 3.1 Search Functionality\n\n**EARS Requirement**: WHEN a user enters a search query, THE system SHALL return products matching the query in the product name, description, or category.\n\n**EARS Requirement**: THE system SHALL support autocomplete suggestions as the user types their search query.\n\n### 3.2 Search Filters\n\n**EARS Requirement**: THE system SHALL provide the following search filters:\n- Price range\n- Brand\n- Rating\n- Availability\n- Category\n- Color\n- Size\n\n**EARS Requirement**: WHEN a user applies multiple filters, THE system SHALL return products that match ALL selected filters.\n\n### 3.3 Search Results\n\n**EARS Requirement**: THE system SHALL display search results with pagination, showing 20 products per page.\n\n**EARS Requirement**: THE system SHALL allow sorting of search results by:\n- Relevance\n- Price (low to high)\n- Price (high to low)\n- Rating\n- Newest\n\n## 4. Product Details\n\n### 4.1 Product Information\n\n**EARS Requirement**: THE system SHALL display the following information on each product detail page:\n- Product name\n- Product description\n- Price\n- Available variants (colors, sizes)\n- Current inventory status\n- Average rating\n- Number of reviews\n\n### 4.2 Product Images\n\n**EARS Requirement**: THE system SHALL support multiple product images (minimum 5 images per product).\n\n**EARS Requirement**: THE system SHALL allow users to zoom in on product images.\n\n### 4.3 Product Descriptions\n\n**EARS Requirement**: THE system SHALL support rich text formatting for product descriptions.\n\n**EARS Requirement**: THE system SHALL allow sellers to include technical specifications in a structured format.\n\n## 5. Product Variants\n\n### 5.1 Variant Types\n\n**EARS Requirement**: THE system SHALL support the following variant types:\n- Color\n- Size\n- Material\n- Custom options (defined by seller)\n\n### 5.2 Variant Management\n\n**EARS Requirement**: WHEN a seller creates a new product, THE system SHALL allow them to define multiple variants.\n\n**EARS Requirement**: THE system SHALL track inventory separately for each product variant.\n\n### 5.3 SKU Management\n\n**EARS Requirement**: THE system SHALL automatically generate a unique SKU for each product variant.\n\n**EARS Requirement**: THE system SHALL prevent duplicate SKUs.\n\n## 6. Inventory Management\n\n### 6.1 Inventory Tracking\n\n**EARS Requirement**: THE system SHALL track inventory levels in real-time for each product variant.\n\n**EARS Requirement**: WHEN inventory reaches 0 for a variant, THE system SHALL mark it as \"out of stock\".\n\n### 6.2 Low Stock Alerts\n\n**EARS Requirement**: THE system SHALL notify sellers when inventory for any variant falls below a configurable threshold.\n\n### 6.3 Inventory Updates\n\n**EARS Requirement**: WHEN a seller updates inventory levels, THE system SHALL validate that the new quantity is a positive integer.\n\n**EARS Requirement**: THE system SHALL update inventory levels automatically when orders are placed or canceled.\n\n## 7. Business Rules\n\n**EARS Requirement**: THE system SHALL prevent sellers from creating products without at least one variant.\n\n**EARS Requirement**: THE system SHALL require all products to have a minimum of one image.\n\n**EARS Requirement**: THE system SHALL validate that product prices are positive numbers.\n\n## 8. Error Handling\n\n**EARS Requirement**: WHEN a user searches for a product that doesn't exist, THE system SHALL display a \"No products found\" message.\n\n**EARS Requirement**: WHEN a seller tries to create a duplicate SKU, THE system SHALL display an error message and prevent creation.\n\n## 9. Performance Requirements\n\n**EARS Requirement**: THE system SHALL return search results within 2 seconds for common queries.\n\n**EARS Requirement**: THE system SHALL load product detail pages within 1 second.\n\n## 10. User Roles and Permissions\n\n**EARS Requirement**: THE system SHALL allow customers to view all product information.\n\n**EARS Requirement**: THE system SHALL allow sellers to create, edit, and delete their own products.\n\n**EARS Requirement**: THE system SHALL allow admins to manage all products and categories.\n\n## 11. Integration Requirements\n\n**EARS Requirement**: THE system SHALL integrate with the shopping cart system to provide real-time inventory validation.\n\n**EARS Requirement**: THE system SHALL integrate with the order system to update inventory levels upon order placement.\n\n## 12. Future Considerations\n\n**EARS Requirement**: THE system SHOULD support product recommendations based on user browsing history.\n\n**EARS Requirement**: THE system SHOULD support bulk product upload for sellers.\n\n## 13. Mermaid Diagrams\n\n### Product Search Flow\n\n```mermaid\ngraph LR\n    A[\"User enters search query\"] --> B[\"System processes query\"]\n    B --> C[\"System applies filters\"]\n    C --> D[\"System retrieves matching products\"]\n    D --> E[\"System displays results\"]\n```\n\n### Product Variant Management\n\n```mermaid\ngraph LR\n    A[\"Seller creates product\"] --> B[\"Seller defines variants\"]\n    B --> C[\"System generates SKUs\"]\n    C --> D[\"System tracks inventory per variant\"]\n    D --> E[\"System updates inventory on orders\"]\n```\n\n## 14. Related Documents\n\n- [Service Overview](./00-toc.md)\n- [User Authentication](./02-user-authentication.md)\n- [Shopping Cart](./04-shopping-cart.md)\n- [Order Placement](./05-order-placement.md)\n\n## 15. Conclusion\n\nThis document provides a comprehensive specification for the product catalog system of the e-commerce shopping mall platform. It defines all aspects of product management, search, display, and inventory tracking to ensure a robust and user-friendly shopping experience.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To specify the shopping cart and wishlist functionality, including adding, removing, and managing items.","filename":"04-shopping-cart.md","documentType":"requirement","outline":["Shopping Cart","Wishlist","Cart Management","Wishlist Management","Cart and Wishlist Integration"],"audience":"development team","keyQuestions":["How do users add items to the cart?","How do users manage their wishlist?","How are cart and wishlist integrated?","What happens when items are out of stock?","How are cart and wishlist items stored?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define cart functionality","Must specify wishlist management","Must include cart and wishlist integration"],"content":"# Shopping Cart and Wishlist Functional Requirements\n\n## 1. Introduction\n\nThis document specifies the functional requirements for the shopping cart and wishlist features of the shoppingMall e-commerce platform. These features are critical for user experience and conversion optimization.\n\n## 2. Shopping Cart Functionality\n\n### 2.1 Adding Items to Cart\n\n**EARS Format:**\n- WHEN a user selects a product, THE system SHALL allow adding the product to the shopping cart.\n- WHEN a user adds a product to the cart, THE system SHALL display a confirmation message.\n- WHEN a product has variants (SKU), THE system SHALL require the user to select a specific variant before adding to cart.\n\n**Business Rules:**\n- Users can add multiple quantities of the same product\n- Products must be in stock to be added to cart\n- Product variants must be selected before adding to cart\n\n### 2.2 Removing Items from Cart\n\n**EARS Format:**\n- WHEN a user removes an item from the cart, THE system SHALL update the cart total immediately.\n- WHEN the last item is removed, THE system SHALL display an empty cart message.\n\n**Business Rules:**\n- Removed items should be available for re-addition\n- Cart total must reflect changes immediately\n\n### 2.3 Updating Item Quantities\n\n**EARS Format:**\n- WHEN a user changes the quantity of an item, THE system SHALL update the cart total immediately.\n- WHEN a user exceeds available inventory, THE system SHALL display an error message.\n\n**Business Rules:**\n- Quantity changes must respect inventory limits\n- Price updates must be real-time\n\n### 2.4 Cart Persistence\n\n**EARS Format:**\n- WHEN a user logs in, THE system SHALL restore their previous cart contents.\n- WHEN a user is inactive for 30 days, THE system SHALL clear their saved cart.\n\n**Business Rules:**\n- Cart contents persist across sessions for logged-in users\n- Guest carts are session-based\n\n### 2.5 Cart Abandonment Handling\n\n**EARS Format:**\n- WHEN a user abandons a cart with items, THE system SHALL send a reminder email after 24 hours.\n- WHEN a user abandons a cart, THE system SHALL save the cart contents for 30 days.\n\n**Business Rules:**\n- Abandoned cart reminders should include product images\n- Cart contents expire after 30 days\n\n### 2.6 Cart Sharing\n\n**EARS Format:**\n- WHEN a user shares their cart, THE system SHALL generate a shareable link.\n- WHEN a shared cart is accessed, THE system SHALL display the cart contents without user-specific information.\n\n**Business Rules:**\n- Shared carts should not expose personal information\n- Shared carts should be accessible without login\n\n## 3. Wishlist Functionality\n\n### 3.1 Adding Items to Wishlist\n\n**EARS Format:**\n- WHEN a user selects a product, THE system SHALL allow adding the product to the wishlist.\n- WHEN a user adds a product to the wishlist, THE system SHALL display a confirmation message.\n\n**Business Rules:**\n- Users can add products regardless of stock status\n- Wishlist items should be sortable\n\n### 3.2 Removing Items from Wishlist\n\n**EARS Format:**\n- WHEN a user removes an item from the wishlist, THE system SHALL update the wishlist display immediately.\n- WHEN the last item is removed, THE system SHALL display an empty wishlist message.\n\n**Business Rules:**\n- Removed items should be available for re-addition\n- Wishlist should update in real-time\n\n### 3.3 Wishlist Organization\n\n**EARS Format:**\n- WHEN a user organizes their wishlist, THE system SHALL save the organization preferences.\n- WHEN a user creates a new wishlist, THE system SHALL allow naming and categorizing the wishlist.\n\n**Business Rules:**\n- Users can create multiple wishlists\n- Wishlists can be private or public\n\n### 3.4 Wishlist Sharing\n\n**EARS Format:**\n- WHEN a user shares their wishlist, THE system SHALL generate a shareable link.\n- WHEN a shared wishlist is accessed, THE system SHALL display the wishlist contents without user-specific information.\n\n**Business Rules:**\n- Shared wishlists should not expose personal information\n- Shared wishlists should be accessible without login\n\n### 3.5 Wishlist Notifications\n\n**EARS Format:**\n- WHEN a wishlist item goes on sale, THE system SHALL notify the user via email.\n- WHEN a wishlist item is back in stock, THE system SHALL notify the user via email.\n\n**Business Rules:**\n- Notifications should be configurable\n- Notifications should include direct links to products\n\n## 4. Cart and Wishlist Integration\n\n### 4.1 Moving Items Between Cart and Wishlist\n\n**EARS Format:**\n- WHEN a user moves an item from wishlist to cart, THE system SHALL update both lists immediately.\n- WHEN a user moves an item from cart to wishlist, THE system SHALL update both lists immediately.\n\n**Business Rules:**\n- Moving items should preserve quantity information\n- Moving items should respect inventory limits\n\n### 4.2 Wishlist to Cart Conversion\n\n**EARS Format:**\n- WHEN a user converts wishlist items to cart, THE system SHALL check inventory availability.\n- WHEN inventory is insufficient, THE system SHALL notify the user of unavailable items.\n\n**Business Rules:**\n- Conversion should respect current inventory\n- Conversion should preserve wishlist organization\n\n### 4.3 Synchronization Between Devices\n\n**EARS Format:**\n- WHEN a user accesses their account from a different device, THE system SHALL synchronize cart and wishlist contents.\n- WHEN a user makes changes on one device, THE system SHALL reflect those changes on all devices.\n\n**Business Rules:**\n- Synchronization should be real-time\n- Synchronization should preserve organization\n\n## 5. Business Rules and Constraints\n\n### 5.1 Inventory Management\n\n**EARS Format:**\n- WHEN a product goes out of stock, THE system SHALL remove it from active carts.\n- WHEN a product goes out of stock, THE system SHALL notify users who have it in their wishlist.\n\n**Business Rules:**\n- Out-of-stock items should be clearly marked\n- Users should be notified of restocking\n\n### 5.2 Out-of-Stock Handling\n\n**EARS Format:**\n- WHEN a user attempts to add an out-of-stock item to cart, THE system SHALL display an error message.\n- WHEN a user attempts to add an out-of-stock item to cart, THE system SHALL offer to add it to the wishlist instead.\n\n**Business Rules:**\n- Out-of-stock items should be clearly marked\n- Users should be notified of restocking\n\n### 5.3 Price Updates\n\n**EARS Format:**\n- WHEN a product price changes, THE system SHALL update the price in active carts.\n- WHEN a product price changes, THE system SHALL notify users who have it in their cart or wishlist.\n\n**Business Rules:**\n- Price changes should be reflected immediately\n- Users should be notified of price changes\n\n### 5.4 Promotions and Discounts\n\n**EARS Format:**\n- WHEN a promotion is applied, THE system SHALL update the cart total immediately.\n- WHEN a promotion expires, THE system SHALL remove the discount from the cart total.\n\n**Business Rules:**\n- Promotions should be clearly marked\n- Discounts should be applied in real-time\n\n## 6. User Interface Considerations\n\n### 6.1 Cart Summary Display\n\n**EARS Format:**\n- THE system SHALL display a summary of cart contents on every page.\n- THE system SHALL display the total number of items and total price in the cart summary.\n\n**Business Rules:**\n- Cart summary should be accessible from any page\n- Cart summary should update in real-time\n\n### 6.2 Wishlist Display\n\n**EARS Format:**\n- THE system SHALL display wishlist items with images and prices.\n- THE system SHALL allow sorting and filtering of wishlist items.\n\n**Business Rules:**\n- Wishlist should be easily accessible\n- Wishlist should be sortable\n\n### 6.3 Mobile Responsiveness\n\n**EARS Format:**\n- THE system SHALL be fully responsive on mobile devices.\n- THE system SHALL provide a simplified cart and wishlist interface on mobile devices.\n\n**Business Rules:**\n- Mobile interface should be intuitive\n- Mobile interface should preserve all functionality\n\n## 7. Performance Requirements\n\n### 7.1 Load Times\n\n**EARS Format:**\n- THE system SHALL load cart and wishlist contents within 2 seconds.\n- THE system SHALL update cart and wishlist contents in real-time.\n\n**Business Rules:**\n- Load times should be optimized\n- Updates should be immediate\n\n### 7.2 Real-time Updates\n\n**EARS Format:**\n- THE system SHALL update cart and wishlist contents in real-time.\n- THE system SHALL reflect changes immediately across all devices.\n\n**Business Rules:**\n- Updates should be immediate\n- Changes should be reflected across devices\n\n### 7.3 Scalability\n\n**EARS Format:**\n- THE system SHALL support up to 10,000 concurrent users.\n- THE system SHALL handle up to 1,000,000 cart and wishlist operations per day.\n\n**Business Rules:**\n- System should be scalable\n- System should handle high traffic\n\n## 8. Security Considerations\n\n### 8.1 Data Privacy\n\n**EARS Format:**\n- THE system SHALL encrypt all cart and wishlist data.\n- THE system SHALL comply with GDPR and CCPA regulations.\n\n**Business Rules:**\n- Data should be encrypted\n- System should comply with regulations\n\n### 8.2 Authentication Requirements\n\n**EARS Format:**\n- THE system SHALL require authentication for accessing cart and wishlist.\n- THE system SHALL allow guest users to create temporary carts.\n\n**Business Rules:**\n- Authentication should be required\n- Guest users should have limited functionality\n\n### 8.3 Payment Information Security\n\n**EARS Format:**\n- THE system SHALL encrypt all payment information.\n- THE system SHALL comply with PCI-DSS regulations.\n\n**Business Rules:**\n- Payment information should be encrypted\n- System should comply with regulations\n\n## 9. User Flow Diagrams\n\n### 9.1 Cart Management Flow\n\n```mermaid\ngraph LR\n    A[\"User Browses Product\"] --> B[\"Add to Cart\"]\n    B --> C[\"View Cart\"]\n    C --> D[\"Update Quantity\"]\n    C --> E[\"Remove Item\"]\n    C --> F[\"Proceed to Checkout\"]\n    D --> C\n    E --> C\n```\n\n### 9.2 Wishlist Management Flow\n\n```mermaid\ngraph LR\n    A[\"User Browses Product\"] --> B[\"Add to Wishlist\"]\n    B --> C[\"View Wishlist\"]\n    C --> D[\"Organize Wishlist\"]\n    C --> E[\"Remove Item\"]\n    C --> F[\"Move to Cart\"]\n    D --> C\n    E --> C\n    F --> G[\"View Cart\"]\n```\n\n### 9.3 Cart and Wishlist Integration Flow\n\n```mermaid\ngraph LR\n    A[\"User Views Wishlist\"] --> B[\"Select Items\"]\n    B --> C[\"Move to Cart\"]\n    C --> D[\"View Cart\"]\n    D --> E[\"Proceed to Checkout\"]\n    E --> F[\"Complete Purchase\"]\n```\n\n## 10. Business Rules Summary\n\n| Rule | Description | Implementation Requirement |\n|------|-------------|---------------------------|\n| Inventory Management | Products must be in stock to be added to cart | Real-time inventory check |\n| Out-of-Stock Handling | Out-of-stock items cannot be added to cart | Error message and wishlist suggestion |\n| Price Updates | Price changes must be reflected in cart | Real-time price update |\n| Promotions and Discounts | Promotions must be applied to cart | Real-time discount application |\n| Cart Persistence | Cart contents must persist across sessions | Session-based storage for guests, account-based for users |\n| Wishlist Organization | Users can create multiple wishlists | Wishlist categorization and naming |\n| Cart and Wishlist Integration | Items can be moved between cart and wishlist | Real-time synchronization |\n| Notifications | Users must be notified of price changes and restocking | Email and in-app notifications |\n| Mobile Responsiveness | System must be fully responsive | Mobile-optimized interface |\n| Performance | System must handle high traffic | Scalable architecture |\n| Security | Data must be encrypted | Encryption and compliance with regulations |\n\n## 11. Conclusion\n\nThis document provides a comprehensive specification for the shopping cart and wishlist functionality of the shoppingMall e-commerce platform. These features are critical for user experience and conversion optimization. The requirements are designed to ensure a seamless and secure shopping experience for users.\n\n## 12. References\n\n- User Authentication: [02-user-authentication.md](./02-user-authentication.md)\n- Product Catalog: [03-product-catalog.md](./03-product-catalog.md)\n- Order Placement: [05-order-placement.md](./05-order-placement.md)\n- Technical Requirements: [11-technical-requirements.md](./11-technical-requirements.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the order placement and payment processing workflow, including payment methods and order confirmation.","filename":"05-order-placement.md","documentType":"requirement","outline":["Order Placement","Payment Processing","Order Confirmation","Payment Methods","Order Status"],"audience":"development team","keyQuestions":["How do users place orders?","What payment methods are supported?","How is order confirmation handled?","How is order status tracked?","What happens if payment fails?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define order placement","Must specify payment methods","Must include order confirmation","Must define order status tracking"],"content":"# Order Placement and Payment Processing Requirements\n\n## 1. Introduction\n\n### Purpose of the Document\nThis document defines the complete requirements for order placement and payment processing in the e-commerce shopping mall platform. It specifies the workflow from cart submission to order confirmation, including all payment methods, error handling, security requirements, and integration points.\n\n### Scope\nThis document covers:\n- Order placement workflow\n- Payment processing with all supported methods\n- Order confirmation and notifications\n- Error handling and edge cases\n- Security and compliance requirements\n- Integration with external systems\n- Performance expectations\n\n## 2. Order Placement Workflow\n\n### User Initiation\n\n**EARS Format**:\n- WHEN a user clicks \"Place Order\" from the cart, THE system SHALL validate the cart contents\n- WHEN the cart is valid, THE system SHALL display the order summary page\n\n### Cart Validation\n\n**EARS Format**:\n- THE system SHALL verify that all items in the cart are still available\n- THE system SHALL check that quantities are within inventory limits\n- THE system SHALL validate shipping and billing addresses\n\n### Order Summary\n\n**EARS Format**:\n- THE order summary page SHALL display all items with quantities and prices\n- THE order summary page SHALL show shipping and billing addresses\n- THE order summary page SHALL display selected shipping method\n- THE order summary page SHALL show order total with tax and shipping\n\n### Order Submission\n\n**EARS Format**:\n- WHEN the user confirms the order, THE system SHALL create an order record\n- THE system SHALL generate a unique order ID\n- THE system SHALL transition the order to \"Pending Payment\" status\n\n```mermaid\ngraph LR\n  A[\"User Clicks Place Order\"] --> B[\"Validate Cart\"]\n  B --> C[\"Show Order Summary\"]\n  C --> D[\"User Confirms Order\"]\n  D --> E[\"Create Order Record\"]\n  E --> F[\"Generate Order ID\"]\n  F --> G[\"Set Status: Pending Payment\"]\n```\n\n## 3. Payment Processing\n\n### Supported Payment Methods\n\n**EARS Format**:\n- THE system SHALL support credit/debit card payments\n- THE system SHALL support PayPal payments\n- THE system SHALL support bank transfer payments\n- THE system SHALL support digital wallet payments (Apple Pay, Google Pay)\n\n### Payment Gateway Integration\n\n**EARS Format**:\n- THE system SHALL integrate with Stripe for credit card processing\n- THE system SHALL integrate with PayPal API for PayPal payments\n- THE system SHALL support manual verification for bank transfers\n\n### Payment Validation\n\n**EARS Format**:\n- WHEN a payment is submitted, THE system SHALL validate payment details\n- THE system SHALL check for sufficient funds\n- THE system SHALL verify payment security (CVV, expiration, etc.)\n\n### Payment Confirmation\n\n**EARS Format**:\n- WHEN payment is successful, THE system SHALL update order status to \"Processing\"\n- THE system SHALL send order confirmation email to the user\n- THE system SHALL update inventory levels\n\n```mermaid\ngraph LR\n  A[\"User Selects Payment Method\"] --> B[\"Enter Payment Details\"]\n  B --> C[\"Validate Payment\"]\n  C --> D[\"Process Payment\"]\n  D --> E[\"Payment Successful?\"]\n  E -->|Yes| F[\"Update Order Status\"]\n  E -->|No| G[\"Show Error Message\"]\n  F --> H[\"Send Confirmation Email\"]\n  F --> I[\"Update Inventory\"]\n```\n\n## 4. Order Confirmation\n\n### Order Status Updates\n\n**EARS Format**:\n- WHEN payment is confirmed, THE system SHALL update order status to \"Processing\"\n- THE system SHALL log the order confirmation timestamp\n- THE system SHALL record payment transaction details\n\n### User Notifications\n\n**EARS Format**:\n- THE system SHALL send order confirmation email with order details\n- THE system SHALL send SMS notification for high-value orders\n- THE system SHALL update the user's order history\n\n### Inventory Updates\n\n**EARS Format**:\n- THE system SHALL deduct ordered quantities from inventory\n- THE system SHALL update product availability status\n- THE system SHALL trigger low stock alerts if needed\n\n## 5. Error Handling and Edge Cases\n\n### Payment Failures\n\n**EARS Format**:\n- WHEN payment fails, THE system SHALL display error message to user\n- THE system SHALL log payment failure details\n- THE system SHALL allow user to retry payment\n\n### Inventory Shortages\n\n**EARS Format**:\n- WHEN inventory is insufficient, THE system SHALL prevent order submission\n- THE system SHALL notify user of stock availability\n- THE system SHALL suggest alternative products\n\n### Order Cancellation\n\n**EARS Format**:\n- WHEN user cancels order before payment, THE system SHALL release inventory\n- WHEN user cancels order after payment, THE system SHALL initiate refund process\n\n```mermaid\ngraph LR\n  A[\"Payment Processing\"] --> B[\"Payment Successful?\"]\n  B -->|No| C[\"Show Error Message\"]\n  B -->|Yes| D[\"Update Order Status\"]\n  C --> E[\"Log Payment Failure\"]\n  C --> F[\"Allow Retry\"]\n  D --> G[\"Send Confirmation\"]\n  D --> H[\"Update Inventory\"]\n```\n\n## 6. Security and Compliance\n\n### Payment Data Security\n\n**EARS Format**:\n- THE system SHALL encrypt all payment data in transit and at rest\n- THE system SHALL comply with PCI DSS standards\n- THE system SHALL use tokenization for payment data\n\n### PCI Compliance\n\n**EARS Format**:\n- THE system SHALL never store full credit card numbers\n- THE system SHALL use PCI-compliant payment gateways\n- THE system SHALL undergo regular PCI compliance audits\n\n### Fraud Detection\n\n**EARS Format**:\n- THE system SHALL implement fraud detection algorithms\n- THE system SHALL flag suspicious transactions for review\n- THE system SHALL use address verification (AVS) and CVV checks\n\n## 7. Integration Requirements\n\n### Third-party Payment Gateways\n\n**EARS Format**:\n- THE system SHALL integrate with Stripe API\n- THE system SHALL integrate with PayPal API\n- THE system SHALL support additional gateways as needed\n\n### Shipping Carriers\n\n**EARS Format**:\n- THE system SHALL integrate with major shipping carriers (UPS, FedEx, DHL)\n- THE system SHALL support real-time shipping rate calculation\n- THE system SHALL provide tracking information\n\n### Inventory Systems\n\n**EARS Format**:\n- THE system SHALL integrate with inventory management system\n- THE system SHALL support real-time inventory updates\n- THE system SHALL handle multi-warehouse inventory\n\n## 8. Performance Requirements\n\n### Response Times\n\n**EARS Format**:\n- THE order placement process SHALL complete within 5 seconds\n- THE payment processing SHALL complete within 3 seconds\n- THE order confirmation SHALL be sent within 1 minute\n\n### Throughput\n\n**EARS Format**:\n- THE system SHALL handle 1000 orders per minute during peak times\n- THE payment gateway SHALL support 500 transactions per second\n\n### Scalability\n\n**EARS Format**:\n- THE system SHALL scale horizontally to handle increased load\n- THE database SHALL support sharding for order data\n- THE payment system SHALL handle distributed processing\n\n## 9. Business Rules\n\n### Order Validation\n\n**EARS Format**:\n- THE system SHALL validate that order total matches cart total\n- THE system SHALL check that shipping address is complete\n- THE system SHALL verify that payment method is supported\n\n### Payment Authorization\n\n**EARS Format**:\n- THE system SHALL authorize payments before order confirmation\n- THE system SHALL capture payments only after order fulfillment\n- THE system SHALL handle partial authorizations for split shipments\n\n### Inventory Management\n\n**EARS Format**:\n- THE system SHALL reserve inventory during order placement\n- THE system SHALL release inventory if payment fails\n- THE system SHALL update inventory across all channels\n\n## 10. User Scenarios\n\n### Successful Order Placement\n\n**EARS Format**:\n- WHEN a user places an order with valid payment, THE system SHALL confirm the order\n- THE system SHALL send confirmation to the user\n- THE system SHALL update inventory levels\n\n### Failed Payment Recovery\n\n**EARS Format**:\n- WHEN payment fails, THE system SHALL allow user to retry\n- THE system SHALL maintain cart contents during retry\n- THE system SHALL provide alternative payment methods\n\n### Order Cancellation\n\n**EARS Format**:\n- WHEN a user cancels an order, THE system SHALL update order status\n- THE system SHALL process refund if payment was made\n- THE system SHALL restore inventory levels\n\n## 11. Related Documents\n\nFor complete understanding of the e-commerce platform, refer to:\n- [User Authentication Requirements](./02-user-authentication.md)\n- [Product Catalog Requirements](./03-product-catalog.md)\n- [Shopping Cart Requirements](./04-shopping-cart.md)\n- [Order Tracking Requirements](./06-order-tracking.md)\n\n## 12. Conclusion\n\nThis document provides comprehensive requirements for order placement and payment processing in the e-commerce shopping mall platform. It covers all aspects from order initiation to confirmation, including payment methods, error handling, security, and integration requirements.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To specify the order tracking and shipping status updates, including notifications and shipping integration.","filename":"06-order-tracking.md","documentType":"requirement","outline":["Order Tracking","Shipping Status","Notifications","Shipping Integration","Return and Refund"],"audience":"development team","keyQuestions":["How do users track their orders?","How are shipping statuses updated?","What notifications are sent to users?","How is shipping integrated?","How are returns and refunds handled?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define order tracking","Must specify shipping status updates","Must include notifications","Must define return and refund process"],"content":"# Order Tracking and Shipping Requirements for Shopping Mall Platform\n\n## Table of Contents\n1. [Introduction](#introduction)\n   - [Purpose](#purpose)\n   - [Scope](#scope)\n   - [Definitions](#definitions)\n2. [Order Tracking](#order-tracking)\n   - [Overview](#overview)\n   - [Tracking Information](#tracking-information)\n   - [Tracking Interface](#tracking-interface)\n3. [Shipping Status](#shipping-status)\n   - [Status Updates](#status-updates)\n   - [Status Notifications](#status-notifications)\n   - [Status History](#status-history)\n4. [Notifications](#notifications)\n   - [Notification Types](#notification-types)\n   - [Notification Channels](#notification-channels)\n   - [Notification Timing](#notification-timing)\n5. [Shipping Integration](#shipping-integration)\n   - [Carrier Integration](#carrier-integration)\n   - [Tracking Data](#tracking-data)\n   - [Shipping Labels](#shipping-labels)\n6. [Return and Refund](#return-and-refund)\n   - [Return Process](#return-process)\n   - [Refund Process](#refund-process)\n   - [Return Shipping](#return-shipping)\n7. [Business Rules](#business-rules)\n   - [Order Status Transitions](#order-status-transitions)\n   - [Notification Rules](#notification-rules)\n   - [Return Policies](#return-policies)\n8. [Performance Requirements](#performance-requirements)\n   - [Tracking Update Frequency](#tracking-update-frequency)\n   - [Notification Delivery](#notification-delivery)\n   - [System Response Time](#system-response-time)\n9. [Error Handling](#error-handling)\n   - [Tracking Failures](#tracking-failures)\n   - [Notification Failures](#notification-failures)\n   - [Return Processing Errors](#return-processing-errors)\n\n## 1. Introduction\n\n### Purpose\nThis document specifies the requirements for order tracking and shipping status updates in the e-commerce shopping mall platform. It defines how users track their orders, receive shipping updates, and manage returns and refunds.\n\n### Scope\nThis document covers:\n- Order tracking functionality\n- Shipping status management\n- User notifications\n- Shipping carrier integration\n- Return and refund processes\n\n### Definitions\n- **Order Tracking**: The system that allows users to monitor the progress of their orders\n- **Shipping Status**: The current state of an order's shipment (e.g., processing, shipped, delivered)\n- **Notification**: Automated messages sent to users about order status changes\n- **Return**: The process of sending back purchased items\n- **Refund**: The process of returning payment to the customer\n\n## 2. Order Tracking\n\n### Overview\nThe order tracking system allows customers to monitor the progress of their orders from placement to delivery.\n\n### Tracking Information\n**EARS**: WHEN a user views an order, THE system SHALL display the current tracking status, estimated delivery date, and shipping carrier information.\n\n### Tracking Interface\n**EARS**: THE order tracking interface SHALL display order status, shipping carrier, tracking number, estimated delivery date, and shipment progress.\n\n```mermaid\ngraph LR\n    A[\"User Views Order\"] --> B[\"System Retrieves Tracking Info\"]\n    B --> C[\"Display Tracking Status\"]\n    C --> D[\"Show Estimated Delivery\"]\n    D --> E[\"Update in Real-time\"]\n```\n\n## 3. Shipping Status\n\n### Status Updates\n**EARS**: WHEN the shipping status changes, THE system SHALL update the order status in real-time.\n\n**EARS**: THE system SHALL support the following shipping statuses: processing, shipped, in transit, out for delivery, delivered, returned.\n\n### Status Notifications\n**EARS**: WHEN the shipping status changes, THE system SHALL send a notification to the customer.\n\n### Status History\n**EARS**: THE system SHALL maintain a history of all status changes for each order.\n\n## 4. Notifications\n\n### Notification Types\n**EARS**: THE system SHALL send notifications for the following events: order confirmation, shipment, delivery, delay, cancellation, return status.\n\n### Notification Channels\n**EARS**: THE system SHALL support notifications via email and SMS.\n\n### Notification Timing\n**EARS**: WHEN an order status changes, THE system SHALL send a notification within 5 minutes.\n\n## 5. Shipping Integration\n\n### Carrier Integration\n**EARS**: THE system SHALL integrate with major shipping carriers (e.g., USPS, FedEx, UPS, DHL) for real-time tracking.\n\n### Tracking Data\n**EARS**: WHEN tracking data is available from the carrier, THE system SHALL update the order status automatically.\n\n### Shipping Labels\n**EARS**: THE system SHALL generate shipping labels for sellers with integrated carriers.\n\n## 6. Return and Refund\n\n### Return Process\n**EARS**: WHEN a customer initiates a return, THE system SHALL generate a return shipping label and update the order status.\n\n**EARS**: THE system SHALL provide a return reason selection and require return shipping information.\n\n### Refund Process\n**EARS**: WHEN a returned item is received, THE system SHALL process the refund within 3 business days.\n\n**EARS**: THE system SHALL support partial refunds for partial returns.\n\n### Return Shipping\n**EARS**: THE system SHALL provide return shipping options with tracking.\n\n## 7. Business Rules\n\n### Order Status Transitions\n**EARS**: THE system SHALL only allow valid status transitions (e.g., processing → shipped → delivered).\n\n### Notification Rules\n**EARS**: THE system SHALL only send notifications for significant status changes.\n\n### Return Policies\n**EARS**: THE system SHALL enforce a 30-day return window from delivery date.\n\n## 8. Performance Requirements\n\n### Tracking Update Frequency\n**EARS**: THE system SHALL update tracking information at least every 4 hours.\n\n### Notification Delivery\n**EARS**: THE system SHALL deliver notifications within 5 minutes of status change.\n\n### System Response Time\n**EARS**: THE order tracking interface SHALL load within 2 seconds.\n\n## 9. Error Handling\n\n### Tracking Failures\n**EARS**: IF tracking data cannot be retrieved, THEN THE system SHALL display the last known status and notify the user.\n\n### Notification Failures\n**EARS**: IF a notification cannot be delivered, THEN THE system SHALL retry delivery up to 3 times.\n\n### Return Processing Errors\n**EARS**: IF a return cannot be processed, THEN THE system SHALL notify the customer and provide manual processing options.\n\n## Related Documents\n- [Service Overview](./00-toc.md)\n- [Order Placement Requirements](./05-order-placement.md)\n- [Seller Accounts Requirements](./08-seller-accounts.md)\n- [Admin Dashboard Requirements](./09-admin-dashboard.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the product reviews and ratings system, including submission, moderation, and display.","filename":"07-product-reviews.md","documentType":"requirement","outline":["Review Submission","Review Moderation","Review Display","Rating System","Review Analytics"],"audience":"development team","keyQuestions":["How do users submit reviews?","How are reviews moderated?","How are reviews displayed?","How is the rating system calculated?","What analytics are available for reviews?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define review submission","Must specify review moderation","Must include review display","Must define rating system"],"content":"# Product Reviews and Ratings System Requirements\n\n## Table of Contents\n1. [Review Submission](#review-submission)\n2. [Review Moderation](#review-moderation)\n3. [Review Display](#review-display)\n4. [Rating System](#rating-system)\n5. [Review Analytics](#review-analytics)\n\n## Review Submission\n\n### User Interface for Submitting Reviews\n\n**EARS Requirement**: \nWHEN a user views a product detail page, THE system SHALL display a \"Write a Review\" button if the user has purchased the product.\n\n**EARS Requirement**: \nWHEN a user clicks the \"Write a Review\" button, THE system SHALL display a review submission form with the following fields:\n- Rating (1-5 stars)\n- Review title (optional)\n- Review text (required, max 1000 characters)\n- Photos (optional, max 5 images)\n- Video (optional, max 1 minute)\n\n### Required Fields and Validation\n\n**EARS Requirement**: \nTHE review submission form SHALL validate that:\n- Rating is between 1 and 5 stars\n- Review text is between 10 and 1000 characters\n- Photos are in JPG/PNG format and under 5MB each\n- Video is in MP4 format and under 50MB\n\n**EARS Requirement**: \nWHEN a user submits a review, THE system SHALL check if the user has verified purchase of the product.\n\n### Review Submission Process\n\n**EARS Requirement**: \nWHEN a user submits a review, THE system SHALL:\n1. Validate all form fields\n2. Check for verified purchase\n3. Store the review in \"pending\" status\n4. Notify the user that their review is under moderation\n5. Send the review to the moderation queue\n\n```mermaid\ngraph LR\n    A[\"User Clicks Write Review\"] --> B[\"Display Review Form\"]\n    B --> C[\"User Submits Review\"]\n    C --> D[\"Validate Form Fields\"]\n    D --> E[\"Check Verified Purchase\"]\n    E --> F[\"Store Review as Pending\"]\n    F --> G[\"Notify User\"]\n    F --> H[\"Send to Moderation Queue\"]\n```\n\n## Review Moderation\n\n### Moderation Workflow\n\n**EARS Requirement**: \nTHE review moderation system SHALL allow admin and seller users to:\n- View pending reviews in a queue\n- Approve or reject reviews\n- Flag reviews for further investigation\n- View review history and moderation actions\n\n**EARS Requirement**: \nWHEN a moderator approves a review, THE system SHALL:\n1. Update the review status to \"approved\"\n2. Make the review visible on the product page\n3. Update the product's average rating\n4. Notify the reviewer that their review is now visible\n\n**EARS Requirement**: \nWHEN a moderator rejects a review, THE system SHALL:\n1. Update the review status to \"rejected\"\n2. Notify the reviewer with the reason for rejection\n3. Allow the reviewer to edit and resubmit the review\n\n### Approval and Rejection Criteria\n\n**EARS Requirement**: \nTHE system SHALL automatically flag reviews that contain:\n- Profanity or offensive language\n- Personal information (emails, phone numbers)\n- Suspicious patterns (same text submitted multiple times)\n\n**EARS Requirement**: \nTHE system SHALL provide moderators with guidelines for:\n- Approving constructive criticism\n- Rejecting off-topic or irrelevant reviews\n- Handling reviews with mixed feedback\n\n### Flagging and Reporting System\n\n**EARS Requirement**: \nWHEN a user views a review, THE system SHALL display a \"Report\" button.\n\n**EARS Requirement**: \nWHEN a user reports a review, THE system SHALL:\n1. Collect the report reason\n2. Flag the review for moderator attention\n3. Notify moderators of the reported review\n\n```mermaid\ngraph LR\n    A[\"Review Submitted\"] --> B[\"Pending Queue\"]\n    B --> C[\"Moderator Reviews\"]\n    C --> D[\"Approve?\"]\n    D -->|Yes| E[\"Update to Approved\"]\n    D -->|No| F[\"Reject with Reason\"]\n    E --> G[\"Visible on Product Page\"]\n    E --> H[\"Update Product Rating\"]\n    F --> I[\"Notify Reviewer\"]\n    F --> J[\"Allow Resubmission\"]\n```\n\n## Review Display\n\n### Review Listing and Sorting\n\n**EARS Requirement**: \nWHEN a user views a product page, THE system SHALL display approved reviews sorted by:\n- Most helpful (default)\n- Most recent\n- Highest rating\n- Lowest rating\n\n**EARS Requirement**: \nTHE system SHALL display the following for each review:\n- User avatar and name\n- Rating (stars)\n- Review title\n- Review text\n- Photos/videos (if any)\n- Date of review\n- Verified purchase badge\n\n### Review Filtering Options\n\n**EARS Requirement**: \nTHE system SHALL provide filtering options for reviews by:\n- Rating (1-5 stars)\n- Verified purchases only\n- With photos/videos\n- Most recent\n\n**EARS Requirement**: \nWHEN a user applies filters, THE system SHALL update the review list in real-time.\n\n### Review Display Format\n\n**EARS Requirement**: \nTHE system SHALL display reviews in a responsive format that includes:\n- User information section (avatar, name, date)\n- Rating display (stars)\n- Review content (title, text)\n- Media gallery (photos/videos)\n- Helpfulness voting (thumbs up/down)\n- Report button\n\n```mermaid\ngraph LR\n    A[\"Product Page Loads\"] --> B[\"Fetch Approved Reviews\"]\n    B --> C[\"Apply Default Sorting\"]\n    C --> D[\"Display Reviews\"]\n    D --> E[\"User Applies Filters\"]\n    E --> F[\"Update Review List\"]\n```\n\n## Rating System\n\n### Rating Calculation Methodology\n\n**EARS Requirement**: \nTHE product rating SHALL be calculated as the average of all approved review ratings.\n\n**EARS Requirement**: \nTHE system SHALL update the product rating in real-time when:\n- A new review is approved\n- An existing review is edited and re-approved\n- A review is deleted\n\n**EARS Requirement**: \nTHE system SHALL display the product rating with:\n- Average star rating (to 1 decimal place)\n- Total number of reviews\n- Rating distribution (number of each star rating)\n\n### Rating Display and Aggregation\n\n**EARS Requirement**: \nWHEN a user views a product page, THE system SHALL display:\n- The average product rating prominently\n- The rating distribution chart\n- The total review count\n\n**EARS Requirement**: \nTHE system SHALL allow users to filter products by rating range in search results.\n\n### Rating Updates and Recalculations\n\n**EARS Requirement**: \nWHEN a review is edited, THE system SHALL:\n1. Place the review back in moderation queue\n2. Temporarily exclude the review from rating calculation\n3. Recalculate the product rating without the pending review\n\n**EARS Requirement**: \nWHEN a review is deleted, THE system SHALL:\n1. Remove the review from the database\n2. Recalculate the product rating excluding the deleted review\n\n```mermaid\ngraph LR\n    A[\"New Review Approved\"] --> B[\"Add to Rating Calculation\"]\n    B --> C[\"Update Product Rating\"]\n    D[\"Review Edited\"] --> E[\"Remove from Calculation\"]\n    E --> F[\"Recalculate Rating\"]\n    G[\"Review Deleted\"] --> H[\"Remove from Calculation\"]\n    H --> I[\"Recalculate Rating\"]\n```\n\n## Review Analytics\n\n### Review Metrics and Statistics\n\n**EARS Requirement**: \nTHE system SHALL track the following review metrics:\n- Total number of reviews\n- Average review rating\n- Number of reviews by rating (1-5 stars)\n- Number of reviews with photos/videos\n- Number of verified purchase reviews\n\n**EARS Requirement**: \nTHE system SHALL provide sellers with analytics on their product reviews including:\n- Review count over time\n- Average rating trends\n- Most common keywords in reviews\n- Review sentiment analysis\n\n### Review Trends and Insights\n\n**EARS Requirement**: \nTHE system SHALL generate insights such as:\n- Most reviewed products\n- Highest rated products\n- Lowest rated products\n- Products with most improved ratings\n- Products with declining ratings\n\n**EARS Requirement**: \nTHE system SHALL allow sellers to compare their review performance against category averages.\n\n### Review Performance Indicators\n\n**EARS Requirement**: \nTHE system SHALL calculate the following performance indicators:\n- Review response rate (reviews per sale)\n- Review approval rate\n- Average time to moderation\n- Review helpfulness score (upvotes/downvotes)\n\n**EARS Requirement**: \nTHE system SHALL display review performance indicators in the seller dashboard.\n\n```mermaid\ngraph LR\n    A[\"Collect Review Data\"] --> B[\"Calculate Metrics\"]\n    B --> C[\"Generate Insights\"]\n    C --> D[\"Display in Dashboard\"]\n    D --> E[\"Seller Views Analytics\"]\n    E --> F[\"Make Data-Driven Decisions\"]\n```\n\n## Integration Requirements\n\n**EARS Requirement**: \nTHE review system SHALL integrate with:\n- User authentication system for verified purchases\n- Product catalog for review association\n- Order history for purchase verification\n- Notification system for review status updates\n\n**EARS Requirement**: \nTHE review system SHALL support localization for:\n- Review submission in multiple languages\n- Review display in user's preferred language\n- Moderation interface in admin's language\n\n## Performance Requirements\n\n**EARS Requirement**: \nTHE review system SHALL:\n- Load reviews within 2 seconds on product pages\n- Support up to 10,000 reviews per product\n- Handle 100 concurrent review submissions\n- Update ratings in real-time (within 1 second of approval)\n\n## Security Requirements\n\n**EARS Requirement**: \nTHE review system SHALL:\n- Prevent duplicate reviews from the same user for the same product\n- Sanitize review text to prevent XSS attacks\n- Validate all uploaded media for malicious content\n- Require authentication for all review actions\n\n## Accessibility Requirements\n\n**EARS Requirement**: \nTHE review system SHALL:\n- Support screen readers for review submission and display\n- Provide keyboard navigation for all review features\n- Ensure color contrast meets WCAG standards for review components\n\n## Future Considerations\n\n**EARS Requirement**: \nTHE system SHOULD support:\n- AI-powered review summarization\n- Automated sentiment analysis\n- Review translation between languages\n- Enhanced media support (360° images, AR previews)\n\n## Developer Note\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*\n\n## Related Documents\n\nFor complete understanding of the e-commerce platform, refer to:\n- [Service Overview](./00-toc.md)\n- [User Authentication](./02-user-authentication.md)\n- [Product Catalog](./03-product-catalog.md)\n- [Shopping Cart](./04-shopping-cart.md)\n- [Order Placement](./05-order-placement.md)\n- [Order Tracking](./06-order-tracking.md)\n- [Seller Accounts](./08-seller-accounts.md)\n- [Admin Dashboard](./09-admin-dashboard.md)\n\n## Conclusion\n\nThis document provides comprehensive requirements for the product reviews and ratings system. It covers the complete review lifecycle from submission to display, including moderation, rating calculation, and analytics. Developers should use this as the primary reference for implementing the review system, ensuring all business requirements are met while maintaining flexibility in technical implementation."},{"reason":"To specify the seller account functionality, including product management, order management, and analytics.","filename":"08-seller-accounts.md","documentType":"requirement","outline":["Seller Registration","Product Management","Order Management","Inventory Management","Seller Analytics"],"audience":"development team","keyQuestions":["How do sellers register?","How do sellers manage their products?","How do sellers manage orders?","How do sellers manage inventory?","What analytics are available to sellers?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define seller registration","Must specify product management","Must include order management","Must define inventory management","Must include seller analytics"],"content":"# Seller Accounts Requirements Specification\n\n## 1. Introduction\n\n### Purpose\nThis document specifies the complete requirements for seller accounts in the e-commerce shopping mall platform. It defines how sellers register, manage products, process orders, track inventory, and access analytics.\n\n### Scope\nThis document covers all aspects of seller account functionality, including:\n- Seller registration and verification\n- Product management capabilities\n- Order processing and fulfillment\n- Inventory tracking and management\n- Analytics and reporting features\n- Security and access control measures\n\n### Definitions\n- **Seller**: A user who registers to sell products on the platform\n- **SKU**: Stock Keeping Unit - a unique identifier for each product variant\n- **Inventory**: The stock of products available for sale\n- **Order Fulfillment**: The process of preparing and shipping orders to customers\n\n## 2. Seller Registration\n\n### Registration Process\n\n**EARS Format**: WHEN a user selects \"Become a Seller\", THE system SHALL display the seller registration form.\n\n**Required Information**:\n- Business name\n- Contact email\n- Phone number\n- Business address\n- Tax identification number\n- Bank account information for payments\n\n**Verification Process**:\n- Email verification\n- Phone number verification\n- Business license validation (if applicable)\n\n**EARS Format**: WHEN a seller submits registration, THE system SHALL verify all provided information and create a seller account IF all validations pass.\n\n### Registration Workflow\n\n```mermaid\ngraph LR\n    A[\"User Selects Become a Seller\"] --> B[\"Display Registration Form\"]\n    B --> C[\"User Submits Information\"]\n    C --> D[\"Verify Information\"]\n    D -->|Success| E[\"Create Seller Account\"]\n    D -->|Failure| F[\"Show Error Message\"]\n    E --> G[\"Send Verification Email\"]\n    G --> H[\"Registration Complete\"]\n```\n\n## 3. Product Management\n\n### Product Creation\n\n**EARS Format**: WHEN a seller selects \"Add New Product\", THE system SHALL display the product creation form.\n\n**Required Product Information**:\n- Product name\n- Product description\n- Category selection\n- Price\n- Product images (minimum 3)\n- Product variants (color, size, material)\n- Initial inventory quantity\n\n**EARS Format**: WHEN a seller submits a new product, THE system SHALL validate all information and create the product listing IF all validations pass.\n\n### Product Editing\n\n**EARS Format**: WHEN a seller selects \"Edit Product\", THE system SHALL display the product editing form with current product information.\n\n**EARS Format**: WHEN a seller submits product edits, THE system SHALL update the product listing with the new information.\n\n### Product Deletion\n\n**EARS Format**: WHEN a seller selects \"Delete Product\", THE system SHALL prompt for confirmation and delete the product IF confirmed.\n\n### Product Variants Management\n\n**EARS Format**: WHEN a seller manages product variants, THE system SHALL allow adding, editing, and deleting of variants with separate SKU tracking.\n\n### Inventory Tracking\n\n**EARS Format**: THE system SHALL track inventory levels for each product variant separately.\n\n**EARS Format**: WHEN inventory reaches the low stock threshold, THE system SHALL notify the seller.\n\n## 4. Order Management\n\n### Order Processing\n\n**EARS Format**: WHEN a new order is placed for a seller's product, THE system SHALL notify the seller and display the order in their dashboard.\n\n**Order Status Workflow**:\n```mermaid\ngraph LR\n    A[\"Order Placed\"] --> B[\"Order Confirmed\"]\n    B --> C[\"Processing\"]\n    C --> D[\"Shipped\"]\n    D --> E[\"Delivered\"]\n    C --> F[\"Cancelled\"]\n    D --> G[\"Returned\"]\n```\n\n### Order Fulfillment\n\n**EARS Format**: WHEN a seller marks an order as \"Shipped\", THE system SHALL update the order status and notify the customer.\n\n**EARS Format**: THE system SHALL provide shipping label generation and carrier integration options.\n\n### Order History\n\n**EARS Format**: THE system SHALL maintain a complete history of all orders for each seller.\n\n**EARS Format**: WHEN a seller views order history, THE system SHALL display all past orders with current status.\n\n### Return and Refund Management\n\n**EARS Format**: WHEN a customer requests a return, THE system SHALL notify the seller and create a return request in the seller dashboard.\n\n**EARS Format**: WHEN a seller processes a return, THE system SHALL update the order status and initiate the refund process.\n\n## 5. Inventory Management\n\n### Stock Level Tracking\n\n**EARS Format**: THE system SHALL track inventory levels in real-time for each product variant.\n\n**EARS Format**: WHEN a product is sold, THE system SHALL decrement the inventory count for the specific variant.\n\n### Low Stock Alerts\n\n**EARS Format**: WHEN inventory reaches the low stock threshold (configurable per seller), THE system SHALL send a notification to the seller.\n\n**EARS Format**: THE system SHALL allow sellers to set custom low stock thresholds for each product.\n\n### Inventory Adjustments\n\n**EARS Format**: WHEN a seller adjusts inventory levels, THE system SHALL update the inventory count and log the adjustment.\n\n**EARS Format**: THE system SHALL support bulk inventory updates via CSV upload.\n\n## 6. Seller Analytics\n\n### Sales Performance\n\n**EARS Format**: THE system SHALL provide sellers with sales performance reports including:\n- Total sales\n- Sales by product\n- Sales by time period\n- Average order value\n\n### Product Performance\n\n**EARS Format**: THE system SHALL provide product performance analytics including:\n- Best-selling products\n- Low-performing products\n- Product views vs. sales conversion\n- Customer reviews and ratings\n\n### Customer Insights\n\n**EARS Format**: THE system SHALL provide customer insights including:\n- Repeat customer rate\n- Customer demographics\n- Customer purchase history\n\n### Financial Reports\n\n**EARS Format**: THE system SHALL generate financial reports including:\n- Total revenue\n- Revenue by product category\n- Payout history\n- Tax calculations\n\n## 7. Security and Access Control\n\n### Authentication\n\n**EARS Format**: THE system SHALL require secure authentication for all seller account access.\n\n**EARS Format**: THE system SHALL support two-factor authentication for seller accounts.\n\n### Authorization\n\n**EARS Format**: THE system SHALL implement role-based access control for seller functionalities.\n\n**EARS Format**: THE system SHALL restrict access to seller-specific data and operations.\n\n### Data Protection\n\n**EARS Format**: THE system SHALL encrypt all sensitive seller data at rest and in transit.\n\n**EARS Format**: THE system SHALL comply with data protection regulations (GDPR, CCPA, etc.).\n\n## 8. Integration Requirements\n\n### Payment Gateway Integration\n\n**EARS Format**: THE system SHALL integrate with multiple payment gateways for order processing.\n\n**EARS Format**: THE system SHALL support automatic payouts to seller bank accounts.\n\n### Shipping Carrier Integration\n\n**EARS Format**: THE system SHALL integrate with major shipping carriers for label generation and tracking.\n\n**EARS Format**: THE system SHALL provide real-time shipping rates calculation.\n\n### Third-Party Services\n\n**EARS Format**: THE system SHALL support integration with accounting software for financial management.\n\n**EARS Format**: THE system SHALL support integration with marketing platforms for product promotion.\n\n## 9. Error Handling and Notifications\n\n### Common Error Scenarios\n\n**EARS Format**: WHEN a seller encounters an error during product creation, THE system SHALL display a clear error message and preserve entered data.\n\n**EARS Format**: WHEN inventory levels are insufficient for an order, THE system SHALL notify both seller and customer.\n\n### Notification System\n\n**EARS Format**: THE system SHALL provide real-time notifications for:\n- New orders\n- Low inventory alerts\n- Return requests\n- Payment processing status\n\n**EARS Format**: THE system SHALL support multiple notification channels (email, SMS, in-app).\n\n### User Support\n\n**EARS Format**: THE system SHALL provide sellers with access to customer support for technical issues.\n\n**EARS Format**: THE system SHALL maintain a knowledge base of common issues and solutions.\n\n## Related Documents\n\nFor more information on user authentication, refer to the [User Authentication Requirements](./02-user-authentication.md).\n\nFor product catalog management, see the [Product Catalog Requirements](./03-product-catalog.md).\n\nOrder placement and tracking details can be found in the [Order Placement Requirements](./05-order-placement.md) and [Order Tracking Requirements](./06-order-tracking.md).\n\nAdmin dashboard functionality is described in the [Admin Dashboard Requirements](./09-admin-dashboard.md).\n\n## Conclusion\n\nThis document provides a comprehensive specification of all seller account functionality for the e-commerce shopping mall platform. It serves as the foundation for backend development, ensuring all seller-related features are properly implemented to support a robust and scalable e-commerce ecosystem."},{"reason":"To define the admin dashboard functionality, including user management, product management, and order management.","filename":"09-admin-dashboard.md","documentType":"requirement","outline":["User Management","Product Management","Order Management","System Analytics","Admin Security"],"audience":"development team","keyQuestions":["How do admins manage users?","How do admins manage products?","How do admins manage orders?","What analytics are available to admins?","What security measures are in place for admins?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define user management","Must specify product management","Must include order management","Must define system analytics","Must include admin security"],"content":"# Admin Dashboard Requirements Analysis\n\n## 1. Introduction\n\n### 1.1 Document Purpose\nThis document defines the comprehensive requirements for the admin dashboard of the shopping mall e-commerce platform. The admin dashboard serves as the central control panel for platform administrators to manage users, products, orders, and system performance.\n\n### 1.2 Scope\nThis document covers all functional and non-functional requirements for the admin dashboard, including:\n- User management and permissions\n- Product catalog oversight\n- Order processing and tracking\n- System analytics and monitoring\n- Security and compliance measures\n\n### 1.3 Target Audience\n- Backend developers implementing admin features\n- System architects designing the platform\n- Project managers overseeing development\n- QA engineers testing admin functionality\n\n## 2. User Management\n\n### 2.1 User Roles and Permissions\n\n#### 2.1.1 Admin Role Definition\n```mermaid\ngraph LR\n    A[\"Admin\"] --> B[\"User Management\"]\n    A --> C[\"Product Management\"]\n    A --> D[\"Order Management\"]\n    A --> E[\"System Analytics\"]\n    A --> F[\"Security Management\"]\n```\n\n#### 2.1.2 Permission Matrix\n\n| Action | Admin | Seller | Customer |\n|--------|-------|--------|-----------|\n| Manage Users | ✅ | ❌ | ❌ |\n| Manage Products | ✅ | ✅ (own) | ❌ |\n| Manage Orders | ✅ | ✅ (own) | ✅ (own) |\n| View Analytics | ✅ | ✅ (limited) | ❌ |\n| System Settings | ✅ | ❌ | ❌ |\n\n### 2.2 User Account Management\n\n#### 2.2.1 User Registration Approval\n```mermaid\ngraph LR\n    A[\"User Registers\"] --> B[\"Pending Approval\"]\n    B -->|Admin Approves| C[\"Active User\"]\n    B -->|Admin Rejects| D[\"Rejected User\"]\n```\n\n#### 2.2.2 User Profile Management\n- **THE system SHALL allow admins to view and edit user profiles**\n- **THE system SHALL enable admins to suspend or deactivate user accounts**\n- **THE system SHALL provide search functionality for user accounts**\n\n### 2.3 User Activity Monitoring\n- **THE system SHALL log all user actions for audit purposes**\n- **THE system SHALL provide activity reports for user accounts**\n- **THE system SHALL alert admins of suspicious user activity**\n\n## 3. Product Management\n\n### 3.1 Product Catalog Management\n\n#### 3.1.1 Product Approval Workflow\n```mermaid\ngraph LR\n    A[\"Seller Submits Product\"] --> B[\"Pending Review\"]\n    B -->|Admin Approves| C[\"Published Product\"]\n    B -->|Admin Rejects| D[\"Rejected Product\"]\n```\n\n#### 3.1.2 Product Editing and Deletion\n- **THE system SHALL allow admins to edit any product details**\n- **THE system SHALL enable admins to delete products from the catalog**\n- **THE system SHALL maintain version history of product changes**\n\n### 3.2 Product Moderation\n- **THE system SHALL flag inappropriate product content**\n- **THE system SHALL allow admins to review flagged products**\n- **THE system SHALL provide bulk moderation tools**\n\n### 3.3 Inventory Oversight\n- **THE system SHALL display inventory levels across all products**\n- **THE system SHALL alert admins of low stock items**\n- **THE system SHALL provide inventory adjustment tools**\n\n## 4. Order Management\n\n### 4.1 Order Processing Workflow\n\n```mermaid\ngraph LR\n    A[\"Order Placed\"] --> B[\"Payment Processing\"]\n    B -->|Success| C[\"Order Confirmed\"]\n    B -->|Failure| D[\"Order Cancelled\"]\n    C --> E[\"Fulfillment\"]\n    E --> F[\"Shipping\"]\n    F --> G[\"Delivery\"]\n```\n\n### 4.2 Order Status Tracking\n- **THE system SHALL display real-time order status updates**\n- **THE system SHALL allow admins to update order status manually**\n- **THE system SHALL provide order search and filtering**\n\n### 4.3 Order Analytics\n- **THE system SHALL generate order volume reports**\n- **THE system SHALL track order fulfillment metrics**\n- **THE system SHALL analyze order cancellation reasons**\n\n## 5. System Analytics\n\n### 5.1 Sales Performance Metrics\n- **THE system SHALL display daily/weekly/monthly sales data**\n- **THE system SHALL track revenue by product category**\n- **THE system SHALL monitor sales trends over time**\n\n### 5.2 User Engagement Analytics\n- **THE system SHALL track user registration and retention rates**\n- **THE system SHALL monitor user activity and engagement**\n- **THE system SHALL analyze user purchase patterns**\n\n### 5.3 System Health Monitoring\n- **THE system SHALL monitor server performance metrics**\n- **THE system SHALL track system uptime and availability**\n- **THE system SHALL alert admins of system anomalies**\n\n## 6. Admin Security\n\n### 6.1 Access Control\n- **THE system SHALL implement role-based access control**\n- **THE system SHALL require multi-factor authentication for admins**\n- **THE system SHALL log all admin actions for audit**\n\n### 6.2 Data Protection\n- **THE system SHALL encrypt sensitive user data**\n- **THE system SHALL implement data backup procedures**\n- **THE system SHALL comply with data protection regulations**\n\n### 6.3 Audit Logging\n- **THE system SHALL maintain comprehensive audit logs**\n- **THE system SHALL provide audit log search functionality**\n- **THE system SHALL generate audit reports**\n\n## 7. Integration and Extensibility\n\n### 7.1 Third-Party Integrations\n- **THE system SHALL support payment gateway integrations**\n- **THE system SHALL enable shipping carrier integrations**\n- **THE system SHALL provide marketing tool integrations**\n\n### 7.2 API Access Management\n- **THE system SHALL provide secure API endpoints for integrations**\n- **THE system SHALL implement API rate limiting**\n- **THE system SHALL monitor API usage and performance**\n\n### 7.3 Plugin/Module Support\n- **THE system SHALL support plugin architecture for extensions**\n- **THE system SHALL provide module installation and management**\n- **THE system SHALL ensure plugin compatibility and security**\n\n## 8. Error Handling and Recovery\n\n### 8.1 Common Error Scenarios\n- **WHEN a product approval fails, THE system SHALL notify the admin with error details**\n- **WHEN an order processing error occurs, THE system SHALL log the error and alert admins**\n- **WHEN user data cannot be loaded, THE system SHALL display appropriate error messages**\n\n### 8.2 Recovery Procedures\n- **THE system SHALL provide data recovery tools for accidental deletions**\n- **THE system SHALL implement transaction rollback for failed operations**\n- **THE system SHALL maintain backup and restore functionality**\n\n## 9. Performance Requirements\n\n### 9.1 Dashboard Responsiveness\n- **THE system SHALL load dashboard metrics within 2 seconds**\n- **THE system SHALL update real-time data within 5 seconds**\n- **THE system SHALL support concurrent admin users without performance degradation**\n\n### 9.2 Data Processing\n- **THE system SHALL process bulk operations efficiently**\n- **THE system SHALL handle large datasets without performance issues**\n- **THE system SHALL optimize database queries for admin operations**\n\n## 10. Business Rules and Constraints\n\n### 10.1 User Management Rules\n- **THE system SHALL prevent admin accounts from being deleted by non-admins**\n- **THE system SHALL require admin approval for seller account creation**\n- **THE system SHALL limit admin accounts to authorized personnel only**\n\n### 10.2 Product Management Rules\n- **THE system SHALL enforce product quality standards**\n- **THE system SHALL prevent duplicate product listings**\n- **THE system SHALL require complete product information for approval**\n\n### 10.3 Order Management Rules\n- **THE system SHALL prevent order modification after shipment**\n- **THE system SHALL enforce order cancellation policies**\n- **THE system SHALL require admin approval for large order refunds**\n\n## 11. Future Considerations\n\n### 11.1 Scalability\n- **THE system SHALL support horizontal scaling for admin operations**\n- **THE system SHALL handle increased data volume efficiently**\n- **THE system SHALL maintain performance with growing user base**\n\n### 11.2 Internationalization\n- **THE system SHALL support multiple languages for admin interface**\n- **THE system SHALL handle currency conversions for international sales**\n- **THE system SHALL comply with international data regulations**\n\n### 11.3 Advanced Analytics\n- **THE system SHALL integrate machine learning for predictive analytics**\n- **THE system SHALL provide AI-driven insights for business decisions**\n- **THE system SHALL support custom report generation**\n\n## 12. Conclusion\n\nThis document provides a comprehensive analysis of the admin dashboard requirements for the shopping mall e-commerce platform. The admin dashboard is critical for platform management, user oversight, and system monitoring. By implementing these requirements, the platform will provide administrators with the tools needed to effectively manage the e-commerce ecosystem.\n\n## 13. References\n\n- [User Authentication Requirements](./02-user-authentication.md)\n- [Product Catalog Requirements](./03-product-catalog.md)\n- [Order Placement Requirements](./05-order-placement.md)\n- [Technical Requirements](./11-technical-requirements.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To provide a comprehensive user flow diagram showing how users interact with the e-commerce platform.","filename":"10-user-flow.md","documentType":"user-flow","outline":["User Registration Flow","Product Browsing Flow","Order Placement Flow","Order Tracking Flow","Review Submission Flow"],"audience":"development team","keyQuestions":["How do users register and log in?","How do users browse and search for products?","How do users place orders?","How do users track orders?","How do users submit reviews?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must include user registration flow","Must include product browsing flow","Must include order placement flow","Must include order tracking flow","Must include review submission flow"],"content":"# User Flow Diagram for E-Commerce Shopping Mall Platform\n\n## Introduction\n\n### Purpose of the User Flow Diagram\nThis document provides a comprehensive visual representation of how users interact with the e-commerce shopping mall platform. The user flow diagrams illustrate the complete journey of different user types (customers, sellers, admins) as they navigate through the platform's features.\n\n### Importance of User Flow in E-commerce\nUser flow diagrams are critical for:\n- Understanding user behavior and expectations\n- Identifying key interaction points\n- Designing intuitive navigation\n- Ensuring all user scenarios are covered\n- Guiding development and testing efforts\n\n## User Registration Flow\n\n### New User Registration\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Homepage\"]\n    B --> C[\"Click Register\"]\n    C --> D[\"Enter Personal Info\"]\n    D --> E[\"Enter Address Info\"]\n    E --> F[\"Set Password\"]\n    F --> G[\"Verify Email\"]\n    G --> H[\"Registration Complete\"]\n```\n\n### Existing User Login\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Homepage\"]\n    B --> C[\"Click Login\"]\n    C --> D[\"Enter Credentials\"]\n    D --> E[\"Authenticate\"]\n    E -->|Success| F[\"Dashboard\"]\n    E -->|Failure| G[\"Error Message\"]\n```\n\n### Account Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Profile\"]\n    B --> C[\"Edit Personal Info\"]\n    B --> D[\"Manage Addresses\"]\n    B --> E[\"Change Password\"]\n    B --> F[\"View Order History\"]\n```\n\n## Product Browsing Flow\n\n### Homepage Navigation\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Homepage\"]\n    B --> C[\"Browse Categories\"]\n    B --> D[\"View Featured Products\"]\n    B --> E[\"View Recommendations\"]\n```\n\n### Category Browsing\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Select Category\"]\n    B --> C[\"View Subcategories\"]\n    C --> D[\"View Products\"]\n    D --> E[\"Filter Products\"]\n    E --> F[\"Sort Products\"]\n```\n\n### Product Search\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Enter Search Terms\"]\n    B --> C[\"View Results\"]\n    C --> D[\"Apply Filters\"]\n    D --> E[\"Select Product\"]\n```\n\n### Product Detail View\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Product Details\"]\n    B --> C[\"View Images\"]\n    B --> D[\"View Description\"]\n    B --> E[\"View Reviews\"]\n    B --> F[\"View Variants\"]\n    B --> G[\"Add to Cart\"]\n    B --> H[\"Add to Wishlist\"]\n```\n\n## Order Placement Flow\n\n### Adding Items to Cart\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Select Product\"]\n    B --> C[\"Choose Variant\"]\n    C --> D[\"Add to Cart\"]\n    D --> E[\"View Cart\"]\n```\n\n### Cart Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Cart\"]\n    B --> C[\"Update Quantity\"]\n    B --> D[\"Remove Item\"]\n    B --> E[\"Apply Coupon\"]\n    B --> F[\"Proceed to Checkout\"]\n```\n\n### Checkout Process\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Review Cart\"]\n    B --> C[\"Enter Shipping Info\"]\n    C --> D[\"Select Payment Method\"]\n    D --> E[\"Enter Payment Details\"]\n    E --> F[\"Place Order\"]\n```\n\n### Payment Processing\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Select Payment Method\"]\n    B --> C[\"Enter Payment Details\"]\n    C --> D[\"Process Payment\"]\n    D -->|Success| E[\"Order Confirmed\"]\n    D -->|Failure| F[\"Payment Error\"]\n```\n\n### Order Confirmation\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Order Placed\"]\n    B --> C[\"Send Confirmation Email\"]\n    B --> D[\"Show Order Summary\"]\n    B --> E[\"Update Inventory\"]\n```\n\n## Order Tracking Flow\n\n### Order History View\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Order History\"]\n    B --> C[\"Select Order\"]\n    C --> D[\"View Order Details\"]\n    D --> E[\"Track Order Status\"]\n```\n\n### Order Status Tracking\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Order Status\"]\n    B --> C[\"Check Shipping Status\"]\n    C --> D[\"View Tracking Info\"]\n    D --> E[\"Receive Notifications\"]\n```\n\n### Shipping Information\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Shipping Info\"]\n    B --> C[\"View Carrier Info\"]\n    B --> D[\"View Estimated Delivery\"]\n    B --> E[\"View Shipping Costs\"]\n```\n\n### Return/Refund Process\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Initiate Return\"]\n    B --> C[\"Select Return Reason\"]\n    C --> D[\"Select Refund Method\"]\n    D --> E[\"Submit Return Request\"]\n    E --> F[\"Process Refund\"]\n```\n\n## Review Submission Flow\n\n### Product Review Submission\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Product\"]\n    B --> C[\"Click Write Review\"]\n    C --> D[\"Enter Review Details\"]\n    D --> E[\"Submit Review\"]\n    E --> F[\"Review Moderation\"]\n    F --> G[\"Review Published\"]\n```\n\n### Review Moderation\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Review Submitted\"]\n    B --> C[\"Admin Review\"]\n    C -->|Approve| D[\"Publish Review\"]\n    C -->|Reject| E[\"Notify User\"]\n```\n\n### Review Display\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Product\"]\n    B --> C[\"View Reviews\"]\n    C --> D[\"View Ratings\"]\n    C --> E[\"View Review Details\"]\n```\n\n## Seller Account Flow\n\n### Seller Registration\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Seller Portal\"]\n    B --> C[\"Click Register\"]\n    C --> D[\"Enter Business Info\"]\n    D --> E[\"Enter Bank Info\"]\n    E --> F[\"Verify Identity\"]\n    F --> G[\"Registration Complete\"]\n```\n\n### Product Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Seller Dashboard\"]\n    B --> C[\"Add Product\"]\n    B --> D[\"Edit Product\"]\n    B --> E[\"Delete Product\"]\n    B --> F[\"Manage Inventory\"]\n```\n\n### Order Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Orders\"]\n    B --> C[\"View Order Details\"]\n    B --> D[\"Update Order Status\"]\n    B --> E[\"Process Refunds\"]\n```\n\n### Inventory Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Inventory\"]\n    B --> C[\"Update Stock Levels\"]\n    B --> D[\"Set Low Stock Alerts\"]\n    B --> E[\"View Inventory Reports\"]\n```\n\n## Admin Dashboard Flow\n\n### User Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"Visit Admin Dashboard\"]\n    B --> C[\"View Users\"]\n    B --> D[\"Edit User Info\"]\n    B --> E[\"Suspend User\"]\n    B --> F[\"View User Activity\"]\n```\n\n### Product Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Products\"]\n    B --> C[\"Edit Product Info\"]\n    B --> D[\"Remove Product\"]\n    B --> E[\"View Product Analytics\"]\n```\n\n### Order Management\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Orders\"]\n    B --> C[\"View Order Details\"]\n    B --> D[\"Update Order Status\"]\n    B --> E[\"Process Refunds\"]\n```\n\n### System Analytics\n\n```mermaid\ngraph LR\n    A[\"Start\"] --> B[\"View Dashboard\"]\n    B --> C[\"View Sales Reports\"]\n    B --> D[\"View User Growth\"]\n    B --> E[\"View Inventory Levels\"]\n    B --> F[\"View System Health\"]\n```\n\n## Conclusion\n\nThis user flow diagram provides a comprehensive overview of all user interactions with the e-commerce shopping mall platform. Each flow is designed to ensure a seamless user experience, covering all key functionalities from registration to order management.\n\nThe diagrams use Mermaid syntax for clear visualization and follow proper syntax rules with double quotes for all labels. This document serves as a critical reference for backend developers, UI/UX designers, and quality assurance teams to ensure all user scenarios are properly implemented and tested.\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the technical requirements and constraints for the e-commerce platform.","filename":"11-technical-requirements.md","documentType":"requirement","outline":["System Architecture","Performance Requirements","Security Requirements","Scalability Requirements","Integration Requirements"],"audience":"development team","keyQuestions":["What is the system architecture?","What are the performance requirements?","What are the security requirements?","What are the scalability requirements?","What are the integration requirements?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must define system architecture","Must specify performance requirements","Must include security requirements","Must define scalability requirements","Must include integration requirements"],"content":"# Technical Requirements Analysis Report\n\n## 1. System Architecture\n\n### Overview\nThe e-commerce shopping mall platform will be designed as a scalable, secure, and high-performance system to support a wide range of features including user registration, product catalog management, order processing, and payment handling.\n\n### Architecture Approach\n- **Microservices Architecture**: The system will be built using a microservices approach to ensure scalability, maintainability, and flexibility. Each core function (user management, product catalog, order processing, etc.) will be a separate service.\n- **API Gateway**: A central API gateway will manage all incoming requests, providing a single entry point for clients and handling authentication, authorization, and rate limiting.\n- **Service Communication**: Services will communicate using RESTful APIs and asynchronous messaging (e.g., Kafka) for event-driven interactions.\n\n### Key Components\n- **User Service**: Handles user registration, authentication, and profile management.\n- **Product Service**: Manages product catalog, categories, and inventory.\n- **Order Service**: Processes orders, manages shopping carts, and handles order tracking.\n- **Payment Service**: Integrates with payment gateways and processes transactions.\n- **Notification Service**: Sends emails, SMS, and push notifications for order updates.\n- **Admin Dashboard**: Provides administrative tools for managing users, products, and orders.\n\n### Data Flow Diagram\n```mermaid\ngraph LR\n    A[\"User\"] -->|Register/Login| B[\"User Service\"]\n    A -->|Browse/Search| C[\"Product Service\"]\n    A -->|Add to Cart| D[\"Order Service\"]\n    A -->|Checkout| E[\"Payment Service\"]\n    B -->|User Data| F[\"Database\"]\n    C -->|Product Data| F\n    D -->|Order Data| F\n    E -->|Payment Data| F\n    G[\"Admin\"] -->|Manage| H[\"Admin Dashboard\"]\n    H -->|CRUD Operations| B\n    H -->|CRUD Operations| C\n    H -->|CRUD Operations| D\n    H -->|CRUD Operations| E\n```\n\n## 2. Performance Requirements\n\n### Response Time Expectations\n- **Page Load Time**: All pages should load within 2 seconds under normal conditions.\n- **API Response Time**: API endpoints should respond within 500ms for 95% of requests.\n- **Search Results**: Product search results should be displayed within 1 second.\n\n### Throughput Requirements\n- **Concurrent Users**: The system should support at least 10,000 concurrent users.\n- **Requests Per Second**: The system should handle at least 1,000 requests per second during peak times.\n\n### Load Handling Capabilities\n- **Peak Load**: The system should maintain performance during peak load times (e.g., Black Friday sales).\n- **Graceful Degradation**: The system should degrade gracefully under extreme load, prioritizing critical functions.\n\n### Caching Strategies\n- **Content Delivery Network (CDN)**: Use CDN for static assets (images, CSS, JavaScript).\n- **API Caching**: Implement caching for frequently accessed API endpoints.\n- **Database Caching**: Use in-memory caching (e.g., Redis) for database queries.\n\n### Performance Testing Approach\n- **Load Testing**: Regular load testing to simulate peak traffic.\n- **Stress Testing**: Stress testing to identify breaking points.\n- **Monitoring**: Continuous performance monitoring and alerting.\n\n## 3. Security Requirements\n\n### Authentication and Authorization\n- **User Authentication**: Implement secure user authentication using JWT (JSON Web Tokens).\n- **Role-Based Access Control (RBAC)**: Define roles (customer, seller, admin) with specific permissions.\n- **Multi-Factor Authentication (MFA)**: Optional MFA for enhanced security.\n\n### Data Encryption\n- **Data in Transit**: Use HTTPS for all data transmission.\n- **Data at Rest**: Encrypt sensitive data (e.g., payment information) in the database.\n\n### Secure Payment Processing\n- **PCI Compliance**: Ensure compliance with Payment Card Industry (PCI) standards.\n- **Tokenization**: Use tokenization for payment data to avoid storing sensitive information.\n\n### Vulnerability Management\n- **Regular Audits**: Conduct regular security audits and penetration testing.\n- **Patch Management**: Implement a patch management system for dependencies.\n\n### Compliance Requirements\n- **GDPR Compliance**: Ensure compliance with General Data Protection Regulation (GDPR).\n- **CCPA Compliance**: Ensure compliance with California Consumer Privacy Act (CCPA).\n\n## 4. Scalability Requirements\n\n### Horizontal vs. Vertical Scaling\n- **Horizontal Scaling**: Prefer horizontal scaling (adding more servers) over vertical scaling (upgrading existing servers).\n- **Auto-Scaling**: Implement auto-scaling policies to handle varying loads.\n\n### Database Scaling Strategies\n- **Database Sharding**: Implement database sharding for large datasets.\n- **Read Replicas**: Use read replicas to offload read operations from the primary database.\n\n### Load Balancing\n- **Load Balancer**: Use a load balancer to distribute traffic evenly across servers.\n- **Health Checks**: Implement health checks to ensure traffic is only routed to healthy instances.\n\n### Auto-Scaling Policies\n- **Thresholds**: Define auto-scaling thresholds based on CPU, memory, and request rates.\n- **Cool-Down Periods**: Implement cool-down periods to prevent rapid scaling.\n\n### Performance Monitoring\n- **Real-Time Monitoring**: Implement real-time performance monitoring.\n- **Alerting**: Set up alerting for performance degradation.\n\n## 5. Integration Requirements\n\n### Third-Party Service Integrations\n- **Payment Gateways**: Integrate with multiple payment gateways (e.g., Stripe, PayPal).\n- **Shipping Carriers**: Integrate with shipping carriers for real-time tracking.\n- **Email Services**: Integrate with email services for notifications.\n\n### API Design Principles\n- **RESTful APIs**: Design RESTful APIs for all services.\n- **Versioning**: Implement API versioning to ensure backward compatibility.\n- **Documentation**: Provide comprehensive API documentation.\n\n### Payment Gateway Integration\n- **Multiple Gateways**: Support multiple payment gateways.\n- **Secure Transactions**: Ensure secure transactions with encryption and tokenization.\n\n### Shipping Carrier Integration\n- **Real-Time Tracking**: Provide real-time tracking information.\n- **Shipping Rates**: Calculate shipping rates based on carrier APIs.\n\n### Analytics and Reporting Tools\n- **User Analytics**: Implement user analytics to track behavior and preferences.\n- **Sales Analytics**: Implement sales analytics to track revenue and performance.\n\n## 6. Technology Stack\n\n### Frontend Technologies\n- **React.js**: Use React.js for building the user interface.\n- **Redux**: Use Redux for state management.\n- **Material-UI**: Use Material-UI for UI components.\n\n### Backend Technologies\n- **Node.js**: Use Node.js for the backend server.\n- **Express.js**: Use Express.js for building RESTful APIs.\n- **GraphQL**: Consider GraphQL for efficient data fetching.\n\n### Database Technologies\n- **MongoDB**: Use MongoDB for the primary database.\n- **Redis**: Use Redis for caching.\n\n### DevOps and Infrastructure\n- **Docker**: Use Docker for containerization.\n- **Kubernetes**: Use Kubernetes for orchestration.\n- **AWS**: Use AWS for cloud infrastructure.\n\n## 7. Deployment and Maintenance\n\n### Deployment Strategy\n- **CI/CD Pipeline**: Implement a CI/CD pipeline for automated deployment.\n- **Blue-Green Deployment**: Use blue-green deployment for zero-downtime updates.\n\n### Continuous Integration/Continuous Deployment (CI/CD)\n- **Automated Testing**: Implement automated testing for all deployments.\n- **Rollback Mechanism**: Implement a rollback mechanism for failed deployments.\n\n### Monitoring and Logging\n- **Centralized Logging**: Implement centralized logging for all services.\n- **Monitoring Tools**: Use monitoring tools (e.g., Prometheus, Grafana) for performance tracking.\n\n### Backup and Disaster Recovery\n- **Regular Backups**: Implement regular backups for all data.\n- **Disaster Recovery Plan**: Develop a disaster recovery plan.\n\n## 8. Compliance and Legal\n\n### Data Privacy Regulations\n- **GDPR Compliance**: Ensure compliance with GDPR.\n- **CCPA Compliance**: Ensure compliance with CCPA.\n\n### Payment Card Industry (PCI) Compliance\n- **PCI Standards**: Ensure compliance with PCI standards for payment processing.\n\n### Accessibility Standards\n- **WCAG Compliance**: Ensure compliance with Web Content Accessibility Guidelines (WCAG).\n\n### Terms of Service and Privacy Policy\n- **Legal Documents**: Provide clear terms of service and privacy policy.\n\n## 9. Future Considerations\n\n### Internationalization and Localization\n- **Multi-Language Support**: Implement support for multiple languages.\n- **Currency Conversion**: Implement currency conversion for international users.\n\n### Mobile Application Support\n- **Responsive Design**: Ensure the platform is responsive for mobile devices.\n- **Mobile App**: Consider developing a mobile app for iOS and Android.\n\n### Voice and AI Integration\n- **Voice Search**: Implement voice search for product discovery.\n- **AI Recommendations**: Implement AI-driven product recommendations.\n\n### Augmented Reality (AR) for Product Visualization\n- **AR Integration**: Consider AR integration for product visualization.\n\n## Conclusion\n\nThis technical requirements analysis report outlines the key architectural, performance, security, scalability, and integration requirements for the e-commerce shopping mall platform. By adhering to these requirements, the development team can build a robust, scalable, and secure platform that meets the needs of customers, sellers, and administrators.\n\n## Next Steps\n\n1. **Review and Approval**: Review the technical requirements with stakeholders and obtain approval.\n2. **Detailed Design**: Proceed with detailed system design based on these requirements.\n3. **Implementation**: Begin implementation of the system architecture and components.\n4. **Testing**: Conduct thorough testing to ensure all requirements are met.\n5. **Deployment**: Deploy the system and monitor performance.\n\n## References\n\n- [Service Overview Document](./00-toc.md)\n- [Business Model Document](./01-business-model.md)\n- [User Authentication Document](./02-user-authentication.md)\n- [Product Catalog Document](./03-product-catalog.md)\n- [Shopping Cart Document](./04-shopping-cart.md)\n- [Order Placement Document](./05-order-placement.md)\n- [Order Tracking Document](./06-order-tracking.md)\n- [Product Reviews Document](./07-product-reviews.md)\n- [Seller Accounts Document](./08-seller-accounts.md)\n- [Admin Dashboard Document](./09-admin-dashboard.md)\n- [User Flow Document](./10-user-flow.md)\n\n## Developer Note\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"}],"created_at":"2025-10-14T14:59:54.680Z","completed_at":"2025-10-14T15:32:39.500Z","step":0},{"id":"0199e35a-241f-756b-800c-5c1151d8f4f3","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-10-14T15:32:39.583Z"},{"type":"prisma","id":"0199e362-34c8-74f8-a766-fb4c620699b8","instruction":"Design comprehensive database schema for e-commerce platform with user accounts, product catalog, variants, orders, payments, reviews, and admin features. Focus on relationships between users, products, orders, and inventory. Ensure proper indexing for performance and scalability.","schemas":{"schema-01-systematic.prisma":"/// Represents the channels through which products are sold in the shopping\n/// mall platform. Each channel can have multiple sections and categories,\n/// forming the foundation of the platform's organizational structure.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channels {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The name of the shopping channel.\n  name String\n  \n  /// A detailed description of the shopping channel.\n  description String?\n  \n  /// The timestamp when the channel was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the channel was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the channel was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_sections shopping_sections[]\n  shopping_channel_categories shopping_channel_categories[]\n  \n  @@unique([name])\n  @@index([created_at])\n  @@index([updated_at])\n}\n\n/// Represents the sections within shopping channels. Each section belongs to\n/// a specific channel and can contain multiple categories.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sections {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The channel to which this section belongs. {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n  \n  /// The name of the shopping section.\n  name String\n  \n  /// A detailed description of the shopping section.\n  description String?\n  \n  /// The timestamp when the section was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the section was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the section was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  \n  shopping_channel_categories shopping_channel_categories[]\n  \n  @@unique([shopping_channel_id, name])\n  @@index([shopping_channel_id, created_at])\n  @@index([shopping_channel_id, updated_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the categories within shopping channel sections. Each category\n/// belongs to a specific section and channel, forming the hierarchical\n/// structure of the platform's product organization.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channel_categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The channel to which this category belongs. {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n  \n  /// The section to which this category belongs. {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n  \n  /// The name of the shopping category.\n  name String\n  \n  /// A detailed description of the shopping category.\n  description String?\n  \n  /// The timestamp when the category was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the category was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// The timestamp when the category was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_section_id])\n  \n  @@unique([shopping_channel_id, shopping_section_id, name], map: \"shopping_channel_categories_shopping_channel_id_shoppi_8ec29d51\")\n  @@index([shopping_channel_id, shopping_section_id, created_at], map: \"shopping_channel_categories_shopping_channel_id_shoppi_bdf01ba1\")\n  @@index([shopping_channel_id, shopping_section_id, updated_at], map: \"shopping_channel_categories_shopping_channel_id_shoppi_8758f887\")\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-02-actors.prisma":"/// Customer information, but not a person but a **connection** basis. This\n/// is the main entity for customer identity management. Contains\n/// authentication credentials and basic profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_customers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Customer's email address. Used for login and communication.\n  email String\n  \n  /// Securely hashed password for authentication.\n  password_hash String\n  \n  /// Customer's full name.\n  name String\n  \n  /// Customer's phone number.\n  phone String?\n  \n  /// Customer's primary address.\n  address String?\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_product_reviews shopping_product_reviews[]\n  shopping_orders shopping_orders[]\n  shopping_shopping_carts shopping_shopping_carts[]\n  shopping_payments shopping_payments[]\n  \n  @@unique([email])\n  @@index([phone])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Seller information for marketplace vendors. Contains authentication\n/// credentials and business profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sellers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Seller's email address. Used for login and communication.\n  email String\n  \n  /// Securely hashed password for authentication.\n  password_hash String\n  \n  /// Seller's business name.\n  business_name String\n  \n  /// Primary contact person's name.\n  contact_name String\n  \n  /// Seller's phone number.\n  phone String?\n  \n  /// Seller's business address.\n  address String?\n  \n  /// Seller's tax identification number.\n  tax_id String?\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_seller_products shopping_seller_products[]\n  shopping_seller_orders shopping_seller_orders[]\n  \n  @@unique([email])\n  @@unique([tax_id])\n  @@index([phone])\n  @@index([business_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([contact_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Administrator information for platform management. Contains\n/// authentication credentials and admin profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_administrators {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Admin's email address. Used for login and communication.\n  email String\n  \n  /// Securely hashed password for authentication.\n  password_hash String\n  \n  /// Admin's full name.\n  name String\n  \n  /// Admin's phone number.\n  phone String?\n  \n  /// Admin's role or permission level.\n  role String\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_review_moderation shopping_review_moderation[]\n  shopping_admin_actions shopping_admin_actions[]\n  shopping_admin_logs shopping_admin_logs[]\n  \n  @@unique([email])\n  @@index([role])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-03-sales.prisma":"/// Core product information for the e-commerce platform. Contains all\n/// essential details about products including name, description, pricing,\n/// and categorization. Serves as the primary entity for product management\n/// and is referenced by variants, inventory, and reviews.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_products {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Category this product belongs to. {@link shopping_categories.id}.\n  shopping_category_id String? @db.Uuid\n  \n  /// Name of the product.\n  name String\n  \n  /// Detailed description of the product.\n  description String?\n  \n  /// Base price of the product.\n  price Float @db.DoublePrecision\n  \n  /// Stock Keeping Unit - unique identifier for the product.\n  sku String\n  \n  /// Timestamp when the product was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the product was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Securely hashed password for authentication.\n  password_hash String\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  //----\n  // RELATIONS\n  //----\n  category shopping_categories? @relation(fields: [shopping_category_id], references: [id], onDelete: Cascade)\n  \n  shopping_product_variants shopping_product_variants[]\n  shopping_inventory shopping_inventory[]\n  shopping_product_reviews shopping_product_reviews[]\n  shopping_seller_products shopping_seller_products[]\n  \n  @@unique([sku])\n  @@index([shopping_category_id])\n  @@index([created_at])\n  @@index([price])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Product variants representing different options (colors, sizes,\n/// materials) for products. Each variant has its own SKU and inventory\n/// tracking. References the main product and contains variant-specific\n/// details.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_product_variants {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Main product this variant belongs to. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n  \n  /// Stock Keeping Unit - unique identifier for this variant.\n  sku String\n  \n  /// Name of the variant option (e.g., Color, Size).\n  option_name String\n  \n  /// Value of the variant option (e.g., Red, Large).\n  option_value String\n  \n  /// Price adjustment for this variant from base price.\n  price_adjustment Float? @db.DoublePrecision\n  \n  /// Timestamp when the variant was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the variant was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  //----\n  // RELATIONS\n  //----\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n  \n  shopping_inventory shopping_inventory?\n  shopping_order_items shopping_order_items[]\n  shopping_cart_items shopping_cart_items[]\n  shopping_seller_inventory shopping_seller_inventory[]\n  \n  @@unique([sku])\n  @@index([shopping_product_id])\n  @@index([created_at])\n  @@index([option_name])\n  @@index([option_value])\n}\n\n/// Product categorization hierarchy for organizing products. Categories can\n/// have parent-child relationships to create a hierarchical structure.\n/// Products are assigned to categories for better organization and\n/// filtering.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Parent category if this is a subcategory. {@link shopping_categories.id}.\n  parent_id String? @db.Uuid\n  \n  /// Name of the category.\n  name String\n  \n  /// Description of the category.\n  description String?\n  \n  /// Unique code for the category.\n  code String\n  \n  /// Timestamp when the category was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the category was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  //----\n  // RELATIONS\n  //----\n  parent shopping_categories? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  \n  shopping_products shopping_products[]\n  recursive shopping_categories[] @relation(\"recursive\")\n  \n  @@unique([code])\n  @@index([parent_id])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Inventory tracking for product variants. Monitors stock levels,\n/// reservations, and availability status for each product variant. Critical\n/// for order fulfillment and stock management.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inventory {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Product variant this inventory tracks. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n  \n  /// Product this inventory belongs to. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n  \n  /// Current available quantity.\n  quantity Int @db.Integer\n  \n  /// Quantity reserved for pending orders.\n  reserved_quantity Int @db.Integer\n  \n  /// Threshold for low stock alerts.\n  low_stock_threshold Int? @db.Integer\n  \n  /// Timestamp of last stock update.\n  last_stock_update DateTime? @db.Timestamptz\n  \n  /// Timestamp when the inventory record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the inventory record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  //----\n  // RELATIONS\n  //----\n  variant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_product_variant_id])\n  \n  @@index([shopping_product_variant_id])\n  @@index([shopping_product_id])\n  @@index([last_stock_update])\n}\n\n/// Customer reviews for products. Contains rating, text, and metadata about\n/// customer feedback on products. Critical for building trust and providing\n/// social proof.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_product_reviews {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Product this review is for. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n  \n  /// Customer who left the review. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n  \n  /// Rating score (1-5).\n  rating Int @db.Integer\n  \n  /// Title of the review.\n  title String?\n  \n  /// Main content of the review.\n  content String\n  \n  /// Timestamp when the review was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the review was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  //----\n  // RELATIONS\n  //----\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n  \n  shopping_review_moderation shopping_review_moderation[]\n  shopping_review_ratings shopping_review_ratings[]\n  \n  @@index([shopping_product_id])\n  @@index([shopping_customer_id])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-04-orders.prisma":"/// Main order table containing all order information. Represents customer\n/// orders with status tracking and payment information. This is the primary\n/// entity for order management.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Customer who placed the order. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n  \n  /// Unique order code for business identification.\n  order_code String\n  \n  /// Total order amount including all items and taxes.\n  total_amount Float @db.DoublePrecision\n  \n  /// Currency used for the order (e.g., USD, KRW).\n  currency String\n  \n  /// Current order status (e.g., pending, processing, shipped, delivered,\n  /// cancelled).\n  status String\n  \n  /// Payment method used for the order.\n  payment_method String\n  \n  /// Selected shipping method for the order.\n  shipping_method String\n  \n  /// Shipping address for the order.\n  shipping_address String\n  \n  /// Billing address for the order.\n  billing_address String\n  \n  /// Timestamp when the order was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order was soft deleted (if applicable).\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n  \n  shopping_order_items shopping_order_items[]\n  shopping_order_status shopping_order_status[]\n  shopping_order_history shopping_order_history[]\n  shopping_seller_orders shopping_seller_orders[]\n  shopping_payments shopping_payments[]\n  shopping_shipping_tracking shopping_shipping_tracking[]\n  \n  @@unique([order_code])\n  @@index([shopping_customer_id, created_at])\n  @@index([status, updated_at])\n}\n\n/// Order line items representing individual products in an order. Each item\n/// references a product variant and tracks quantity and price.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Order this item belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// Product variant being ordered. {@link shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n  \n  /// Number of units ordered.\n  quantity Int @db.Integer\n  \n  /// Price per unit at time of order.\n  unit_price Float @db.DoublePrecision\n  \n  /// Total price for this line item (quantity × unit_price).\n  total_price Float @db.DoublePrecision\n  \n  /// Timestamp when the order item was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the order item was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id, created_at])\n  @@index([shopping_product_variant_id, created_at])\n}\n\n/// Order status tracking table. Records all status changes for an order with\n/// timestamps.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_status {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Order this status belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// Order status at this point in time.\n  status String\n  \n  /// Timestamp when this status was set.\n  changed_at DateTime @db.Timestamptz\n  \n  /// User or system that changed the status.\n  changed_by String?\n  \n  /// Additional notes about the status change.\n  notes String?\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id, changed_at])\n  @@index([status, changed_at])\n}\n\n/// Historical record of all order changes. Captures snapshots of order\n/// states for audit trails and change tracking.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_history {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Order this history record belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// Action performed on the order (e.g., created, updated, cancelled).\n  action String\n  \n  /// Timestamp when this action occurred.\n  changed_at DateTime @db.Timestamptz\n  \n  /// User or system that performed the action.\n  changed_by String?\n  \n  /// JSON object containing order state at time of action.\n  details String?\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id, changed_at])\n  @@index([action, changed_at])\n}","schema-05-carts.prisma":"/// Represents a customer's shopping cart containing items they intend to\n/// purchase. Each cart belongs to a specific customer and can contain\n/// multiple cart items. This is a primary business entity that users manage\n/// independently through their shopping experience.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shopping_carts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Customer who owns this shopping cart. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n  \n  /// Timestamp when the shopping cart was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the shopping cart was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n  \n  shopping_cart_items shopping_cart_items[]\n  \n  @@unique([shopping_customer_id])\n  @@index([created_at])\n}\n\n/// Represents individual items in a shopping cart. Each item references a\n/// specific product variant and belongs to a specific shopping cart. This is\n/// a subsidiary entity managed through the parent shopping cart.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_cart_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Shopping cart that contains this item. {@link shopping_shopping_carts.id}.\n  shopping_shopping_cart_id String @db.Uuid\n  \n  /// Product variant referenced by this cart item. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n  \n  /// Quantity of this product variant in the cart.\n  quantity Int @db.Integer\n  \n  /// Price of the product variant at the time it was added to the cart.\n  price Float @db.DoublePrecision\n  \n  /// Timestamp when the cart item was added.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the cart item was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  cart shopping_shopping_carts @relation(fields: [shopping_shopping_cart_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_shopping_cart_id, shopping_product_variant_id], map: \"shopping_cart_items_shopping_shopping_cart_id_shopping_127c34ce\")\n  @@index([shopping_product_variant_id, created_at])\n}","schema-06-reviews.prisma":"/// Tracks moderation actions taken on product reviews. This table records\n/// each moderation event, including the administrator who performed the\n/// action, the type of action, reason, and timestamp. It supports the review\n/// approval workflow and audit trail.\n///\n/// @namespace Reviews\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_review_moderation {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The review being moderated. {@link shopping_product_reviews.id}.\n  shopping_product_review_id String @db.Uuid\n  \n  /// The administrator who performed the moderation action. {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String @db.Uuid\n  \n  /// Type of moderation action (approve, reject, flag).\n  action_type String\n  \n  /// Reason for the moderation action.\n  reason String?\n  \n  /// When the moderation action was performed.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  review shopping_product_reviews @relation(fields: [shopping_product_review_id], references: [id], onDelete: Cascade)\n  administrator shopping_administrators @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_product_review_id, created_at], map: \"shopping_review_moderation_shopping_product_review_id__cee1f633\")\n  @@index([shopping_administrator_id, created_at], map: \"shopping_review_moderation_shopping_administrator_id_c_756759fb\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Stores detailed rating breakdowns for product reviews. This table\n/// captures individual rating dimensions (quality, value, etc.) that\n/// contribute to the overall rating. It allows for granular analysis of\n/// review ratings across different aspects.\n///\n/// @namespace Reviews\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_review_ratings {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The review this rating belongs to. {@link shopping_product_reviews.id}.\n  shopping_product_review_id String @db.Uuid\n  \n  /// Rating for product quality (1-5).\n  quality_rating Int @db.Integer\n  \n  /// Rating for product value (1-5).\n  value_rating Int @db.Integer\n  \n  /// Rating for service experience (1-5).\n  service_rating Int @db.Integer\n  \n  /// When the rating was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  review shopping_product_reviews @relation(fields: [shopping_product_review_id], references: [id], onDelete: Cascade)\n  \n  @@unique([shopping_product_review_id])\n  @@index([shopping_product_review_id, created_at], map: \"shopping_review_ratings_shopping_product_review_id_cre_096320ab\")\n}","schema-07-sellers.prisma":"/// Products managed by sellers, including product details and\n/// seller-specific information. This table represents the products that\n/// sellers offer on the platform, with a relationship to the main products\n/// table.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_products {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the seller who owns this product. {@link\n  /// shopping_sellers.id}.\n  shopping_seller_id String @db.Uuid\n  \n  /// Reference to the main product in the catalog. {@link\n  /// shopping_products.id}.\n  shopping_product_id String @db.Uuid\n  \n  /// Seller-specific product code for internal management.\n  seller_product_code String\n  \n  /// Seller's price for the product.\n  price Float @db.DoublePrecision\n  \n  /// Current available quantity for this product.\n  quantity_available Int @db.Integer\n  \n  /// Status of the product (e.g., active, draft, archived).\n  status String\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  /// Timestamp when the seller product was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller product was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller product was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  seller shopping_sellers @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n  \n  shopping_seller_inventory shopping_seller_inventory[]\n  \n  @@index([shopping_product_id])\n  \n  @@unique([shopping_seller_id, seller_product_code], map: \"shopping_seller_products_shopping_seller_id_seller_pro_4cbbccb3\")\n  @@index([created_at])\n  @@index([status])\n  @@index([seller_product_code(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Inventory tracking for seller products, including stock levels and\n/// management details. This table represents the inventory information that\n/// sellers manage for their products.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_inventory {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the seller product. {@link shopping_seller_products.id}.\n  shopping_seller_product_id String @db.Uuid\n  \n  /// Reference to the specific product variant. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n  \n  /// Current stock quantity for this inventory item.\n  stock_quantity Int @db.Integer\n  \n  /// Threshold for low stock alerts.\n  low_stock_threshold Int? @db.Integer\n  \n  /// Status of the inventory item (e.g., in_stock, low_stock, out_of_stock).\n  status String\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  /// Timestamp when the inventory record was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the inventory record was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the inventory record was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  sellerProduct shopping_seller_products @relation(fields: [shopping_seller_product_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_product_variant_id])\n  \n  @@unique([shopping_seller_product_id, shopping_product_variant_id], map: \"shopping_seller_inventory_shopping_seller_product_id_s_22ae8a5d\")\n  @@index([created_at])\n  @@index([status])\n}\n\n/// Orders managed by sellers, including order details and seller-specific\n/// information. This table represents the orders that sellers need to\n/// fulfill and manage.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the seller who owns this order. {@link shopping_sellers.id}.\n  shopping_seller_id String @db.Uuid\n  \n  /// Reference to the main order. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// Seller-specific order code for internal management.\n  seller_order_code String\n  \n  /// Current fulfillment status of the order (e.g., pending, processing,\n  /// shipped, delivered).\n  fulfillment_status String\n  \n  /// Business-specific status for workflow management.\n  business_status String?\n  \n  /// Timestamp when the seller order was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller order was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the seller order was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  seller shopping_sellers @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id])\n  \n  @@unique([shopping_seller_id, seller_order_code])\n  @@index([created_at])\n  @@index([fulfillment_status])\n  @@index([seller_order_code(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-08-admin.prisma":"/// Records of actions performed by administrators. Tracks all administrative\n/// activities for audit and accountability purposes. Each action is linked\n/// to a specific administrator.\n///\n/// @namespace Admin\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_admin_actions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Administrator who performed the action. {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String @db.Uuid\n  \n  /// Type of action performed (e.g., 'user_management', 'product_approval',\n  /// 'order_update').\n  action_type String\n  \n  /// Detailed description of the action performed.\n  description String\n  \n  /// Timestamp when the action was performed.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  administrator shopping_administrators @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_administrator_id, created_at])\n}\n\n/// System logs recording important events and changes. Tracks system-level\n/// events that may be initiated by administrators or system processes.\n///\n/// @namespace Admin\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_admin_logs {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Administrator associated with the log entry (if applicable). {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String? @db.Uuid\n  \n  /// Type of log entry (e.g., 'system_event', 'security_event', 'data_change').\n  log_type String\n  \n  /// Detailed log message describing the event.\n  message String\n  \n  /// Timestamp when the log entry was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  administrator shopping_administrators? @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_administrator_id, created_at])\n}","schema-09-payments.prisma":"/// Payment records for all transactions in the shopping mall platform. This\n/// table stores information about each payment made by customers, including\n/// payment method, amount, status, and related order information. It serves\n/// as the central record for all financial transactions in the system.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Customer who made the payment. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n  \n  /// Order associated with this payment. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// Payment method used for this transaction. {@link\n  /// shopping_payment_methods.id}.\n  payment_method_id String @db.Uuid\n  \n  /// Total amount paid in this transaction.\n  amount Float @db.DoublePrecision\n  \n  /// Currency used for the payment (e.g., USD, EUR).\n  currency String\n  \n  /// Current status of the payment (e.g., pending, completed, failed,\n  /// refunded).\n  status String\n  \n  /// External transaction ID from payment gateway.\n  transaction_id String?\n  \n  /// Date and time when the payment was processed.\n  payment_date DateTime @db.Timestamptz\n  \n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  \n  shopping_payment_transactions shopping_payment_transactions[]\n  \n  @@unique([transaction_id])\n  @@index([shopping_customer_id, created_at])\n  @@index([shopping_order_id, created_at])\n  @@index([payment_date])\n}\n\n/// Available payment methods in the shopping mall platform. This table\n/// defines all supported payment methods that customers can use to make\n/// purchases, including credit cards, digital wallets, bank transfers, etc.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payment_methods {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Name of the payment method (e.g., Credit Card, PayPal, Apple Pay).\n  method_name String\n  \n  /// Type of payment method (e.g., card, digital_wallet, bank_transfer).\n  method_type String\n  \n  /// Payment provider name (e.g., Stripe, PayPal, Visa).\n  provider String?\n  \n  /// Whether this payment method is currently active and available.\n  is_active Boolean\n  \n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([method_name])\n  @@index([method_type])\n  @@index([provider])\n}\n\n/// Detailed records of individual payment transactions. This table captures\n/// all the detailed information about each payment transaction, including\n/// authorization, capture, refund, and chargeback information.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payment_transactions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Payment record this transaction belongs to. {@link shopping_payments.id}.\n  shopping_payment_id String @db.Uuid\n  \n  /// Type of transaction (e.g., authorization, capture, refund, chargeback).\n  transaction_type String\n  \n  /// Amount involved in this transaction.\n  amount Float @db.DoublePrecision\n  \n  /// Currency used for this transaction.\n  currency String\n  \n  /// Current status of this transaction.\n  status String\n  \n  /// Raw response from payment gateway.\n  gateway_response String?\n  \n  /// Date and time when this transaction occurred.\n  transaction_date DateTime @db.Timestamptz\n  \n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  payment shopping_payments @relation(fields: [shopping_payment_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_payment_id, transaction_date], map: \"shopping_payment_transactions_shopping_payment_id_tran_6c883fbd\")\n  @@index([transaction_type, status])\n}","schema-10-shipping.prisma":"/// Shipping methods available for order fulfillment. Contains information\n/// about different shipping options, their costs, and delivery time\n/// estimates.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_methods {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Name of the shipping method (e.g., Standard, Express, Overnight).\n  name String\n  \n  /// Detailed description of the shipping method.\n  description String?\n  \n  /// Base cost of the shipping method.\n  cost Float @db.DoublePrecision\n  \n  /// Estimated number of days for delivery.\n  estimated_delivery_days Int @db.Integer\n  \n  /// Timestamp when the shipping method was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the shipping method was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_shipping_tracking shopping_shipping_tracking[]\n  \n  @@unique([name])\n  @@index([created_at])\n}\n\n/// Shipping carriers that handle order deliveries. Contains information\n/// about different shipping companies and their services.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_carriers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Name of the shipping carrier (e.g., UPS, FedEx, DHL).\n  name String\n  \n  /// Detailed description of the shipping carrier.\n  description String?\n  \n  /// URL template for tracking shipments with this carrier.\n  tracking_url_template String?\n  \n  /// Timestamp when the shipping carrier was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the shipping carrier was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  shopping_shipping_tracking shopping_shipping_tracking[]\n  \n  @@unique([name])\n  @@index([created_at])\n}\n\n/// Tracking information for shipped orders. Contains details about shipment\n/// status, tracking numbers, and carrier information.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_tracking {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The order being tracked. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n  \n  /// The carrier handling the shipment. {@link shopping_shipping_carriers.id}.\n  shopping_shipping_carrier_id String @db.Uuid\n  \n  /// The shipping method used for this shipment. {@link\n  /// shopping_shipping_methods.id}.\n  shopping_shipping_method_id String @db.Uuid\n  \n  /// Tracking number provided by the carrier.\n  tracking_number String\n  \n  /// Current status of the shipment (e.g., Processing, Shipped, Delivered).\n  status String\n  \n  /// Estimated delivery date for the shipment.\n  estimated_delivery_date DateTime? @db.Timestamptz\n  \n  /// Actual delivery date when the shipment was delivered.\n  actual_delivery_date DateTime? @db.Timestamptz\n  \n  /// Timestamp when the tracking information was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the tracking information was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  carrier shopping_shipping_carriers @relation(fields: [shopping_shipping_carrier_id], references: [id], onDelete: Cascade)\n  method shopping_shipping_methods @relation(fields: [shopping_shipping_method_id], references: [id], onDelete: Cascade)\n  \n  @@index([shopping_order_id])\n  @@index([shopping_shipping_carrier_id])\n  @@index([shopping_shipping_method_id])\n  \n  @@unique([tracking_number])\n  @@index([created_at])\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-systematic.prisma","namespace":"Systematic","models":[{"name":"shopping_channels","description":"Represents the channels through which products are sold in the shopping mall platform. Each channel can have multiple sections and categories, forming the foundation of the platform's organizational structure.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"name","type":"string","description":"The name of the shopping channel.","nullable":false},{"name":"description","type":"string","description":"A detailed description of the shopping channel.","nullable":true},{"name":"created_at","type":"datetime","description":"The timestamp when the channel was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"The timestamp when the channel was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"The timestamp when the channel was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["name"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["updated_at"]}],"ginIndexes":[]},{"name":"shopping_sections","description":"Represents the sections within shopping channels. Each section belongs to a specific channel and can contain multiple categories.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"The channel to which this section belongs. {@link shopping_channels.id}.","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":false}],"plainFields":[{"name":"name","type":"string","description":"The name of the shopping section.","nullable":false},{"name":"description","type":"string","description":"A detailed description of the shopping section.","nullable":true},{"name":"created_at","type":"datetime","description":"The timestamp when the section was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"The timestamp when the section was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"The timestamp when the section was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_channel_id","name"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id","created_at"]},{"fieldNames":["shopping_channel_id","updated_at"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_channel_categories","description":"Represents the categories within shopping channel sections. Each category belongs to a specific section and channel, forming the hierarchical structure of the platform's product organization.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_channel_id","type":"uuid","description":"The channel to which this category belongs. {@link shopping_channels.id}.","relation":{"name":"channel","targetModel":"shopping_channels"},"unique":false,"nullable":false},{"name":"shopping_section_id","type":"uuid","description":"The section to which this category belongs. {@link shopping_sections.id}.","relation":{"name":"section","targetModel":"shopping_sections"},"unique":false,"nullable":false}],"plainFields":[{"name":"name","type":"string","description":"The name of the shopping category.","nullable":false},{"name":"description","type":"string","description":"A detailed description of the shopping category.","nullable":true},{"name":"created_at","type":"datetime","description":"The timestamp when the category was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"The timestamp when the category was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"The timestamp when the category was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_channel_id","shopping_section_id","name"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_channel_id","shopping_section_id","created_at"]},{"fieldNames":["shopping_channel_id","shopping_section_id","updated_at"]}],"ginIndexes":[{"fieldName":"name"}]}]},{"filename":"schema-02-actors.prisma","namespace":"Actors","models":[{"name":"shopping_customers","description":"Customer information, but not a person but a **connection** basis. This is the main entity for customer identity management. Contains authentication credentials and basic profile information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Customer's email address. Used for login and communication.","nullable":false},{"name":"password_hash","type":"string","description":"Securely hashed password for authentication.","nullable":false},{"name":"name","type":"string","description":"Customer's full name.","nullable":false},{"name":"phone","type":"string","description":"Customer's phone number.","nullable":true},{"name":"address","type":"string","description":"Customer's primary address.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["phone"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_sellers","description":"Seller information for marketplace vendors. Contains authentication credentials and business profile information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Seller's email address. Used for login and communication.","nullable":false},{"name":"password_hash","type":"string","description":"Securely hashed password for authentication.","nullable":false},{"name":"business_name","type":"string","description":"Seller's business name.","nullable":false},{"name":"contact_name","type":"string","description":"Primary contact person's name.","nullable":false},{"name":"phone","type":"string","description":"Seller's phone number.","nullable":true},{"name":"address","type":"string","description":"Seller's business address.","nullable":true},{"name":"tax_id","type":"string","description":"Seller's tax identification number.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true},{"fieldNames":["tax_id"],"unique":true}],"plainIndexes":[{"fieldNames":["phone"]}],"ginIndexes":[{"fieldName":"business_name"},{"fieldName":"contact_name"}]},{"name":"shopping_administrators","description":"Administrator information for platform management. Contains authentication credentials and admin profile information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Admin's email address. Used for login and communication.","nullable":false},{"name":"password_hash","type":"string","description":"Securely hashed password for authentication.","nullable":false},{"name":"name","type":"string","description":"Admin's full name.","nullable":false},{"name":"phone","type":"string","description":"Admin's phone number.","nullable":true},{"name":"role","type":"string","description":"Admin's role or permission level.","nullable":false}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["role"]}],"ginIndexes":[{"fieldName":"name"}]}]},{"filename":"schema-03-sales.prisma","namespace":"Sales","models":[{"name":"shopping_products","description":"Core product information for the e-commerce platform. Contains all essential details about products including name, description, pricing, and categorization. Serves as the primary entity for product management and is referenced by variants, inventory, and reviews.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_category_id","type":"uuid","description":"Category this product belongs to. {@link shopping_categories.id}.","relation":{"name":"category","targetModel":"shopping_categories"},"unique":false,"nullable":true}],"plainFields":[{"name":"name","type":"string","description":"Name of the product.","nullable":false},{"name":"description","type":"string","description":"Detailed description of the product.","nullable":true},{"name":"price","type":"double","description":"Base price of the product.","nullable":false},{"name":"sku","type":"string","description":"Stock Keeping Unit - unique identifier for the product.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the product was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the product was last updated.","nullable":false},{"name":"password_hash","type":"string","description":"Securely hashed password for authentication.","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true}],"uniqueIndexes":[{"fieldNames":["sku"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_category_id"]},{"fieldNames":["created_at"]},{"fieldNames":["price"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_product_variants","description":"Product variants representing different options (colors, sizes, materials) for products. Each variant has its own SKU and inventory tracking. References the main product and contains variant-specific details.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_product_id","type":"uuid","description":"Main product this variant belongs to. {@link shopping_products.id}.","relation":{"name":"product","targetModel":"shopping_products"},"unique":false,"nullable":false}],"plainFields":[{"name":"sku","type":"string","description":"Stock Keeping Unit - unique identifier for this variant.","nullable":false},{"name":"option_name","type":"string","description":"Name of the variant option (e.g., Color, Size).","nullable":false},{"name":"option_value","type":"string","description":"Value of the variant option (e.g., Red, Large).","nullable":false},{"name":"price_adjustment","type":"double","description":"Price adjustment for this variant from base price.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the variant was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the variant was last updated.","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true}],"uniqueIndexes":[{"fieldNames":["sku"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_product_id"]},{"fieldNames":["created_at"]},{"fieldNames":["option_name"]},{"fieldNames":["option_value"]}],"ginIndexes":[]},{"name":"shopping_categories","description":"Product categorization hierarchy for organizing products. Categories can have parent-child relationships to create a hierarchical structure. Products are assigned to categories for better organization and filtering.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"parent_id","type":"uuid","description":"Parent category if this is a subcategory. {@link shopping_categories.id}.","relation":{"name":"parent","targetModel":"shopping_categories","mappingName":"recursive"},"unique":false,"nullable":true}],"plainFields":[{"name":"name","type":"string","description":"Name of the category.","nullable":false},{"name":"description","type":"string","description":"Description of the category.","nullable":true},{"name":"code","type":"string","description":"Unique code for the category.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the category was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the category was last updated.","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true}],"uniqueIndexes":[{"fieldNames":["code"],"unique":true}],"plainIndexes":[{"fieldNames":["parent_id"]},{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"name"}]},{"name":"shopping_inventory","description":"Inventory tracking for product variants. Monitors stock levels, reservations, and availability status for each product variant. Critical for order fulfillment and stock management.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_product_variant_id","type":"uuid","description":"Product variant this inventory tracks. {@link shopping_product_variants.id}.","relation":{"name":"variant","targetModel":"shopping_product_variants"},"unique":true,"nullable":false},{"name":"shopping_product_id","type":"uuid","description":"Product this inventory belongs to. {@link shopping_products.id}.","relation":{"name":"product","targetModel":"shopping_products"},"unique":false,"nullable":false}],"plainFields":[{"name":"quantity","type":"int","description":"Current available quantity.","nullable":false},{"name":"reserved_quantity","type":"int","description":"Quantity reserved for pending orders.","nullable":false},{"name":"low_stock_threshold","type":"int","description":"Threshold for low stock alerts.","nullable":true},{"name":"last_stock_update","type":"datetime","description":"Timestamp of last stock update.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the inventory record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the inventory record was last updated.","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_product_variant_id"]},{"fieldNames":["shopping_product_id"]},{"fieldNames":["last_stock_update"]}],"ginIndexes":[]},{"name":"shopping_product_reviews","description":"Customer reviews for products. Contains rating, text, and metadata about customer feedback on products. Critical for building trust and providing social proof.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_product_id","type":"uuid","description":"Product this review is for. {@link shopping_products.id}.","relation":{"name":"product","targetModel":"shopping_products"},"unique":false,"nullable":false},{"name":"shopping_customer_id","type":"uuid","description":"Customer who left the review. {@link shopping_customers.id}.","relation":{"name":"customer","targetModel":"shopping_customers"},"unique":false,"nullable":false}],"plainFields":[{"name":"rating","type":"int","description":"Rating score (1-5).","nullable":false},{"name":"title","type":"string","description":"Title of the review.","nullable":true},{"name":"content","type":"string","description":"Main content of the review.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the review was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the review was last updated.","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_product_id"]},{"fieldNames":["shopping_customer_id"]},{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"content"}]}]},{"filename":"schema-04-orders.prisma","namespace":"Orders","models":[{"name":"shopping_orders","description":"Main order table containing all order information. Represents customer orders with status tracking and payment information. This is the primary entity for order management.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_customer_id","type":"uuid","description":"Customer who placed the order. {@link shopping_customers.id}.","relation":{"name":"customer","targetModel":"shopping_customers"},"unique":false,"nullable":false}],"plainFields":[{"name":"order_code","type":"string","description":"Unique order code for business identification.","nullable":false},{"name":"total_amount","type":"double","description":"Total order amount including all items and taxes.","nullable":false},{"name":"currency","type":"string","description":"Currency used for the order (e.g., USD, KRW).","nullable":false},{"name":"status","type":"string","description":"Current order status (e.g., pending, processing, shipped, delivered, cancelled).","nullable":false},{"name":"payment_method","type":"string","description":"Payment method used for the order.","nullable":false},{"name":"shipping_method","type":"string","description":"Selected shipping method for the order.","nullable":false},{"name":"shipping_address","type":"string","description":"Shipping address for the order.","nullable":false},{"name":"billing_address","type":"string","description":"Billing address for the order.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the order was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the order was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the order was soft deleted (if applicable).","nullable":true}],"uniqueIndexes":[{"fieldNames":["order_code"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_customer_id","created_at"]},{"fieldNames":["status","updated_at"]}],"ginIndexes":[]},{"name":"shopping_order_items","description":"Order line items representing individual products in an order. Each item references a product variant and tracks quantity and price.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"Order this item belongs to. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false},{"name":"shopping_product_variant_id","type":"uuid","description":"Product variant being ordered. {@link shopping_product_variants.id}.","relation":{"name":"productVariant","targetModel":"shopping_product_variants"},"unique":false,"nullable":false}],"plainFields":[{"name":"quantity","type":"int","description":"Number of units ordered.","nullable":false},{"name":"unit_price","type":"double","description":"Price per unit at time of order.","nullable":false},{"name":"total_price","type":"double","description":"Total price for this line item (quantity × unit_price).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the order item was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the order item was last updated.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_order_id","created_at"]},{"fieldNames":["shopping_product_variant_id","created_at"]}],"ginIndexes":[]},{"name":"shopping_order_status","description":"Order status tracking table. Records all status changes for an order with timestamps.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"Order this status belongs to. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"status","type":"string","description":"Order status at this point in time.","nullable":false},{"name":"changed_at","type":"datetime","description":"Timestamp when this status was set.","nullable":false},{"name":"changed_by","type":"string","description":"User or system that changed the status.","nullable":true},{"name":"notes","type":"string","description":"Additional notes about the status change.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_order_id","changed_at"]},{"fieldNames":["status","changed_at"]}],"ginIndexes":[]},{"name":"shopping_order_history","description":"Historical record of all order changes. Captures snapshots of order states for audit trails and change tracking.","material":false,"stance":"snapshot","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"Order this history record belongs to. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"action","type":"string","description":"Action performed on the order (e.g., created, updated, cancelled).","nullable":false},{"name":"changed_at","type":"datetime","description":"Timestamp when this action occurred.","nullable":false},{"name":"changed_by","type":"string","description":"User or system that performed the action.","nullable":true},{"name":"details","type":"string","description":"JSON object containing order state at time of action.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_order_id","changed_at"]},{"fieldNames":["action","changed_at"]}],"ginIndexes":[]}]},{"filename":"schema-05-carts.prisma","namespace":"Carts","models":[{"name":"shopping_shopping_carts","description":"Represents a customer's shopping cart containing items they intend to purchase. Each cart belongs to a specific customer and can contain multiple cart items. This is a primary business entity that users manage independently through their shopping experience.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_customer_id","type":"uuid","description":"Customer who owns this shopping cart. {@link shopping_customers.id}.","relation":{"name":"customer","targetModel":"shopping_customers"},"unique":false,"nullable":false}],"plainFields":[{"name":"created_at","type":"datetime","description":"Timestamp when the shopping cart was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the shopping cart was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["shopping_customer_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"shopping_cart_items","description":"Represents individual items in a shopping cart. Each item references a specific product variant and belongs to a specific shopping cart. This is a subsidiary entity managed through the parent shopping cart.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_shopping_cart_id","type":"uuid","description":"Shopping cart that contains this item. {@link shopping_shopping_carts.id}.","relation":{"name":"cart","targetModel":"shopping_shopping_carts"},"unique":false,"nullable":false},{"name":"shopping_product_variant_id","type":"uuid","description":"Product variant referenced by this cart item. {@link shopping_product_variants.id}.","relation":{"name":"productVariant","targetModel":"shopping_product_variants"},"unique":false,"nullable":false}],"plainFields":[{"name":"quantity","type":"int","description":"Quantity of this product variant in the cart.","nullable":false},{"name":"price","type":"double","description":"Price of the product variant at the time it was added to the cart.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the cart item was added.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the cart item was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["shopping_shopping_cart_id","shopping_product_variant_id"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_product_variant_id","created_at"]}],"ginIndexes":[]}]},{"filename":"schema-06-reviews.prisma","namespace":"Reviews","models":[{"name":"shopping_review_moderation","description":"Tracks moderation actions taken on product reviews. This table records each moderation event, including the administrator who performed the action, the type of action, reason, and timestamp. It supports the review approval workflow and audit trail.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_product_review_id","type":"uuid","description":"The review being moderated. {@link shopping_product_reviews.id}.","relation":{"name":"review","targetModel":"shopping_product_reviews"},"unique":false,"nullable":false},{"name":"shopping_administrator_id","type":"uuid","description":"The administrator who performed the moderation action. {@link shopping_administrators.id}.","relation":{"name":"administrator","targetModel":"shopping_administrators"},"unique":false,"nullable":false}],"plainFields":[{"name":"action_type","type":"string","description":"Type of moderation action (approve, reject, flag).","nullable":false},{"name":"reason","type":"string","description":"Reason for the moderation action.","nullable":true},{"name":"created_at","type":"datetime","description":"When the moderation action was performed.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_product_review_id","created_at"]},{"fieldNames":["shopping_administrator_id","created_at"]}],"ginIndexes":[{"fieldName":"reason"}]},{"name":"shopping_review_ratings","description":"Stores detailed rating breakdowns for product reviews. This table captures individual rating dimensions (quality, value, etc.) that contribute to the overall rating. It allows for granular analysis of review ratings across different aspects.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_product_review_id","type":"uuid","description":"The review this rating belongs to. {@link shopping_product_reviews.id}.","relation":{"name":"review","targetModel":"shopping_product_reviews"},"unique":false,"nullable":false}],"plainFields":[{"name":"quality_rating","type":"int","description":"Rating for product quality (1-5).","nullable":false},{"name":"value_rating","type":"int","description":"Rating for product value (1-5).","nullable":false},{"name":"service_rating","type":"int","description":"Rating for service experience (1-5).","nullable":false},{"name":"created_at","type":"datetime","description":"When the rating was created.","nullable":false}],"uniqueIndexes":[{"fieldNames":["shopping_product_review_id"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_product_review_id","created_at"]}],"ginIndexes":[]}]},{"filename":"schema-07-sellers.prisma","namespace":"Sellers","models":[{"name":"shopping_seller_products","description":"Products managed by sellers, including product details and seller-specific information. This table represents the products that sellers offer on the platform, with a relationship to the main products table.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_seller_id","type":"uuid","description":"Reference to the seller who owns this product. {@link shopping_sellers.id}.","relation":{"name":"seller","targetModel":"shopping_sellers"},"unique":false,"nullable":false},{"name":"shopping_product_id","type":"uuid","description":"Reference to the main product in the catalog. {@link shopping_products.id}.","relation":{"name":"product","targetModel":"shopping_products"},"unique":false,"nullable":false}],"plainFields":[{"name":"seller_product_code","type":"string","description":"Seller-specific product code for internal management.","nullable":false},{"name":"price","type":"double","description":"Seller's price for the product.","nullable":false},{"name":"quantity_available","type":"int","description":"Current available quantity for this product.","nullable":false},{"name":"status","type":"string","description":"Status of the product (e.g., active, draft, archived).","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the seller product was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the seller product was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the seller product was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_seller_id","seller_product_code"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["status"]}],"ginIndexes":[{"fieldName":"seller_product_code"}]},{"name":"shopping_seller_inventory","description":"Inventory tracking for seller products, including stock levels and management details. This table represents the inventory information that sellers manage for their products.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_seller_product_id","type":"uuid","description":"Reference to the seller product. {@link shopping_seller_products.id}.","relation":{"name":"sellerProduct","targetModel":"shopping_seller_products"},"unique":false,"nullable":false},{"name":"shopping_product_variant_id","type":"uuid","description":"Reference to the specific product variant. {@link shopping_product_variants.id}.","relation":{"name":"productVariant","targetModel":"shopping_product_variants"},"unique":false,"nullable":false}],"plainFields":[{"name":"stock_quantity","type":"int","description":"Current stock quantity for this inventory item.","nullable":false},{"name":"low_stock_threshold","type":"int","description":"Threshold for low stock alerts.","nullable":true},{"name":"status","type":"string","description":"Status of the inventory item (e.g., in_stock, low_stock, out_of_stock).","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the inventory record was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the inventory record was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the inventory record was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_seller_product_id","shopping_product_variant_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["status"]}],"ginIndexes":[]},{"name":"shopping_seller_orders","description":"Orders managed by sellers, including order details and seller-specific information. This table represents the orders that sellers need to fulfill and manage.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_seller_id","type":"uuid","description":"Reference to the seller who owns this order. {@link shopping_sellers.id}.","relation":{"name":"seller","targetModel":"shopping_sellers"},"unique":false,"nullable":false},{"name":"shopping_order_id","type":"uuid","description":"Reference to the main order. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"seller_order_code","type":"string","description":"Seller-specific order code for internal management.","nullable":false},{"name":"fulfillment_status","type":"string","description":"Current fulfillment status of the order (e.g., pending, processing, shipped, delivered).","nullable":false},{"name":"business_status","type":"string","description":"Business-specific status for workflow management.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the seller order was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the seller order was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the seller order was soft deleted, if applicable.","nullable":true}],"uniqueIndexes":[{"fieldNames":["shopping_seller_id","seller_order_code"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["fulfillment_status"]}],"ginIndexes":[{"fieldName":"seller_order_code"}]}]},{"filename":"schema-08-admin.prisma","namespace":"Admin","models":[{"name":"shopping_admin_actions","description":"Records of actions performed by administrators. Tracks all administrative activities for audit and accountability purposes. Each action is linked to a specific administrator.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_administrator_id","type":"uuid","description":"Administrator who performed the action. {@link shopping_administrators.id}.","relation":{"name":"administrator","targetModel":"shopping_administrators"},"unique":false,"nullable":false}],"plainFields":[{"name":"action_type","type":"string","description":"Type of action performed (e.g., 'user_management', 'product_approval', 'order_update').","nullable":false},{"name":"description","type":"string","description":"Detailed description of the action performed.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the action was performed.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_administrator_id","created_at"]}],"ginIndexes":[]},{"name":"shopping_admin_logs","description":"System logs recording important events and changes. Tracks system-level events that may be initiated by administrators or system processes.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_administrator_id","type":"uuid","description":"Administrator associated with the log entry (if applicable). {@link shopping_administrators.id}.","relation":{"name":"administrator","targetModel":"shopping_administrators"},"unique":false,"nullable":true}],"plainFields":[{"name":"log_type","type":"string","description":"Type of log entry (e.g., 'system_event', 'security_event', 'data_change').","nullable":false},{"name":"message","type":"string","description":"Detailed log message describing the event.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the log entry was created.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_administrator_id","created_at"]}],"ginIndexes":[]}]},{"filename":"schema-09-payments.prisma","namespace":"Payments","models":[{"name":"shopping_payments","description":"Payment records for all transactions in the shopping mall platform. This table stores information about each payment made by customers, including payment method, amount, status, and related order information. It serves as the central record for all financial transactions in the system.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_customer_id","type":"uuid","description":"Customer who made the payment. {@link shopping_customers.id}.","relation":{"name":"customer","targetModel":"shopping_customers"},"unique":false,"nullable":false},{"name":"shopping_order_id","type":"uuid","description":"Order associated with this payment. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false}],"plainFields":[{"name":"payment_method_id","type":"uuid","description":"Payment method used for this transaction. {@link shopping_payment_methods.id}.","nullable":false},{"name":"amount","type":"double","description":"Total amount paid in this transaction.","nullable":false},{"name":"currency","type":"string","description":"Currency used for the payment (e.g., USD, EUR).","nullable":false},{"name":"status","type":"string","description":"Current status of the payment (e.g., pending, completed, failed, refunded).","nullable":false},{"name":"transaction_id","type":"string","description":"External transaction ID from payment gateway.","nullable":true},{"name":"payment_date","type":"datetime","description":"Date and time when the payment was processed.","nullable":false},{"name":"created_at","type":"datetime","description":"Record creation timestamp.","nullable":false},{"name":"updated_at","type":"datetime","description":"Record last update timestamp.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Soft delete timestamp.","nullable":true}],"uniqueIndexes":[{"fieldNames":["transaction_id"],"unique":true}],"plainIndexes":[{"fieldNames":["shopping_customer_id","created_at"]},{"fieldNames":["shopping_order_id","created_at"]},{"fieldNames":["payment_date"]}],"ginIndexes":[]},{"name":"shopping_payment_methods","description":"Available payment methods in the shopping mall platform. This table defines all supported payment methods that customers can use to make purchases, including credit cards, digital wallets, bank transfers, etc.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"method_name","type":"string","description":"Name of the payment method (e.g., Credit Card, PayPal, Apple Pay).","nullable":false},{"name":"method_type","type":"string","description":"Type of payment method (e.g., card, digital_wallet, bank_transfer).","nullable":false},{"name":"provider","type":"string","description":"Payment provider name (e.g., Stripe, PayPal, Visa).","nullable":true},{"name":"is_active","type":"boolean","description":"Whether this payment method is currently active and available.","nullable":false},{"name":"created_at","type":"datetime","description":"Record creation timestamp.","nullable":false},{"name":"updated_at","type":"datetime","description":"Record last update timestamp.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Soft delete timestamp.","nullable":true}],"uniqueIndexes":[{"fieldNames":["method_name"],"unique":true}],"plainIndexes":[{"fieldNames":["method_type"]},{"fieldNames":["provider"]}],"ginIndexes":[]},{"name":"shopping_payment_transactions","description":"Detailed records of individual payment transactions. This table captures all the detailed information about each payment transaction, including authorization, capture, refund, and chargeback information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_payment_id","type":"uuid","description":"Payment record this transaction belongs to. {@link shopping_payments.id}.","relation":{"name":"payment","targetModel":"shopping_payments"},"unique":false,"nullable":false}],"plainFields":[{"name":"transaction_type","type":"string","description":"Type of transaction (e.g., authorization, capture, refund, chargeback).","nullable":false},{"name":"amount","type":"double","description":"Amount involved in this transaction.","nullable":false},{"name":"currency","type":"string","description":"Currency used for this transaction.","nullable":false},{"name":"status","type":"string","description":"Current status of this transaction.","nullable":false},{"name":"gateway_response","type":"string","description":"Raw response from payment gateway.","nullable":true},{"name":"transaction_date","type":"datetime","description":"Date and time when this transaction occurred.","nullable":false},{"name":"created_at","type":"datetime","description":"Record creation timestamp.","nullable":false},{"name":"updated_at","type":"datetime","description":"Record last update timestamp.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Soft delete timestamp.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["shopping_payment_id","transaction_date"]},{"fieldNames":["transaction_type","status"]}],"ginIndexes":[]}]},{"filename":"schema-10-shipping.prisma","namespace":"Shipping","models":[{"name":"shopping_shipping_methods","description":"Shipping methods available for order fulfillment. Contains information about different shipping options, their costs, and delivery time estimates.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"name","type":"string","description":"Name of the shipping method (e.g., Standard, Express, Overnight).","nullable":false},{"name":"description","type":"string","description":"Detailed description of the shipping method.","nullable":true},{"name":"cost","type":"double","description":"Base cost of the shipping method.","nullable":false},{"name":"estimated_delivery_days","type":"int","description":"Estimated number of days for delivery.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the shipping method was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the shipping method was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["name"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"shopping_shipping_carriers","description":"Shipping carriers that handle order deliveries. Contains information about different shipping companies and their services.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"name","type":"string","description":"Name of the shipping carrier (e.g., UPS, FedEx, DHL).","nullable":false},{"name":"description","type":"string","description":"Detailed description of the shipping carrier.","nullable":true},{"name":"tracking_url_template","type":"string","description":"URL template for tracking shipments with this carrier.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the shipping carrier was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the shipping carrier was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["name"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"shopping_shipping_tracking","description":"Tracking information for shipped orders. Contains details about shipment status, tracking numbers, and carrier information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"shopping_order_id","type":"uuid","description":"The order being tracked. {@link shopping_orders.id}.","relation":{"name":"order","targetModel":"shopping_orders"},"unique":false,"nullable":false},{"name":"shopping_shipping_carrier_id","type":"uuid","description":"The carrier handling the shipment. {@link shopping_shipping_carriers.id}.","relation":{"name":"carrier","targetModel":"shopping_shipping_carriers"},"unique":false,"nullable":false},{"name":"shopping_shipping_method_id","type":"uuid","description":"The shipping method used for this shipment. {@link shopping_shipping_methods.id}.","relation":{"name":"method","targetModel":"shopping_shipping_methods"},"unique":false,"nullable":false}],"plainFields":[{"name":"tracking_number","type":"string","description":"Tracking number provided by the carrier.","nullable":false},{"name":"status","type":"string","description":"Current status of the shipment (e.g., Processing, Shipped, Delivered).","nullable":false},{"name":"estimated_delivery_date","type":"datetime","description":"Estimated delivery date for the shipment.","nullable":true},{"name":"actual_delivery_date","type":"datetime","description":"Actual delivery date when the shipment was delivered.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the tracking information was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the tracking information was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["tracking_number"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-systematic.prisma":"/// Represents the channels through which products are sold in the shopping\n/// mall platform. Each channel can have multiple sections and categories,\n/// forming the foundation of the platform's organizational structure.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channels {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The name of the shopping channel.\n  name String\n\n  /// A detailed description of the shopping channel.\n  description String?\n\n  /// The timestamp when the channel was created.\n  created_at DateTime @db.Timestamptz\n\n  /// The timestamp when the channel was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// The timestamp when the channel was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_sections           shopping_sections[]\n  shopping_channel_categories shopping_channel_categories[]\n\n  @@unique([name])\n  @@index([created_at])\n  @@index([updated_at])\n}\n\n/// Represents the sections within shopping channels. Each section belongs to\n/// a specific channel and can contain multiple categories.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sections {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The channel to which this section belongs. {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n\n  /// The name of the shopping section.\n  name String\n\n  /// A detailed description of the shopping section.\n  description String?\n\n  /// The timestamp when the section was created.\n  created_at DateTime @db.Timestamptz\n\n  /// The timestamp when the section was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// The timestamp when the section was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n\n  shopping_channel_categories shopping_channel_categories[]\n\n  @@unique([shopping_channel_id, name])\n  @@index([shopping_channel_id, created_at])\n  @@index([shopping_channel_id, updated_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents the categories within shopping channel sections. Each category\n/// belongs to a specific section and channel, forming the hierarchical\n/// structure of the platform's product organization.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_channel_categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The channel to which this category belongs. {@link shopping_channels.id}.\n  shopping_channel_id String @db.Uuid\n\n  /// The section to which this category belongs. {@link shopping_sections.id}.\n  shopping_section_id String @db.Uuid\n\n  /// The name of the shopping category.\n  name String\n\n  /// A detailed description of the shopping category.\n  description String?\n\n  /// The timestamp when the category was created.\n  created_at DateTime @db.Timestamptz\n\n  /// The timestamp when the category was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// The timestamp when the category was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  channel shopping_channels @relation(fields: [shopping_channel_id], references: [id], onDelete: Cascade)\n  section shopping_sections @relation(fields: [shopping_section_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_channel_id, shopping_section_id, name], map: \"shopping_channel_categories_shopping_channel_id_shoppi_8ec29d51\")\n  @@index([shopping_section_id])\n  @@index([shopping_channel_id, shopping_section_id, created_at], map: \"shopping_channel_categories_shopping_channel_id_shoppi_bdf01ba1\")\n  @@index([shopping_channel_id, shopping_section_id, updated_at], map: \"shopping_channel_categories_shopping_channel_id_shoppi_8758f887\")\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-02-actors.prisma":"/// Customer information, but not a person but a **connection** basis. This\n/// is the main entity for customer identity management. Contains\n/// authentication credentials and basic profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_customers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Customer's email address. Used for login and communication.\n  email String\n\n  /// Securely hashed password for authentication.\n  password_hash String\n\n  /// Customer's full name.\n  name String\n\n  /// Customer's phone number.\n  phone String?\n\n  /// Customer's primary address.\n  address String?\n\n  //----\n  // RELATIONS\n  //----\n  shopping_product_reviews shopping_product_reviews[]\n  shopping_orders          shopping_orders[]\n  shopping_shopping_carts  shopping_shopping_carts[]\n  shopping_payments        shopping_payments[]\n\n  @@unique([email])\n  @@index([phone])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Seller information for marketplace vendors. Contains authentication\n/// credentials and business profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_sellers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Seller's email address. Used for login and communication.\n  email String\n\n  /// Securely hashed password for authentication.\n  password_hash String\n\n  /// Seller's business name.\n  business_name String\n\n  /// Primary contact person's name.\n  contact_name String\n\n  /// Seller's phone number.\n  phone String?\n\n  /// Seller's business address.\n  address String?\n\n  /// Seller's tax identification number.\n  tax_id String?\n\n  //----\n  // RELATIONS\n  //----\n  shopping_seller_products shopping_seller_products[]\n  shopping_seller_orders   shopping_seller_orders[]\n\n  @@unique([email])\n  @@unique([tax_id])\n  @@index([phone])\n  @@index([business_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([contact_name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Administrator information for platform management. Contains\n/// authentication credentials and admin profile information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_administrators {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Admin's email address. Used for login and communication.\n  email String\n\n  /// Securely hashed password for authentication.\n  password_hash String\n\n  /// Admin's full name.\n  name String\n\n  /// Admin's phone number.\n  phone String?\n\n  /// Admin's role or permission level.\n  role String\n\n  //----\n  // RELATIONS\n  //----\n  shopping_review_moderation shopping_review_moderation[]\n  shopping_admin_actions     shopping_admin_actions[]\n  shopping_admin_logs        shopping_admin_logs[]\n\n  @@unique([email])\n  @@index([role])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-03-sales.prisma":"/// Core product information for the e-commerce platform. Contains all\n/// essential details about products including name, description, pricing,\n/// and categorization. Serves as the primary entity for product management\n/// and is referenced by variants, inventory, and reviews.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_products {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Category this product belongs to. {@link shopping_categories.id}.\n  shopping_category_id String? @db.Uuid\n\n  /// Name of the product.\n  name String\n\n  /// Detailed description of the product.\n  description String?\n\n  /// Base price of the product.\n  price Float @db.DoublePrecision\n\n  /// Stock Keeping Unit - unique identifier for the product.\n  sku String\n\n  /// Timestamp when the product was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the product was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Securely hashed password for authentication.\n  password_hash String\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  //----\n  // RELATIONS\n  //----\n  category shopping_categories? @relation(fields: [shopping_category_id], references: [id], onDelete: Cascade)\n\n  shopping_product_variants shopping_product_variants[]\n  shopping_inventory        shopping_inventory[]\n  shopping_product_reviews  shopping_product_reviews[]\n  shopping_seller_products  shopping_seller_products[]\n\n  @@unique([sku])\n  @@index([shopping_category_id])\n  @@index([created_at])\n  @@index([price])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Product variants representing different options (colors, sizes,\n/// materials) for products. Each variant has its own SKU and inventory\n/// tracking. References the main product and contains variant-specific\n/// details.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_product_variants {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Main product this variant belongs to. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n\n  /// Stock Keeping Unit - unique identifier for this variant.\n  sku String\n\n  /// Name of the variant option (e.g., Color, Size).\n  option_name String\n\n  /// Value of the variant option (e.g., Red, Large).\n  option_value String\n\n  /// Price adjustment for this variant from base price.\n  price_adjustment Float? @db.DoublePrecision\n\n  /// Timestamp when the variant was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the variant was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  //----\n  // RELATIONS\n  //----\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n\n  shopping_inventory        shopping_inventory?\n  shopping_order_items      shopping_order_items[]\n  shopping_cart_items       shopping_cart_items[]\n  shopping_seller_inventory shopping_seller_inventory[]\n\n  @@unique([sku])\n  @@index([shopping_product_id])\n  @@index([created_at])\n  @@index([option_name])\n  @@index([option_value])\n}\n\n/// Product categorization hierarchy for organizing products. Categories can\n/// have parent-child relationships to create a hierarchical structure.\n/// Products are assigned to categories for better organization and\n/// filtering.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Parent category if this is a subcategory. {@link shopping_categories.id}.\n  parent_id String? @db.Uuid\n\n  /// Name of the category.\n  name String\n\n  /// Description of the category.\n  description String?\n\n  /// Unique code for the category.\n  code String\n\n  /// Timestamp when the category was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the category was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  //----\n  // RELATIONS\n  //----\n  parent shopping_categories? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n\n  shopping_products shopping_products[]\n  recursive         shopping_categories[] @relation(\"recursive\")\n\n  @@unique([code])\n  @@index([parent_id])\n  @@index([created_at])\n  @@index([name(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Inventory tracking for product variants. Monitors stock levels,\n/// reservations, and availability status for each product variant. Critical\n/// for order fulfillment and stock management.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_inventory {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Product variant this inventory tracks. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n\n  /// Product this inventory belongs to. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n\n  /// Current available quantity.\n  quantity Int @db.Integer\n\n  /// Quantity reserved for pending orders.\n  reserved_quantity Int @db.Integer\n\n  /// Threshold for low stock alerts.\n  low_stock_threshold Int? @db.Integer\n\n  /// Timestamp of last stock update.\n  last_stock_update DateTime? @db.Timestamptz\n\n  /// Timestamp when the inventory record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the inventory record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  //----\n  // RELATIONS\n  //----\n  variant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n  product shopping_products         @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_product_variant_id])\n  @@index([shopping_product_variant_id])\n  @@index([shopping_product_id])\n  @@index([last_stock_update])\n}\n\n/// Customer reviews for products. Contains rating, text, and metadata about\n/// customer feedback on products. Critical for building trust and providing\n/// social proof.\n///\n/// @namespace Sales\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_product_reviews {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Product this review is for. {@link shopping_products.id}.\n  shopping_product_id String @db.Uuid\n\n  /// Customer who left the review. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n\n  /// Rating score (1-5).\n  rating Int @db.Integer\n\n  /// Title of the review.\n  title String?\n\n  /// Main content of the review.\n  content String\n\n  /// Timestamp when the review was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the review was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  //----\n  // RELATIONS\n  //----\n  product  shopping_products  @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n\n  shopping_review_moderation shopping_review_moderation[]\n  shopping_review_ratings    shopping_review_ratings[]\n\n  @@index([shopping_product_id])\n  @@index([shopping_customer_id])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-04-orders.prisma":"/// Main order table containing all order information. Represents customer\n/// orders with status tracking and payment information. This is the primary\n/// entity for order management.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Customer who placed the order. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n\n  /// Unique order code for business identification.\n  order_code String\n\n  /// Total order amount including all items and taxes.\n  total_amount Float @db.DoublePrecision\n\n  /// Currency used for the order (e.g., USD, KRW).\n  currency String\n\n  /// Current order status (e.g., pending, processing, shipped, delivered,\n  /// cancelled).\n  status String\n\n  /// Payment method used for the order.\n  payment_method String\n\n  /// Selected shipping method for the order.\n  shipping_method String\n\n  /// Shipping address for the order.\n  shipping_address String\n\n  /// Billing address for the order.\n  billing_address String\n\n  /// Timestamp when the order was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order was soft deleted (if applicable).\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n\n  shopping_order_items       shopping_order_items[]\n  shopping_order_status      shopping_order_status[]\n  shopping_order_history     shopping_order_history[]\n  shopping_seller_orders     shopping_seller_orders[]\n  shopping_payments          shopping_payments[]\n  shopping_shipping_tracking shopping_shipping_tracking[]\n\n  @@unique([order_code])\n  @@index([shopping_customer_id, created_at])\n  @@index([status, updated_at])\n}\n\n/// Order line items representing individual products in an order. Each item\n/// references a product variant and tracks quantity and price.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Order this item belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// Product variant being ordered. {@link shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n\n  /// Number of units ordered.\n  quantity Int @db.Integer\n\n  /// Price per unit at time of order.\n  unit_price Float @db.DoublePrecision\n\n  /// Total price for this line item (quantity × unit_price).\n  total_price Float @db.DoublePrecision\n\n  /// Timestamp when the order item was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the order item was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  order          shopping_orders           @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_order_id, created_at])\n  @@index([shopping_product_variant_id, created_at])\n}\n\n/// Order status tracking table. Records all status changes for an order with\n/// timestamps.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_status {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Order this status belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// Order status at this point in time.\n  status String\n\n  /// Timestamp when this status was set.\n  changed_at DateTime @db.Timestamptz\n\n  /// User or system that changed the status.\n  changed_by String?\n\n  /// Additional notes about the status change.\n  notes String?\n\n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_order_id, changed_at])\n  @@index([status, changed_at])\n}\n\n/// Historical record of all order changes. Captures snapshots of order\n/// states for audit trails and change tracking.\n///\n/// @namespace Orders\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_order_history {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Order this history record belongs to. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// Action performed on the order (e.g., created, updated, cancelled).\n  action String\n\n  /// Timestamp when this action occurred.\n  changed_at DateTime @db.Timestamptz\n\n  /// User or system that performed the action.\n  changed_by String?\n\n  /// JSON object containing order state at time of action.\n  details String?\n\n  //----\n  // RELATIONS\n  //----\n  order shopping_orders @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_order_id, changed_at])\n  @@index([action, changed_at])\n}\n","schema-05-carts.prisma":"/// Represents a customer's shopping cart containing items they intend to\n/// purchase. Each cart belongs to a specific customer and can contain\n/// multiple cart items. This is a primary business entity that users manage\n/// independently through their shopping experience.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shopping_carts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Customer who owns this shopping cart. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n\n  /// Timestamp when the shopping cart was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the shopping cart was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n\n  shopping_cart_items shopping_cart_items[]\n\n  @@unique([shopping_customer_id])\n  @@index([created_at])\n}\n\n/// Represents individual items in a shopping cart. Each item references a\n/// specific product variant and belongs to a specific shopping cart. This is\n/// a subsidiary entity managed through the parent shopping cart.\n///\n/// @namespace Carts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_cart_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Shopping cart that contains this item. {@link shopping_shopping_carts.id}.\n  shopping_shopping_cart_id String @db.Uuid\n\n  /// Product variant referenced by this cart item. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n\n  /// Quantity of this product variant in the cart.\n  quantity Int @db.Integer\n\n  /// Price of the product variant at the time it was added to the cart.\n  price Float @db.DoublePrecision\n\n  /// Timestamp when the cart item was added.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the cart item was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  cart           shopping_shopping_carts   @relation(fields: [shopping_shopping_cart_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_shopping_cart_id, shopping_product_variant_id], map: \"shopping_cart_items_shopping_shopping_cart_id_shopping_127c34ce\")\n  @@index([shopping_product_variant_id, created_at])\n}\n","schema-06-reviews.prisma":"/// Tracks moderation actions taken on product reviews. This table records\n/// each moderation event, including the administrator who performed the\n/// action, the type of action, reason, and timestamp. It supports the review\n/// approval workflow and audit trail.\n///\n/// @namespace Reviews\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_review_moderation {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The review being moderated. {@link shopping_product_reviews.id}.\n  shopping_product_review_id String @db.Uuid\n\n  /// The administrator who performed the moderation action. {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String @db.Uuid\n\n  /// Type of moderation action (approve, reject, flag).\n  action_type String\n\n  /// Reason for the moderation action.\n  reason String?\n\n  /// When the moderation action was performed.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  review        shopping_product_reviews @relation(fields: [shopping_product_review_id], references: [id], onDelete: Cascade)\n  administrator shopping_administrators  @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_product_review_id, created_at], map: \"shopping_review_moderation_shopping_product_review_id__cee1f633\")\n  @@index([shopping_administrator_id, created_at], map: \"shopping_review_moderation_shopping_administrator_id_c_756759fb\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Stores detailed rating breakdowns for product reviews. This table\n/// captures individual rating dimensions (quality, value, etc.) that\n/// contribute to the overall rating. It allows for granular analysis of\n/// review ratings across different aspects.\n///\n/// @namespace Reviews\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_review_ratings {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The review this rating belongs to. {@link shopping_product_reviews.id}.\n  shopping_product_review_id String @db.Uuid\n\n  /// Rating for product quality (1-5).\n  quality_rating Int @db.Integer\n\n  /// Rating for product value (1-5).\n  value_rating Int @db.Integer\n\n  /// Rating for service experience (1-5).\n  service_rating Int @db.Integer\n\n  /// When the rating was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  review shopping_product_reviews @relation(fields: [shopping_product_review_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_product_review_id])\n  @@index([shopping_product_review_id, created_at], map: \"shopping_review_ratings_shopping_product_review_id_cre_096320ab\")\n}\n","schema-07-sellers.prisma":"/// Products managed by sellers, including product details and\n/// seller-specific information. This table represents the products that\n/// sellers offer on the platform, with a relationship to the main products\n/// table.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_products {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the seller who owns this product. {@link\n  /// shopping_sellers.id}.\n  shopping_seller_id String @db.Uuid\n\n  /// Reference to the main product in the catalog. {@link\n  /// shopping_products.id}.\n  shopping_product_id String @db.Uuid\n\n  /// Seller-specific product code for internal management.\n  seller_product_code String\n\n  /// Seller's price for the product.\n  price Float @db.DoublePrecision\n\n  /// Current available quantity for this product.\n  quantity_available Int @db.Integer\n\n  /// Status of the product (e.g., active, draft, archived).\n  status String\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  /// Timestamp when the seller product was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller product was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller product was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  seller  shopping_sellers  @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)\n  product shopping_products @relation(fields: [shopping_product_id], references: [id], onDelete: Cascade)\n\n  shopping_seller_inventory shopping_seller_inventory[]\n\n  @@unique([shopping_seller_id, seller_product_code], map: \"shopping_seller_products_shopping_seller_id_seller_pro_4cbbccb3\")\n  @@index([shopping_product_id])\n  @@index([created_at])\n  @@index([status])\n  @@index([seller_product_code(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Inventory tracking for seller products, including stock levels and\n/// management details. This table represents the inventory information that\n/// sellers manage for their products.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_inventory {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the seller product. {@link shopping_seller_products.id}.\n  shopping_seller_product_id String @db.Uuid\n\n  /// Reference to the specific product variant. {@link\n  /// shopping_product_variants.id}.\n  shopping_product_variant_id String @db.Uuid\n\n  /// Current stock quantity for this inventory item.\n  stock_quantity Int @db.Integer\n\n  /// Threshold for low stock alerts.\n  low_stock_threshold Int? @db.Integer\n\n  /// Status of the inventory item (e.g., in_stock, low_stock, out_of_stock).\n  status String\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  /// Timestamp when the inventory record was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the inventory record was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the inventory record was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  sellerProduct  shopping_seller_products  @relation(fields: [shopping_seller_product_id], references: [id], onDelete: Cascade)\n  productVariant shopping_product_variants @relation(fields: [shopping_product_variant_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_seller_product_id, shopping_product_variant_id], map: \"shopping_seller_inventory_shopping_seller_product_id_s_22ae8a5d\")\n  @@index([shopping_product_variant_id])\n  @@index([created_at])\n  @@index([status])\n}\n\n/// Orders managed by sellers, including order details and seller-specific\n/// information. This table represents the orders that sellers need to\n/// fulfill and manage.\n///\n/// @namespace Sellers\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_seller_orders {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the seller who owns this order. {@link shopping_sellers.id}.\n  shopping_seller_id String @db.Uuid\n\n  /// Reference to the main order. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// Seller-specific order code for internal management.\n  seller_order_code String\n\n  /// Current fulfillment status of the order (e.g., pending, processing,\n  /// shipped, delivered).\n  fulfillment_status String\n\n  /// Business-specific status for workflow management.\n  business_status String?\n\n  /// Timestamp when the seller order was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller order was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the seller order was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  seller shopping_sellers @relation(fields: [shopping_seller_id], references: [id], onDelete: Cascade)\n  order  shopping_orders  @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  @@unique([shopping_seller_id, seller_order_code])\n  @@index([shopping_order_id])\n  @@index([created_at])\n  @@index([fulfillment_status])\n  @@index([seller_order_code(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-08-admin.prisma":"/// Records of actions performed by administrators. Tracks all administrative\n/// activities for audit and accountability purposes. Each action is linked\n/// to a specific administrator.\n///\n/// @namespace Admin\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_admin_actions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Administrator who performed the action. {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String @db.Uuid\n\n  /// Type of action performed (e.g., 'user_management', 'product_approval',\n  /// 'order_update').\n  action_type String\n\n  /// Detailed description of the action performed.\n  description String\n\n  /// Timestamp when the action was performed.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  administrator shopping_administrators @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_administrator_id, created_at])\n}\n\n/// System logs recording important events and changes. Tracks system-level\n/// events that may be initiated by administrators or system processes.\n///\n/// @namespace Admin\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_admin_logs {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Administrator associated with the log entry (if applicable). {@link\n  /// shopping_administrators.id}.\n  shopping_administrator_id String? @db.Uuid\n\n  /// Type of log entry (e.g., 'system_event', 'security_event', 'data_change').\n  log_type String\n\n  /// Detailed log message describing the event.\n  message String\n\n  /// Timestamp when the log entry was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  administrator shopping_administrators? @relation(fields: [shopping_administrator_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_administrator_id, created_at])\n}\n","schema-09-payments.prisma":"/// Payment records for all transactions in the shopping mall platform. This\n/// table stores information about each payment made by customers, including\n/// payment method, amount, status, and related order information. It serves\n/// as the central record for all financial transactions in the system.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Customer who made the payment. {@link shopping_customers.id}.\n  shopping_customer_id String @db.Uuid\n\n  /// Order associated with this payment. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// Payment method used for this transaction. {@link\n  /// shopping_payment_methods.id}.\n  payment_method_id String @db.Uuid\n\n  /// Total amount paid in this transaction.\n  amount Float @db.DoublePrecision\n\n  /// Currency used for the payment (e.g., USD, EUR).\n  currency String\n\n  /// Current status of the payment (e.g., pending, completed, failed,\n  /// refunded).\n  status String\n\n  /// External transaction ID from payment gateway.\n  transaction_id String?\n\n  /// Date and time when the payment was processed.\n  payment_date DateTime @db.Timestamptz\n\n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  customer shopping_customers @relation(fields: [shopping_customer_id], references: [id], onDelete: Cascade)\n  order    shopping_orders    @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n\n  shopping_payment_transactions shopping_payment_transactions[]\n\n  @@unique([transaction_id])\n  @@index([shopping_customer_id, created_at])\n  @@index([shopping_order_id, created_at])\n  @@index([payment_date])\n}\n\n/// Available payment methods in the shopping mall platform. This table\n/// defines all supported payment methods that customers can use to make\n/// purchases, including credit cards, digital wallets, bank transfers, etc.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payment_methods {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Name of the payment method (e.g., Credit Card, PayPal, Apple Pay).\n  method_name String\n\n  /// Type of payment method (e.g., card, digital_wallet, bank_transfer).\n  method_type String\n\n  /// Payment provider name (e.g., Stripe, PayPal, Visa).\n  provider String?\n\n  /// Whether this payment method is currently active and available.\n  is_active Boolean\n\n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([method_name])\n  @@index([method_type])\n  @@index([provider])\n}\n\n/// Detailed records of individual payment transactions. This table captures\n/// all the detailed information about each payment transaction, including\n/// authorization, capture, refund, and chargeback information.\n///\n/// @namespace Payments\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_payment_transactions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Payment record this transaction belongs to. {@link shopping_payments.id}.\n  shopping_payment_id String @db.Uuid\n\n  /// Type of transaction (e.g., authorization, capture, refund, chargeback).\n  transaction_type String\n\n  /// Amount involved in this transaction.\n  amount Float @db.DoublePrecision\n\n  /// Currency used for this transaction.\n  currency String\n\n  /// Current status of this transaction.\n  status String\n\n  /// Raw response from payment gateway.\n  gateway_response String?\n\n  /// Date and time when this transaction occurred.\n  transaction_date DateTime @db.Timestamptz\n\n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Record last update timestamp.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft delete timestamp.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  payment shopping_payments @relation(fields: [shopping_payment_id], references: [id], onDelete: Cascade)\n\n  @@index([shopping_payment_id, transaction_date], map: \"shopping_payment_transactions_shopping_payment_id_tran_6c883fbd\")\n  @@index([transaction_type, status])\n}\n","schema-10-shipping.prisma":"/// Shipping methods available for order fulfillment. Contains information\n/// about different shipping options, their costs, and delivery time\n/// estimates.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_methods {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Name of the shipping method (e.g., Standard, Express, Overnight).\n  name String\n\n  /// Detailed description of the shipping method.\n  description String?\n\n  /// Base cost of the shipping method.\n  cost Float @db.DoublePrecision\n\n  /// Estimated number of days for delivery.\n  estimated_delivery_days Int @db.Integer\n\n  /// Timestamp when the shipping method was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the shipping method was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_shipping_tracking shopping_shipping_tracking[]\n\n  @@unique([name])\n  @@index([created_at])\n}\n\n/// Shipping carriers that handle order deliveries. Contains information\n/// about different shipping companies and their services.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_carriers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Name of the shipping carrier (e.g., UPS, FedEx, DHL).\n  name String\n\n  /// Detailed description of the shipping carrier.\n  description String?\n\n  /// URL template for tracking shipments with this carrier.\n  tracking_url_template String?\n\n  /// Timestamp when the shipping carrier was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the shipping carrier was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  shopping_shipping_tracking shopping_shipping_tracking[]\n\n  @@unique([name])\n  @@index([created_at])\n}\n\n/// Tracking information for shipped orders. Contains details about shipment\n/// status, tracking numbers, and carrier information.\n///\n/// @namespace Shipping\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel shopping_shipping_tracking {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The order being tracked. {@link shopping_orders.id}.\n  shopping_order_id String @db.Uuid\n\n  /// The carrier handling the shipment. {@link shopping_shipping_carriers.id}.\n  shopping_shipping_carrier_id String @db.Uuid\n\n  /// The shipping method used for this shipment. {@link\n  /// shopping_shipping_methods.id}.\n  shopping_shipping_method_id String @db.Uuid\n\n  /// Tracking number provided by the carrier.\n  tracking_number String\n\n  /// Current status of the shipment (e.g., Processing, Shipped, Delivered).\n  status String\n\n  /// Estimated delivery date for the shipment.\n  estimated_delivery_date DateTime? @db.Timestamptz\n\n  /// Actual delivery date when the shipment was delivered.\n  actual_delivery_date DateTime? @db.Timestamptz\n\n  /// Timestamp when the tracking information was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the tracking information was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  order   shopping_orders            @relation(fields: [shopping_order_id], references: [id], onDelete: Cascade)\n  carrier shopping_shipping_carriers @relation(fields: [shopping_shipping_carrier_id], references: [id], onDelete: Cascade)\n  method  shopping_shipping_methods  @relation(fields: [shopping_shipping_method_id], references: [id], onDelete: Cascade)\n\n  @@unique([tracking_number])\n  @@index([shopping_order_id])\n  @@index([shopping_shipping_carrier_id])\n  @@index([shopping_shipping_method_id])\n  @@index([created_at])\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model shopping_channels\n * Represents the channels through which products are sold in the shopping\n * mall platform. Each channel can have multiple sections and categories,\n * forming the foundation of the platform's organizational structure.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_channels = $Result.DefaultSelection<Prisma.$shopping_channelsPayload>\n/**\n * Model shopping_sections\n * Represents the sections within shopping channels. Each section belongs to\n * a specific channel and can contain multiple categories.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sections = $Result.DefaultSelection<Prisma.$shopping_sectionsPayload>\n/**\n * Model shopping_channel_categories\n * Represents the categories within shopping channel sections. Each category\n * belongs to a specific section and channel, forming the hierarchical\n * structure of the platform's product organization.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_channel_categories = $Result.DefaultSelection<Prisma.$shopping_channel_categoriesPayload>\n/**\n * Model shopping_customers\n * Customer information, but not a person but a **connection** basis. This\n * is the main entity for customer identity management. Contains\n * authentication credentials and basic profile information.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_customers = $Result.DefaultSelection<Prisma.$shopping_customersPayload>\n/**\n * Model shopping_sellers\n * Seller information for marketplace vendors. Contains authentication\n * credentials and business profile information.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_sellers = $Result.DefaultSelection<Prisma.$shopping_sellersPayload>\n/**\n * Model shopping_administrators\n * Administrator information for platform management. Contains\n * authentication credentials and admin profile information.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_administrators = $Result.DefaultSelection<Prisma.$shopping_administratorsPayload>\n/**\n * Model shopping_products\n * Core product information for the e-commerce platform. Contains all\n * essential details about products including name, description, pricing,\n * and categorization. Serves as the primary entity for product management\n * and is referenced by variants, inventory, and reviews.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_products = $Result.DefaultSelection<Prisma.$shopping_productsPayload>\n/**\n * Model shopping_product_variants\n * Product variants representing different options (colors, sizes,\n * materials) for products. Each variant has its own SKU and inventory\n * tracking. References the main product and contains variant-specific\n * details.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_product_variants = $Result.DefaultSelection<Prisma.$shopping_product_variantsPayload>\n/**\n * Model shopping_categories\n * Product categorization hierarchy for organizing products. Categories can\n * have parent-child relationships to create a hierarchical structure.\n * Products are assigned to categories for better organization and\n * filtering.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_categories = $Result.DefaultSelection<Prisma.$shopping_categoriesPayload>\n/**\n * Model shopping_inventory\n * Inventory tracking for product variants. Monitors stock levels,\n * reservations, and availability status for each product variant. Critical\n * for order fulfillment and stock management.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_inventory = $Result.DefaultSelection<Prisma.$shopping_inventoryPayload>\n/**\n * Model shopping_product_reviews\n * Customer reviews for products. Contains rating, text, and metadata about\n * customer feedback on products. Critical for building trust and providing\n * social proof.\n * \n * @namespace Sales\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_product_reviews = $Result.DefaultSelection<Prisma.$shopping_product_reviewsPayload>\n/**\n * Model shopping_orders\n * Main order table containing all order information. Represents customer\n * orders with status tracking and payment information. This is the primary\n * entity for order management.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_orders = $Result.DefaultSelection<Prisma.$shopping_ordersPayload>\n/**\n * Model shopping_order_items\n * Order line items representing individual products in an order. Each item\n * references a product variant and tracks quantity and price.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_order_items = $Result.DefaultSelection<Prisma.$shopping_order_itemsPayload>\n/**\n * Model shopping_order_status\n * Order status tracking table. Records all status changes for an order with\n * timestamps.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_order_status = $Result.DefaultSelection<Prisma.$shopping_order_statusPayload>\n/**\n * Model shopping_order_history\n * Historical record of all order changes. Captures snapshots of order\n * states for audit trails and change tracking.\n * \n * @namespace Orders\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_order_history = $Result.DefaultSelection<Prisma.$shopping_order_historyPayload>\n/**\n * Model shopping_shopping_carts\n * Represents a customer's shopping cart containing items they intend to\n * purchase. Each cart belongs to a specific customer and can contain\n * multiple cart items. This is a primary business entity that users manage\n * independently through their shopping experience.\n * \n * @namespace Carts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_shopping_carts = $Result.DefaultSelection<Prisma.$shopping_shopping_cartsPayload>\n/**\n * Model shopping_cart_items\n * Represents individual items in a shopping cart. Each item references a\n * specific product variant and belongs to a specific shopping cart. This is\n * a subsidiary entity managed through the parent shopping cart.\n * \n * @namespace Carts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_cart_items = $Result.DefaultSelection<Prisma.$shopping_cart_itemsPayload>\n/**\n * Model shopping_review_moderation\n * Tracks moderation actions taken on product reviews. This table records\n * each moderation event, including the administrator who performed the\n * action, the type of action, reason, and timestamp. It supports the review\n * approval workflow and audit trail.\n * \n * @namespace Reviews\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_review_moderation = $Result.DefaultSelection<Prisma.$shopping_review_moderationPayload>\n/**\n * Model shopping_review_ratings\n * Stores detailed rating breakdowns for product reviews. This table\n * captures individual rating dimensions (quality, value, etc.) that\n * contribute to the overall rating. It allows for granular analysis of\n * review ratings across different aspects.\n * \n * @namespace Reviews\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_review_ratings = $Result.DefaultSelection<Prisma.$shopping_review_ratingsPayload>\n/**\n * Model shopping_seller_products\n * Products managed by sellers, including product details and\n * seller-specific information. This table represents the products that\n * sellers offer on the platform, with a relationship to the main products\n * table.\n * \n * @namespace Sellers\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_seller_products = $Result.DefaultSelection<Prisma.$shopping_seller_productsPayload>\n/**\n * Model shopping_seller_inventory\n * Inventory tracking for seller products, including stock levels and\n * management details. This table represents the inventory information that\n * sellers manage for their products.\n * \n * @namespace Sellers\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_seller_inventory = $Result.DefaultSelection<Prisma.$shopping_seller_inventoryPayload>\n/**\n * Model shopping_seller_orders\n * Orders managed by sellers, including order details and seller-specific\n * information. This table represents the orders that sellers need to\n * fulfill and manage.\n * \n * @namespace Sellers\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_seller_orders = $Result.DefaultSelection<Prisma.$shopping_seller_ordersPayload>\n/**\n * Model shopping_admin_actions\n * Records of actions performed by administrators. Tracks all administrative\n * activities for audit and accountability purposes. Each action is linked\n * to a specific administrator.\n * \n * @namespace Admin\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_admin_actions = $Result.DefaultSelection<Prisma.$shopping_admin_actionsPayload>\n/**\n * Model shopping_admin_logs\n * System logs recording important events and changes. Tracks system-level\n * events that may be initiated by administrators or system processes.\n * \n * @namespace Admin\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_admin_logs = $Result.DefaultSelection<Prisma.$shopping_admin_logsPayload>\n/**\n * Model shopping_payments\n * Payment records for all transactions in the shopping mall platform. This\n * table stores information about each payment made by customers, including\n * payment method, amount, status, and related order information. It serves\n * as the central record for all financial transactions in the system.\n * \n * @namespace Payments\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_payments = $Result.DefaultSelection<Prisma.$shopping_paymentsPayload>\n/**\n * Model shopping_payment_methods\n * Available payment methods in the shopping mall platform. This table\n * defines all supported payment methods that customers can use to make\n * purchases, including credit cards, digital wallets, bank transfers, etc.\n * \n * @namespace Payments\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_payment_methods = $Result.DefaultSelection<Prisma.$shopping_payment_methodsPayload>\n/**\n * Model shopping_payment_transactions\n * Detailed records of individual payment transactions. This table captures\n * all the detailed information about each payment transaction, including\n * authorization, capture, refund, and chargeback information.\n * \n * @namespace Payments\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_payment_transactions = $Result.DefaultSelection<Prisma.$shopping_payment_transactionsPayload>\n/**\n * Model shopping_shipping_methods\n * Shipping methods available for order fulfillment. Contains information\n * about different shipping options, their costs, and delivery time\n * estimates.\n * \n * @namespace Shipping\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_shipping_methods = $Result.DefaultSelection<Prisma.$shopping_shipping_methodsPayload>\n/**\n * Model shopping_shipping_carriers\n * Shipping carriers that handle order deliveries. Contains information\n * about different shipping companies and their services.\n * \n * @namespace Shipping\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_shipping_carriers = $Result.DefaultSelection<Prisma.$shopping_shipping_carriersPayload>\n/**\n * Model shopping_shipping_tracking\n * Tracking information for shipped orders. Contains details about shipment\n * status, tracking numbers, and carrier information.\n * \n * @namespace Shipping\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type shopping_shipping_tracking = $Result.DefaultSelection<Prisma.$shopping_shipping_trackingPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Shopping_channels\n * const shopping_channels = await prisma.shopping_channels.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Shopping_channels\n   * const shopping_channels = await prisma.shopping_channels.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.shopping_channels`: Exposes CRUD operations for the **shopping_channels** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_channels\n    * const shopping_channels = await prisma.shopping_channels.findMany()\n    * ```\n    */\n  get shopping_channels(): Prisma.shopping_channelsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sections`: Exposes CRUD operations for the **shopping_sections** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sections\n    * const shopping_sections = await prisma.shopping_sections.findMany()\n    * ```\n    */\n  get shopping_sections(): Prisma.shopping_sectionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_channel_categories`: Exposes CRUD operations for the **shopping_channel_categories** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_channel_categories\n    * const shopping_channel_categories = await prisma.shopping_channel_categories.findMany()\n    * ```\n    */\n  get shopping_channel_categories(): Prisma.shopping_channel_categoriesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_customers`: Exposes CRUD operations for the **shopping_customers** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_customers\n    * const shopping_customers = await prisma.shopping_customers.findMany()\n    * ```\n    */\n  get shopping_customers(): Prisma.shopping_customersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_sellers`: Exposes CRUD operations for the **shopping_sellers** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_sellers\n    * const shopping_sellers = await prisma.shopping_sellers.findMany()\n    * ```\n    */\n  get shopping_sellers(): Prisma.shopping_sellersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_administrators`: Exposes CRUD operations for the **shopping_administrators** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_administrators\n    * const shopping_administrators = await prisma.shopping_administrators.findMany()\n    * ```\n    */\n  get shopping_administrators(): Prisma.shopping_administratorsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_products`: Exposes CRUD operations for the **shopping_products** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_products\n    * const shopping_products = await prisma.shopping_products.findMany()\n    * ```\n    */\n  get shopping_products(): Prisma.shopping_productsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_product_variants`: Exposes CRUD operations for the **shopping_product_variants** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_product_variants\n    * const shopping_product_variants = await prisma.shopping_product_variants.findMany()\n    * ```\n    */\n  get shopping_product_variants(): Prisma.shopping_product_variantsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_categories`: Exposes CRUD operations for the **shopping_categories** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_categories\n    * const shopping_categories = await prisma.shopping_categories.findMany()\n    * ```\n    */\n  get shopping_categories(): Prisma.shopping_categoriesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_inventory`: Exposes CRUD operations for the **shopping_inventory** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_inventories\n    * const shopping_inventories = await prisma.shopping_inventory.findMany()\n    * ```\n    */\n  get shopping_inventory(): Prisma.shopping_inventoryDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_product_reviews`: Exposes CRUD operations for the **shopping_product_reviews** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_product_reviews\n    * const shopping_product_reviews = await prisma.shopping_product_reviews.findMany()\n    * ```\n    */\n  get shopping_product_reviews(): Prisma.shopping_product_reviewsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_orders`: Exposes CRUD operations for the **shopping_orders** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_orders\n    * const shopping_orders = await prisma.shopping_orders.findMany()\n    * ```\n    */\n  get shopping_orders(): Prisma.shopping_ordersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_order_items`: Exposes CRUD operations for the **shopping_order_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_order_items\n    * const shopping_order_items = await prisma.shopping_order_items.findMany()\n    * ```\n    */\n  get shopping_order_items(): Prisma.shopping_order_itemsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_order_status`: Exposes CRUD operations for the **shopping_order_status** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_order_statuses\n    * const shopping_order_statuses = await prisma.shopping_order_status.findMany()\n    * ```\n    */\n  get shopping_order_status(): Prisma.shopping_order_statusDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_order_history`: Exposes CRUD operations for the **shopping_order_history** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_order_histories\n    * const shopping_order_histories = await prisma.shopping_order_history.findMany()\n    * ```\n    */\n  get shopping_order_history(): Prisma.shopping_order_historyDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_shopping_carts`: Exposes CRUD operations for the **shopping_shopping_carts** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_shopping_carts\n    * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findMany()\n    * ```\n    */\n  get shopping_shopping_carts(): Prisma.shopping_shopping_cartsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_cart_items`: Exposes CRUD operations for the **shopping_cart_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_cart_items\n    * const shopping_cart_items = await prisma.shopping_cart_items.findMany()\n    * ```\n    */\n  get shopping_cart_items(): Prisma.shopping_cart_itemsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_review_moderation`: Exposes CRUD operations for the **shopping_review_moderation** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_review_moderations\n    * const shopping_review_moderations = await prisma.shopping_review_moderation.findMany()\n    * ```\n    */\n  get shopping_review_moderation(): Prisma.shopping_review_moderationDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_review_ratings`: Exposes CRUD operations for the **shopping_review_ratings** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_review_ratings\n    * const shopping_review_ratings = await prisma.shopping_review_ratings.findMany()\n    * ```\n    */\n  get shopping_review_ratings(): Prisma.shopping_review_ratingsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_seller_products`: Exposes CRUD operations for the **shopping_seller_products** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_seller_products\n    * const shopping_seller_products = await prisma.shopping_seller_products.findMany()\n    * ```\n    */\n  get shopping_seller_products(): Prisma.shopping_seller_productsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_seller_inventory`: Exposes CRUD operations for the **shopping_seller_inventory** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_seller_inventories\n    * const shopping_seller_inventories = await prisma.shopping_seller_inventory.findMany()\n    * ```\n    */\n  get shopping_seller_inventory(): Prisma.shopping_seller_inventoryDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_seller_orders`: Exposes CRUD operations for the **shopping_seller_orders** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_seller_orders\n    * const shopping_seller_orders = await prisma.shopping_seller_orders.findMany()\n    * ```\n    */\n  get shopping_seller_orders(): Prisma.shopping_seller_ordersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_admin_actions`: Exposes CRUD operations for the **shopping_admin_actions** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_admin_actions\n    * const shopping_admin_actions = await prisma.shopping_admin_actions.findMany()\n    * ```\n    */\n  get shopping_admin_actions(): Prisma.shopping_admin_actionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_admin_logs`: Exposes CRUD operations for the **shopping_admin_logs** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_admin_logs\n    * const shopping_admin_logs = await prisma.shopping_admin_logs.findMany()\n    * ```\n    */\n  get shopping_admin_logs(): Prisma.shopping_admin_logsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_payments`: Exposes CRUD operations for the **shopping_payments** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_payments\n    * const shopping_payments = await prisma.shopping_payments.findMany()\n    * ```\n    */\n  get shopping_payments(): Prisma.shopping_paymentsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_payment_methods`: Exposes CRUD operations for the **shopping_payment_methods** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_payment_methods\n    * const shopping_payment_methods = await prisma.shopping_payment_methods.findMany()\n    * ```\n    */\n  get shopping_payment_methods(): Prisma.shopping_payment_methodsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_payment_transactions`: Exposes CRUD operations for the **shopping_payment_transactions** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_payment_transactions\n    * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findMany()\n    * ```\n    */\n  get shopping_payment_transactions(): Prisma.shopping_payment_transactionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_shipping_methods`: Exposes CRUD operations for the **shopping_shipping_methods** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_shipping_methods\n    * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findMany()\n    * ```\n    */\n  get shopping_shipping_methods(): Prisma.shopping_shipping_methodsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_shipping_carriers`: Exposes CRUD operations for the **shopping_shipping_carriers** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_shipping_carriers\n    * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findMany()\n    * ```\n    */\n  get shopping_shipping_carriers(): Prisma.shopping_shipping_carriersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.shopping_shipping_tracking`: Exposes CRUD operations for the **shopping_shipping_tracking** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Shopping_shipping_trackings\n    * const shopping_shipping_trackings = await prisma.shopping_shipping_tracking.findMany()\n    * ```\n    */\n  get shopping_shipping_tracking(): Prisma.shopping_shipping_trackingDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    shopping_channels: 'shopping_channels',\n    shopping_sections: 'shopping_sections',\n    shopping_channel_categories: 'shopping_channel_categories',\n    shopping_customers: 'shopping_customers',\n    shopping_sellers: 'shopping_sellers',\n    shopping_administrators: 'shopping_administrators',\n    shopping_products: 'shopping_products',\n    shopping_product_variants: 'shopping_product_variants',\n    shopping_categories: 'shopping_categories',\n    shopping_inventory: 'shopping_inventory',\n    shopping_product_reviews: 'shopping_product_reviews',\n    shopping_orders: 'shopping_orders',\n    shopping_order_items: 'shopping_order_items',\n    shopping_order_status: 'shopping_order_status',\n    shopping_order_history: 'shopping_order_history',\n    shopping_shopping_carts: 'shopping_shopping_carts',\n    shopping_cart_items: 'shopping_cart_items',\n    shopping_review_moderation: 'shopping_review_moderation',\n    shopping_review_ratings: 'shopping_review_ratings',\n    shopping_seller_products: 'shopping_seller_products',\n    shopping_seller_inventory: 'shopping_seller_inventory',\n    shopping_seller_orders: 'shopping_seller_orders',\n    shopping_admin_actions: 'shopping_admin_actions',\n    shopping_admin_logs: 'shopping_admin_logs',\n    shopping_payments: 'shopping_payments',\n    shopping_payment_methods: 'shopping_payment_methods',\n    shopping_payment_transactions: 'shopping_payment_transactions',\n    shopping_shipping_methods: 'shopping_shipping_methods',\n    shopping_shipping_carriers: 'shopping_shipping_carriers',\n    shopping_shipping_tracking: 'shopping_shipping_tracking'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"shopping_channels\" | \"shopping_sections\" | \"shopping_channel_categories\" | \"shopping_customers\" | \"shopping_sellers\" | \"shopping_administrators\" | \"shopping_products\" | \"shopping_product_variants\" | \"shopping_categories\" | \"shopping_inventory\" | \"shopping_product_reviews\" | \"shopping_orders\" | \"shopping_order_items\" | \"shopping_order_status\" | \"shopping_order_history\" | \"shopping_shopping_carts\" | \"shopping_cart_items\" | \"shopping_review_moderation\" | \"shopping_review_ratings\" | \"shopping_seller_products\" | \"shopping_seller_inventory\" | \"shopping_seller_orders\" | \"shopping_admin_actions\" | \"shopping_admin_logs\" | \"shopping_payments\" | \"shopping_payment_methods\" | \"shopping_payment_transactions\" | \"shopping_shipping_methods\" | \"shopping_shipping_carriers\" | \"shopping_shipping_tracking\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      shopping_channels: {\n        payload: Prisma.$shopping_channelsPayload<ExtArgs>\n        fields: Prisma.shopping_channelsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_channelsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_channelsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_channelsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_channelsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_channelsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_channelsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_channelsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_channelsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_channelsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          update: {\n            args: Prisma.shopping_channelsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_channelsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_channelsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_channelsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_channelsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channelsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_channelsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_channels>\n          }\n          groupBy: {\n            args: Prisma.shopping_channelsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channelsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_channelsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channelsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sections: {\n        payload: Prisma.$shopping_sectionsPayload<ExtArgs>\n        fields: Prisma.shopping_sectionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sectionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sectionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sectionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sectionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sectionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sectionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sectionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sectionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sectionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_sectionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sectionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sectionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sectionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sectionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sectionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sectionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sections>\n          }\n          groupBy: {\n            args: Prisma.shopping_sectionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sectionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sectionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sectionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_channel_categories: {\n        payload: Prisma.$shopping_channel_categoriesPayload<ExtArgs>\n        fields: Prisma.shopping_channel_categoriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_channel_categoriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_channel_categoriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_channel_categoriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_channel_categoriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_channel_categoriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_channel_categoriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_channel_categoriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_channel_categoriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_channel_categoriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          update: {\n            args: Prisma.shopping_channel_categoriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_channel_categoriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_channel_categoriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_channel_categoriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_channel_categoriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_channel_categoriesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_channel_categoriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_channel_categories>\n          }\n          groupBy: {\n            args: Prisma.shopping_channel_categoriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channel_categoriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_channel_categoriesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_channel_categoriesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_customers: {\n        payload: Prisma.$shopping_customersPayload<ExtArgs>\n        fields: Prisma.shopping_customersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_customersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_customersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_customersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_customersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_customersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_customersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_customersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_customersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_customersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          update: {\n            args: Prisma.shopping_customersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_customersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_customersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_customersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_customersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_customersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_customersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_customers>\n          }\n          groupBy: {\n            args: Prisma.shopping_customersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_customersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_customersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_customersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_sellers: {\n        payload: Prisma.$shopping_sellersPayload<ExtArgs>\n        fields: Prisma.shopping_sellersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_sellersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_sellersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_sellersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_sellersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_sellersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_sellersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_sellersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_sellersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_sellersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          update: {\n            args: Prisma.shopping_sellersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_sellersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_sellersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_sellersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_sellersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_sellersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_sellersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_sellers>\n          }\n          groupBy: {\n            args: Prisma.shopping_sellersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sellersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_sellersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_sellersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_administrators: {\n        payload: Prisma.$shopping_administratorsPayload<ExtArgs>\n        fields: Prisma.shopping_administratorsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_administratorsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_administratorsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_administratorsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_administratorsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_administratorsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_administratorsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_administratorsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_administratorsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_administratorsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          update: {\n            args: Prisma.shopping_administratorsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_administratorsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_administratorsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_administratorsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_administratorsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_administratorsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_administratorsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_administrators>\n          }\n          groupBy: {\n            args: Prisma.shopping_administratorsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_administratorsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_administratorsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_administratorsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_products: {\n        payload: Prisma.$shopping_productsPayload<ExtArgs>\n        fields: Prisma.shopping_productsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_productsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_productsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_productsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_productsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_productsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_productsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_productsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_productsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_productsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          update: {\n            args: Prisma.shopping_productsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_productsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_productsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_productsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_productsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_productsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_productsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_products>\n          }\n          groupBy: {\n            args: Prisma.shopping_productsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_productsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_productsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_productsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_product_variants: {\n        payload: Prisma.$shopping_product_variantsPayload<ExtArgs>\n        fields: Prisma.shopping_product_variantsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_product_variantsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_product_variantsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_product_variantsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_product_variantsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_product_variantsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_product_variantsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_product_variantsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_product_variantsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_product_variantsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          update: {\n            args: Prisma.shopping_product_variantsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_product_variantsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_product_variantsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_product_variantsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_product_variantsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_variantsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_product_variantsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_product_variants>\n          }\n          groupBy: {\n            args: Prisma.shopping_product_variantsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_product_variantsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_product_variantsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_product_variantsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_categories: {\n        payload: Prisma.$shopping_categoriesPayload<ExtArgs>\n        fields: Prisma.shopping_categoriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_categoriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_categoriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_categoriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_categoriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_categoriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_categoriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_categoriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_categoriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_categoriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          update: {\n            args: Prisma.shopping_categoriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_categoriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_categoriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_categoriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_categoriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_categoriesPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_categoriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_categories>\n          }\n          groupBy: {\n            args: Prisma.shopping_categoriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_categoriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_categoriesCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_categoriesCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_inventory: {\n        payload: Prisma.$shopping_inventoryPayload<ExtArgs>\n        fields: Prisma.shopping_inventoryFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_inventoryFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_inventoryFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_inventoryFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_inventoryFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_inventoryFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_inventoryCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_inventoryCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_inventoryCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_inventoryDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          update: {\n            args: Prisma.shopping_inventoryUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_inventoryDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_inventoryUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_inventoryUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_inventoryUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_inventoryPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_inventoryAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_inventory>\n          }\n          groupBy: {\n            args: Prisma.shopping_inventoryGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inventoryGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_inventoryCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_inventoryCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_product_reviews: {\n        payload: Prisma.$shopping_product_reviewsPayload<ExtArgs>\n        fields: Prisma.shopping_product_reviewsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_product_reviewsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_product_reviewsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_product_reviewsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_product_reviewsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_product_reviewsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_product_reviewsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_product_reviewsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_product_reviewsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_product_reviewsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          update: {\n            args: Prisma.shopping_product_reviewsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_product_reviewsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_product_reviewsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_product_reviewsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_product_reviewsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_product_reviewsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_product_reviewsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_product_reviews>\n          }\n          groupBy: {\n            args: Prisma.shopping_product_reviewsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_product_reviewsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_product_reviewsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_product_reviewsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_orders: {\n        payload: Prisma.$shopping_ordersPayload<ExtArgs>\n        fields: Prisma.shopping_ordersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_ordersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_ordersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_ordersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_ordersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_ordersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_ordersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_ordersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_ordersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_ordersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          update: {\n            args: Prisma.shopping_ordersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_ordersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_ordersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_ordersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_ordersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_ordersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_ordersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_orders>\n          }\n          groupBy: {\n            args: Prisma.shopping_ordersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_ordersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_ordersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_ordersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_order_items: {\n        payload: Prisma.$shopping_order_itemsPayload<ExtArgs>\n        fields: Prisma.shopping_order_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_order_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_order_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_order_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_order_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_order_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_order_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_order_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_order_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          update: {\n            args: Prisma.shopping_order_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_order_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_order_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_order_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_order_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_order_items>\n          }\n          groupBy: {\n            args: Prisma.shopping_order_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_order_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_order_status: {\n        payload: Prisma.$shopping_order_statusPayload<ExtArgs>\n        fields: Prisma.shopping_order_statusFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_order_statusFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_order_statusFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_order_statusFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_order_statusFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_order_statusFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_order_statusCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_order_statusCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_order_statusCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_order_statusDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          update: {\n            args: Prisma.shopping_order_statusUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_order_statusDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_order_statusUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_order_statusUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_order_statusUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_statusPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_order_statusAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_order_status>\n          }\n          groupBy: {\n            args: Prisma.shopping_order_statusGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_statusGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_order_statusCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_statusCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_order_history: {\n        payload: Prisma.$shopping_order_historyPayload<ExtArgs>\n        fields: Prisma.shopping_order_historyFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_order_historyFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_order_historyFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_order_historyFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_order_historyFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_order_historyFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_order_historyCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_order_historyCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_order_historyCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_order_historyDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          update: {\n            args: Prisma.shopping_order_historyUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_order_historyDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_order_historyUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_order_historyUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_order_historyUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_order_historyPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_order_historyAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_order_history>\n          }\n          groupBy: {\n            args: Prisma.shopping_order_historyGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_historyGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_order_historyCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_order_historyCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_shopping_carts: {\n        payload: Prisma.$shopping_shopping_cartsPayload<ExtArgs>\n        fields: Prisma.shopping_shopping_cartsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_shopping_cartsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_shopping_cartsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_shopping_cartsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_shopping_cartsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_shopping_cartsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_shopping_cartsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_shopping_cartsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_shopping_cartsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_shopping_cartsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          update: {\n            args: Prisma.shopping_shopping_cartsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_shopping_cartsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_shopping_cartsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_shopping_cartsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_shopping_cartsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shopping_cartsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_shopping_cartsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_shopping_carts>\n          }\n          groupBy: {\n            args: Prisma.shopping_shopping_cartsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shopping_cartsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_shopping_cartsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shopping_cartsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_cart_items: {\n        payload: Prisma.$shopping_cart_itemsPayload<ExtArgs>\n        fields: Prisma.shopping_cart_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_cart_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_cart_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_cart_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_cart_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_cart_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_cart_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          update: {\n            args: Prisma.shopping_cart_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_cart_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_cart_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_cart_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_cart_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_cart_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_cart_items>\n          }\n          groupBy: {\n            args: Prisma.shopping_cart_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cart_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_cart_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_cart_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_review_moderation: {\n        payload: Prisma.$shopping_review_moderationPayload<ExtArgs>\n        fields: Prisma.shopping_review_moderationFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_review_moderationFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_review_moderationFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_review_moderationFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_review_moderationFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_review_moderationFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_review_moderationCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_review_moderationCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_review_moderationCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_review_moderationDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          update: {\n            args: Prisma.shopping_review_moderationUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_review_moderationDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_review_moderationUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_review_moderationUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_review_moderationUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_moderationPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_review_moderationAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_review_moderation>\n          }\n          groupBy: {\n            args: Prisma.shopping_review_moderationGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_review_moderationGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_review_moderationCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_review_moderationCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_review_ratings: {\n        payload: Prisma.$shopping_review_ratingsPayload<ExtArgs>\n        fields: Prisma.shopping_review_ratingsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_review_ratingsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_review_ratingsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_review_ratingsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_review_ratingsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_review_ratingsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_review_ratingsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_review_ratingsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_review_ratingsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_review_ratingsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          update: {\n            args: Prisma.shopping_review_ratingsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_review_ratingsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_review_ratingsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_review_ratingsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_review_ratingsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_review_ratingsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_review_ratingsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_review_ratings>\n          }\n          groupBy: {\n            args: Prisma.shopping_review_ratingsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_review_ratingsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_review_ratingsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_review_ratingsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_seller_products: {\n        payload: Prisma.$shopping_seller_productsPayload<ExtArgs>\n        fields: Prisma.shopping_seller_productsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_seller_productsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_seller_productsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_seller_productsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_seller_productsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_seller_productsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_seller_productsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_seller_productsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_seller_productsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_seller_productsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          update: {\n            args: Prisma.shopping_seller_productsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_seller_productsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_seller_productsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_seller_productsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_seller_productsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_productsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_seller_productsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_seller_products>\n          }\n          groupBy: {\n            args: Prisma.shopping_seller_productsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_productsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_seller_productsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_productsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_seller_inventory: {\n        payload: Prisma.$shopping_seller_inventoryPayload<ExtArgs>\n        fields: Prisma.shopping_seller_inventoryFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_seller_inventoryFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_seller_inventoryFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_seller_inventoryFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_seller_inventoryFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_seller_inventoryFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_seller_inventoryCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_seller_inventoryCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_seller_inventoryCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_seller_inventoryDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          update: {\n            args: Prisma.shopping_seller_inventoryUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_seller_inventoryDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_seller_inventoryUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_seller_inventoryUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_seller_inventoryUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_inventoryPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_seller_inventoryAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_seller_inventory>\n          }\n          groupBy: {\n            args: Prisma.shopping_seller_inventoryGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_inventoryGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_seller_inventoryCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_inventoryCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_seller_orders: {\n        payload: Prisma.$shopping_seller_ordersPayload<ExtArgs>\n        fields: Prisma.shopping_seller_ordersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_seller_ordersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_seller_ordersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_seller_ordersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_seller_ordersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_seller_ordersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_seller_ordersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_seller_ordersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_seller_ordersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_seller_ordersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          update: {\n            args: Prisma.shopping_seller_ordersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_seller_ordersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_seller_ordersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_seller_ordersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_seller_ordersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_seller_ordersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_seller_ordersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_seller_orders>\n          }\n          groupBy: {\n            args: Prisma.shopping_seller_ordersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_ordersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_seller_ordersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_seller_ordersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_admin_actions: {\n        payload: Prisma.$shopping_admin_actionsPayload<ExtArgs>\n        fields: Prisma.shopping_admin_actionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_admin_actionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_admin_actionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_admin_actionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_admin_actionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_admin_actionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_admin_actionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_admin_actionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_admin_actionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_admin_actionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_admin_actionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_admin_actionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_admin_actionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_admin_actionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_admin_actionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_actionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_admin_actionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_admin_actions>\n          }\n          groupBy: {\n            args: Prisma.shopping_admin_actionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_admin_actionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_admin_actionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_admin_actionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_admin_logs: {\n        payload: Prisma.$shopping_admin_logsPayload<ExtArgs>\n        fields: Prisma.shopping_admin_logsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_admin_logsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_admin_logsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_admin_logsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_admin_logsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_admin_logsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_admin_logsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_admin_logsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_admin_logsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_admin_logsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          update: {\n            args: Prisma.shopping_admin_logsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_admin_logsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_admin_logsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_admin_logsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_admin_logsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_admin_logsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_admin_logsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_admin_logs>\n          }\n          groupBy: {\n            args: Prisma.shopping_admin_logsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_admin_logsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_admin_logsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_admin_logsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_payments: {\n        payload: Prisma.$shopping_paymentsPayload<ExtArgs>\n        fields: Prisma.shopping_paymentsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_paymentsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_paymentsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_paymentsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_paymentsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_paymentsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_paymentsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_paymentsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_paymentsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_paymentsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          update: {\n            args: Prisma.shopping_paymentsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_paymentsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_paymentsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_paymentsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_paymentsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_paymentsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_paymentsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_payments>\n          }\n          groupBy: {\n            args: Prisma.shopping_paymentsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_paymentsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_paymentsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_paymentsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_payment_methods: {\n        payload: Prisma.$shopping_payment_methodsPayload<ExtArgs>\n        fields: Prisma.shopping_payment_methodsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_payment_methodsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_payment_methodsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_payment_methodsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_payment_methodsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_payment_methodsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_payment_methodsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_payment_methodsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_payment_methodsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_payment_methodsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          update: {\n            args: Prisma.shopping_payment_methodsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_payment_methodsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_payment_methodsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_payment_methodsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_payment_methodsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_methodsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_payment_methodsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_payment_methods>\n          }\n          groupBy: {\n            args: Prisma.shopping_payment_methodsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_payment_methodsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_payment_methodsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_payment_methodsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_payment_transactions: {\n        payload: Prisma.$shopping_payment_transactionsPayload<ExtArgs>\n        fields: Prisma.shopping_payment_transactionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_payment_transactionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_payment_transactionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_payment_transactionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_payment_transactionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_payment_transactionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_payment_transactionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_payment_transactionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_payment_transactionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_payment_transactionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          update: {\n            args: Prisma.shopping_payment_transactionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_payment_transactionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_payment_transactionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_payment_transactionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_payment_transactionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_payment_transactionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_payment_transactionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_payment_transactions>\n          }\n          groupBy: {\n            args: Prisma.shopping_payment_transactionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_payment_transactionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_payment_transactionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_payment_transactionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_shipping_methods: {\n        payload: Prisma.$shopping_shipping_methodsPayload<ExtArgs>\n        fields: Prisma.shopping_shipping_methodsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_shipping_methodsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_shipping_methodsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_shipping_methodsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_shipping_methodsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_shipping_methodsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_shipping_methodsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_shipping_methodsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_shipping_methodsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_shipping_methodsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          update: {\n            args: Prisma.shopping_shipping_methodsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_shipping_methodsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_shipping_methodsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_shipping_methodsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_shipping_methodsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_methodsPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_shipping_methodsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_shipping_methods>\n          }\n          groupBy: {\n            args: Prisma.shopping_shipping_methodsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_methodsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_shipping_methodsCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_methodsCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_shipping_carriers: {\n        payload: Prisma.$shopping_shipping_carriersPayload<ExtArgs>\n        fields: Prisma.shopping_shipping_carriersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_shipping_carriersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_shipping_carriersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_shipping_carriersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_shipping_carriersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_shipping_carriersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_shipping_carriersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_shipping_carriersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_shipping_carriersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_shipping_carriersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          update: {\n            args: Prisma.shopping_shipping_carriersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_shipping_carriersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_shipping_carriersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_shipping_carriersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_shipping_carriersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_carriersPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_shipping_carriersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_shipping_carriers>\n          }\n          groupBy: {\n            args: Prisma.shopping_shipping_carriersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_carriersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_shipping_carriersCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_carriersCountAggregateOutputType> | number\n          }\n        }\n      }\n      shopping_shipping_tracking: {\n        payload: Prisma.$shopping_shipping_trackingPayload<ExtArgs>\n        fields: Prisma.shopping_shipping_trackingFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.shopping_shipping_trackingFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.shopping_shipping_trackingFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          findFirst: {\n            args: Prisma.shopping_shipping_trackingFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.shopping_shipping_trackingFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          findMany: {\n            args: Prisma.shopping_shipping_trackingFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>[]\n          }\n          create: {\n            args: Prisma.shopping_shipping_trackingCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          createMany: {\n            args: Prisma.shopping_shipping_trackingCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.shopping_shipping_trackingCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>[]\n          }\n          delete: {\n            args: Prisma.shopping_shipping_trackingDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          update: {\n            args: Prisma.shopping_shipping_trackingUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          deleteMany: {\n            args: Prisma.shopping_shipping_trackingDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.shopping_shipping_trackingUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.shopping_shipping_trackingUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>[]\n          }\n          upsert: {\n            args: Prisma.shopping_shipping_trackingUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$shopping_shipping_trackingPayload>\n          }\n          aggregate: {\n            args: Prisma.Shopping_shipping_trackingAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateShopping_shipping_tracking>\n          }\n          groupBy: {\n            args: Prisma.shopping_shipping_trackingGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_trackingGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.shopping_shipping_trackingCountArgs<ExtArgs>\n            result: $Utils.Optional<Shopping_shipping_trackingCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    shopping_channels?: shopping_channelsOmit\n    shopping_sections?: shopping_sectionsOmit\n    shopping_channel_categories?: shopping_channel_categoriesOmit\n    shopping_customers?: shopping_customersOmit\n    shopping_sellers?: shopping_sellersOmit\n    shopping_administrators?: shopping_administratorsOmit\n    shopping_products?: shopping_productsOmit\n    shopping_product_variants?: shopping_product_variantsOmit\n    shopping_categories?: shopping_categoriesOmit\n    shopping_inventory?: shopping_inventoryOmit\n    shopping_product_reviews?: shopping_product_reviewsOmit\n    shopping_orders?: shopping_ordersOmit\n    shopping_order_items?: shopping_order_itemsOmit\n    shopping_order_status?: shopping_order_statusOmit\n    shopping_order_history?: shopping_order_historyOmit\n    shopping_shopping_carts?: shopping_shopping_cartsOmit\n    shopping_cart_items?: shopping_cart_itemsOmit\n    shopping_review_moderation?: shopping_review_moderationOmit\n    shopping_review_ratings?: shopping_review_ratingsOmit\n    shopping_seller_products?: shopping_seller_productsOmit\n    shopping_seller_inventory?: shopping_seller_inventoryOmit\n    shopping_seller_orders?: shopping_seller_ordersOmit\n    shopping_admin_actions?: shopping_admin_actionsOmit\n    shopping_admin_logs?: shopping_admin_logsOmit\n    shopping_payments?: shopping_paymentsOmit\n    shopping_payment_methods?: shopping_payment_methodsOmit\n    shopping_payment_transactions?: shopping_payment_transactionsOmit\n    shopping_shipping_methods?: shopping_shipping_methodsOmit\n    shopping_shipping_carriers?: shopping_shipping_carriersOmit\n    shopping_shipping_tracking?: shopping_shipping_trackingOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Shopping_channelsCountOutputType\n   */\n\n  export type Shopping_channelsCountOutputType = {\n    shopping_sections: number\n    shopping_channel_categories: number\n  }\n\n  export type Shopping_channelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sections?: boolean | Shopping_channelsCountOutputTypeCountShopping_sectionsArgs\n    shopping_channel_categories?: boolean | Shopping_channelsCountOutputTypeCountShopping_channel_categoriesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_channelsCountOutputType\n     */\n    select?: Shopping_channelsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sectionsWhereInput\n  }\n\n  /**\n   * Shopping_channelsCountOutputType without action\n   */\n  export type Shopping_channelsCountOutputTypeCountShopping_channel_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_channel_categoriesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_sectionsCountOutputType\n   */\n\n  export type Shopping_sectionsCountOutputType = {\n    shopping_channel_categories: number\n  }\n\n  export type Shopping_sectionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_channel_categories?: boolean | Shopping_sectionsCountOutputTypeCountShopping_channel_categoriesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_sectionsCountOutputType\n     */\n    select?: Shopping_sectionsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_sectionsCountOutputType without action\n   */\n  export type Shopping_sectionsCountOutputTypeCountShopping_channel_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_channel_categoriesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_customersCountOutputType\n   */\n\n  export type Shopping_customersCountOutputType = {\n    shopping_product_reviews: number\n    shopping_orders: number\n    shopping_shopping_carts: number\n    shopping_payments: number\n  }\n\n  export type Shopping_customersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_product_reviews?: boolean | Shopping_customersCountOutputTypeCountShopping_product_reviewsArgs\n    shopping_orders?: boolean | Shopping_customersCountOutputTypeCountShopping_ordersArgs\n    shopping_shopping_carts?: boolean | Shopping_customersCountOutputTypeCountShopping_shopping_cartsArgs\n    shopping_payments?: boolean | Shopping_customersCountOutputTypeCountShopping_paymentsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_customersCountOutputType without action\n   */\n  export type Shopping_customersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_customersCountOutputType\n     */\n    select?: Shopping_customersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_customersCountOutputType without action\n   */\n  export type Shopping_customersCountOutputTypeCountShopping_product_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_product_reviewsWhereInput\n  }\n\n  /**\n   * Shopping_customersCountOutputType without action\n   */\n  export type Shopping_customersCountOutputTypeCountShopping_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_ordersWhereInput\n  }\n\n  /**\n   * Shopping_customersCountOutputType without action\n   */\n  export type Shopping_customersCountOutputTypeCountShopping_shopping_cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shopping_cartsWhereInput\n  }\n\n  /**\n   * Shopping_customersCountOutputType without action\n   */\n  export type Shopping_customersCountOutputTypeCountShopping_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_paymentsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_sellersCountOutputType\n   */\n\n  export type Shopping_sellersCountOutputType = {\n    shopping_seller_products: number\n    shopping_seller_orders: number\n  }\n\n  export type Shopping_sellersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_seller_products?: boolean | Shopping_sellersCountOutputTypeCountShopping_seller_productsArgs\n    shopping_seller_orders?: boolean | Shopping_sellersCountOutputTypeCountShopping_seller_ordersArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_sellersCountOutputType without action\n   */\n  export type Shopping_sellersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_sellersCountOutputType\n     */\n    select?: Shopping_sellersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_sellersCountOutputType without action\n   */\n  export type Shopping_sellersCountOutputTypeCountShopping_seller_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_productsWhereInput\n  }\n\n  /**\n   * Shopping_sellersCountOutputType without action\n   */\n  export type Shopping_sellersCountOutputTypeCountShopping_seller_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_ordersWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_administratorsCountOutputType\n   */\n\n  export type Shopping_administratorsCountOutputType = {\n    shopping_review_moderation: number\n    shopping_admin_actions: number\n    shopping_admin_logs: number\n  }\n\n  export type Shopping_administratorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_review_moderation?: boolean | Shopping_administratorsCountOutputTypeCountShopping_review_moderationArgs\n    shopping_admin_actions?: boolean | Shopping_administratorsCountOutputTypeCountShopping_admin_actionsArgs\n    shopping_admin_logs?: boolean | Shopping_administratorsCountOutputTypeCountShopping_admin_logsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_administratorsCountOutputType without action\n   */\n  export type Shopping_administratorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_administratorsCountOutputType\n     */\n    select?: Shopping_administratorsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_administratorsCountOutputType without action\n   */\n  export type Shopping_administratorsCountOutputTypeCountShopping_review_moderationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_review_moderationWhereInput\n  }\n\n  /**\n   * Shopping_administratorsCountOutputType without action\n   */\n  export type Shopping_administratorsCountOutputTypeCountShopping_admin_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_admin_actionsWhereInput\n  }\n\n  /**\n   * Shopping_administratorsCountOutputType without action\n   */\n  export type Shopping_administratorsCountOutputTypeCountShopping_admin_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_admin_logsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_productsCountOutputType\n   */\n\n  export type Shopping_productsCountOutputType = {\n    shopping_product_variants: number\n    shopping_inventory: number\n    shopping_product_reviews: number\n    shopping_seller_products: number\n  }\n\n  export type Shopping_productsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_product_variants?: boolean | Shopping_productsCountOutputTypeCountShopping_product_variantsArgs\n    shopping_inventory?: boolean | Shopping_productsCountOutputTypeCountShopping_inventoryArgs\n    shopping_product_reviews?: boolean | Shopping_productsCountOutputTypeCountShopping_product_reviewsArgs\n    shopping_seller_products?: boolean | Shopping_productsCountOutputTypeCountShopping_seller_productsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_productsCountOutputType without action\n   */\n  export type Shopping_productsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_productsCountOutputType\n     */\n    select?: Shopping_productsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_productsCountOutputType without action\n   */\n  export type Shopping_productsCountOutputTypeCountShopping_product_variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_product_variantsWhereInput\n  }\n\n  /**\n   * Shopping_productsCountOutputType without action\n   */\n  export type Shopping_productsCountOutputTypeCountShopping_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inventoryWhereInput\n  }\n\n  /**\n   * Shopping_productsCountOutputType without action\n   */\n  export type Shopping_productsCountOutputTypeCountShopping_product_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_product_reviewsWhereInput\n  }\n\n  /**\n   * Shopping_productsCountOutputType without action\n   */\n  export type Shopping_productsCountOutputTypeCountShopping_seller_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_productsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_product_variantsCountOutputType\n   */\n\n  export type Shopping_product_variantsCountOutputType = {\n    shopping_order_items: number\n    shopping_cart_items: number\n    shopping_seller_inventory: number\n  }\n\n  export type Shopping_product_variantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_order_items?: boolean | Shopping_product_variantsCountOutputTypeCountShopping_order_itemsArgs\n    shopping_cart_items?: boolean | Shopping_product_variantsCountOutputTypeCountShopping_cart_itemsArgs\n    shopping_seller_inventory?: boolean | Shopping_product_variantsCountOutputTypeCountShopping_seller_inventoryArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_product_variantsCountOutputType without action\n   */\n  export type Shopping_product_variantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_product_variantsCountOutputType\n     */\n    select?: Shopping_product_variantsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_product_variantsCountOutputType without action\n   */\n  export type Shopping_product_variantsCountOutputTypeCountShopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_itemsWhereInput\n  }\n\n  /**\n   * Shopping_product_variantsCountOutputType without action\n   */\n  export type Shopping_product_variantsCountOutputTypeCountShopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n  }\n\n  /**\n   * Shopping_product_variantsCountOutputType without action\n   */\n  export type Shopping_product_variantsCountOutputTypeCountShopping_seller_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_inventoryWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_categoriesCountOutputType\n   */\n\n  export type Shopping_categoriesCountOutputType = {\n    shopping_products: number\n    recursive: number\n  }\n\n  export type Shopping_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_products?: boolean | Shopping_categoriesCountOutputTypeCountShopping_productsArgs\n    recursive?: boolean | Shopping_categoriesCountOutputTypeCountRecursiveArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_categoriesCountOutputType without action\n   */\n  export type Shopping_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_categoriesCountOutputType\n     */\n    select?: Shopping_categoriesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_categoriesCountOutputType without action\n   */\n  export type Shopping_categoriesCountOutputTypeCountShopping_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_productsWhereInput\n  }\n\n  /**\n   * Shopping_categoriesCountOutputType without action\n   */\n  export type Shopping_categoriesCountOutputTypeCountRecursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_categoriesWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_product_reviewsCountOutputType\n   */\n\n  export type Shopping_product_reviewsCountOutputType = {\n    shopping_review_moderation: number\n    shopping_review_ratings: number\n  }\n\n  export type Shopping_product_reviewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_review_moderation?: boolean | Shopping_product_reviewsCountOutputTypeCountShopping_review_moderationArgs\n    shopping_review_ratings?: boolean | Shopping_product_reviewsCountOutputTypeCountShopping_review_ratingsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_product_reviewsCountOutputType without action\n   */\n  export type Shopping_product_reviewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_product_reviewsCountOutputType\n     */\n    select?: Shopping_product_reviewsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_product_reviewsCountOutputType without action\n   */\n  export type Shopping_product_reviewsCountOutputTypeCountShopping_review_moderationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_review_moderationWhereInput\n  }\n\n  /**\n   * Shopping_product_reviewsCountOutputType without action\n   */\n  export type Shopping_product_reviewsCountOutputTypeCountShopping_review_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_review_ratingsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_ordersCountOutputType\n   */\n\n  export type Shopping_ordersCountOutputType = {\n    shopping_order_items: number\n    shopping_order_status: number\n    shopping_order_history: number\n    shopping_seller_orders: number\n    shopping_payments: number\n    shopping_shipping_tracking: number\n  }\n\n  export type Shopping_ordersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_order_items?: boolean | Shopping_ordersCountOutputTypeCountShopping_order_itemsArgs\n    shopping_order_status?: boolean | Shopping_ordersCountOutputTypeCountShopping_order_statusArgs\n    shopping_order_history?: boolean | Shopping_ordersCountOutputTypeCountShopping_order_historyArgs\n    shopping_seller_orders?: boolean | Shopping_ordersCountOutputTypeCountShopping_seller_ordersArgs\n    shopping_payments?: boolean | Shopping_ordersCountOutputTypeCountShopping_paymentsArgs\n    shopping_shipping_tracking?: boolean | Shopping_ordersCountOutputTypeCountShopping_shipping_trackingArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_ordersCountOutputType\n     */\n    select?: Shopping_ordersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_itemsWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_order_statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_statusWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_order_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_historyWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_seller_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_ordersWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_paymentsWhereInput\n  }\n\n  /**\n   * Shopping_ordersCountOutputType without action\n   */\n  export type Shopping_ordersCountOutputTypeCountShopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_trackingWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_shopping_cartsCountOutputType\n   */\n\n  export type Shopping_shopping_cartsCountOutputType = {\n    shopping_cart_items: number\n  }\n\n  export type Shopping_shopping_cartsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_cart_items?: boolean | Shopping_shopping_cartsCountOutputTypeCountShopping_cart_itemsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_shopping_cartsCountOutputType without action\n   */\n  export type Shopping_shopping_cartsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_shopping_cartsCountOutputType\n     */\n    select?: Shopping_shopping_cartsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_shopping_cartsCountOutputType without action\n   */\n  export type Shopping_shopping_cartsCountOutputTypeCountShopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_seller_productsCountOutputType\n   */\n\n  export type Shopping_seller_productsCountOutputType = {\n    shopping_seller_inventory: number\n  }\n\n  export type Shopping_seller_productsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_seller_inventory?: boolean | Shopping_seller_productsCountOutputTypeCountShopping_seller_inventoryArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_seller_productsCountOutputType without action\n   */\n  export type Shopping_seller_productsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_seller_productsCountOutputType\n     */\n    select?: Shopping_seller_productsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_seller_productsCountOutputType without action\n   */\n  export type Shopping_seller_productsCountOutputTypeCountShopping_seller_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_inventoryWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_paymentsCountOutputType\n   */\n\n  export type Shopping_paymentsCountOutputType = {\n    shopping_payment_transactions: number\n  }\n\n  export type Shopping_paymentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_payment_transactions?: boolean | Shopping_paymentsCountOutputTypeCountShopping_payment_transactionsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_paymentsCountOutputType without action\n   */\n  export type Shopping_paymentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_paymentsCountOutputType\n     */\n    select?: Shopping_paymentsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_paymentsCountOutputType without action\n   */\n  export type Shopping_paymentsCountOutputTypeCountShopping_payment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_payment_transactionsWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_shipping_methodsCountOutputType\n   */\n\n  export type Shopping_shipping_methodsCountOutputType = {\n    shopping_shipping_tracking: number\n  }\n\n  export type Shopping_shipping_methodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_shipping_tracking?: boolean | Shopping_shipping_methodsCountOutputTypeCountShopping_shipping_trackingArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_shipping_methodsCountOutputType without action\n   */\n  export type Shopping_shipping_methodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_shipping_methodsCountOutputType\n     */\n    select?: Shopping_shipping_methodsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_shipping_methodsCountOutputType without action\n   */\n  export type Shopping_shipping_methodsCountOutputTypeCountShopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_trackingWhereInput\n  }\n\n\n  /**\n   * Count Type Shopping_shipping_carriersCountOutputType\n   */\n\n  export type Shopping_shipping_carriersCountOutputType = {\n    shopping_shipping_tracking: number\n  }\n\n  export type Shopping_shipping_carriersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_shipping_tracking?: boolean | Shopping_shipping_carriersCountOutputTypeCountShopping_shipping_trackingArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Shopping_shipping_carriersCountOutputType without action\n   */\n  export type Shopping_shipping_carriersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Shopping_shipping_carriersCountOutputType\n     */\n    select?: Shopping_shipping_carriersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Shopping_shipping_carriersCountOutputType without action\n   */\n  export type Shopping_shipping_carriersCountOutputTypeCountShopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_trackingWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model shopping_channels\n   */\n\n  export type AggregateShopping_channels = {\n    _count: Shopping_channelsCountAggregateOutputType | null\n    _min: Shopping_channelsMinAggregateOutputType | null\n    _max: Shopping_channelsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_channelsMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channelsMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channelsCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_channelsMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channelsMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channelsCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_channelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channels to aggregate.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_channels\n    **/\n    _count?: true | Shopping_channelsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_channelsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_channelsMaxAggregateInputType\n  }\n\n  export type GetShopping_channelsAggregateType<T extends Shopping_channelsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_channels]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_channels[P]>\n      : GetScalarType<T[P], AggregateShopping_channels[P]>\n  }\n\n\n\n\n  export type shopping_channelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_channelsWhereInput\n    orderBy?: shopping_channelsOrderByWithAggregationInput | shopping_channelsOrderByWithAggregationInput[]\n    by: Shopping_channelsScalarFieldEnum[] | Shopping_channelsScalarFieldEnum\n    having?: shopping_channelsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_channelsCountAggregateInputType | true\n    _min?: Shopping_channelsMinAggregateInputType\n    _max?: Shopping_channelsMaxAggregateInputType\n  }\n\n  export type Shopping_channelsGroupByOutputType = {\n    id: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_channelsCountAggregateOutputType | null\n    _min: Shopping_channelsMinAggregateOutputType | null\n    _max: Shopping_channelsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_channelsGroupByPayload<T extends shopping_channelsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_channelsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_channelsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_channelsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_channelsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_channelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    shopping_sections?: boolean | shopping_channels$shopping_sectionsArgs<ExtArgs>\n    shopping_channel_categories?: boolean | shopping_channels$shopping_channel_categoriesArgs<ExtArgs>\n    _count?: boolean | Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_channels\"]>\n\n  export type shopping_channelsSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_channelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_channels\"]>\n  export type shopping_channelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_sections?: boolean | shopping_channels$shopping_sectionsArgs<ExtArgs>\n    shopping_channel_categories?: boolean | shopping_channels$shopping_channel_categoriesArgs<ExtArgs>\n    _count?: boolean | Shopping_channelsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_channelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_channelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_channelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_channels\"\n    objects: {\n      shopping_sections: Prisma.$shopping_sectionsPayload<ExtArgs>[]\n      shopping_channel_categories: Prisma.$shopping_channel_categoriesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The name of the shopping channel.\n       */\n      name: string\n      /**\n       * A detailed description of the shopping channel.\n       */\n      description: string | null\n      /**\n       * The timestamp when the channel was created.\n       */\n      created_at: Date\n      /**\n       * The timestamp when the channel was last updated.\n       */\n      updated_at: Date\n      /**\n       * The timestamp when the channel was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_channels\"]>\n    composites: {}\n  }\n\n  type shopping_channelsGetPayload<S extends boolean | null | undefined | shopping_channelsDefaultArgs> = $Result.GetResult<Prisma.$shopping_channelsPayload, S>\n\n  type shopping_channelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_channelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_channelsCountAggregateInputType | true\n    }\n\n  export interface shopping_channelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_channels'], meta: { name: 'shopping_channels' } }\n    /**\n     * Find zero or one Shopping_channels that matches the filter.\n     * @param {shopping_channelsFindUniqueArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_channelsFindUniqueArgs>(args: SelectSubset<T, shopping_channelsFindUniqueArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_channels that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_channelsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_channelsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_channelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channels that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindFirstArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_channelsFindFirstArgs>(args?: SelectSubset<T, shopping_channelsFindFirstArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channels that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindFirstOrThrowArgs} args - Arguments to find a Shopping_channels\n     * @example\n     * // Get one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_channelsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_channelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_channels that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findMany()\n     * \n     * // Get first 10 Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_channelsFindManyArgs>(args?: SelectSubset<T, shopping_channelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_channels.\n     * @param {shopping_channelsCreateArgs} args - Arguments to create a Shopping_channels.\n     * @example\n     * // Create one Shopping_channels\n     * const Shopping_channels = await prisma.shopping_channels.create({\n     *   data: {\n     *     // ... data to create a Shopping_channels\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_channelsCreateArgs>(args: SelectSubset<T, shopping_channelsCreateArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_channels.\n     * @param {shopping_channelsCreateManyArgs} args - Arguments to create many Shopping_channels.\n     * @example\n     * // Create many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_channelsCreateManyArgs>(args?: SelectSubset<T, shopping_channelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_channels and returns the data saved in the database.\n     * @param {shopping_channelsCreateManyAndReturnArgs} args - Arguments to create many Shopping_channels.\n     * @example\n     * // Create many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_channels and only return the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_channelsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_channelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_channels.\n     * @param {shopping_channelsDeleteArgs} args - Arguments to delete one Shopping_channels.\n     * @example\n     * // Delete one Shopping_channels\n     * const Shopping_channels = await prisma.shopping_channels.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_channels\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_channelsDeleteArgs>(args: SelectSubset<T, shopping_channelsDeleteArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_channels.\n     * @param {shopping_channelsUpdateArgs} args - Arguments to update one Shopping_channels.\n     * @example\n     * // Update one Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_channelsUpdateArgs>(args: SelectSubset<T, shopping_channelsUpdateArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_channels.\n     * @param {shopping_channelsDeleteManyArgs} args - Arguments to filter Shopping_channels to delete.\n     * @example\n     * // Delete a few Shopping_channels\n     * const { count } = await prisma.shopping_channels.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_channelsDeleteManyArgs>(args?: SelectSubset<T, shopping_channelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_channelsUpdateManyArgs>(args: SelectSubset<T, shopping_channelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channels and returns the data updated in the database.\n     * @param {shopping_channelsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_channels.\n     * @example\n     * // Update many Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_channels and only return the `id`\n     * const shopping_channelsWithIdOnly = await prisma.shopping_channels.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_channelsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_channelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_channels.\n     * @param {shopping_channelsUpsertArgs} args - Arguments to update or create a Shopping_channels.\n     * @example\n     * // Update or create a Shopping_channels\n     * const shopping_channels = await prisma.shopping_channels.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_channels\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_channels we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_channelsUpsertArgs>(args: SelectSubset<T, shopping_channelsUpsertArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsCountArgs} args - Arguments to filter Shopping_channels to count.\n     * @example\n     * // Count the number of Shopping_channels\n     * const count = await prisma.shopping_channels.count({\n     *   where: {\n     *     // ... the filter for the Shopping_channels we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_channelsCountArgs>(\n      args?: Subset<T, shopping_channelsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_channelsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_channelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_channelsAggregateArgs>(args: Subset<T, Shopping_channelsAggregateArgs>): Prisma.PrismaPromise<GetShopping_channelsAggregateType<T>>\n\n    /**\n     * Group by Shopping_channels.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channelsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_channelsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_channelsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_channelsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_channelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_channelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_channels model\n   */\n  readonly fields: shopping_channelsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_channels.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_channelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_sections<T extends shopping_channels$shopping_sectionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_channel_categories<T extends shopping_channels$shopping_channel_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channels$shopping_channel_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_channels model\n   */\n  interface shopping_channelsFieldRefs {\n    readonly id: FieldRef<\"shopping_channels\", 'String'>\n    readonly name: FieldRef<\"shopping_channels\", 'String'>\n    readonly description: FieldRef<\"shopping_channels\", 'String'>\n    readonly created_at: FieldRef<\"shopping_channels\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_channels\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_channels\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_channels findUnique\n   */\n  export type shopping_channelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels findUniqueOrThrow\n   */\n  export type shopping_channelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels findFirst\n   */\n  export type shopping_channelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channels.\n     */\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels findFirstOrThrow\n   */\n  export type shopping_channelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channels.\n     */\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels findMany\n   */\n  export type shopping_channelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channels to fetch.\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channels to fetch.\n     */\n    orderBy?: shopping_channelsOrderByWithRelationInput | shopping_channelsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_channels.\n     */\n    cursor?: shopping_channelsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channels from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channels.\n     */\n    skip?: number\n    distinct?: Shopping_channelsScalarFieldEnum | Shopping_channelsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels create\n   */\n  export type shopping_channelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_channels.\n     */\n    data: XOR<shopping_channelsCreateInput, shopping_channelsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_channels createMany\n   */\n  export type shopping_channelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_channels.\n     */\n    data: shopping_channelsCreateManyInput | shopping_channelsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_channels createManyAndReturn\n   */\n  export type shopping_channelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_channels.\n     */\n    data: shopping_channelsCreateManyInput | shopping_channelsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_channels update\n   */\n  export type shopping_channelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateInput, shopping_channelsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_channels to update.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels updateMany\n   */\n  export type shopping_channelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateManyMutationInput, shopping_channelsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channels to update\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels updateManyAndReturn\n   */\n  export type shopping_channelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_channels.\n     */\n    data: XOR<shopping_channelsUpdateManyMutationInput, shopping_channelsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channels to update\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels upsert\n   */\n  export type shopping_channelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_channels to update in case it exists.\n     */\n    where: shopping_channelsWhereUniqueInput\n    /**\n     * In case the shopping_channels found by the `where` argument doesn't exist, create a new shopping_channels with this data.\n     */\n    create: XOR<shopping_channelsCreateInput, shopping_channelsUncheckedCreateInput>\n    /**\n     * In case the shopping_channels was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_channelsUpdateInput, shopping_channelsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_channels delete\n   */\n  export type shopping_channelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_channels to delete.\n     */\n    where: shopping_channelsWhereUniqueInput\n  }\n\n  /**\n   * shopping_channels deleteMany\n   */\n  export type shopping_channelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channels to delete\n     */\n    where?: shopping_channelsWhereInput\n    /**\n     * Limit how many shopping_channels to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channels.shopping_sections\n   */\n  export type shopping_channels$shopping_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    where?: shopping_sectionsWhereInput\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    cursor?: shopping_sectionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels.shopping_channel_categories\n   */\n  export type shopping_channels$shopping_channel_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    where?: shopping_channel_categoriesWhereInput\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_channel_categoriesScalarFieldEnum | Shopping_channel_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channels without action\n   */\n  export type shopping_channelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channels\n     */\n    select?: shopping_channelsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channels\n     */\n    omit?: shopping_channelsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channelsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sections\n   */\n\n  export type AggregateShopping_sections = {\n    _count: Shopping_sectionsCountAggregateOutputType | null\n    _min: Shopping_sectionsMinAggregateOutputType | null\n    _max: Shopping_sectionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sectionsMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sectionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_sectionsCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_sectionsMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sectionsMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_sectionsCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_sectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sections to aggregate.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sections\n    **/\n    _count?: true | Shopping_sectionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sectionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sectionsMaxAggregateInputType\n  }\n\n  export type GetShopping_sectionsAggregateType<T extends Shopping_sectionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sections]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sections[P]>\n      : GetScalarType<T[P], AggregateShopping_sections[P]>\n  }\n\n\n\n\n  export type shopping_sectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sectionsWhereInput\n    orderBy?: shopping_sectionsOrderByWithAggregationInput | shopping_sectionsOrderByWithAggregationInput[]\n    by: Shopping_sectionsScalarFieldEnum[] | Shopping_sectionsScalarFieldEnum\n    having?: shopping_sectionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sectionsCountAggregateInputType | true\n    _min?: Shopping_sectionsMinAggregateInputType\n    _max?: Shopping_sectionsMaxAggregateInputType\n  }\n\n  export type Shopping_sectionsGroupByOutputType = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_sectionsCountAggregateOutputType | null\n    _min: Shopping_sectionsMinAggregateOutputType | null\n    _max: Shopping_sectionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sectionsGroupByPayload<T extends shopping_sectionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sectionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sectionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sectionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sectionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    shopping_channel_categories?: boolean | shopping_sections$shopping_channel_categoriesArgs<ExtArgs>\n    _count?: boolean | Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sections\"]>\n\n  export type shopping_sectionsSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_sectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_sections\"]>\n  export type shopping_sectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    shopping_channel_categories?: boolean | shopping_sections$shopping_channel_categoriesArgs<ExtArgs>\n    _count?: boolean | Shopping_sectionsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_sectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }\n  export type shopping_sectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_sectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sections\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs>\n      shopping_channel_categories: Prisma.$shopping_channel_categoriesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The channel to which this section belongs. {@link shopping_channels.id}.\n       */\n      shopping_channel_id: string\n      /**\n       * The name of the shopping section.\n       */\n      name: string\n      /**\n       * A detailed description of the shopping section.\n       */\n      description: string | null\n      /**\n       * The timestamp when the section was created.\n       */\n      created_at: Date\n      /**\n       * The timestamp when the section was last updated.\n       */\n      updated_at: Date\n      /**\n       * The timestamp when the section was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_sections\"]>\n    composites: {}\n  }\n\n  type shopping_sectionsGetPayload<S extends boolean | null | undefined | shopping_sectionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_sectionsPayload, S>\n\n  type shopping_sectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sectionsCountAggregateInputType | true\n    }\n\n  export interface shopping_sectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sections'], meta: { name: 'shopping_sections' } }\n    /**\n     * Find zero or one Shopping_sections that matches the filter.\n     * @param {shopping_sectionsFindUniqueArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sectionsFindUniqueArgs>(args: SelectSubset<T, shopping_sectionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sections that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sectionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sections that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindFirstArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sectionsFindFirstArgs>(args?: SelectSubset<T, shopping_sectionsFindFirstArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sections that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_sections\n     * @example\n     * // Get one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sections that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findMany()\n     * \n     * // Get first 10 Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sectionsFindManyArgs>(args?: SelectSubset<T, shopping_sectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sections.\n     * @param {shopping_sectionsCreateArgs} args - Arguments to create a Shopping_sections.\n     * @example\n     * // Create one Shopping_sections\n     * const Shopping_sections = await prisma.shopping_sections.create({\n     *   data: {\n     *     // ... data to create a Shopping_sections\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sectionsCreateArgs>(args: SelectSubset<T, shopping_sectionsCreateArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sections.\n     * @param {shopping_sectionsCreateManyArgs} args - Arguments to create many Shopping_sections.\n     * @example\n     * // Create many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sectionsCreateManyArgs>(args?: SelectSubset<T, shopping_sectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sections and returns the data saved in the database.\n     * @param {shopping_sectionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_sections.\n     * @example\n     * // Create many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sections and only return the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sections.\n     * @param {shopping_sectionsDeleteArgs} args - Arguments to delete one Shopping_sections.\n     * @example\n     * // Delete one Shopping_sections\n     * const Shopping_sections = await prisma.shopping_sections.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sections\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sectionsDeleteArgs>(args: SelectSubset<T, shopping_sectionsDeleteArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sections.\n     * @param {shopping_sectionsUpdateArgs} args - Arguments to update one Shopping_sections.\n     * @example\n     * // Update one Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sectionsUpdateArgs>(args: SelectSubset<T, shopping_sectionsUpdateArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sections.\n     * @param {shopping_sectionsDeleteManyArgs} args - Arguments to filter Shopping_sections to delete.\n     * @example\n     * // Delete a few Shopping_sections\n     * const { count } = await prisma.shopping_sections.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sectionsDeleteManyArgs>(args?: SelectSubset<T, shopping_sectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sectionsUpdateManyArgs>(args: SelectSubset<T, shopping_sectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sections and returns the data updated in the database.\n     * @param {shopping_sectionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sections.\n     * @example\n     * // Update many Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sections and only return the `id`\n     * const shopping_sectionsWithIdOnly = await prisma.shopping_sections.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sections.\n     * @param {shopping_sectionsUpsertArgs} args - Arguments to update or create a Shopping_sections.\n     * @example\n     * // Update or create a Shopping_sections\n     * const shopping_sections = await prisma.shopping_sections.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sections\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sections we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sectionsUpsertArgs>(args: SelectSubset<T, shopping_sectionsUpsertArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsCountArgs} args - Arguments to filter Shopping_sections to count.\n     * @example\n     * // Count the number of Shopping_sections\n     * const count = await prisma.shopping_sections.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sections we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sectionsCountArgs>(\n      args?: Subset<T, shopping_sectionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sectionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sectionsAggregateArgs>(args: Subset<T, Shopping_sectionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_sectionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_sections.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sectionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sectionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sectionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sectionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sections model\n   */\n  readonly fields: shopping_sectionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sections.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channelsDefaultArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_channel_categories<T extends shopping_sections$shopping_channel_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sections$shopping_channel_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sections model\n   */\n  interface shopping_sectionsFieldRefs {\n    readonly id: FieldRef<\"shopping_sections\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_sections\", 'String'>\n    readonly name: FieldRef<\"shopping_sections\", 'String'>\n    readonly description: FieldRef<\"shopping_sections\", 'String'>\n    readonly created_at: FieldRef<\"shopping_sections\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_sections\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_sections\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sections findUnique\n   */\n  export type shopping_sectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections findUniqueOrThrow\n   */\n  export type shopping_sectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections findFirst\n   */\n  export type shopping_sectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sections.\n     */\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections findFirstOrThrow\n   */\n  export type shopping_sectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sections.\n     */\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections findMany\n   */\n  export type shopping_sectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sections to fetch.\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sections to fetch.\n     */\n    orderBy?: shopping_sectionsOrderByWithRelationInput | shopping_sectionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sections.\n     */\n    cursor?: shopping_sectionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sections from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sections.\n     */\n    skip?: number\n    distinct?: Shopping_sectionsScalarFieldEnum | Shopping_sectionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections create\n   */\n  export type shopping_sectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sections.\n     */\n    data: XOR<shopping_sectionsCreateInput, shopping_sectionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sections createMany\n   */\n  export type shopping_sectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sections.\n     */\n    data: shopping_sectionsCreateManyInput | shopping_sectionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sections createManyAndReturn\n   */\n  export type shopping_sectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sections.\n     */\n    data: shopping_sectionsCreateManyInput | shopping_sectionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sections update\n   */\n  export type shopping_sectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateInput, shopping_sectionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sections to update.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections updateMany\n   */\n  export type shopping_sectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sections to update\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sections updateManyAndReturn\n   */\n  export type shopping_sectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sections.\n     */\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sections to update\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_sections upsert\n   */\n  export type shopping_sectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sections to update in case it exists.\n     */\n    where: shopping_sectionsWhereUniqueInput\n    /**\n     * In case the shopping_sections found by the `where` argument doesn't exist, create a new shopping_sections with this data.\n     */\n    create: XOR<shopping_sectionsCreateInput, shopping_sectionsUncheckedCreateInput>\n    /**\n     * In case the shopping_sections was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sectionsUpdateInput, shopping_sectionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sections delete\n   */\n  export type shopping_sectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sections to delete.\n     */\n    where: shopping_sectionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_sections deleteMany\n   */\n  export type shopping_sectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sections to delete\n     */\n    where?: shopping_sectionsWhereInput\n    /**\n     * Limit how many shopping_sections to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sections.shopping_channel_categories\n   */\n  export type shopping_sections$shopping_channel_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    where?: shopping_channel_categoriesWhereInput\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_channel_categoriesScalarFieldEnum | Shopping_channel_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sections without action\n   */\n  export type shopping_sectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sections\n     */\n    select?: shopping_sectionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sections\n     */\n    omit?: shopping_sectionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sectionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_channel_categories\n   */\n\n  export type AggregateShopping_channel_categories = {\n    _count: Shopping_channel_categoriesCountAggregateOutputType | null\n    _min: Shopping_channel_categoriesMinAggregateOutputType | null\n    _max: Shopping_channel_categoriesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_channel_categoriesMinAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channel_categoriesMaxAggregateOutputType = {\n    id: string | null\n    shopping_channel_id: string | null\n    shopping_section_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_channel_categoriesCountAggregateOutputType = {\n    id: number\n    shopping_channel_id: number\n    shopping_section_id: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_channel_categoriesMinAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channel_categoriesMaxAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_channel_categoriesCountAggregateInputType = {\n    id?: true\n    shopping_channel_id?: true\n    shopping_section_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_channel_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channel_categories to aggregate.\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channel_categories to fetch.\n     */\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channel_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channel_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_channel_categories\n    **/\n    _count?: true | Shopping_channel_categoriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_channel_categoriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_channel_categoriesMaxAggregateInputType\n  }\n\n  export type GetShopping_channel_categoriesAggregateType<T extends Shopping_channel_categoriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_channel_categories]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_channel_categories[P]>\n      : GetScalarType<T[P], AggregateShopping_channel_categories[P]>\n  }\n\n\n\n\n  export type shopping_channel_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_channel_categoriesWhereInput\n    orderBy?: shopping_channel_categoriesOrderByWithAggregationInput | shopping_channel_categoriesOrderByWithAggregationInput[]\n    by: Shopping_channel_categoriesScalarFieldEnum[] | Shopping_channel_categoriesScalarFieldEnum\n    having?: shopping_channel_categoriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_channel_categoriesCountAggregateInputType | true\n    _min?: Shopping_channel_categoriesMinAggregateInputType\n    _max?: Shopping_channel_categoriesMaxAggregateInputType\n  }\n\n  export type Shopping_channel_categoriesGroupByOutputType = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_channel_categoriesCountAggregateOutputType | null\n    _min: Shopping_channel_categoriesMinAggregateOutputType | null\n    _max: Shopping_channel_categoriesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_channel_categoriesGroupByPayload<T extends shopping_channel_categoriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_channel_categoriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_channel_categoriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_channel_categoriesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_channel_categoriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_channel_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_channel_categories\"]>\n\n  export type shopping_channel_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_channel_categories\"]>\n\n  export type shopping_channel_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_channel_categories\"]>\n\n  export type shopping_channel_categoriesSelectScalar = {\n    id?: boolean\n    shopping_channel_id?: boolean\n    shopping_section_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_channel_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_channel_id\" | \"shopping_section_id\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_channel_categories\"]>\n  export type shopping_channel_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n  export type shopping_channel_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n  export type shopping_channel_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    channel?: boolean | shopping_channelsDefaultArgs<ExtArgs>\n    section?: boolean | shopping_sectionsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_channel_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_channel_categories\"\n    objects: {\n      channel: Prisma.$shopping_channelsPayload<ExtArgs>\n      section: Prisma.$shopping_sectionsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The channel to which this category belongs. {@link shopping_channels.id}.\n       */\n      shopping_channel_id: string\n      /**\n       * The section to which this category belongs. {@link shopping_sections.id}.\n       */\n      shopping_section_id: string\n      /**\n       * The name of the shopping category.\n       */\n      name: string\n      /**\n       * A detailed description of the shopping category.\n       */\n      description: string | null\n      /**\n       * The timestamp when the category was created.\n       */\n      created_at: Date\n      /**\n       * The timestamp when the category was last updated.\n       */\n      updated_at: Date\n      /**\n       * The timestamp when the category was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_channel_categories\"]>\n    composites: {}\n  }\n\n  type shopping_channel_categoriesGetPayload<S extends boolean | null | undefined | shopping_channel_categoriesDefaultArgs> = $Result.GetResult<Prisma.$shopping_channel_categoriesPayload, S>\n\n  type shopping_channel_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_channel_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_channel_categoriesCountAggregateInputType | true\n    }\n\n  export interface shopping_channel_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_channel_categories'], meta: { name: 'shopping_channel_categories' } }\n    /**\n     * Find zero or one Shopping_channel_categories that matches the filter.\n     * @param {shopping_channel_categoriesFindUniqueArgs} args - Arguments to find a Shopping_channel_categories\n     * @example\n     * // Get one Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_channel_categoriesFindUniqueArgs>(args: SelectSubset<T, shopping_channel_categoriesFindUniqueArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_channel_categories that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_channel_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_channel_categories\n     * @example\n     * // Get one Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_channel_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_channel_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channel_categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesFindFirstArgs} args - Arguments to find a Shopping_channel_categories\n     * @example\n     * // Get one Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_channel_categoriesFindFirstArgs>(args?: SelectSubset<T, shopping_channel_categoriesFindFirstArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_channel_categories that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesFindFirstOrThrowArgs} args - Arguments to find a Shopping_channel_categories\n     * @example\n     * // Get one Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_channel_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_channel_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_channel_categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findMany()\n     * \n     * // Get first 10 Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_channel_categoriesWithIdOnly = await prisma.shopping_channel_categories.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_channel_categoriesFindManyArgs>(args?: SelectSubset<T, shopping_channel_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_channel_categories.\n     * @param {shopping_channel_categoriesCreateArgs} args - Arguments to create a Shopping_channel_categories.\n     * @example\n     * // Create one Shopping_channel_categories\n     * const Shopping_channel_categories = await prisma.shopping_channel_categories.create({\n     *   data: {\n     *     // ... data to create a Shopping_channel_categories\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_channel_categoriesCreateArgs>(args: SelectSubset<T, shopping_channel_categoriesCreateArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_channel_categories.\n     * @param {shopping_channel_categoriesCreateManyArgs} args - Arguments to create many Shopping_channel_categories.\n     * @example\n     * // Create many Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_channel_categoriesCreateManyArgs>(args?: SelectSubset<T, shopping_channel_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_channel_categories and returns the data saved in the database.\n     * @param {shopping_channel_categoriesCreateManyAndReturnArgs} args - Arguments to create many Shopping_channel_categories.\n     * @example\n     * // Create many Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_channel_categories and only return the `id`\n     * const shopping_channel_categoriesWithIdOnly = await prisma.shopping_channel_categories.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_channel_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_channel_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_channel_categories.\n     * @param {shopping_channel_categoriesDeleteArgs} args - Arguments to delete one Shopping_channel_categories.\n     * @example\n     * // Delete one Shopping_channel_categories\n     * const Shopping_channel_categories = await prisma.shopping_channel_categories.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_channel_categories\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_channel_categoriesDeleteArgs>(args: SelectSubset<T, shopping_channel_categoriesDeleteArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_channel_categories.\n     * @param {shopping_channel_categoriesUpdateArgs} args - Arguments to update one Shopping_channel_categories.\n     * @example\n     * // Update one Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_channel_categoriesUpdateArgs>(args: SelectSubset<T, shopping_channel_categoriesUpdateArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_channel_categories.\n     * @param {shopping_channel_categoriesDeleteManyArgs} args - Arguments to filter Shopping_channel_categories to delete.\n     * @example\n     * // Delete a few Shopping_channel_categories\n     * const { count } = await prisma.shopping_channel_categories.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_channel_categoriesDeleteManyArgs>(args?: SelectSubset<T, shopping_channel_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channel_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_channel_categoriesUpdateManyArgs>(args: SelectSubset<T, shopping_channel_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_channel_categories and returns the data updated in the database.\n     * @param {shopping_channel_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_channel_categories.\n     * @example\n     * // Update many Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_channel_categories and only return the `id`\n     * const shopping_channel_categoriesWithIdOnly = await prisma.shopping_channel_categories.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_channel_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_channel_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_channel_categories.\n     * @param {shopping_channel_categoriesUpsertArgs} args - Arguments to update or create a Shopping_channel_categories.\n     * @example\n     * // Update or create a Shopping_channel_categories\n     * const shopping_channel_categories = await prisma.shopping_channel_categories.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_channel_categories\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_channel_categories we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_channel_categoriesUpsertArgs>(args: SelectSubset<T, shopping_channel_categoriesUpsertArgs<ExtArgs>>): Prisma__shopping_channel_categoriesClient<$Result.GetResult<Prisma.$shopping_channel_categoriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_channel_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesCountArgs} args - Arguments to filter Shopping_channel_categories to count.\n     * @example\n     * // Count the number of Shopping_channel_categories\n     * const count = await prisma.shopping_channel_categories.count({\n     *   where: {\n     *     // ... the filter for the Shopping_channel_categories we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_channel_categoriesCountArgs>(\n      args?: Subset<T, shopping_channel_categoriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_channel_categoriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_channel_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_channel_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_channel_categoriesAggregateArgs>(args: Subset<T, Shopping_channel_categoriesAggregateArgs>): Prisma.PrismaPromise<GetShopping_channel_categoriesAggregateType<T>>\n\n    /**\n     * Group by Shopping_channel_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_channel_categoriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_channel_categoriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_channel_categoriesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_channel_categoriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_channel_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_channel_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_channel_categories model\n   */\n  readonly fields: shopping_channel_categoriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_channel_categories.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_channel_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    channel<T extends shopping_channelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_channelsDefaultArgs<ExtArgs>>): Prisma__shopping_channelsClient<$Result.GetResult<Prisma.$shopping_channelsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    section<T extends shopping_sectionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sectionsDefaultArgs<ExtArgs>>): Prisma__shopping_sectionsClient<$Result.GetResult<Prisma.$shopping_sectionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_channel_categories model\n   */\n  interface shopping_channel_categoriesFieldRefs {\n    readonly id: FieldRef<\"shopping_channel_categories\", 'String'>\n    readonly shopping_channel_id: FieldRef<\"shopping_channel_categories\", 'String'>\n    readonly shopping_section_id: FieldRef<\"shopping_channel_categories\", 'String'>\n    readonly name: FieldRef<\"shopping_channel_categories\", 'String'>\n    readonly description: FieldRef<\"shopping_channel_categories\", 'String'>\n    readonly created_at: FieldRef<\"shopping_channel_categories\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_channel_categories\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_channel_categories\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_channel_categories findUnique\n   */\n  export type shopping_channel_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channel_categories to fetch.\n     */\n    where: shopping_channel_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_channel_categories findUniqueOrThrow\n   */\n  export type shopping_channel_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channel_categories to fetch.\n     */\n    where: shopping_channel_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_channel_categories findFirst\n   */\n  export type shopping_channel_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channel_categories to fetch.\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channel_categories to fetch.\n     */\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channel_categories.\n     */\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channel_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channel_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channel_categories.\n     */\n    distinct?: Shopping_channel_categoriesScalarFieldEnum | Shopping_channel_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channel_categories findFirstOrThrow\n   */\n  export type shopping_channel_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channel_categories to fetch.\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channel_categories to fetch.\n     */\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_channel_categories.\n     */\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channel_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channel_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_channel_categories.\n     */\n    distinct?: Shopping_channel_categoriesScalarFieldEnum | Shopping_channel_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channel_categories findMany\n   */\n  export type shopping_channel_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_channel_categories to fetch.\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_channel_categories to fetch.\n     */\n    orderBy?: shopping_channel_categoriesOrderByWithRelationInput | shopping_channel_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_channel_categories.\n     */\n    cursor?: shopping_channel_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_channel_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_channel_categories.\n     */\n    skip?: number\n    distinct?: Shopping_channel_categoriesScalarFieldEnum | Shopping_channel_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_channel_categories create\n   */\n  export type shopping_channel_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_channel_categories.\n     */\n    data: XOR<shopping_channel_categoriesCreateInput, shopping_channel_categoriesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_channel_categories createMany\n   */\n  export type shopping_channel_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_channel_categories.\n     */\n    data: shopping_channel_categoriesCreateManyInput | shopping_channel_categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_channel_categories createManyAndReturn\n   */\n  export type shopping_channel_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_channel_categories.\n     */\n    data: shopping_channel_categoriesCreateManyInput | shopping_channel_categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_channel_categories update\n   */\n  export type shopping_channel_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_channel_categories.\n     */\n    data: XOR<shopping_channel_categoriesUpdateInput, shopping_channel_categoriesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_channel_categories to update.\n     */\n    where: shopping_channel_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_channel_categories updateMany\n   */\n  export type shopping_channel_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_channel_categories.\n     */\n    data: XOR<shopping_channel_categoriesUpdateManyMutationInput, shopping_channel_categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channel_categories to update\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * Limit how many shopping_channel_categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channel_categories updateManyAndReturn\n   */\n  export type shopping_channel_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_channel_categories.\n     */\n    data: XOR<shopping_channel_categoriesUpdateManyMutationInput, shopping_channel_categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_channel_categories to update\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * Limit how many shopping_channel_categories to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_channel_categories upsert\n   */\n  export type shopping_channel_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_channel_categories to update in case it exists.\n     */\n    where: shopping_channel_categoriesWhereUniqueInput\n    /**\n     * In case the shopping_channel_categories found by the `where` argument doesn't exist, create a new shopping_channel_categories with this data.\n     */\n    create: XOR<shopping_channel_categoriesCreateInput, shopping_channel_categoriesUncheckedCreateInput>\n    /**\n     * In case the shopping_channel_categories was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_channel_categoriesUpdateInput, shopping_channel_categoriesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_channel_categories delete\n   */\n  export type shopping_channel_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_channel_categories to delete.\n     */\n    where: shopping_channel_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_channel_categories deleteMany\n   */\n  export type shopping_channel_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_channel_categories to delete\n     */\n    where?: shopping_channel_categoriesWhereInput\n    /**\n     * Limit how many shopping_channel_categories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_channel_categories without action\n   */\n  export type shopping_channel_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_channel_categories\n     */\n    select?: shopping_channel_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_channel_categories\n     */\n    omit?: shopping_channel_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_channel_categoriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_customers\n   */\n\n  export type AggregateShopping_customers = {\n    _count: Shopping_customersCountAggregateOutputType | null\n    _min: Shopping_customersMinAggregateOutputType | null\n    _max: Shopping_customersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_customersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    address: string | null\n  }\n\n  export type Shopping_customersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    address: string | null\n  }\n\n  export type Shopping_customersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    phone: number\n    address: number\n    _all: number\n  }\n\n\n  export type Shopping_customersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n  }\n\n  export type Shopping_customersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n  }\n\n  export type Shopping_customersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    address?: true\n    _all?: true\n  }\n\n  export type Shopping_customersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_customers to aggregate.\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_customers to fetch.\n     */\n    orderBy?: shopping_customersOrderByWithRelationInput | shopping_customersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_customersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_customers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_customers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_customers\n    **/\n    _count?: true | Shopping_customersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_customersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_customersMaxAggregateInputType\n  }\n\n  export type GetShopping_customersAggregateType<T extends Shopping_customersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_customers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_customers[P]>\n      : GetScalarType<T[P], AggregateShopping_customers[P]>\n  }\n\n\n\n\n  export type shopping_customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_customersWhereInput\n    orderBy?: shopping_customersOrderByWithAggregationInput | shopping_customersOrderByWithAggregationInput[]\n    by: Shopping_customersScalarFieldEnum[] | Shopping_customersScalarFieldEnum\n    having?: shopping_customersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_customersCountAggregateInputType | true\n    _min?: Shopping_customersMinAggregateInputType\n    _max?: Shopping_customersMaxAggregateInputType\n  }\n\n  export type Shopping_customersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone: string | null\n    address: string | null\n    _count: Shopping_customersCountAggregateOutputType | null\n    _min: Shopping_customersMinAggregateOutputType | null\n    _max: Shopping_customersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_customersGroupByPayload<T extends shopping_customersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_customersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_customersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_customersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_customersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n    shopping_product_reviews?: boolean | shopping_customers$shopping_product_reviewsArgs<ExtArgs>\n    shopping_orders?: boolean | shopping_customers$shopping_ordersArgs<ExtArgs>\n    shopping_shopping_carts?: boolean | shopping_customers$shopping_shopping_cartsArgs<ExtArgs>\n    shopping_payments?: boolean | shopping_customers$shopping_paymentsArgs<ExtArgs>\n    _count?: boolean | Shopping_customersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_customers\"]>\n\n  export type shopping_customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n  }, ExtArgs[\"result\"][\"shopping_customers\"]>\n\n  export type shopping_customersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n  }, ExtArgs[\"result\"][\"shopping_customers\"]>\n\n  export type shopping_customersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    address?: boolean\n  }\n\n  export type shopping_customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"phone\" | \"address\", ExtArgs[\"result\"][\"shopping_customers\"]>\n  export type shopping_customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_product_reviews?: boolean | shopping_customers$shopping_product_reviewsArgs<ExtArgs>\n    shopping_orders?: boolean | shopping_customers$shopping_ordersArgs<ExtArgs>\n    shopping_shopping_carts?: boolean | shopping_customers$shopping_shopping_cartsArgs<ExtArgs>\n    shopping_payments?: boolean | shopping_customers$shopping_paymentsArgs<ExtArgs>\n    _count?: boolean | Shopping_customersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_customersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_customers\"\n    objects: {\n      shopping_product_reviews: Prisma.$shopping_product_reviewsPayload<ExtArgs>[]\n      shopping_orders: Prisma.$shopping_ordersPayload<ExtArgs>[]\n      shopping_shopping_carts: Prisma.$shopping_shopping_cartsPayload<ExtArgs>[]\n      shopping_payments: Prisma.$shopping_paymentsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Customer's email address. Used for login and communication.\n       */\n      email: string\n      /**\n       * Securely hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Customer's full name.\n       */\n      name: string\n      /**\n       * Customer's phone number.\n       */\n      phone: string | null\n      /**\n       * Customer's primary address.\n       */\n      address: string | null\n    }, ExtArgs[\"result\"][\"shopping_customers\"]>\n    composites: {}\n  }\n\n  type shopping_customersGetPayload<S extends boolean | null | undefined | shopping_customersDefaultArgs> = $Result.GetResult<Prisma.$shopping_customersPayload, S>\n\n  type shopping_customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_customersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_customersCountAggregateInputType | true\n    }\n\n  export interface shopping_customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_customers'], meta: { name: 'shopping_customers' } }\n    /**\n     * Find zero or one Shopping_customers that matches the filter.\n     * @param {shopping_customersFindUniqueArgs} args - Arguments to find a Shopping_customers\n     * @example\n     * // Get one Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_customersFindUniqueArgs>(args: SelectSubset<T, shopping_customersFindUniqueArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_customers that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_customersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_customers\n     * @example\n     * // Get one Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_customersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_customers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersFindFirstArgs} args - Arguments to find a Shopping_customers\n     * @example\n     * // Get one Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_customersFindFirstArgs>(args?: SelectSubset<T, shopping_customersFindFirstArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_customers that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersFindFirstOrThrowArgs} args - Arguments to find a Shopping_customers\n     * @example\n     * // Get one Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_customersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_customers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findMany()\n     * \n     * // Get first 10 Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_customersWithIdOnly = await prisma.shopping_customers.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_customersFindManyArgs>(args?: SelectSubset<T, shopping_customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_customers.\n     * @param {shopping_customersCreateArgs} args - Arguments to create a Shopping_customers.\n     * @example\n     * // Create one Shopping_customers\n     * const Shopping_customers = await prisma.shopping_customers.create({\n     *   data: {\n     *     // ... data to create a Shopping_customers\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_customersCreateArgs>(args: SelectSubset<T, shopping_customersCreateArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_customers.\n     * @param {shopping_customersCreateManyArgs} args - Arguments to create many Shopping_customers.\n     * @example\n     * // Create many Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_customersCreateManyArgs>(args?: SelectSubset<T, shopping_customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_customers and returns the data saved in the database.\n     * @param {shopping_customersCreateManyAndReturnArgs} args - Arguments to create many Shopping_customers.\n     * @example\n     * // Create many Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_customers and only return the `id`\n     * const shopping_customersWithIdOnly = await prisma.shopping_customers.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_customersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_customers.\n     * @param {shopping_customersDeleteArgs} args - Arguments to delete one Shopping_customers.\n     * @example\n     * // Delete one Shopping_customers\n     * const Shopping_customers = await prisma.shopping_customers.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_customers\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_customersDeleteArgs>(args: SelectSubset<T, shopping_customersDeleteArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_customers.\n     * @param {shopping_customersUpdateArgs} args - Arguments to update one Shopping_customers.\n     * @example\n     * // Update one Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_customersUpdateArgs>(args: SelectSubset<T, shopping_customersUpdateArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_customers.\n     * @param {shopping_customersDeleteManyArgs} args - Arguments to filter Shopping_customers to delete.\n     * @example\n     * // Delete a few Shopping_customers\n     * const { count } = await prisma.shopping_customers.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_customersDeleteManyArgs>(args?: SelectSubset<T, shopping_customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_customers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_customersUpdateManyArgs>(args: SelectSubset<T, shopping_customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_customers and returns the data updated in the database.\n     * @param {shopping_customersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_customers.\n     * @example\n     * // Update many Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_customers and only return the `id`\n     * const shopping_customersWithIdOnly = await prisma.shopping_customers.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_customersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_customersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_customers.\n     * @param {shopping_customersUpsertArgs} args - Arguments to update or create a Shopping_customers.\n     * @example\n     * // Update or create a Shopping_customers\n     * const shopping_customers = await prisma.shopping_customers.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_customers\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_customers we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_customersUpsertArgs>(args: SelectSubset<T, shopping_customersUpsertArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_customers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersCountArgs} args - Arguments to filter Shopping_customers to count.\n     * @example\n     * // Count the number of Shopping_customers\n     * const count = await prisma.shopping_customers.count({\n     *   where: {\n     *     // ... the filter for the Shopping_customers we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_customersCountArgs>(\n      args?: Subset<T, shopping_customersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_customersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_customers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_customersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_customersAggregateArgs>(args: Subset<T, Shopping_customersAggregateArgs>): Prisma.PrismaPromise<GetShopping_customersAggregateType<T>>\n\n    /**\n     * Group by Shopping_customers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_customersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_customersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_customersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_customersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_customersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_customers model\n   */\n  readonly fields: shopping_customersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_customers.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_product_reviews<T extends shopping_customers$shopping_product_reviewsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customers$shopping_product_reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_orders<T extends shopping_customers$shopping_ordersArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customers$shopping_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_shopping_carts<T extends shopping_customers$shopping_shopping_cartsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customers$shopping_shopping_cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_payments<T extends shopping_customers$shopping_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customers$shopping_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_customers model\n   */\n  interface shopping_customersFieldRefs {\n    readonly id: FieldRef<\"shopping_customers\", 'String'>\n    readonly email: FieldRef<\"shopping_customers\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_customers\", 'String'>\n    readonly name: FieldRef<\"shopping_customers\", 'String'>\n    readonly phone: FieldRef<\"shopping_customers\", 'String'>\n    readonly address: FieldRef<\"shopping_customers\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_customers findUnique\n   */\n  export type shopping_customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_customers to fetch.\n     */\n    where: shopping_customersWhereUniqueInput\n  }\n\n  /**\n   * shopping_customers findUniqueOrThrow\n   */\n  export type shopping_customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_customers to fetch.\n     */\n    where: shopping_customersWhereUniqueInput\n  }\n\n  /**\n   * shopping_customers findFirst\n   */\n  export type shopping_customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_customers to fetch.\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_customers to fetch.\n     */\n    orderBy?: shopping_customersOrderByWithRelationInput | shopping_customersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_customers.\n     */\n    cursor?: shopping_customersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_customers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_customers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_customers.\n     */\n    distinct?: Shopping_customersScalarFieldEnum | Shopping_customersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers findFirstOrThrow\n   */\n  export type shopping_customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_customers to fetch.\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_customers to fetch.\n     */\n    orderBy?: shopping_customersOrderByWithRelationInput | shopping_customersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_customers.\n     */\n    cursor?: shopping_customersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_customers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_customers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_customers.\n     */\n    distinct?: Shopping_customersScalarFieldEnum | Shopping_customersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers findMany\n   */\n  export type shopping_customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_customers to fetch.\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_customers to fetch.\n     */\n    orderBy?: shopping_customersOrderByWithRelationInput | shopping_customersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_customers.\n     */\n    cursor?: shopping_customersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_customers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_customers.\n     */\n    skip?: number\n    distinct?: Shopping_customersScalarFieldEnum | Shopping_customersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers create\n   */\n  export type shopping_customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_customers.\n     */\n    data: XOR<shopping_customersCreateInput, shopping_customersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_customers createMany\n   */\n  export type shopping_customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_customers.\n     */\n    data: shopping_customersCreateManyInput | shopping_customersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_customers createManyAndReturn\n   */\n  export type shopping_customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_customers.\n     */\n    data: shopping_customersCreateManyInput | shopping_customersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_customers update\n   */\n  export type shopping_customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_customers.\n     */\n    data: XOR<shopping_customersUpdateInput, shopping_customersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_customers to update.\n     */\n    where: shopping_customersWhereUniqueInput\n  }\n\n  /**\n   * shopping_customers updateMany\n   */\n  export type shopping_customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_customers.\n     */\n    data: XOR<shopping_customersUpdateManyMutationInput, shopping_customersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_customers to update\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * Limit how many shopping_customers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_customers updateManyAndReturn\n   */\n  export type shopping_customersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_customers.\n     */\n    data: XOR<shopping_customersUpdateManyMutationInput, shopping_customersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_customers to update\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * Limit how many shopping_customers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_customers upsert\n   */\n  export type shopping_customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_customers to update in case it exists.\n     */\n    where: shopping_customersWhereUniqueInput\n    /**\n     * In case the shopping_customers found by the `where` argument doesn't exist, create a new shopping_customers with this data.\n     */\n    create: XOR<shopping_customersCreateInput, shopping_customersUncheckedCreateInput>\n    /**\n     * In case the shopping_customers was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_customersUpdateInput, shopping_customersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_customers delete\n   */\n  export type shopping_customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_customers to delete.\n     */\n    where: shopping_customersWhereUniqueInput\n  }\n\n  /**\n   * shopping_customers deleteMany\n   */\n  export type shopping_customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_customers to delete\n     */\n    where?: shopping_customersWhereInput\n    /**\n     * Limit how many shopping_customers to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_customers.shopping_product_reviews\n   */\n  export type shopping_customers$shopping_product_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    where?: shopping_product_reviewsWhereInput\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_product_reviewsScalarFieldEnum | Shopping_product_reviewsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers.shopping_orders\n   */\n  export type shopping_customers$shopping_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    where?: shopping_ordersWhereInput\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    cursor?: shopping_ordersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers.shopping_shopping_carts\n   */\n  export type shopping_customers$shopping_shopping_cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    where?: shopping_shopping_cartsWhereInput\n    orderBy?: shopping_shopping_cartsOrderByWithRelationInput | shopping_shopping_cartsOrderByWithRelationInput[]\n    cursor?: shopping_shopping_cartsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_shopping_cartsScalarFieldEnum | Shopping_shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers.shopping_payments\n   */\n  export type shopping_customers$shopping_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    where?: shopping_paymentsWhereInput\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    cursor?: shopping_paymentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_paymentsScalarFieldEnum | Shopping_paymentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_customers without action\n   */\n  export type shopping_customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_customers\n     */\n    select?: shopping_customersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_customers\n     */\n    omit?: shopping_customersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_customersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_sellers\n   */\n\n  export type AggregateShopping_sellers = {\n    _count: Shopping_sellersCountAggregateOutputType | null\n    _min: Shopping_sellersMinAggregateOutputType | null\n    _max: Shopping_sellersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_sellersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    business_name: string | null\n    contact_name: string | null\n    phone: string | null\n    address: string | null\n    tax_id: string | null\n  }\n\n  export type Shopping_sellersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    business_name: string | null\n    contact_name: string | null\n    phone: string | null\n    address: string | null\n    tax_id: string | null\n  }\n\n  export type Shopping_sellersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    business_name: number\n    contact_name: number\n    phone: number\n    address: number\n    tax_id: number\n    _all: number\n  }\n\n\n  export type Shopping_sellersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    business_name?: true\n    contact_name?: true\n    phone?: true\n    address?: true\n    tax_id?: true\n  }\n\n  export type Shopping_sellersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    business_name?: true\n    contact_name?: true\n    phone?: true\n    address?: true\n    tax_id?: true\n  }\n\n  export type Shopping_sellersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    business_name?: true\n    contact_name?: true\n    phone?: true\n    address?: true\n    tax_id?: true\n    _all?: true\n  }\n\n  export type Shopping_sellersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sellers to aggregate.\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sellers to fetch.\n     */\n    orderBy?: shopping_sellersOrderByWithRelationInput | shopping_sellersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_sellersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_sellers\n    **/\n    _count?: true | Shopping_sellersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_sellersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_sellersMaxAggregateInputType\n  }\n\n  export type GetShopping_sellersAggregateType<T extends Shopping_sellersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_sellers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_sellers[P]>\n      : GetScalarType<T[P], AggregateShopping_sellers[P]>\n  }\n\n\n\n\n  export type shopping_sellersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_sellersWhereInput\n    orderBy?: shopping_sellersOrderByWithAggregationInput | shopping_sellersOrderByWithAggregationInput[]\n    by: Shopping_sellersScalarFieldEnum[] | Shopping_sellersScalarFieldEnum\n    having?: shopping_sellersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_sellersCountAggregateInputType | true\n    _min?: Shopping_sellersMinAggregateInputType\n    _max?: Shopping_sellersMaxAggregateInputType\n  }\n\n  export type Shopping_sellersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone: string | null\n    address: string | null\n    tax_id: string | null\n    _count: Shopping_sellersCountAggregateOutputType | null\n    _min: Shopping_sellersMinAggregateOutputType | null\n    _max: Shopping_sellersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_sellersGroupByPayload<T extends shopping_sellersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_sellersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_sellersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_sellersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_sellersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_sellersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    business_name?: boolean\n    contact_name?: boolean\n    phone?: boolean\n    address?: boolean\n    tax_id?: boolean\n    shopping_seller_products?: boolean | shopping_sellers$shopping_seller_productsArgs<ExtArgs>\n    shopping_seller_orders?: boolean | shopping_sellers$shopping_seller_ordersArgs<ExtArgs>\n    _count?: boolean | Shopping_sellersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_sellers\"]>\n\n  export type shopping_sellersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    business_name?: boolean\n    contact_name?: boolean\n    phone?: boolean\n    address?: boolean\n    tax_id?: boolean\n  }, ExtArgs[\"result\"][\"shopping_sellers\"]>\n\n  export type shopping_sellersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    business_name?: boolean\n    contact_name?: boolean\n    phone?: boolean\n    address?: boolean\n    tax_id?: boolean\n  }, ExtArgs[\"result\"][\"shopping_sellers\"]>\n\n  export type shopping_sellersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    business_name?: boolean\n    contact_name?: boolean\n    phone?: boolean\n    address?: boolean\n    tax_id?: boolean\n  }\n\n  export type shopping_sellersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"business_name\" | \"contact_name\" | \"phone\" | \"address\" | \"tax_id\", ExtArgs[\"result\"][\"shopping_sellers\"]>\n  export type shopping_sellersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_seller_products?: boolean | shopping_sellers$shopping_seller_productsArgs<ExtArgs>\n    shopping_seller_orders?: boolean | shopping_sellers$shopping_seller_ordersArgs<ExtArgs>\n    _count?: boolean | Shopping_sellersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_sellersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_sellersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_sellersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_sellers\"\n    objects: {\n      shopping_seller_products: Prisma.$shopping_seller_productsPayload<ExtArgs>[]\n      shopping_seller_orders: Prisma.$shopping_seller_ordersPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Seller's email address. Used for login and communication.\n       */\n      email: string\n      /**\n       * Securely hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Seller's business name.\n       */\n      business_name: string\n      /**\n       * Primary contact person's name.\n       */\n      contact_name: string\n      /**\n       * Seller's phone number.\n       */\n      phone: string | null\n      /**\n       * Seller's business address.\n       */\n      address: string | null\n      /**\n       * Seller's tax identification number.\n       */\n      tax_id: string | null\n    }, ExtArgs[\"result\"][\"shopping_sellers\"]>\n    composites: {}\n  }\n\n  type shopping_sellersGetPayload<S extends boolean | null | undefined | shopping_sellersDefaultArgs> = $Result.GetResult<Prisma.$shopping_sellersPayload, S>\n\n  type shopping_sellersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_sellersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_sellersCountAggregateInputType | true\n    }\n\n  export interface shopping_sellersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_sellers'], meta: { name: 'shopping_sellers' } }\n    /**\n     * Find zero or one Shopping_sellers that matches the filter.\n     * @param {shopping_sellersFindUniqueArgs} args - Arguments to find a Shopping_sellers\n     * @example\n     * // Get one Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_sellersFindUniqueArgs>(args: SelectSubset<T, shopping_sellersFindUniqueArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_sellers that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_sellersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_sellers\n     * @example\n     * // Get one Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_sellersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_sellersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sellers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersFindFirstArgs} args - Arguments to find a Shopping_sellers\n     * @example\n     * // Get one Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_sellersFindFirstArgs>(args?: SelectSubset<T, shopping_sellersFindFirstArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_sellers that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersFindFirstOrThrowArgs} args - Arguments to find a Shopping_sellers\n     * @example\n     * // Get one Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_sellersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_sellersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_sellers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findMany()\n     * \n     * // Get first 10 Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_sellersWithIdOnly = await prisma.shopping_sellers.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_sellersFindManyArgs>(args?: SelectSubset<T, shopping_sellersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_sellers.\n     * @param {shopping_sellersCreateArgs} args - Arguments to create a Shopping_sellers.\n     * @example\n     * // Create one Shopping_sellers\n     * const Shopping_sellers = await prisma.shopping_sellers.create({\n     *   data: {\n     *     // ... data to create a Shopping_sellers\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_sellersCreateArgs>(args: SelectSubset<T, shopping_sellersCreateArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_sellers.\n     * @param {shopping_sellersCreateManyArgs} args - Arguments to create many Shopping_sellers.\n     * @example\n     * // Create many Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_sellersCreateManyArgs>(args?: SelectSubset<T, shopping_sellersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_sellers and returns the data saved in the database.\n     * @param {shopping_sellersCreateManyAndReturnArgs} args - Arguments to create many Shopping_sellers.\n     * @example\n     * // Create many Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_sellers and only return the `id`\n     * const shopping_sellersWithIdOnly = await prisma.shopping_sellers.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_sellersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_sellersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_sellers.\n     * @param {shopping_sellersDeleteArgs} args - Arguments to delete one Shopping_sellers.\n     * @example\n     * // Delete one Shopping_sellers\n     * const Shopping_sellers = await prisma.shopping_sellers.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_sellers\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_sellersDeleteArgs>(args: SelectSubset<T, shopping_sellersDeleteArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_sellers.\n     * @param {shopping_sellersUpdateArgs} args - Arguments to update one Shopping_sellers.\n     * @example\n     * // Update one Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_sellersUpdateArgs>(args: SelectSubset<T, shopping_sellersUpdateArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_sellers.\n     * @param {shopping_sellersDeleteManyArgs} args - Arguments to filter Shopping_sellers to delete.\n     * @example\n     * // Delete a few Shopping_sellers\n     * const { count } = await prisma.shopping_sellers.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_sellersDeleteManyArgs>(args?: SelectSubset<T, shopping_sellersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_sellersUpdateManyArgs>(args: SelectSubset<T, shopping_sellersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_sellers and returns the data updated in the database.\n     * @param {shopping_sellersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_sellers.\n     * @example\n     * // Update many Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_sellers and only return the `id`\n     * const shopping_sellersWithIdOnly = await prisma.shopping_sellers.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_sellersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_sellersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_sellers.\n     * @param {shopping_sellersUpsertArgs} args - Arguments to update or create a Shopping_sellers.\n     * @example\n     * // Update or create a Shopping_sellers\n     * const shopping_sellers = await prisma.shopping_sellers.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_sellers\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_sellers we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_sellersUpsertArgs>(args: SelectSubset<T, shopping_sellersUpsertArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersCountArgs} args - Arguments to filter Shopping_sellers to count.\n     * @example\n     * // Count the number of Shopping_sellers\n     * const count = await prisma.shopping_sellers.count({\n     *   where: {\n     *     // ... the filter for the Shopping_sellers we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_sellersCountArgs>(\n      args?: Subset<T, shopping_sellersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_sellersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_sellersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_sellersAggregateArgs>(args: Subset<T, Shopping_sellersAggregateArgs>): Prisma.PrismaPromise<GetShopping_sellersAggregateType<T>>\n\n    /**\n     * Group by Shopping_sellers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_sellersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_sellersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_sellersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_sellersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_sellersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_sellersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_sellers model\n   */\n  readonly fields: shopping_sellersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_sellers.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_sellersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_seller_products<T extends shopping_sellers$shopping_seller_productsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sellers$shopping_seller_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_seller_orders<T extends shopping_sellers$shopping_seller_ordersArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sellers$shopping_seller_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_sellers model\n   */\n  interface shopping_sellersFieldRefs {\n    readonly id: FieldRef<\"shopping_sellers\", 'String'>\n    readonly email: FieldRef<\"shopping_sellers\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_sellers\", 'String'>\n    readonly business_name: FieldRef<\"shopping_sellers\", 'String'>\n    readonly contact_name: FieldRef<\"shopping_sellers\", 'String'>\n    readonly phone: FieldRef<\"shopping_sellers\", 'String'>\n    readonly address: FieldRef<\"shopping_sellers\", 'String'>\n    readonly tax_id: FieldRef<\"shopping_sellers\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_sellers findUnique\n   */\n  export type shopping_sellersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sellers to fetch.\n     */\n    where: shopping_sellersWhereUniqueInput\n  }\n\n  /**\n   * shopping_sellers findUniqueOrThrow\n   */\n  export type shopping_sellersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sellers to fetch.\n     */\n    where: shopping_sellersWhereUniqueInput\n  }\n\n  /**\n   * shopping_sellers findFirst\n   */\n  export type shopping_sellersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sellers to fetch.\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sellers to fetch.\n     */\n    orderBy?: shopping_sellersOrderByWithRelationInput | shopping_sellersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sellers.\n     */\n    cursor?: shopping_sellersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sellers.\n     */\n    distinct?: Shopping_sellersScalarFieldEnum | Shopping_sellersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sellers findFirstOrThrow\n   */\n  export type shopping_sellersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sellers to fetch.\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sellers to fetch.\n     */\n    orderBy?: shopping_sellersOrderByWithRelationInput | shopping_sellersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_sellers.\n     */\n    cursor?: shopping_sellersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sellers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_sellers.\n     */\n    distinct?: Shopping_sellersScalarFieldEnum | Shopping_sellersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sellers findMany\n   */\n  export type shopping_sellersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_sellers to fetch.\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_sellers to fetch.\n     */\n    orderBy?: shopping_sellersOrderByWithRelationInput | shopping_sellersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_sellers.\n     */\n    cursor?: shopping_sellersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_sellers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_sellers.\n     */\n    skip?: number\n    distinct?: Shopping_sellersScalarFieldEnum | Shopping_sellersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sellers create\n   */\n  export type shopping_sellersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_sellers.\n     */\n    data: XOR<shopping_sellersCreateInput, shopping_sellersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_sellers createMany\n   */\n  export type shopping_sellersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_sellers.\n     */\n    data: shopping_sellersCreateManyInput | shopping_sellersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sellers createManyAndReturn\n   */\n  export type shopping_sellersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_sellers.\n     */\n    data: shopping_sellersCreateManyInput | shopping_sellersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_sellers update\n   */\n  export type shopping_sellersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_sellers.\n     */\n    data: XOR<shopping_sellersUpdateInput, shopping_sellersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_sellers to update.\n     */\n    where: shopping_sellersWhereUniqueInput\n  }\n\n  /**\n   * shopping_sellers updateMany\n   */\n  export type shopping_sellersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_sellers.\n     */\n    data: XOR<shopping_sellersUpdateManyMutationInput, shopping_sellersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sellers to update\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * Limit how many shopping_sellers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sellers updateManyAndReturn\n   */\n  export type shopping_sellersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_sellers.\n     */\n    data: XOR<shopping_sellersUpdateManyMutationInput, shopping_sellersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_sellers to update\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * Limit how many shopping_sellers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sellers upsert\n   */\n  export type shopping_sellersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_sellers to update in case it exists.\n     */\n    where: shopping_sellersWhereUniqueInput\n    /**\n     * In case the shopping_sellers found by the `where` argument doesn't exist, create a new shopping_sellers with this data.\n     */\n    create: XOR<shopping_sellersCreateInput, shopping_sellersUncheckedCreateInput>\n    /**\n     * In case the shopping_sellers was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_sellersUpdateInput, shopping_sellersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_sellers delete\n   */\n  export type shopping_sellersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_sellers to delete.\n     */\n    where: shopping_sellersWhereUniqueInput\n  }\n\n  /**\n   * shopping_sellers deleteMany\n   */\n  export type shopping_sellersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_sellers to delete\n     */\n    where?: shopping_sellersWhereInput\n    /**\n     * Limit how many shopping_sellers to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_sellers.shopping_seller_products\n   */\n  export type shopping_sellers$shopping_seller_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    where?: shopping_seller_productsWhereInput\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    cursor?: shopping_seller_productsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_productsScalarFieldEnum | Shopping_seller_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sellers.shopping_seller_orders\n   */\n  export type shopping_sellers$shopping_seller_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    where?: shopping_seller_ordersWhereInput\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_ordersScalarFieldEnum | Shopping_seller_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_sellers without action\n   */\n  export type shopping_sellersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_sellers\n     */\n    select?: shopping_sellersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_sellers\n     */\n    omit?: shopping_sellersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_sellersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_administrators\n   */\n\n  export type AggregateShopping_administrators = {\n    _count: Shopping_administratorsCountAggregateOutputType | null\n    _min: Shopping_administratorsMinAggregateOutputType | null\n    _max: Shopping_administratorsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_administratorsMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    role: string | null\n  }\n\n  export type Shopping_administratorsMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    name: string | null\n    phone: string | null\n    role: string | null\n  }\n\n  export type Shopping_administratorsCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    name: number\n    phone: number\n    role: number\n    _all: number\n  }\n\n\n  export type Shopping_administratorsMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n  }\n\n  export type Shopping_administratorsMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n  }\n\n  export type Shopping_administratorsCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    name?: true\n    phone?: true\n    role?: true\n    _all?: true\n  }\n\n  export type Shopping_administratorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_administrators to aggregate.\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_administrators to fetch.\n     */\n    orderBy?: shopping_administratorsOrderByWithRelationInput | shopping_administratorsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_administratorsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_administrators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_administrators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_administrators\n    **/\n    _count?: true | Shopping_administratorsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_administratorsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_administratorsMaxAggregateInputType\n  }\n\n  export type GetShopping_administratorsAggregateType<T extends Shopping_administratorsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_administrators]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_administrators[P]>\n      : GetScalarType<T[P], AggregateShopping_administrators[P]>\n  }\n\n\n\n\n  export type shopping_administratorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_administratorsWhereInput\n    orderBy?: shopping_administratorsOrderByWithAggregationInput | shopping_administratorsOrderByWithAggregationInput[]\n    by: Shopping_administratorsScalarFieldEnum[] | Shopping_administratorsScalarFieldEnum\n    having?: shopping_administratorsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_administratorsCountAggregateInputType | true\n    _min?: Shopping_administratorsMinAggregateInputType\n    _max?: Shopping_administratorsMaxAggregateInputType\n  }\n\n  export type Shopping_administratorsGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone: string | null\n    role: string\n    _count: Shopping_administratorsCountAggregateOutputType | null\n    _min: Shopping_administratorsMinAggregateOutputType | null\n    _max: Shopping_administratorsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_administratorsGroupByPayload<T extends shopping_administratorsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_administratorsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_administratorsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_administratorsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_administratorsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_administratorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n    shopping_review_moderation?: boolean | shopping_administrators$shopping_review_moderationArgs<ExtArgs>\n    shopping_admin_actions?: boolean | shopping_administrators$shopping_admin_actionsArgs<ExtArgs>\n    shopping_admin_logs?: boolean | shopping_administrators$shopping_admin_logsArgs<ExtArgs>\n    _count?: boolean | Shopping_administratorsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_administrators\"]>\n\n  export type shopping_administratorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n  }, ExtArgs[\"result\"][\"shopping_administrators\"]>\n\n  export type shopping_administratorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n  }, ExtArgs[\"result\"][\"shopping_administrators\"]>\n\n  export type shopping_administratorsSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    name?: boolean\n    phone?: boolean\n    role?: boolean\n  }\n\n  export type shopping_administratorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"name\" | \"phone\" | \"role\", ExtArgs[\"result\"][\"shopping_administrators\"]>\n  export type shopping_administratorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_review_moderation?: boolean | shopping_administrators$shopping_review_moderationArgs<ExtArgs>\n    shopping_admin_actions?: boolean | shopping_administrators$shopping_admin_actionsArgs<ExtArgs>\n    shopping_admin_logs?: boolean | shopping_administrators$shopping_admin_logsArgs<ExtArgs>\n    _count?: boolean | Shopping_administratorsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_administratorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_administratorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_administratorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_administrators\"\n    objects: {\n      shopping_review_moderation: Prisma.$shopping_review_moderationPayload<ExtArgs>[]\n      shopping_admin_actions: Prisma.$shopping_admin_actionsPayload<ExtArgs>[]\n      shopping_admin_logs: Prisma.$shopping_admin_logsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Admin's email address. Used for login and communication.\n       */\n      email: string\n      /**\n       * Securely hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Admin's full name.\n       */\n      name: string\n      /**\n       * Admin's phone number.\n       */\n      phone: string | null\n      /**\n       * Admin's role or permission level.\n       */\n      role: string\n    }, ExtArgs[\"result\"][\"shopping_administrators\"]>\n    composites: {}\n  }\n\n  type shopping_administratorsGetPayload<S extends boolean | null | undefined | shopping_administratorsDefaultArgs> = $Result.GetResult<Prisma.$shopping_administratorsPayload, S>\n\n  type shopping_administratorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_administratorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_administratorsCountAggregateInputType | true\n    }\n\n  export interface shopping_administratorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_administrators'], meta: { name: 'shopping_administrators' } }\n    /**\n     * Find zero or one Shopping_administrators that matches the filter.\n     * @param {shopping_administratorsFindUniqueArgs} args - Arguments to find a Shopping_administrators\n     * @example\n     * // Get one Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_administratorsFindUniqueArgs>(args: SelectSubset<T, shopping_administratorsFindUniqueArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_administrators that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_administratorsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_administrators\n     * @example\n     * // Get one Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_administratorsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_administratorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_administrators that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsFindFirstArgs} args - Arguments to find a Shopping_administrators\n     * @example\n     * // Get one Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_administratorsFindFirstArgs>(args?: SelectSubset<T, shopping_administratorsFindFirstArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_administrators that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsFindFirstOrThrowArgs} args - Arguments to find a Shopping_administrators\n     * @example\n     * // Get one Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_administratorsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_administratorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_administrators that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findMany()\n     * \n     * // Get first 10 Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_administratorsWithIdOnly = await prisma.shopping_administrators.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_administratorsFindManyArgs>(args?: SelectSubset<T, shopping_administratorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_administrators.\n     * @param {shopping_administratorsCreateArgs} args - Arguments to create a Shopping_administrators.\n     * @example\n     * // Create one Shopping_administrators\n     * const Shopping_administrators = await prisma.shopping_administrators.create({\n     *   data: {\n     *     // ... data to create a Shopping_administrators\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_administratorsCreateArgs>(args: SelectSubset<T, shopping_administratorsCreateArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_administrators.\n     * @param {shopping_administratorsCreateManyArgs} args - Arguments to create many Shopping_administrators.\n     * @example\n     * // Create many Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_administratorsCreateManyArgs>(args?: SelectSubset<T, shopping_administratorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_administrators and returns the data saved in the database.\n     * @param {shopping_administratorsCreateManyAndReturnArgs} args - Arguments to create many Shopping_administrators.\n     * @example\n     * // Create many Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_administrators and only return the `id`\n     * const shopping_administratorsWithIdOnly = await prisma.shopping_administrators.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_administratorsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_administratorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_administrators.\n     * @param {shopping_administratorsDeleteArgs} args - Arguments to delete one Shopping_administrators.\n     * @example\n     * // Delete one Shopping_administrators\n     * const Shopping_administrators = await prisma.shopping_administrators.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_administrators\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_administratorsDeleteArgs>(args: SelectSubset<T, shopping_administratorsDeleteArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_administrators.\n     * @param {shopping_administratorsUpdateArgs} args - Arguments to update one Shopping_administrators.\n     * @example\n     * // Update one Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_administratorsUpdateArgs>(args: SelectSubset<T, shopping_administratorsUpdateArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_administrators.\n     * @param {shopping_administratorsDeleteManyArgs} args - Arguments to filter Shopping_administrators to delete.\n     * @example\n     * // Delete a few Shopping_administrators\n     * const { count } = await prisma.shopping_administrators.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_administratorsDeleteManyArgs>(args?: SelectSubset<T, shopping_administratorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_administrators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_administratorsUpdateManyArgs>(args: SelectSubset<T, shopping_administratorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_administrators and returns the data updated in the database.\n     * @param {shopping_administratorsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_administrators.\n     * @example\n     * // Update many Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_administrators and only return the `id`\n     * const shopping_administratorsWithIdOnly = await prisma.shopping_administrators.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_administratorsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_administratorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_administrators.\n     * @param {shopping_administratorsUpsertArgs} args - Arguments to update or create a Shopping_administrators.\n     * @example\n     * // Update or create a Shopping_administrators\n     * const shopping_administrators = await prisma.shopping_administrators.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_administrators\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_administrators we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_administratorsUpsertArgs>(args: SelectSubset<T, shopping_administratorsUpsertArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_administrators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsCountArgs} args - Arguments to filter Shopping_administrators to count.\n     * @example\n     * // Count the number of Shopping_administrators\n     * const count = await prisma.shopping_administrators.count({\n     *   where: {\n     *     // ... the filter for the Shopping_administrators we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_administratorsCountArgs>(\n      args?: Subset<T, shopping_administratorsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_administratorsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_administrators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_administratorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_administratorsAggregateArgs>(args: Subset<T, Shopping_administratorsAggregateArgs>): Prisma.PrismaPromise<GetShopping_administratorsAggregateType<T>>\n\n    /**\n     * Group by Shopping_administrators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_administratorsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_administratorsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_administratorsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_administratorsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_administratorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_administratorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_administrators model\n   */\n  readonly fields: shopping_administratorsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_administrators.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_administratorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_review_moderation<T extends shopping_administrators$shopping_review_moderationArgs<ExtArgs> = {}>(args?: Subset<T, shopping_administrators$shopping_review_moderationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_admin_actions<T extends shopping_administrators$shopping_admin_actionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_administrators$shopping_admin_actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_admin_logs<T extends shopping_administrators$shopping_admin_logsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_administrators$shopping_admin_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_administrators model\n   */\n  interface shopping_administratorsFieldRefs {\n    readonly id: FieldRef<\"shopping_administrators\", 'String'>\n    readonly email: FieldRef<\"shopping_administrators\", 'String'>\n    readonly password_hash: FieldRef<\"shopping_administrators\", 'String'>\n    readonly name: FieldRef<\"shopping_administrators\", 'String'>\n    readonly phone: FieldRef<\"shopping_administrators\", 'String'>\n    readonly role: FieldRef<\"shopping_administrators\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_administrators findUnique\n   */\n  export type shopping_administratorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_administrators to fetch.\n     */\n    where: shopping_administratorsWhereUniqueInput\n  }\n\n  /**\n   * shopping_administrators findUniqueOrThrow\n   */\n  export type shopping_administratorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_administrators to fetch.\n     */\n    where: shopping_administratorsWhereUniqueInput\n  }\n\n  /**\n   * shopping_administrators findFirst\n   */\n  export type shopping_administratorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_administrators to fetch.\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_administrators to fetch.\n     */\n    orderBy?: shopping_administratorsOrderByWithRelationInput | shopping_administratorsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_administrators.\n     */\n    cursor?: shopping_administratorsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_administrators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_administrators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_administrators.\n     */\n    distinct?: Shopping_administratorsScalarFieldEnum | Shopping_administratorsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators findFirstOrThrow\n   */\n  export type shopping_administratorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_administrators to fetch.\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_administrators to fetch.\n     */\n    orderBy?: shopping_administratorsOrderByWithRelationInput | shopping_administratorsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_administrators.\n     */\n    cursor?: shopping_administratorsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_administrators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_administrators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_administrators.\n     */\n    distinct?: Shopping_administratorsScalarFieldEnum | Shopping_administratorsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators findMany\n   */\n  export type shopping_administratorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_administrators to fetch.\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_administrators to fetch.\n     */\n    orderBy?: shopping_administratorsOrderByWithRelationInput | shopping_administratorsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_administrators.\n     */\n    cursor?: shopping_administratorsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_administrators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_administrators.\n     */\n    skip?: number\n    distinct?: Shopping_administratorsScalarFieldEnum | Shopping_administratorsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators create\n   */\n  export type shopping_administratorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_administrators.\n     */\n    data: XOR<shopping_administratorsCreateInput, shopping_administratorsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_administrators createMany\n   */\n  export type shopping_administratorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_administrators.\n     */\n    data: shopping_administratorsCreateManyInput | shopping_administratorsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_administrators createManyAndReturn\n   */\n  export type shopping_administratorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_administrators.\n     */\n    data: shopping_administratorsCreateManyInput | shopping_administratorsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_administrators update\n   */\n  export type shopping_administratorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_administrators.\n     */\n    data: XOR<shopping_administratorsUpdateInput, shopping_administratorsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_administrators to update.\n     */\n    where: shopping_administratorsWhereUniqueInput\n  }\n\n  /**\n   * shopping_administrators updateMany\n   */\n  export type shopping_administratorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_administrators.\n     */\n    data: XOR<shopping_administratorsUpdateManyMutationInput, shopping_administratorsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_administrators to update\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * Limit how many shopping_administrators to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_administrators updateManyAndReturn\n   */\n  export type shopping_administratorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_administrators.\n     */\n    data: XOR<shopping_administratorsUpdateManyMutationInput, shopping_administratorsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_administrators to update\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * Limit how many shopping_administrators to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_administrators upsert\n   */\n  export type shopping_administratorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_administrators to update in case it exists.\n     */\n    where: shopping_administratorsWhereUniqueInput\n    /**\n     * In case the shopping_administrators found by the `where` argument doesn't exist, create a new shopping_administrators with this data.\n     */\n    create: XOR<shopping_administratorsCreateInput, shopping_administratorsUncheckedCreateInput>\n    /**\n     * In case the shopping_administrators was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_administratorsUpdateInput, shopping_administratorsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_administrators delete\n   */\n  export type shopping_administratorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_administrators to delete.\n     */\n    where: shopping_administratorsWhereUniqueInput\n  }\n\n  /**\n   * shopping_administrators deleteMany\n   */\n  export type shopping_administratorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_administrators to delete\n     */\n    where?: shopping_administratorsWhereInput\n    /**\n     * Limit how many shopping_administrators to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_administrators.shopping_review_moderation\n   */\n  export type shopping_administrators$shopping_review_moderationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    where?: shopping_review_moderationWhereInput\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    cursor?: shopping_review_moderationWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_review_moderationScalarFieldEnum | Shopping_review_moderationScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators.shopping_admin_actions\n   */\n  export type shopping_administrators$shopping_admin_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    where?: shopping_admin_actionsWhereInput\n    orderBy?: shopping_admin_actionsOrderByWithRelationInput | shopping_admin_actionsOrderByWithRelationInput[]\n    cursor?: shopping_admin_actionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_admin_actionsScalarFieldEnum | Shopping_admin_actionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators.shopping_admin_logs\n   */\n  export type shopping_administrators$shopping_admin_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    where?: shopping_admin_logsWhereInput\n    orderBy?: shopping_admin_logsOrderByWithRelationInput | shopping_admin_logsOrderByWithRelationInput[]\n    cursor?: shopping_admin_logsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_admin_logsScalarFieldEnum | Shopping_admin_logsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_administrators without action\n   */\n  export type shopping_administratorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_products\n   */\n\n  export type AggregateShopping_products = {\n    _count: Shopping_productsCountAggregateOutputType | null\n    _avg: Shopping_productsAvgAggregateOutputType | null\n    _sum: Shopping_productsSumAggregateOutputType | null\n    _min: Shopping_productsMinAggregateOutputType | null\n    _max: Shopping_productsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_productsAvgAggregateOutputType = {\n    price: number | null\n  }\n\n  export type Shopping_productsSumAggregateOutputType = {\n    price: number | null\n  }\n\n  export type Shopping_productsMinAggregateOutputType = {\n    id: string | null\n    shopping_category_id: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    sku: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    password_hash: string | null\n    business_status: string | null\n  }\n\n  export type Shopping_productsMaxAggregateOutputType = {\n    id: string | null\n    shopping_category_id: string | null\n    name: string | null\n    description: string | null\n    price: number | null\n    sku: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    password_hash: string | null\n    business_status: string | null\n  }\n\n  export type Shopping_productsCountAggregateOutputType = {\n    id: number\n    shopping_category_id: number\n    name: number\n    description: number\n    price: number\n    sku: number\n    created_at: number\n    updated_at: number\n    password_hash: number\n    business_status: number\n    _all: number\n  }\n\n\n  export type Shopping_productsAvgAggregateInputType = {\n    price?: true\n  }\n\n  export type Shopping_productsSumAggregateInputType = {\n    price?: true\n  }\n\n  export type Shopping_productsMinAggregateInputType = {\n    id?: true\n    shopping_category_id?: true\n    name?: true\n    description?: true\n    price?: true\n    sku?: true\n    created_at?: true\n    updated_at?: true\n    password_hash?: true\n    business_status?: true\n  }\n\n  export type Shopping_productsMaxAggregateInputType = {\n    id?: true\n    shopping_category_id?: true\n    name?: true\n    description?: true\n    price?: true\n    sku?: true\n    created_at?: true\n    updated_at?: true\n    password_hash?: true\n    business_status?: true\n  }\n\n  export type Shopping_productsCountAggregateInputType = {\n    id?: true\n    shopping_category_id?: true\n    name?: true\n    description?: true\n    price?: true\n    sku?: true\n    created_at?: true\n    updated_at?: true\n    password_hash?: true\n    business_status?: true\n    _all?: true\n  }\n\n  export type Shopping_productsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_products to aggregate.\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_products to fetch.\n     */\n    orderBy?: shopping_productsOrderByWithRelationInput | shopping_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_products\n    **/\n    _count?: true | Shopping_productsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_productsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_productsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_productsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_productsMaxAggregateInputType\n  }\n\n  export type GetShopping_productsAggregateType<T extends Shopping_productsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_products]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_products[P]>\n      : GetScalarType<T[P], AggregateShopping_products[P]>\n  }\n\n\n\n\n  export type shopping_productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_productsWhereInput\n    orderBy?: shopping_productsOrderByWithAggregationInput | shopping_productsOrderByWithAggregationInput[]\n    by: Shopping_productsScalarFieldEnum[] | Shopping_productsScalarFieldEnum\n    having?: shopping_productsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_productsCountAggregateInputType | true\n    _avg?: Shopping_productsAvgAggregateInputType\n    _sum?: Shopping_productsSumAggregateInputType\n    _min?: Shopping_productsMinAggregateInputType\n    _max?: Shopping_productsMaxAggregateInputType\n  }\n\n  export type Shopping_productsGroupByOutputType = {\n    id: string\n    shopping_category_id: string | null\n    name: string\n    description: string | null\n    price: number\n    sku: string\n    created_at: Date\n    updated_at: Date\n    password_hash: string\n    business_status: string | null\n    _count: Shopping_productsCountAggregateOutputType | null\n    _avg: Shopping_productsAvgAggregateOutputType | null\n    _sum: Shopping_productsSumAggregateOutputType | null\n    _min: Shopping_productsMinAggregateOutputType | null\n    _max: Shopping_productsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_productsGroupByPayload<T extends shopping_productsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_productsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_productsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_productsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_productsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_category_id?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    sku?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    password_hash?: boolean\n    business_status?: boolean\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n    shopping_product_variants?: boolean | shopping_products$shopping_product_variantsArgs<ExtArgs>\n    shopping_inventory?: boolean | shopping_products$shopping_inventoryArgs<ExtArgs>\n    shopping_product_reviews?: boolean | shopping_products$shopping_product_reviewsArgs<ExtArgs>\n    shopping_seller_products?: boolean | shopping_products$shopping_seller_productsArgs<ExtArgs>\n    _count?: boolean | Shopping_productsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_products\"]>\n\n  export type shopping_productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_category_id?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    sku?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    password_hash?: boolean\n    business_status?: boolean\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_products\"]>\n\n  export type shopping_productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_category_id?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    sku?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    password_hash?: boolean\n    business_status?: boolean\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_products\"]>\n\n  export type shopping_productsSelectScalar = {\n    id?: boolean\n    shopping_category_id?: boolean\n    name?: boolean\n    description?: boolean\n    price?: boolean\n    sku?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    password_hash?: boolean\n    business_status?: boolean\n  }\n\n  export type shopping_productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_category_id\" | \"name\" | \"description\" | \"price\" | \"sku\" | \"created_at\" | \"updated_at\" | \"password_hash\" | \"business_status\", ExtArgs[\"result\"][\"shopping_products\"]>\n  export type shopping_productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n    shopping_product_variants?: boolean | shopping_products$shopping_product_variantsArgs<ExtArgs>\n    shopping_inventory?: boolean | shopping_products$shopping_inventoryArgs<ExtArgs>\n    shopping_product_reviews?: boolean | shopping_products$shopping_product_reviewsArgs<ExtArgs>\n    shopping_seller_products?: boolean | shopping_products$shopping_seller_productsArgs<ExtArgs>\n    _count?: boolean | Shopping_productsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n  }\n  export type shopping_productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    category?: boolean | shopping_products$categoryArgs<ExtArgs>\n  }\n\n  export type $shopping_productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_products\"\n    objects: {\n      category: Prisma.$shopping_categoriesPayload<ExtArgs> | null\n      shopping_product_variants: Prisma.$shopping_product_variantsPayload<ExtArgs>[]\n      shopping_inventory: Prisma.$shopping_inventoryPayload<ExtArgs>[]\n      shopping_product_reviews: Prisma.$shopping_product_reviewsPayload<ExtArgs>[]\n      shopping_seller_products: Prisma.$shopping_seller_productsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Category this product belongs to. {@link shopping_categories.id}.\n       */\n      shopping_category_id: string | null\n      /**\n       * Name of the product.\n       */\n      name: string\n      /**\n       * Detailed description of the product.\n       */\n      description: string | null\n      /**\n       * Base price of the product.\n       */\n      price: number\n      /**\n       * Stock Keeping Unit - unique identifier for the product.\n       */\n      sku: string\n      /**\n       * Timestamp when the product was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the product was last updated.\n       */\n      updated_at: Date\n      /**\n       * Securely hashed password for authentication.\n       */\n      password_hash: string\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n    }, ExtArgs[\"result\"][\"shopping_products\"]>\n    composites: {}\n  }\n\n  type shopping_productsGetPayload<S extends boolean | null | undefined | shopping_productsDefaultArgs> = $Result.GetResult<Prisma.$shopping_productsPayload, S>\n\n  type shopping_productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_productsCountAggregateInputType | true\n    }\n\n  export interface shopping_productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_products'], meta: { name: 'shopping_products' } }\n    /**\n     * Find zero or one Shopping_products that matches the filter.\n     * @param {shopping_productsFindUniqueArgs} args - Arguments to find a Shopping_products\n     * @example\n     * // Get one Shopping_products\n     * const shopping_products = await prisma.shopping_products.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_productsFindUniqueArgs>(args: SelectSubset<T, shopping_productsFindUniqueArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_products that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_productsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_products\n     * @example\n     * // Get one Shopping_products\n     * const shopping_products = await prisma.shopping_products.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_productsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_products that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsFindFirstArgs} args - Arguments to find a Shopping_products\n     * @example\n     * // Get one Shopping_products\n     * const shopping_products = await prisma.shopping_products.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_productsFindFirstArgs>(args?: SelectSubset<T, shopping_productsFindFirstArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_products that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsFindFirstOrThrowArgs} args - Arguments to find a Shopping_products\n     * @example\n     * // Get one Shopping_products\n     * const shopping_products = await prisma.shopping_products.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_productsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_products that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_products\n     * const shopping_products = await prisma.shopping_products.findMany()\n     * \n     * // Get first 10 Shopping_products\n     * const shopping_products = await prisma.shopping_products.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_productsWithIdOnly = await prisma.shopping_products.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_productsFindManyArgs>(args?: SelectSubset<T, shopping_productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_products.\n     * @param {shopping_productsCreateArgs} args - Arguments to create a Shopping_products.\n     * @example\n     * // Create one Shopping_products\n     * const Shopping_products = await prisma.shopping_products.create({\n     *   data: {\n     *     // ... data to create a Shopping_products\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_productsCreateArgs>(args: SelectSubset<T, shopping_productsCreateArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_products.\n     * @param {shopping_productsCreateManyArgs} args - Arguments to create many Shopping_products.\n     * @example\n     * // Create many Shopping_products\n     * const shopping_products = await prisma.shopping_products.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_productsCreateManyArgs>(args?: SelectSubset<T, shopping_productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_products and returns the data saved in the database.\n     * @param {shopping_productsCreateManyAndReturnArgs} args - Arguments to create many Shopping_products.\n     * @example\n     * // Create many Shopping_products\n     * const shopping_products = await prisma.shopping_products.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_products and only return the `id`\n     * const shopping_productsWithIdOnly = await prisma.shopping_products.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_productsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_products.\n     * @param {shopping_productsDeleteArgs} args - Arguments to delete one Shopping_products.\n     * @example\n     * // Delete one Shopping_products\n     * const Shopping_products = await prisma.shopping_products.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_products\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_productsDeleteArgs>(args: SelectSubset<T, shopping_productsDeleteArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_products.\n     * @param {shopping_productsUpdateArgs} args - Arguments to update one Shopping_products.\n     * @example\n     * // Update one Shopping_products\n     * const shopping_products = await prisma.shopping_products.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_productsUpdateArgs>(args: SelectSubset<T, shopping_productsUpdateArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_products.\n     * @param {shopping_productsDeleteManyArgs} args - Arguments to filter Shopping_products to delete.\n     * @example\n     * // Delete a few Shopping_products\n     * const { count } = await prisma.shopping_products.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_productsDeleteManyArgs>(args?: SelectSubset<T, shopping_productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_products\n     * const shopping_products = await prisma.shopping_products.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_productsUpdateManyArgs>(args: SelectSubset<T, shopping_productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_products and returns the data updated in the database.\n     * @param {shopping_productsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_products.\n     * @example\n     * // Update many Shopping_products\n     * const shopping_products = await prisma.shopping_products.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_products and only return the `id`\n     * const shopping_productsWithIdOnly = await prisma.shopping_products.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_productsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_products.\n     * @param {shopping_productsUpsertArgs} args - Arguments to update or create a Shopping_products.\n     * @example\n     * // Update or create a Shopping_products\n     * const shopping_products = await prisma.shopping_products.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_products\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_products we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_productsUpsertArgs>(args: SelectSubset<T, shopping_productsUpsertArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsCountArgs} args - Arguments to filter Shopping_products to count.\n     * @example\n     * // Count the number of Shopping_products\n     * const count = await prisma.shopping_products.count({\n     *   where: {\n     *     // ... the filter for the Shopping_products we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_productsCountArgs>(\n      args?: Subset<T, shopping_productsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_productsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_productsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_productsAggregateArgs>(args: Subset<T, Shopping_productsAggregateArgs>): Prisma.PrismaPromise<GetShopping_productsAggregateType<T>>\n\n    /**\n     * Group by Shopping_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_productsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_productsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_productsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_productsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_productsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_products model\n   */\n  readonly fields: shopping_productsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_products.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    category<T extends shopping_products$categoryArgs<ExtArgs> = {}>(args?: Subset<T, shopping_products$categoryArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    shopping_product_variants<T extends shopping_products$shopping_product_variantsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_products$shopping_product_variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_inventory<T extends shopping_products$shopping_inventoryArgs<ExtArgs> = {}>(args?: Subset<T, shopping_products$shopping_inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_product_reviews<T extends shopping_products$shopping_product_reviewsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_products$shopping_product_reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_seller_products<T extends shopping_products$shopping_seller_productsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_products$shopping_seller_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_products model\n   */\n  interface shopping_productsFieldRefs {\n    readonly id: FieldRef<\"shopping_products\", 'String'>\n    readonly shopping_category_id: FieldRef<\"shopping_products\", 'String'>\n    readonly name: FieldRef<\"shopping_products\", 'String'>\n    readonly description: FieldRef<\"shopping_products\", 'String'>\n    readonly price: FieldRef<\"shopping_products\", 'Float'>\n    readonly sku: FieldRef<\"shopping_products\", 'String'>\n    readonly created_at: FieldRef<\"shopping_products\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_products\", 'DateTime'>\n    readonly password_hash: FieldRef<\"shopping_products\", 'String'>\n    readonly business_status: FieldRef<\"shopping_products\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_products findUnique\n   */\n  export type shopping_productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_products to fetch.\n     */\n    where: shopping_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_products findUniqueOrThrow\n   */\n  export type shopping_productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_products to fetch.\n     */\n    where: shopping_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_products findFirst\n   */\n  export type shopping_productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_products to fetch.\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_products to fetch.\n     */\n    orderBy?: shopping_productsOrderByWithRelationInput | shopping_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_products.\n     */\n    cursor?: shopping_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_products.\n     */\n    distinct?: Shopping_productsScalarFieldEnum | Shopping_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products findFirstOrThrow\n   */\n  export type shopping_productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_products to fetch.\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_products to fetch.\n     */\n    orderBy?: shopping_productsOrderByWithRelationInput | shopping_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_products.\n     */\n    cursor?: shopping_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_products.\n     */\n    distinct?: Shopping_productsScalarFieldEnum | Shopping_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products findMany\n   */\n  export type shopping_productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_products to fetch.\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_products to fetch.\n     */\n    orderBy?: shopping_productsOrderByWithRelationInput | shopping_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_products.\n     */\n    cursor?: shopping_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_products.\n     */\n    skip?: number\n    distinct?: Shopping_productsScalarFieldEnum | Shopping_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products create\n   */\n  export type shopping_productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_products.\n     */\n    data: XOR<shopping_productsCreateInput, shopping_productsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_products createMany\n   */\n  export type shopping_productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_products.\n     */\n    data: shopping_productsCreateManyInput | shopping_productsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_products createManyAndReturn\n   */\n  export type shopping_productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_products.\n     */\n    data: shopping_productsCreateManyInput | shopping_productsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_products update\n   */\n  export type shopping_productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_products.\n     */\n    data: XOR<shopping_productsUpdateInput, shopping_productsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_products to update.\n     */\n    where: shopping_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_products updateMany\n   */\n  export type shopping_productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_products.\n     */\n    data: XOR<shopping_productsUpdateManyMutationInput, shopping_productsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_products to update\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * Limit how many shopping_products to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_products updateManyAndReturn\n   */\n  export type shopping_productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_products.\n     */\n    data: XOR<shopping_productsUpdateManyMutationInput, shopping_productsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_products to update\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * Limit how many shopping_products to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_products upsert\n   */\n  export type shopping_productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_products to update in case it exists.\n     */\n    where: shopping_productsWhereUniqueInput\n    /**\n     * In case the shopping_products found by the `where` argument doesn't exist, create a new shopping_products with this data.\n     */\n    create: XOR<shopping_productsCreateInput, shopping_productsUncheckedCreateInput>\n    /**\n     * In case the shopping_products was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_productsUpdateInput, shopping_productsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_products delete\n   */\n  export type shopping_productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_products to delete.\n     */\n    where: shopping_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_products deleteMany\n   */\n  export type shopping_productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_products to delete\n     */\n    where?: shopping_productsWhereInput\n    /**\n     * Limit how many shopping_products to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_products.category\n   */\n  export type shopping_products$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    where?: shopping_categoriesWhereInput\n  }\n\n  /**\n   * shopping_products.shopping_product_variants\n   */\n  export type shopping_products$shopping_product_variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    where?: shopping_product_variantsWhereInput\n    orderBy?: shopping_product_variantsOrderByWithRelationInput | shopping_product_variantsOrderByWithRelationInput[]\n    cursor?: shopping_product_variantsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_product_variantsScalarFieldEnum | Shopping_product_variantsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products.shopping_inventory\n   */\n  export type shopping_products$shopping_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    where?: shopping_inventoryWhereInput\n    orderBy?: shopping_inventoryOrderByWithRelationInput | shopping_inventoryOrderByWithRelationInput[]\n    cursor?: shopping_inventoryWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_inventoryScalarFieldEnum | Shopping_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products.shopping_product_reviews\n   */\n  export type shopping_products$shopping_product_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    where?: shopping_product_reviewsWhereInput\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_product_reviewsScalarFieldEnum | Shopping_product_reviewsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products.shopping_seller_products\n   */\n  export type shopping_products$shopping_seller_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    where?: shopping_seller_productsWhereInput\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    cursor?: shopping_seller_productsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_productsScalarFieldEnum | Shopping_seller_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_products without action\n   */\n  export type shopping_productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_product_variants\n   */\n\n  export type AggregateShopping_product_variants = {\n    _count: Shopping_product_variantsCountAggregateOutputType | null\n    _avg: Shopping_product_variantsAvgAggregateOutputType | null\n    _sum: Shopping_product_variantsSumAggregateOutputType | null\n    _min: Shopping_product_variantsMinAggregateOutputType | null\n    _max: Shopping_product_variantsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_product_variantsAvgAggregateOutputType = {\n    price_adjustment: number | null\n  }\n\n  export type Shopping_product_variantsSumAggregateOutputType = {\n    price_adjustment: number | null\n  }\n\n  export type Shopping_product_variantsMinAggregateOutputType = {\n    id: string | null\n    shopping_product_id: string | null\n    sku: string | null\n    option_name: string | null\n    option_value: string | null\n    price_adjustment: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_product_variantsMaxAggregateOutputType = {\n    id: string | null\n    shopping_product_id: string | null\n    sku: string | null\n    option_name: string | null\n    option_value: string | null\n    price_adjustment: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_product_variantsCountAggregateOutputType = {\n    id: number\n    shopping_product_id: number\n    sku: number\n    option_name: number\n    option_value: number\n    price_adjustment: number\n    created_at: number\n    updated_at: number\n    business_status: number\n    _all: number\n  }\n\n\n  export type Shopping_product_variantsAvgAggregateInputType = {\n    price_adjustment?: true\n  }\n\n  export type Shopping_product_variantsSumAggregateInputType = {\n    price_adjustment?: true\n  }\n\n  export type Shopping_product_variantsMinAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    sku?: true\n    option_name?: true\n    option_value?: true\n    price_adjustment?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_product_variantsMaxAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    sku?: true\n    option_name?: true\n    option_value?: true\n    price_adjustment?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_product_variantsCountAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    sku?: true\n    option_name?: true\n    option_value?: true\n    price_adjustment?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n    _all?: true\n  }\n\n  export type Shopping_product_variantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_product_variants to aggregate.\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_variants to fetch.\n     */\n    orderBy?: shopping_product_variantsOrderByWithRelationInput | shopping_product_variantsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_product_variantsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_variants from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_variants.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_product_variants\n    **/\n    _count?: true | Shopping_product_variantsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_product_variantsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_product_variantsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_product_variantsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_product_variantsMaxAggregateInputType\n  }\n\n  export type GetShopping_product_variantsAggregateType<T extends Shopping_product_variantsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_product_variants]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_product_variants[P]>\n      : GetScalarType<T[P], AggregateShopping_product_variants[P]>\n  }\n\n\n\n\n  export type shopping_product_variantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_product_variantsWhereInput\n    orderBy?: shopping_product_variantsOrderByWithAggregationInput | shopping_product_variantsOrderByWithAggregationInput[]\n    by: Shopping_product_variantsScalarFieldEnum[] | Shopping_product_variantsScalarFieldEnum\n    having?: shopping_product_variantsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_product_variantsCountAggregateInputType | true\n    _avg?: Shopping_product_variantsAvgAggregateInputType\n    _sum?: Shopping_product_variantsSumAggregateInputType\n    _min?: Shopping_product_variantsMinAggregateInputType\n    _max?: Shopping_product_variantsMaxAggregateInputType\n  }\n\n  export type Shopping_product_variantsGroupByOutputType = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment: number | null\n    created_at: Date\n    updated_at: Date\n    business_status: string | null\n    _count: Shopping_product_variantsCountAggregateOutputType | null\n    _avg: Shopping_product_variantsAvgAggregateOutputType | null\n    _sum: Shopping_product_variantsSumAggregateOutputType | null\n    _min: Shopping_product_variantsMinAggregateOutputType | null\n    _max: Shopping_product_variantsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_product_variantsGroupByPayload<T extends shopping_product_variantsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_product_variantsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_product_variantsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_product_variantsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_product_variantsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_product_variantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    sku?: boolean\n    option_name?: boolean\n    option_value?: boolean\n    price_adjustment?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    shopping_inventory?: boolean | shopping_product_variants$shopping_inventoryArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_product_variants$shopping_order_itemsArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_product_variants$shopping_cart_itemsArgs<ExtArgs>\n    shopping_seller_inventory?: boolean | shopping_product_variants$shopping_seller_inventoryArgs<ExtArgs>\n    _count?: boolean | Shopping_product_variantsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_variants\"]>\n\n  export type shopping_product_variantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    sku?: boolean\n    option_name?: boolean\n    option_value?: boolean\n    price_adjustment?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_variants\"]>\n\n  export type shopping_product_variantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    sku?: boolean\n    option_name?: boolean\n    option_value?: boolean\n    price_adjustment?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_variants\"]>\n\n  export type shopping_product_variantsSelectScalar = {\n    id?: boolean\n    shopping_product_id?: boolean\n    sku?: boolean\n    option_name?: boolean\n    option_value?: boolean\n    price_adjustment?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n  }\n\n  export type shopping_product_variantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_product_id\" | \"sku\" | \"option_name\" | \"option_value\" | \"price_adjustment\" | \"created_at\" | \"updated_at\" | \"business_status\", ExtArgs[\"result\"][\"shopping_product_variants\"]>\n  export type shopping_product_variantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    shopping_inventory?: boolean | shopping_product_variants$shopping_inventoryArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_product_variants$shopping_order_itemsArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_product_variants$shopping_cart_itemsArgs<ExtArgs>\n    shopping_seller_inventory?: boolean | shopping_product_variants$shopping_seller_inventoryArgs<ExtArgs>\n    _count?: boolean | Shopping_product_variantsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_product_variantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n  export type shopping_product_variantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_product_variantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_product_variants\"\n    objects: {\n      product: Prisma.$shopping_productsPayload<ExtArgs>\n      shopping_inventory: Prisma.$shopping_inventoryPayload<ExtArgs> | null\n      shopping_order_items: Prisma.$shopping_order_itemsPayload<ExtArgs>[]\n      shopping_cart_items: Prisma.$shopping_cart_itemsPayload<ExtArgs>[]\n      shopping_seller_inventory: Prisma.$shopping_seller_inventoryPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Main product this variant belongs to. {@link shopping_products.id}.\n       */\n      shopping_product_id: string\n      /**\n       * Stock Keeping Unit - unique identifier for this variant.\n       */\n      sku: string\n      /**\n       * Name of the variant option (e.g., Color, Size).\n       */\n      option_name: string\n      /**\n       * Value of the variant option (e.g., Red, Large).\n       */\n      option_value: string\n      /**\n       * Price adjustment for this variant from base price.\n       */\n      price_adjustment: number | null\n      /**\n       * Timestamp when the variant was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the variant was last updated.\n       */\n      updated_at: Date\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n    }, ExtArgs[\"result\"][\"shopping_product_variants\"]>\n    composites: {}\n  }\n\n  type shopping_product_variantsGetPayload<S extends boolean | null | undefined | shopping_product_variantsDefaultArgs> = $Result.GetResult<Prisma.$shopping_product_variantsPayload, S>\n\n  type shopping_product_variantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_product_variantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_product_variantsCountAggregateInputType | true\n    }\n\n  export interface shopping_product_variantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_product_variants'], meta: { name: 'shopping_product_variants' } }\n    /**\n     * Find zero or one Shopping_product_variants that matches the filter.\n     * @param {shopping_product_variantsFindUniqueArgs} args - Arguments to find a Shopping_product_variants\n     * @example\n     * // Get one Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_product_variantsFindUniqueArgs>(args: SelectSubset<T, shopping_product_variantsFindUniqueArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_product_variants that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_product_variantsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_product_variants\n     * @example\n     * // Get one Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_product_variantsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_product_variantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_product_variants that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsFindFirstArgs} args - Arguments to find a Shopping_product_variants\n     * @example\n     * // Get one Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_product_variantsFindFirstArgs>(args?: SelectSubset<T, shopping_product_variantsFindFirstArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_product_variants that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsFindFirstOrThrowArgs} args - Arguments to find a Shopping_product_variants\n     * @example\n     * // Get one Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_product_variantsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_product_variantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_product_variants that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findMany()\n     * \n     * // Get first 10 Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_product_variantsWithIdOnly = await prisma.shopping_product_variants.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_product_variantsFindManyArgs>(args?: SelectSubset<T, shopping_product_variantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_product_variants.\n     * @param {shopping_product_variantsCreateArgs} args - Arguments to create a Shopping_product_variants.\n     * @example\n     * // Create one Shopping_product_variants\n     * const Shopping_product_variants = await prisma.shopping_product_variants.create({\n     *   data: {\n     *     // ... data to create a Shopping_product_variants\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_product_variantsCreateArgs>(args: SelectSubset<T, shopping_product_variantsCreateArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_product_variants.\n     * @param {shopping_product_variantsCreateManyArgs} args - Arguments to create many Shopping_product_variants.\n     * @example\n     * // Create many Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_product_variantsCreateManyArgs>(args?: SelectSubset<T, shopping_product_variantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_product_variants and returns the data saved in the database.\n     * @param {shopping_product_variantsCreateManyAndReturnArgs} args - Arguments to create many Shopping_product_variants.\n     * @example\n     * // Create many Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_product_variants and only return the `id`\n     * const shopping_product_variantsWithIdOnly = await prisma.shopping_product_variants.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_product_variantsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_product_variantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_product_variants.\n     * @param {shopping_product_variantsDeleteArgs} args - Arguments to delete one Shopping_product_variants.\n     * @example\n     * // Delete one Shopping_product_variants\n     * const Shopping_product_variants = await prisma.shopping_product_variants.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_product_variants\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_product_variantsDeleteArgs>(args: SelectSubset<T, shopping_product_variantsDeleteArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_product_variants.\n     * @param {shopping_product_variantsUpdateArgs} args - Arguments to update one Shopping_product_variants.\n     * @example\n     * // Update one Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_product_variantsUpdateArgs>(args: SelectSubset<T, shopping_product_variantsUpdateArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_product_variants.\n     * @param {shopping_product_variantsDeleteManyArgs} args - Arguments to filter Shopping_product_variants to delete.\n     * @example\n     * // Delete a few Shopping_product_variants\n     * const { count } = await prisma.shopping_product_variants.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_product_variantsDeleteManyArgs>(args?: SelectSubset<T, shopping_product_variantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_product_variants.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_product_variantsUpdateManyArgs>(args: SelectSubset<T, shopping_product_variantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_product_variants and returns the data updated in the database.\n     * @param {shopping_product_variantsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_product_variants.\n     * @example\n     * // Update many Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_product_variants and only return the `id`\n     * const shopping_product_variantsWithIdOnly = await prisma.shopping_product_variants.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_product_variantsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_product_variantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_product_variants.\n     * @param {shopping_product_variantsUpsertArgs} args - Arguments to update or create a Shopping_product_variants.\n     * @example\n     * // Update or create a Shopping_product_variants\n     * const shopping_product_variants = await prisma.shopping_product_variants.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_product_variants\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_product_variants we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_product_variantsUpsertArgs>(args: SelectSubset<T, shopping_product_variantsUpsertArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_product_variants.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsCountArgs} args - Arguments to filter Shopping_product_variants to count.\n     * @example\n     * // Count the number of Shopping_product_variants\n     * const count = await prisma.shopping_product_variants.count({\n     *   where: {\n     *     // ... the filter for the Shopping_product_variants we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_product_variantsCountArgs>(\n      args?: Subset<T, shopping_product_variantsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_product_variantsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_product_variants.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_product_variantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_product_variantsAggregateArgs>(args: Subset<T, Shopping_product_variantsAggregateArgs>): Prisma.PrismaPromise<GetShopping_product_variantsAggregateType<T>>\n\n    /**\n     * Group by Shopping_product_variants.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_variantsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_product_variantsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_product_variantsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_product_variantsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_product_variantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_product_variantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_product_variants model\n   */\n  readonly fields: shopping_product_variantsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_product_variants.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_product_variantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    product<T extends shopping_productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_productsDefaultArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_inventory<T extends shopping_product_variants$shopping_inventoryArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variants$shopping_inventoryArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    shopping_order_items<T extends shopping_product_variants$shopping_order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variants$shopping_order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_cart_items<T extends shopping_product_variants$shopping_cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variants$shopping_cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_seller_inventory<T extends shopping_product_variants$shopping_seller_inventoryArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variants$shopping_seller_inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_product_variants model\n   */\n  interface shopping_product_variantsFieldRefs {\n    readonly id: FieldRef<\"shopping_product_variants\", 'String'>\n    readonly shopping_product_id: FieldRef<\"shopping_product_variants\", 'String'>\n    readonly sku: FieldRef<\"shopping_product_variants\", 'String'>\n    readonly option_name: FieldRef<\"shopping_product_variants\", 'String'>\n    readonly option_value: FieldRef<\"shopping_product_variants\", 'String'>\n    readonly price_adjustment: FieldRef<\"shopping_product_variants\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_product_variants\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_product_variants\", 'DateTime'>\n    readonly business_status: FieldRef<\"shopping_product_variants\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_product_variants findUnique\n   */\n  export type shopping_product_variantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_variants to fetch.\n     */\n    where: shopping_product_variantsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_variants findUniqueOrThrow\n   */\n  export type shopping_product_variantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_variants to fetch.\n     */\n    where: shopping_product_variantsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_variants findFirst\n   */\n  export type shopping_product_variantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_variants to fetch.\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_variants to fetch.\n     */\n    orderBy?: shopping_product_variantsOrderByWithRelationInput | shopping_product_variantsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_product_variants.\n     */\n    cursor?: shopping_product_variantsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_variants from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_variants.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_product_variants.\n     */\n    distinct?: Shopping_product_variantsScalarFieldEnum | Shopping_product_variantsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants findFirstOrThrow\n   */\n  export type shopping_product_variantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_variants to fetch.\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_variants to fetch.\n     */\n    orderBy?: shopping_product_variantsOrderByWithRelationInput | shopping_product_variantsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_product_variants.\n     */\n    cursor?: shopping_product_variantsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_variants from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_variants.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_product_variants.\n     */\n    distinct?: Shopping_product_variantsScalarFieldEnum | Shopping_product_variantsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants findMany\n   */\n  export type shopping_product_variantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_variants to fetch.\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_variants to fetch.\n     */\n    orderBy?: shopping_product_variantsOrderByWithRelationInput | shopping_product_variantsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_product_variants.\n     */\n    cursor?: shopping_product_variantsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_variants from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_variants.\n     */\n    skip?: number\n    distinct?: Shopping_product_variantsScalarFieldEnum | Shopping_product_variantsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants create\n   */\n  export type shopping_product_variantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_product_variants.\n     */\n    data: XOR<shopping_product_variantsCreateInput, shopping_product_variantsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_product_variants createMany\n   */\n  export type shopping_product_variantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_product_variants.\n     */\n    data: shopping_product_variantsCreateManyInput | shopping_product_variantsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_product_variants createManyAndReturn\n   */\n  export type shopping_product_variantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_product_variants.\n     */\n    data: shopping_product_variantsCreateManyInput | shopping_product_variantsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_product_variants update\n   */\n  export type shopping_product_variantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_product_variants.\n     */\n    data: XOR<shopping_product_variantsUpdateInput, shopping_product_variantsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_product_variants to update.\n     */\n    where: shopping_product_variantsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_variants updateMany\n   */\n  export type shopping_product_variantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_product_variants.\n     */\n    data: XOR<shopping_product_variantsUpdateManyMutationInput, shopping_product_variantsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_product_variants to update\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * Limit how many shopping_product_variants to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_product_variants updateManyAndReturn\n   */\n  export type shopping_product_variantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_product_variants.\n     */\n    data: XOR<shopping_product_variantsUpdateManyMutationInput, shopping_product_variantsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_product_variants to update\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * Limit how many shopping_product_variants to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_product_variants upsert\n   */\n  export type shopping_product_variantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_product_variants to update in case it exists.\n     */\n    where: shopping_product_variantsWhereUniqueInput\n    /**\n     * In case the shopping_product_variants found by the `where` argument doesn't exist, create a new shopping_product_variants with this data.\n     */\n    create: XOR<shopping_product_variantsCreateInput, shopping_product_variantsUncheckedCreateInput>\n    /**\n     * In case the shopping_product_variants was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_product_variantsUpdateInput, shopping_product_variantsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_product_variants delete\n   */\n  export type shopping_product_variantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_product_variants to delete.\n     */\n    where: shopping_product_variantsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_variants deleteMany\n   */\n  export type shopping_product_variantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_product_variants to delete\n     */\n    where?: shopping_product_variantsWhereInput\n    /**\n     * Limit how many shopping_product_variants to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_product_variants.shopping_inventory\n   */\n  export type shopping_product_variants$shopping_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    where?: shopping_inventoryWhereInput\n  }\n\n  /**\n   * shopping_product_variants.shopping_order_items\n   */\n  export type shopping_product_variants$shopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    where?: shopping_order_itemsWhereInput\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    cursor?: shopping_order_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants.shopping_cart_items\n   */\n  export type shopping_product_variants$shopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants.shopping_seller_inventory\n   */\n  export type shopping_product_variants$shopping_seller_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    where?: shopping_seller_inventoryWhereInput\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_inventoryScalarFieldEnum | Shopping_seller_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_variants without action\n   */\n  export type shopping_product_variantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_variants\n     */\n    select?: shopping_product_variantsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_variants\n     */\n    omit?: shopping_product_variantsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_variantsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_categories\n   */\n\n  export type AggregateShopping_categories = {\n    _count: Shopping_categoriesCountAggregateOutputType | null\n    _min: Shopping_categoriesMinAggregateOutputType | null\n    _max: Shopping_categoriesMaxAggregateOutputType | null\n  }\n\n  export type Shopping_categoriesMinAggregateOutputType = {\n    id: string | null\n    parent_id: string | null\n    name: string | null\n    description: string | null\n    code: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_categoriesMaxAggregateOutputType = {\n    id: string | null\n    parent_id: string | null\n    name: string | null\n    description: string | null\n    code: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_categoriesCountAggregateOutputType = {\n    id: number\n    parent_id: number\n    name: number\n    description: number\n    code: number\n    created_at: number\n    updated_at: number\n    business_status: number\n    _all: number\n  }\n\n\n  export type Shopping_categoriesMinAggregateInputType = {\n    id?: true\n    parent_id?: true\n    name?: true\n    description?: true\n    code?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_categoriesMaxAggregateInputType = {\n    id?: true\n    parent_id?: true\n    name?: true\n    description?: true\n    code?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_categoriesCountAggregateInputType = {\n    id?: true\n    parent_id?: true\n    name?: true\n    description?: true\n    code?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n    _all?: true\n  }\n\n  export type Shopping_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_categories to aggregate.\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_categories to fetch.\n     */\n    orderBy?: shopping_categoriesOrderByWithRelationInput | shopping_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_categories\n    **/\n    _count?: true | Shopping_categoriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_categoriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_categoriesMaxAggregateInputType\n  }\n\n  export type GetShopping_categoriesAggregateType<T extends Shopping_categoriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_categories]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_categories[P]>\n      : GetScalarType<T[P], AggregateShopping_categories[P]>\n  }\n\n\n\n\n  export type shopping_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_categoriesWhereInput\n    orderBy?: shopping_categoriesOrderByWithAggregationInput | shopping_categoriesOrderByWithAggregationInput[]\n    by: Shopping_categoriesScalarFieldEnum[] | Shopping_categoriesScalarFieldEnum\n    having?: shopping_categoriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_categoriesCountAggregateInputType | true\n    _min?: Shopping_categoriesMinAggregateInputType\n    _max?: Shopping_categoriesMaxAggregateInputType\n  }\n\n  export type Shopping_categoriesGroupByOutputType = {\n    id: string\n    parent_id: string | null\n    name: string\n    description: string | null\n    code: string\n    created_at: Date\n    updated_at: Date\n    business_status: string | null\n    _count: Shopping_categoriesCountAggregateOutputType | null\n    _min: Shopping_categoriesMinAggregateOutputType | null\n    _max: Shopping_categoriesMaxAggregateOutputType | null\n  }\n\n  type GetShopping_categoriesGroupByPayload<T extends shopping_categoriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_categoriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_categoriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_categoriesGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_categoriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    parent_id?: boolean\n    name?: boolean\n    description?: boolean\n    code?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n    shopping_products?: boolean | shopping_categories$shopping_productsArgs<ExtArgs>\n    recursive?: boolean | shopping_categories$recursiveArgs<ExtArgs>\n    _count?: boolean | Shopping_categoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_categories\"]>\n\n  export type shopping_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    parent_id?: boolean\n    name?: boolean\n    description?: boolean\n    code?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_categories\"]>\n\n  export type shopping_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    parent_id?: boolean\n    name?: boolean\n    description?: boolean\n    code?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_categories\"]>\n\n  export type shopping_categoriesSelectScalar = {\n    id?: boolean\n    parent_id?: boolean\n    name?: boolean\n    description?: boolean\n    code?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n  }\n\n  export type shopping_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"parent_id\" | \"name\" | \"description\" | \"code\" | \"created_at\" | \"updated_at\" | \"business_status\", ExtArgs[\"result\"][\"shopping_categories\"]>\n  export type shopping_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n    shopping_products?: boolean | shopping_categories$shopping_productsArgs<ExtArgs>\n    recursive?: boolean | shopping_categories$recursiveArgs<ExtArgs>\n    _count?: boolean | Shopping_categoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n  }\n  export type shopping_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    parent?: boolean | shopping_categories$parentArgs<ExtArgs>\n  }\n\n  export type $shopping_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_categories\"\n    objects: {\n      parent: Prisma.$shopping_categoriesPayload<ExtArgs> | null\n      shopping_products: Prisma.$shopping_productsPayload<ExtArgs>[]\n      recursive: Prisma.$shopping_categoriesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Parent category if this is a subcategory. {@link shopping_categories.id}.\n       */\n      parent_id: string | null\n      /**\n       * Name of the category.\n       */\n      name: string\n      /**\n       * Description of the category.\n       */\n      description: string | null\n      /**\n       * Unique code for the category.\n       */\n      code: string\n      /**\n       * Timestamp when the category was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the category was last updated.\n       */\n      updated_at: Date\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n    }, ExtArgs[\"result\"][\"shopping_categories\"]>\n    composites: {}\n  }\n\n  type shopping_categoriesGetPayload<S extends boolean | null | undefined | shopping_categoriesDefaultArgs> = $Result.GetResult<Prisma.$shopping_categoriesPayload, S>\n\n  type shopping_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_categoriesCountAggregateInputType | true\n    }\n\n  export interface shopping_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_categories'], meta: { name: 'shopping_categories' } }\n    /**\n     * Find zero or one Shopping_categories that matches the filter.\n     * @param {shopping_categoriesFindUniqueArgs} args - Arguments to find a Shopping_categories\n     * @example\n     * // Get one Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_categoriesFindUniqueArgs>(args: SelectSubset<T, shopping_categoriesFindUniqueArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_categories that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Shopping_categories\n     * @example\n     * // Get one Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesFindFirstArgs} args - Arguments to find a Shopping_categories\n     * @example\n     * // Get one Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_categoriesFindFirstArgs>(args?: SelectSubset<T, shopping_categoriesFindFirstArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_categories that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesFindFirstOrThrowArgs} args - Arguments to find a Shopping_categories\n     * @example\n     * // Get one Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findMany()\n     * \n     * // Get first 10 Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_categoriesWithIdOnly = await prisma.shopping_categories.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_categoriesFindManyArgs>(args?: SelectSubset<T, shopping_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_categories.\n     * @param {shopping_categoriesCreateArgs} args - Arguments to create a Shopping_categories.\n     * @example\n     * // Create one Shopping_categories\n     * const Shopping_categories = await prisma.shopping_categories.create({\n     *   data: {\n     *     // ... data to create a Shopping_categories\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_categoriesCreateArgs>(args: SelectSubset<T, shopping_categoriesCreateArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_categories.\n     * @param {shopping_categoriesCreateManyArgs} args - Arguments to create many Shopping_categories.\n     * @example\n     * // Create many Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_categoriesCreateManyArgs>(args?: SelectSubset<T, shopping_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_categories and returns the data saved in the database.\n     * @param {shopping_categoriesCreateManyAndReturnArgs} args - Arguments to create many Shopping_categories.\n     * @example\n     * // Create many Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_categories and only return the `id`\n     * const shopping_categoriesWithIdOnly = await prisma.shopping_categories.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_categories.\n     * @param {shopping_categoriesDeleteArgs} args - Arguments to delete one Shopping_categories.\n     * @example\n     * // Delete one Shopping_categories\n     * const Shopping_categories = await prisma.shopping_categories.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_categories\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_categoriesDeleteArgs>(args: SelectSubset<T, shopping_categoriesDeleteArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_categories.\n     * @param {shopping_categoriesUpdateArgs} args - Arguments to update one Shopping_categories.\n     * @example\n     * // Update one Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_categoriesUpdateArgs>(args: SelectSubset<T, shopping_categoriesUpdateArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_categories.\n     * @param {shopping_categoriesDeleteManyArgs} args - Arguments to filter Shopping_categories to delete.\n     * @example\n     * // Delete a few Shopping_categories\n     * const { count } = await prisma.shopping_categories.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_categoriesDeleteManyArgs>(args?: SelectSubset<T, shopping_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_categoriesUpdateManyArgs>(args: SelectSubset<T, shopping_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_categories and returns the data updated in the database.\n     * @param {shopping_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Shopping_categories.\n     * @example\n     * // Update many Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_categories and only return the `id`\n     * const shopping_categoriesWithIdOnly = await prisma.shopping_categories.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_categories.\n     * @param {shopping_categoriesUpsertArgs} args - Arguments to update or create a Shopping_categories.\n     * @example\n     * // Update or create a Shopping_categories\n     * const shopping_categories = await prisma.shopping_categories.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_categories\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_categories we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_categoriesUpsertArgs>(args: SelectSubset<T, shopping_categoriesUpsertArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesCountArgs} args - Arguments to filter Shopping_categories to count.\n     * @example\n     * // Count the number of Shopping_categories\n     * const count = await prisma.shopping_categories.count({\n     *   where: {\n     *     // ... the filter for the Shopping_categories we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_categoriesCountArgs>(\n      args?: Subset<T, shopping_categoriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_categoriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_categoriesAggregateArgs>(args: Subset<T, Shopping_categoriesAggregateArgs>): Prisma.PrismaPromise<GetShopping_categoriesAggregateType<T>>\n\n    /**\n     * Group by Shopping_categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_categoriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_categoriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_categoriesGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_categoriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_categories model\n   */\n  readonly fields: shopping_categoriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_categories.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    parent<T extends shopping_categories$parentArgs<ExtArgs> = {}>(args?: Subset<T, shopping_categories$parentArgs<ExtArgs>>): Prisma__shopping_categoriesClient<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    shopping_products<T extends shopping_categories$shopping_productsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_categories$shopping_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    recursive<T extends shopping_categories$recursiveArgs<ExtArgs> = {}>(args?: Subset<T, shopping_categories$recursiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_categories model\n   */\n  interface shopping_categoriesFieldRefs {\n    readonly id: FieldRef<\"shopping_categories\", 'String'>\n    readonly parent_id: FieldRef<\"shopping_categories\", 'String'>\n    readonly name: FieldRef<\"shopping_categories\", 'String'>\n    readonly description: FieldRef<\"shopping_categories\", 'String'>\n    readonly code: FieldRef<\"shopping_categories\", 'String'>\n    readonly created_at: FieldRef<\"shopping_categories\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_categories\", 'DateTime'>\n    readonly business_status: FieldRef<\"shopping_categories\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_categories findUnique\n   */\n  export type shopping_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_categories to fetch.\n     */\n    where: shopping_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_categories findUniqueOrThrow\n   */\n  export type shopping_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_categories to fetch.\n     */\n    where: shopping_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_categories findFirst\n   */\n  export type shopping_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_categories to fetch.\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_categories to fetch.\n     */\n    orderBy?: shopping_categoriesOrderByWithRelationInput | shopping_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_categories.\n     */\n    cursor?: shopping_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_categories.\n     */\n    distinct?: Shopping_categoriesScalarFieldEnum | Shopping_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_categories findFirstOrThrow\n   */\n  export type shopping_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_categories to fetch.\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_categories to fetch.\n     */\n    orderBy?: shopping_categoriesOrderByWithRelationInput | shopping_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_categories.\n     */\n    cursor?: shopping_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_categories.\n     */\n    distinct?: Shopping_categoriesScalarFieldEnum | Shopping_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_categories findMany\n   */\n  export type shopping_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_categories to fetch.\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_categories to fetch.\n     */\n    orderBy?: shopping_categoriesOrderByWithRelationInput | shopping_categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_categories.\n     */\n    cursor?: shopping_categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_categories.\n     */\n    skip?: number\n    distinct?: Shopping_categoriesScalarFieldEnum | Shopping_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_categories create\n   */\n  export type shopping_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_categories.\n     */\n    data: XOR<shopping_categoriesCreateInput, shopping_categoriesUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_categories createMany\n   */\n  export type shopping_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_categories.\n     */\n    data: shopping_categoriesCreateManyInput | shopping_categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_categories createManyAndReturn\n   */\n  export type shopping_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_categories.\n     */\n    data: shopping_categoriesCreateManyInput | shopping_categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_categories update\n   */\n  export type shopping_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_categories.\n     */\n    data: XOR<shopping_categoriesUpdateInput, shopping_categoriesUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_categories to update.\n     */\n    where: shopping_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_categories updateMany\n   */\n  export type shopping_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_categories.\n     */\n    data: XOR<shopping_categoriesUpdateManyMutationInput, shopping_categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_categories to update\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * Limit how many shopping_categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_categories updateManyAndReturn\n   */\n  export type shopping_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_categories.\n     */\n    data: XOR<shopping_categoriesUpdateManyMutationInput, shopping_categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_categories to update\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * Limit how many shopping_categories to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_categories upsert\n   */\n  export type shopping_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_categories to update in case it exists.\n     */\n    where: shopping_categoriesWhereUniqueInput\n    /**\n     * In case the shopping_categories found by the `where` argument doesn't exist, create a new shopping_categories with this data.\n     */\n    create: XOR<shopping_categoriesCreateInput, shopping_categoriesUncheckedCreateInput>\n    /**\n     * In case the shopping_categories was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_categoriesUpdateInput, shopping_categoriesUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_categories delete\n   */\n  export type shopping_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_categories to delete.\n     */\n    where: shopping_categoriesWhereUniqueInput\n  }\n\n  /**\n   * shopping_categories deleteMany\n   */\n  export type shopping_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_categories to delete\n     */\n    where?: shopping_categoriesWhereInput\n    /**\n     * Limit how many shopping_categories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_categories.parent\n   */\n  export type shopping_categories$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    where?: shopping_categoriesWhereInput\n  }\n\n  /**\n   * shopping_categories.shopping_products\n   */\n  export type shopping_categories$shopping_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_products\n     */\n    select?: shopping_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_products\n     */\n    omit?: shopping_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_productsInclude<ExtArgs> | null\n    where?: shopping_productsWhereInput\n    orderBy?: shopping_productsOrderByWithRelationInput | shopping_productsOrderByWithRelationInput[]\n    cursor?: shopping_productsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_productsScalarFieldEnum | Shopping_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_categories.recursive\n   */\n  export type shopping_categories$recursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n    where?: shopping_categoriesWhereInput\n    orderBy?: shopping_categoriesOrderByWithRelationInput | shopping_categoriesOrderByWithRelationInput[]\n    cursor?: shopping_categoriesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_categoriesScalarFieldEnum | Shopping_categoriesScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_categories without action\n   */\n  export type shopping_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_categories\n     */\n    select?: shopping_categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_categories\n     */\n    omit?: shopping_categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_categoriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_inventory\n   */\n\n  export type AggregateShopping_inventory = {\n    _count: Shopping_inventoryCountAggregateOutputType | null\n    _avg: Shopping_inventoryAvgAggregateOutputType | null\n    _sum: Shopping_inventorySumAggregateOutputType | null\n    _min: Shopping_inventoryMinAggregateOutputType | null\n    _max: Shopping_inventoryMaxAggregateOutputType | null\n  }\n\n  export type Shopping_inventoryAvgAggregateOutputType = {\n    quantity: number | null\n    reserved_quantity: number | null\n    low_stock_threshold: number | null\n  }\n\n  export type Shopping_inventorySumAggregateOutputType = {\n    quantity: number | null\n    reserved_quantity: number | null\n    low_stock_threshold: number | null\n  }\n\n  export type Shopping_inventoryMinAggregateOutputType = {\n    id: string | null\n    shopping_product_variant_id: string | null\n    shopping_product_id: string | null\n    quantity: number | null\n    reserved_quantity: number | null\n    low_stock_threshold: number | null\n    last_stock_update: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_inventoryMaxAggregateOutputType = {\n    id: string | null\n    shopping_product_variant_id: string | null\n    shopping_product_id: string | null\n    quantity: number | null\n    reserved_quantity: number | null\n    low_stock_threshold: number | null\n    last_stock_update: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_inventoryCountAggregateOutputType = {\n    id: number\n    shopping_product_variant_id: number\n    shopping_product_id: number\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold: number\n    last_stock_update: number\n    created_at: number\n    updated_at: number\n    business_status: number\n    _all: number\n  }\n\n\n  export type Shopping_inventoryAvgAggregateInputType = {\n    quantity?: true\n    reserved_quantity?: true\n    low_stock_threshold?: true\n  }\n\n  export type Shopping_inventorySumAggregateInputType = {\n    quantity?: true\n    reserved_quantity?: true\n    low_stock_threshold?: true\n  }\n\n  export type Shopping_inventoryMinAggregateInputType = {\n    id?: true\n    shopping_product_variant_id?: true\n    shopping_product_id?: true\n    quantity?: true\n    reserved_quantity?: true\n    low_stock_threshold?: true\n    last_stock_update?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_inventoryMaxAggregateInputType = {\n    id?: true\n    shopping_product_variant_id?: true\n    shopping_product_id?: true\n    quantity?: true\n    reserved_quantity?: true\n    low_stock_threshold?: true\n    last_stock_update?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_inventoryCountAggregateInputType = {\n    id?: true\n    shopping_product_variant_id?: true\n    shopping_product_id?: true\n    quantity?: true\n    reserved_quantity?: true\n    low_stock_threshold?: true\n    last_stock_update?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n    _all?: true\n  }\n\n  export type Shopping_inventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inventory to aggregate.\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inventories to fetch.\n     */\n    orderBy?: shopping_inventoryOrderByWithRelationInput | shopping_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_inventories\n    **/\n    _count?: true | Shopping_inventoryCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_inventoryAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_inventorySumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_inventoryMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_inventoryMaxAggregateInputType\n  }\n\n  export type GetShopping_inventoryAggregateType<T extends Shopping_inventoryAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_inventory]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_inventory[P]>\n      : GetScalarType<T[P], AggregateShopping_inventory[P]>\n  }\n\n\n\n\n  export type shopping_inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_inventoryWhereInput\n    orderBy?: shopping_inventoryOrderByWithAggregationInput | shopping_inventoryOrderByWithAggregationInput[]\n    by: Shopping_inventoryScalarFieldEnum[] | Shopping_inventoryScalarFieldEnum\n    having?: shopping_inventoryScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_inventoryCountAggregateInputType | true\n    _avg?: Shopping_inventoryAvgAggregateInputType\n    _sum?: Shopping_inventorySumAggregateInputType\n    _min?: Shopping_inventoryMinAggregateInputType\n    _max?: Shopping_inventoryMaxAggregateInputType\n  }\n\n  export type Shopping_inventoryGroupByOutputType = {\n    id: string\n    shopping_product_variant_id: string\n    shopping_product_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold: number | null\n    last_stock_update: Date | null\n    created_at: Date\n    updated_at: Date\n    business_status: string | null\n    _count: Shopping_inventoryCountAggregateOutputType | null\n    _avg: Shopping_inventoryAvgAggregateOutputType | null\n    _sum: Shopping_inventorySumAggregateOutputType | null\n    _min: Shopping_inventoryMinAggregateOutputType | null\n    _max: Shopping_inventoryMaxAggregateOutputType | null\n  }\n\n  type GetShopping_inventoryGroupByPayload<T extends shopping_inventoryGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_inventoryGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_inventoryGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_inventoryGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_inventoryGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_variant_id?: boolean\n    shopping_product_id?: boolean\n    quantity?: boolean\n    reserved_quantity?: boolean\n    low_stock_threshold?: boolean\n    last_stock_update?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inventory\"]>\n\n  export type shopping_inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_variant_id?: boolean\n    shopping_product_id?: boolean\n    quantity?: boolean\n    reserved_quantity?: boolean\n    low_stock_threshold?: boolean\n    last_stock_update?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inventory\"]>\n\n  export type shopping_inventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_variant_id?: boolean\n    shopping_product_id?: boolean\n    quantity?: boolean\n    reserved_quantity?: boolean\n    low_stock_threshold?: boolean\n    last_stock_update?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_inventory\"]>\n\n  export type shopping_inventorySelectScalar = {\n    id?: boolean\n    shopping_product_variant_id?: boolean\n    shopping_product_id?: boolean\n    quantity?: boolean\n    reserved_quantity?: boolean\n    low_stock_threshold?: boolean\n    last_stock_update?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n  }\n\n  export type shopping_inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_product_variant_id\" | \"shopping_product_id\" | \"quantity\" | \"reserved_quantity\" | \"low_stock_threshold\" | \"last_stock_update\" | \"created_at\" | \"updated_at\" | \"business_status\", ExtArgs[\"result\"][\"shopping_inventory\"]>\n  export type shopping_inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n  export type shopping_inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n  export type shopping_inventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    variant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_inventory\"\n    objects: {\n      variant: Prisma.$shopping_product_variantsPayload<ExtArgs>\n      product: Prisma.$shopping_productsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Product variant this inventory tracks. {@link\n       * shopping_product_variants.id}.\n       */\n      shopping_product_variant_id: string\n      /**\n       * Product this inventory belongs to. {@link shopping_products.id}.\n       */\n      shopping_product_id: string\n      /**\n       * Current available quantity.\n       */\n      quantity: number\n      /**\n       * Quantity reserved for pending orders.\n       */\n      reserved_quantity: number\n      /**\n       * Threshold for low stock alerts.\n       */\n      low_stock_threshold: number | null\n      /**\n       * Timestamp of last stock update.\n       */\n      last_stock_update: Date | null\n      /**\n       * Timestamp when the inventory record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the inventory record was last updated.\n       */\n      updated_at: Date\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n    }, ExtArgs[\"result\"][\"shopping_inventory\"]>\n    composites: {}\n  }\n\n  type shopping_inventoryGetPayload<S extends boolean | null | undefined | shopping_inventoryDefaultArgs> = $Result.GetResult<Prisma.$shopping_inventoryPayload, S>\n\n  type shopping_inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_inventoryCountAggregateInputType | true\n    }\n\n  export interface shopping_inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_inventory'], meta: { name: 'shopping_inventory' } }\n    /**\n     * Find zero or one Shopping_inventory that matches the filter.\n     * @param {shopping_inventoryFindUniqueArgs} args - Arguments to find a Shopping_inventory\n     * @example\n     * // Get one Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_inventoryFindUniqueArgs>(args: SelectSubset<T, shopping_inventoryFindUniqueArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_inventory that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_inventoryFindUniqueOrThrowArgs} args - Arguments to find a Shopping_inventory\n     * @example\n     * // Get one Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inventory that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryFindFirstArgs} args - Arguments to find a Shopping_inventory\n     * @example\n     * // Get one Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_inventoryFindFirstArgs>(args?: SelectSubset<T, shopping_inventoryFindFirstArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_inventory that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryFindFirstOrThrowArgs} args - Arguments to find a Shopping_inventory\n     * @example\n     * // Get one Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_inventories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_inventories\n     * const shopping_inventories = await prisma.shopping_inventory.findMany()\n     * \n     * // Get first 10 Shopping_inventories\n     * const shopping_inventories = await prisma.shopping_inventory.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_inventoryWithIdOnly = await prisma.shopping_inventory.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_inventoryFindManyArgs>(args?: SelectSubset<T, shopping_inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_inventory.\n     * @param {shopping_inventoryCreateArgs} args - Arguments to create a Shopping_inventory.\n     * @example\n     * // Create one Shopping_inventory\n     * const Shopping_inventory = await prisma.shopping_inventory.create({\n     *   data: {\n     *     // ... data to create a Shopping_inventory\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_inventoryCreateArgs>(args: SelectSubset<T, shopping_inventoryCreateArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_inventories.\n     * @param {shopping_inventoryCreateManyArgs} args - Arguments to create many Shopping_inventories.\n     * @example\n     * // Create many Shopping_inventories\n     * const shopping_inventory = await prisma.shopping_inventory.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_inventoryCreateManyArgs>(args?: SelectSubset<T, shopping_inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_inventories and returns the data saved in the database.\n     * @param {shopping_inventoryCreateManyAndReturnArgs} args - Arguments to create many Shopping_inventories.\n     * @example\n     * // Create many Shopping_inventories\n     * const shopping_inventory = await prisma.shopping_inventory.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_inventories and only return the `id`\n     * const shopping_inventoryWithIdOnly = await prisma.shopping_inventory.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_inventory.\n     * @param {shopping_inventoryDeleteArgs} args - Arguments to delete one Shopping_inventory.\n     * @example\n     * // Delete one Shopping_inventory\n     * const Shopping_inventory = await prisma.shopping_inventory.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_inventory\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_inventoryDeleteArgs>(args: SelectSubset<T, shopping_inventoryDeleteArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_inventory.\n     * @param {shopping_inventoryUpdateArgs} args - Arguments to update one Shopping_inventory.\n     * @example\n     * // Update one Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_inventoryUpdateArgs>(args: SelectSubset<T, shopping_inventoryUpdateArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_inventories.\n     * @param {shopping_inventoryDeleteManyArgs} args - Arguments to filter Shopping_inventories to delete.\n     * @example\n     * // Delete a few Shopping_inventories\n     * const { count } = await prisma.shopping_inventory.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_inventoryDeleteManyArgs>(args?: SelectSubset<T, shopping_inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inventories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_inventories\n     * const shopping_inventory = await prisma.shopping_inventory.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_inventoryUpdateManyArgs>(args: SelectSubset<T, shopping_inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_inventories and returns the data updated in the database.\n     * @param {shopping_inventoryUpdateManyAndReturnArgs} args - Arguments to update many Shopping_inventories.\n     * @example\n     * // Update many Shopping_inventories\n     * const shopping_inventory = await prisma.shopping_inventory.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_inventories and only return the `id`\n     * const shopping_inventoryWithIdOnly = await prisma.shopping_inventory.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_inventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_inventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_inventory.\n     * @param {shopping_inventoryUpsertArgs} args - Arguments to update or create a Shopping_inventory.\n     * @example\n     * // Update or create a Shopping_inventory\n     * const shopping_inventory = await prisma.shopping_inventory.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_inventory\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_inventory we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_inventoryUpsertArgs>(args: SelectSubset<T, shopping_inventoryUpsertArgs<ExtArgs>>): Prisma__shopping_inventoryClient<$Result.GetResult<Prisma.$shopping_inventoryPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_inventories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryCountArgs} args - Arguments to filter Shopping_inventories to count.\n     * @example\n     * // Count the number of Shopping_inventories\n     * const count = await prisma.shopping_inventory.count({\n     *   where: {\n     *     // ... the filter for the Shopping_inventories we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_inventoryCountArgs>(\n      args?: Subset<T, shopping_inventoryCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_inventoryCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_inventory.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_inventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_inventoryAggregateArgs>(args: Subset<T, Shopping_inventoryAggregateArgs>): Prisma.PrismaPromise<GetShopping_inventoryAggregateType<T>>\n\n    /**\n     * Group by Shopping_inventory.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_inventoryGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_inventoryGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_inventoryGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_inventoryGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_inventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_inventory model\n   */\n  readonly fields: shopping_inventoryFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_inventory.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    variant<T extends shopping_product_variantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variantsDefaultArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    product<T extends shopping_productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_productsDefaultArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_inventory model\n   */\n  interface shopping_inventoryFieldRefs {\n    readonly id: FieldRef<\"shopping_inventory\", 'String'>\n    readonly shopping_product_variant_id: FieldRef<\"shopping_inventory\", 'String'>\n    readonly shopping_product_id: FieldRef<\"shopping_inventory\", 'String'>\n    readonly quantity: FieldRef<\"shopping_inventory\", 'Int'>\n    readonly reserved_quantity: FieldRef<\"shopping_inventory\", 'Int'>\n    readonly low_stock_threshold: FieldRef<\"shopping_inventory\", 'Int'>\n    readonly last_stock_update: FieldRef<\"shopping_inventory\", 'DateTime'>\n    readonly created_at: FieldRef<\"shopping_inventory\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_inventory\", 'DateTime'>\n    readonly business_status: FieldRef<\"shopping_inventory\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_inventory findUnique\n   */\n  export type shopping_inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inventory to fetch.\n     */\n    where: shopping_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_inventory findUniqueOrThrow\n   */\n  export type shopping_inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inventory to fetch.\n     */\n    where: shopping_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_inventory findFirst\n   */\n  export type shopping_inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inventory to fetch.\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inventories to fetch.\n     */\n    orderBy?: shopping_inventoryOrderByWithRelationInput | shopping_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inventories.\n     */\n    cursor?: shopping_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inventories.\n     */\n    distinct?: Shopping_inventoryScalarFieldEnum | Shopping_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inventory findFirstOrThrow\n   */\n  export type shopping_inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inventory to fetch.\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inventories to fetch.\n     */\n    orderBy?: shopping_inventoryOrderByWithRelationInput | shopping_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_inventories.\n     */\n    cursor?: shopping_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_inventories.\n     */\n    distinct?: Shopping_inventoryScalarFieldEnum | Shopping_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inventory findMany\n   */\n  export type shopping_inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_inventories to fetch.\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_inventories to fetch.\n     */\n    orderBy?: shopping_inventoryOrderByWithRelationInput | shopping_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_inventories.\n     */\n    cursor?: shopping_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_inventories.\n     */\n    skip?: number\n    distinct?: Shopping_inventoryScalarFieldEnum | Shopping_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_inventory create\n   */\n  export type shopping_inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_inventory.\n     */\n    data: XOR<shopping_inventoryCreateInput, shopping_inventoryUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_inventory createMany\n   */\n  export type shopping_inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_inventories.\n     */\n    data: shopping_inventoryCreateManyInput | shopping_inventoryCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_inventory createManyAndReturn\n   */\n  export type shopping_inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_inventories.\n     */\n    data: shopping_inventoryCreateManyInput | shopping_inventoryCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inventory update\n   */\n  export type shopping_inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_inventory.\n     */\n    data: XOR<shopping_inventoryUpdateInput, shopping_inventoryUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_inventory to update.\n     */\n    where: shopping_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_inventory updateMany\n   */\n  export type shopping_inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_inventories.\n     */\n    data: XOR<shopping_inventoryUpdateManyMutationInput, shopping_inventoryUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inventories to update\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * Limit how many shopping_inventories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inventory updateManyAndReturn\n   */\n  export type shopping_inventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_inventories.\n     */\n    data: XOR<shopping_inventoryUpdateManyMutationInput, shopping_inventoryUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_inventories to update\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * Limit how many shopping_inventories to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_inventory upsert\n   */\n  export type shopping_inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_inventory to update in case it exists.\n     */\n    where: shopping_inventoryWhereUniqueInput\n    /**\n     * In case the shopping_inventory found by the `where` argument doesn't exist, create a new shopping_inventory with this data.\n     */\n    create: XOR<shopping_inventoryCreateInput, shopping_inventoryUncheckedCreateInput>\n    /**\n     * In case the shopping_inventory was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_inventoryUpdateInput, shopping_inventoryUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_inventory delete\n   */\n  export type shopping_inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_inventory to delete.\n     */\n    where: shopping_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_inventory deleteMany\n   */\n  export type shopping_inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_inventories to delete\n     */\n    where?: shopping_inventoryWhereInput\n    /**\n     * Limit how many shopping_inventories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_inventory without action\n   */\n  export type shopping_inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_inventory\n     */\n    select?: shopping_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_inventory\n     */\n    omit?: shopping_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_inventoryInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_product_reviews\n   */\n\n  export type AggregateShopping_product_reviews = {\n    _count: Shopping_product_reviewsCountAggregateOutputType | null\n    _avg: Shopping_product_reviewsAvgAggregateOutputType | null\n    _sum: Shopping_product_reviewsSumAggregateOutputType | null\n    _min: Shopping_product_reviewsMinAggregateOutputType | null\n    _max: Shopping_product_reviewsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_product_reviewsAvgAggregateOutputType = {\n    rating: number | null\n  }\n\n  export type Shopping_product_reviewsSumAggregateOutputType = {\n    rating: number | null\n  }\n\n  export type Shopping_product_reviewsMinAggregateOutputType = {\n    id: string | null\n    shopping_product_id: string | null\n    shopping_customer_id: string | null\n    rating: number | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_product_reviewsMaxAggregateOutputType = {\n    id: string | null\n    shopping_product_id: string | null\n    shopping_customer_id: string | null\n    rating: number | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    business_status: string | null\n  }\n\n  export type Shopping_product_reviewsCountAggregateOutputType = {\n    id: number\n    shopping_product_id: number\n    shopping_customer_id: number\n    rating: number\n    title: number\n    content: number\n    created_at: number\n    updated_at: number\n    business_status: number\n    _all: number\n  }\n\n\n  export type Shopping_product_reviewsAvgAggregateInputType = {\n    rating?: true\n  }\n\n  export type Shopping_product_reviewsSumAggregateInputType = {\n    rating?: true\n  }\n\n  export type Shopping_product_reviewsMinAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    shopping_customer_id?: true\n    rating?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_product_reviewsMaxAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    shopping_customer_id?: true\n    rating?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n  }\n\n  export type Shopping_product_reviewsCountAggregateInputType = {\n    id?: true\n    shopping_product_id?: true\n    shopping_customer_id?: true\n    rating?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    business_status?: true\n    _all?: true\n  }\n\n  export type Shopping_product_reviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_product_reviews to aggregate.\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_reviews to fetch.\n     */\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_reviews from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_reviews.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_product_reviews\n    **/\n    _count?: true | Shopping_product_reviewsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_product_reviewsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_product_reviewsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_product_reviewsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_product_reviewsMaxAggregateInputType\n  }\n\n  export type GetShopping_product_reviewsAggregateType<T extends Shopping_product_reviewsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_product_reviews]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_product_reviews[P]>\n      : GetScalarType<T[P], AggregateShopping_product_reviews[P]>\n  }\n\n\n\n\n  export type shopping_product_reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_product_reviewsWhereInput\n    orderBy?: shopping_product_reviewsOrderByWithAggregationInput | shopping_product_reviewsOrderByWithAggregationInput[]\n    by: Shopping_product_reviewsScalarFieldEnum[] | Shopping_product_reviewsScalarFieldEnum\n    having?: shopping_product_reviewsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_product_reviewsCountAggregateInputType | true\n    _avg?: Shopping_product_reviewsAvgAggregateInputType\n    _sum?: Shopping_product_reviewsSumAggregateInputType\n    _min?: Shopping_product_reviewsMinAggregateInputType\n    _max?: Shopping_product_reviewsMaxAggregateInputType\n  }\n\n  export type Shopping_product_reviewsGroupByOutputType = {\n    id: string\n    shopping_product_id: string\n    shopping_customer_id: string\n    rating: number\n    title: string | null\n    content: string\n    created_at: Date\n    updated_at: Date\n    business_status: string | null\n    _count: Shopping_product_reviewsCountAggregateOutputType | null\n    _avg: Shopping_product_reviewsAvgAggregateOutputType | null\n    _sum: Shopping_product_reviewsSumAggregateOutputType | null\n    _min: Shopping_product_reviewsMinAggregateOutputType | null\n    _max: Shopping_product_reviewsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_product_reviewsGroupByPayload<T extends shopping_product_reviewsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_product_reviewsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_product_reviewsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_product_reviewsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_product_reviewsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_product_reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    shopping_customer_id?: boolean\n    rating?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_review_moderation?: boolean | shopping_product_reviews$shopping_review_moderationArgs<ExtArgs>\n    shopping_review_ratings?: boolean | shopping_product_reviews$shopping_review_ratingsArgs<ExtArgs>\n    _count?: boolean | Shopping_product_reviewsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_reviews\"]>\n\n  export type shopping_product_reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    shopping_customer_id?: boolean\n    rating?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_reviews\"]>\n\n  export type shopping_product_reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_id?: boolean\n    shopping_customer_id?: boolean\n    rating?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_product_reviews\"]>\n\n  export type shopping_product_reviewsSelectScalar = {\n    id?: boolean\n    shopping_product_id?: boolean\n    shopping_customer_id?: boolean\n    rating?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    business_status?: boolean\n  }\n\n  export type shopping_product_reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_product_id\" | \"shopping_customer_id\" | \"rating\" | \"title\" | \"content\" | \"created_at\" | \"updated_at\" | \"business_status\", ExtArgs[\"result\"][\"shopping_product_reviews\"]>\n  export type shopping_product_reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_review_moderation?: boolean | shopping_product_reviews$shopping_review_moderationArgs<ExtArgs>\n    shopping_review_ratings?: boolean | shopping_product_reviews$shopping_review_ratingsArgs<ExtArgs>\n    _count?: boolean | Shopping_product_reviewsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_product_reviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n  export type shopping_product_reviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_product_reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_product_reviews\"\n    objects: {\n      product: Prisma.$shopping_productsPayload<ExtArgs>\n      customer: Prisma.$shopping_customersPayload<ExtArgs>\n      shopping_review_moderation: Prisma.$shopping_review_moderationPayload<ExtArgs>[]\n      shopping_review_ratings: Prisma.$shopping_review_ratingsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Product this review is for. {@link shopping_products.id}.\n       */\n      shopping_product_id: string\n      /**\n       * Customer who left the review. {@link shopping_customers.id}.\n       */\n      shopping_customer_id: string\n      /**\n       * Rating score (1-5).\n       */\n      rating: number\n      /**\n       * Title of the review.\n       */\n      title: string | null\n      /**\n       * Main content of the review.\n       */\n      content: string\n      /**\n       * Timestamp when the review was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the review was last updated.\n       */\n      updated_at: Date\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n    }, ExtArgs[\"result\"][\"shopping_product_reviews\"]>\n    composites: {}\n  }\n\n  type shopping_product_reviewsGetPayload<S extends boolean | null | undefined | shopping_product_reviewsDefaultArgs> = $Result.GetResult<Prisma.$shopping_product_reviewsPayload, S>\n\n  type shopping_product_reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_product_reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_product_reviewsCountAggregateInputType | true\n    }\n\n  export interface shopping_product_reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_product_reviews'], meta: { name: 'shopping_product_reviews' } }\n    /**\n     * Find zero or one Shopping_product_reviews that matches the filter.\n     * @param {shopping_product_reviewsFindUniqueArgs} args - Arguments to find a Shopping_product_reviews\n     * @example\n     * // Get one Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_product_reviewsFindUniqueArgs>(args: SelectSubset<T, shopping_product_reviewsFindUniqueArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_product_reviews that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_product_reviewsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_product_reviews\n     * @example\n     * // Get one Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_product_reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_product_reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_product_reviews that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsFindFirstArgs} args - Arguments to find a Shopping_product_reviews\n     * @example\n     * // Get one Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_product_reviewsFindFirstArgs>(args?: SelectSubset<T, shopping_product_reviewsFindFirstArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_product_reviews that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsFindFirstOrThrowArgs} args - Arguments to find a Shopping_product_reviews\n     * @example\n     * // Get one Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_product_reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_product_reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_product_reviews that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findMany()\n     * \n     * // Get first 10 Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_product_reviewsWithIdOnly = await prisma.shopping_product_reviews.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_product_reviewsFindManyArgs>(args?: SelectSubset<T, shopping_product_reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_product_reviews.\n     * @param {shopping_product_reviewsCreateArgs} args - Arguments to create a Shopping_product_reviews.\n     * @example\n     * // Create one Shopping_product_reviews\n     * const Shopping_product_reviews = await prisma.shopping_product_reviews.create({\n     *   data: {\n     *     // ... data to create a Shopping_product_reviews\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_product_reviewsCreateArgs>(args: SelectSubset<T, shopping_product_reviewsCreateArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_product_reviews.\n     * @param {shopping_product_reviewsCreateManyArgs} args - Arguments to create many Shopping_product_reviews.\n     * @example\n     * // Create many Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_product_reviewsCreateManyArgs>(args?: SelectSubset<T, shopping_product_reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_product_reviews and returns the data saved in the database.\n     * @param {shopping_product_reviewsCreateManyAndReturnArgs} args - Arguments to create many Shopping_product_reviews.\n     * @example\n     * // Create many Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_product_reviews and only return the `id`\n     * const shopping_product_reviewsWithIdOnly = await prisma.shopping_product_reviews.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_product_reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_product_reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_product_reviews.\n     * @param {shopping_product_reviewsDeleteArgs} args - Arguments to delete one Shopping_product_reviews.\n     * @example\n     * // Delete one Shopping_product_reviews\n     * const Shopping_product_reviews = await prisma.shopping_product_reviews.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_product_reviews\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_product_reviewsDeleteArgs>(args: SelectSubset<T, shopping_product_reviewsDeleteArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_product_reviews.\n     * @param {shopping_product_reviewsUpdateArgs} args - Arguments to update one Shopping_product_reviews.\n     * @example\n     * // Update one Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_product_reviewsUpdateArgs>(args: SelectSubset<T, shopping_product_reviewsUpdateArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_product_reviews.\n     * @param {shopping_product_reviewsDeleteManyArgs} args - Arguments to filter Shopping_product_reviews to delete.\n     * @example\n     * // Delete a few Shopping_product_reviews\n     * const { count } = await prisma.shopping_product_reviews.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_product_reviewsDeleteManyArgs>(args?: SelectSubset<T, shopping_product_reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_product_reviews.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_product_reviewsUpdateManyArgs>(args: SelectSubset<T, shopping_product_reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_product_reviews and returns the data updated in the database.\n     * @param {shopping_product_reviewsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_product_reviews.\n     * @example\n     * // Update many Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_product_reviews and only return the `id`\n     * const shopping_product_reviewsWithIdOnly = await prisma.shopping_product_reviews.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_product_reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_product_reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_product_reviews.\n     * @param {shopping_product_reviewsUpsertArgs} args - Arguments to update or create a Shopping_product_reviews.\n     * @example\n     * // Update or create a Shopping_product_reviews\n     * const shopping_product_reviews = await prisma.shopping_product_reviews.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_product_reviews\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_product_reviews we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_product_reviewsUpsertArgs>(args: SelectSubset<T, shopping_product_reviewsUpsertArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_product_reviews.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsCountArgs} args - Arguments to filter Shopping_product_reviews to count.\n     * @example\n     * // Count the number of Shopping_product_reviews\n     * const count = await prisma.shopping_product_reviews.count({\n     *   where: {\n     *     // ... the filter for the Shopping_product_reviews we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_product_reviewsCountArgs>(\n      args?: Subset<T, shopping_product_reviewsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_product_reviewsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_product_reviews.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_product_reviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_product_reviewsAggregateArgs>(args: Subset<T, Shopping_product_reviewsAggregateArgs>): Prisma.PrismaPromise<GetShopping_product_reviewsAggregateType<T>>\n\n    /**\n     * Group by Shopping_product_reviews.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_product_reviewsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_product_reviewsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_product_reviewsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_product_reviewsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_product_reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_product_reviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_product_reviews model\n   */\n  readonly fields: shopping_product_reviewsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_product_reviews.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_product_reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    product<T extends shopping_productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_productsDefaultArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    customer<T extends shopping_customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customersDefaultArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_review_moderation<T extends shopping_product_reviews$shopping_review_moderationArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_reviews$shopping_review_moderationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_review_ratings<T extends shopping_product_reviews$shopping_review_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_reviews$shopping_review_ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_product_reviews model\n   */\n  interface shopping_product_reviewsFieldRefs {\n    readonly id: FieldRef<\"shopping_product_reviews\", 'String'>\n    readonly shopping_product_id: FieldRef<\"shopping_product_reviews\", 'String'>\n    readonly shopping_customer_id: FieldRef<\"shopping_product_reviews\", 'String'>\n    readonly rating: FieldRef<\"shopping_product_reviews\", 'Int'>\n    readonly title: FieldRef<\"shopping_product_reviews\", 'String'>\n    readonly content: FieldRef<\"shopping_product_reviews\", 'String'>\n    readonly created_at: FieldRef<\"shopping_product_reviews\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_product_reviews\", 'DateTime'>\n    readonly business_status: FieldRef<\"shopping_product_reviews\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_product_reviews findUnique\n   */\n  export type shopping_product_reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_reviews to fetch.\n     */\n    where: shopping_product_reviewsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_reviews findUniqueOrThrow\n   */\n  export type shopping_product_reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_reviews to fetch.\n     */\n    where: shopping_product_reviewsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_reviews findFirst\n   */\n  export type shopping_product_reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_reviews to fetch.\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_reviews to fetch.\n     */\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_product_reviews.\n     */\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_reviews from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_reviews.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_product_reviews.\n     */\n    distinct?: Shopping_product_reviewsScalarFieldEnum | Shopping_product_reviewsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_reviews findFirstOrThrow\n   */\n  export type shopping_product_reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_reviews to fetch.\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_reviews to fetch.\n     */\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_product_reviews.\n     */\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_reviews from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_reviews.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_product_reviews.\n     */\n    distinct?: Shopping_product_reviewsScalarFieldEnum | Shopping_product_reviewsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_reviews findMany\n   */\n  export type shopping_product_reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_product_reviews to fetch.\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_product_reviews to fetch.\n     */\n    orderBy?: shopping_product_reviewsOrderByWithRelationInput | shopping_product_reviewsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_product_reviews.\n     */\n    cursor?: shopping_product_reviewsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_product_reviews from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_product_reviews.\n     */\n    skip?: number\n    distinct?: Shopping_product_reviewsScalarFieldEnum | Shopping_product_reviewsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_reviews create\n   */\n  export type shopping_product_reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_product_reviews.\n     */\n    data: XOR<shopping_product_reviewsCreateInput, shopping_product_reviewsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_product_reviews createMany\n   */\n  export type shopping_product_reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_product_reviews.\n     */\n    data: shopping_product_reviewsCreateManyInput | shopping_product_reviewsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_product_reviews createManyAndReturn\n   */\n  export type shopping_product_reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_product_reviews.\n     */\n    data: shopping_product_reviewsCreateManyInput | shopping_product_reviewsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_product_reviews update\n   */\n  export type shopping_product_reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_product_reviews.\n     */\n    data: XOR<shopping_product_reviewsUpdateInput, shopping_product_reviewsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_product_reviews to update.\n     */\n    where: shopping_product_reviewsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_reviews updateMany\n   */\n  export type shopping_product_reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_product_reviews.\n     */\n    data: XOR<shopping_product_reviewsUpdateManyMutationInput, shopping_product_reviewsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_product_reviews to update\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * Limit how many shopping_product_reviews to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_product_reviews updateManyAndReturn\n   */\n  export type shopping_product_reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_product_reviews.\n     */\n    data: XOR<shopping_product_reviewsUpdateManyMutationInput, shopping_product_reviewsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_product_reviews to update\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * Limit how many shopping_product_reviews to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_product_reviews upsert\n   */\n  export type shopping_product_reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_product_reviews to update in case it exists.\n     */\n    where: shopping_product_reviewsWhereUniqueInput\n    /**\n     * In case the shopping_product_reviews found by the `where` argument doesn't exist, create a new shopping_product_reviews with this data.\n     */\n    create: XOR<shopping_product_reviewsCreateInput, shopping_product_reviewsUncheckedCreateInput>\n    /**\n     * In case the shopping_product_reviews was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_product_reviewsUpdateInput, shopping_product_reviewsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_product_reviews delete\n   */\n  export type shopping_product_reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_product_reviews to delete.\n     */\n    where: shopping_product_reviewsWhereUniqueInput\n  }\n\n  /**\n   * shopping_product_reviews deleteMany\n   */\n  export type shopping_product_reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_product_reviews to delete\n     */\n    where?: shopping_product_reviewsWhereInput\n    /**\n     * Limit how many shopping_product_reviews to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_product_reviews.shopping_review_moderation\n   */\n  export type shopping_product_reviews$shopping_review_moderationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    where?: shopping_review_moderationWhereInput\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    cursor?: shopping_review_moderationWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_review_moderationScalarFieldEnum | Shopping_review_moderationScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_reviews.shopping_review_ratings\n   */\n  export type shopping_product_reviews$shopping_review_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    where?: shopping_review_ratingsWhereInput\n    orderBy?: shopping_review_ratingsOrderByWithRelationInput | shopping_review_ratingsOrderByWithRelationInput[]\n    cursor?: shopping_review_ratingsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_review_ratingsScalarFieldEnum | Shopping_review_ratingsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_product_reviews without action\n   */\n  export type shopping_product_reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_product_reviews\n     */\n    select?: shopping_product_reviewsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_product_reviews\n     */\n    omit?: shopping_product_reviewsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_product_reviewsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_orders\n   */\n\n  export type AggregateShopping_orders = {\n    _count: Shopping_ordersCountAggregateOutputType | null\n    _avg: Shopping_ordersAvgAggregateOutputType | null\n    _sum: Shopping_ordersSumAggregateOutputType | null\n    _min: Shopping_ordersMinAggregateOutputType | null\n    _max: Shopping_ordersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_ordersAvgAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_ordersSumAggregateOutputType = {\n    total_amount: number | null\n  }\n\n  export type Shopping_ordersMinAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    order_code: string | null\n    total_amount: number | null\n    currency: string | null\n    status: string | null\n    payment_method: string | null\n    shipping_method: string | null\n    shipping_address: string | null\n    billing_address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_ordersMaxAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    order_code: string | null\n    total_amount: number | null\n    currency: string | null\n    status: string | null\n    payment_method: string | null\n    shipping_method: string | null\n    shipping_address: string | null\n    billing_address: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_ordersCountAggregateOutputType = {\n    id: number\n    shopping_customer_id: number\n    order_code: number\n    total_amount: number\n    currency: number\n    status: number\n    payment_method: number\n    shipping_method: number\n    shipping_address: number\n    billing_address: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_ordersAvgAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_ordersSumAggregateInputType = {\n    total_amount?: true\n  }\n\n  export type Shopping_ordersMinAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    order_code?: true\n    total_amount?: true\n    currency?: true\n    status?: true\n    payment_method?: true\n    shipping_method?: true\n    shipping_address?: true\n    billing_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_ordersMaxAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    order_code?: true\n    total_amount?: true\n    currency?: true\n    status?: true\n    payment_method?: true\n    shipping_method?: true\n    shipping_address?: true\n    billing_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_ordersCountAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    order_code?: true\n    total_amount?: true\n    currency?: true\n    status?: true\n    payment_method?: true\n    shipping_method?: true\n    shipping_address?: true\n    billing_address?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_orders to aggregate.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_orders\n    **/\n    _count?: true | Shopping_ordersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_ordersAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_ordersSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_ordersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_ordersMaxAggregateInputType\n  }\n\n  export type GetShopping_ordersAggregateType<T extends Shopping_ordersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_orders]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_orders[P]>\n      : GetScalarType<T[P], AggregateShopping_orders[P]>\n  }\n\n\n\n\n  export type shopping_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_ordersWhereInput\n    orderBy?: shopping_ordersOrderByWithAggregationInput | shopping_ordersOrderByWithAggregationInput[]\n    by: Shopping_ordersScalarFieldEnum[] | Shopping_ordersScalarFieldEnum\n    having?: shopping_ordersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_ordersCountAggregateInputType | true\n    _avg?: Shopping_ordersAvgAggregateInputType\n    _sum?: Shopping_ordersSumAggregateInputType\n    _min?: Shopping_ordersMinAggregateInputType\n    _max?: Shopping_ordersMaxAggregateInputType\n  }\n\n  export type Shopping_ordersGroupByOutputType = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_ordersCountAggregateOutputType | null\n    _avg: Shopping_ordersAvgAggregateOutputType | null\n    _sum: Shopping_ordersSumAggregateOutputType | null\n    _min: Shopping_ordersMinAggregateOutputType | null\n    _max: Shopping_ordersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_ordersGroupByPayload<T extends shopping_ordersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_ordersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_ordersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_ordersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_ordersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    order_code?: boolean\n    total_amount?: boolean\n    currency?: boolean\n    status?: boolean\n    payment_method?: boolean\n    shipping_method?: boolean\n    shipping_address?: boolean\n    billing_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_orders$shopping_order_itemsArgs<ExtArgs>\n    shopping_order_status?: boolean | shopping_orders$shopping_order_statusArgs<ExtArgs>\n    shopping_order_history?: boolean | shopping_orders$shopping_order_historyArgs<ExtArgs>\n    shopping_seller_orders?: boolean | shopping_orders$shopping_seller_ordersArgs<ExtArgs>\n    shopping_payments?: boolean | shopping_orders$shopping_paymentsArgs<ExtArgs>\n    shopping_shipping_tracking?: boolean | shopping_orders$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    order_code?: boolean\n    total_amount?: boolean\n    currency?: boolean\n    status?: boolean\n    payment_method?: boolean\n    shipping_method?: boolean\n    shipping_address?: boolean\n    billing_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    order_code?: boolean\n    total_amount?: boolean\n    currency?: boolean\n    status?: boolean\n    payment_method?: boolean\n    shipping_method?: boolean\n    shipping_address?: boolean\n    billing_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_orders\"]>\n\n  export type shopping_ordersSelectScalar = {\n    id?: boolean\n    shopping_customer_id?: boolean\n    order_code?: boolean\n    total_amount?: boolean\n    currency?: boolean\n    status?: boolean\n    payment_method?: boolean\n    shipping_method?: boolean\n    shipping_address?: boolean\n    billing_address?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_customer_id\" | \"order_code\" | \"total_amount\" | \"currency\" | \"status\" | \"payment_method\" | \"shipping_method\" | \"shipping_address\" | \"billing_address\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_orders\"]>\n  export type shopping_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_order_items?: boolean | shopping_orders$shopping_order_itemsArgs<ExtArgs>\n    shopping_order_status?: boolean | shopping_orders$shopping_order_statusArgs<ExtArgs>\n    shopping_order_history?: boolean | shopping_orders$shopping_order_historyArgs<ExtArgs>\n    shopping_seller_orders?: boolean | shopping_orders$shopping_seller_ordersArgs<ExtArgs>\n    shopping_payments?: boolean | shopping_orders$shopping_paymentsArgs<ExtArgs>\n    shopping_shipping_tracking?: boolean | shopping_orders$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_ordersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n  export type shopping_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_orders\"\n    objects: {\n      customer: Prisma.$shopping_customersPayload<ExtArgs>\n      shopping_order_items: Prisma.$shopping_order_itemsPayload<ExtArgs>[]\n      shopping_order_status: Prisma.$shopping_order_statusPayload<ExtArgs>[]\n      shopping_order_history: Prisma.$shopping_order_historyPayload<ExtArgs>[]\n      shopping_seller_orders: Prisma.$shopping_seller_ordersPayload<ExtArgs>[]\n      shopping_payments: Prisma.$shopping_paymentsPayload<ExtArgs>[]\n      shopping_shipping_tracking: Prisma.$shopping_shipping_trackingPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Customer who placed the order. {@link shopping_customers.id}.\n       */\n      shopping_customer_id: string\n      /**\n       * Unique order code for business identification.\n       */\n      order_code: string\n      /**\n       * Total order amount including all items and taxes.\n       */\n      total_amount: number\n      /**\n       * Currency used for the order (e.g., USD, KRW).\n       */\n      currency: string\n      /**\n       * Current order status (e.g., pending, processing, shipped, delivered,\n       * cancelled).\n       */\n      status: string\n      /**\n       * Payment method used for the order.\n       */\n      payment_method: string\n      /**\n       * Selected shipping method for the order.\n       */\n      shipping_method: string\n      /**\n       * Shipping address for the order.\n       */\n      shipping_address: string\n      /**\n       * Billing address for the order.\n       */\n      billing_address: string\n      /**\n       * Timestamp when the order was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the order was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the order was soft deleted (if applicable).\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_orders\"]>\n    composites: {}\n  }\n\n  type shopping_ordersGetPayload<S extends boolean | null | undefined | shopping_ordersDefaultArgs> = $Result.GetResult<Prisma.$shopping_ordersPayload, S>\n\n  type shopping_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_ordersCountAggregateInputType | true\n    }\n\n  export interface shopping_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_orders'], meta: { name: 'shopping_orders' } }\n    /**\n     * Find zero or one Shopping_orders that matches the filter.\n     * @param {shopping_ordersFindUniqueArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_ordersFindUniqueArgs>(args: SelectSubset<T, shopping_ordersFindUniqueArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_orders that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_ordersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindFirstArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_ordersFindFirstArgs>(args?: SelectSubset<T, shopping_ordersFindFirstArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_orders that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindFirstOrThrowArgs} args - Arguments to find a Shopping_orders\n     * @example\n     * // Get one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findMany()\n     * \n     * // Get first 10 Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_ordersFindManyArgs>(args?: SelectSubset<T, shopping_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_orders.\n     * @param {shopping_ordersCreateArgs} args - Arguments to create a Shopping_orders.\n     * @example\n     * // Create one Shopping_orders\n     * const Shopping_orders = await prisma.shopping_orders.create({\n     *   data: {\n     *     // ... data to create a Shopping_orders\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_ordersCreateArgs>(args: SelectSubset<T, shopping_ordersCreateArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_orders.\n     * @param {shopping_ordersCreateManyArgs} args - Arguments to create many Shopping_orders.\n     * @example\n     * // Create many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_ordersCreateManyArgs>(args?: SelectSubset<T, shopping_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_orders and returns the data saved in the database.\n     * @param {shopping_ordersCreateManyAndReturnArgs} args - Arguments to create many Shopping_orders.\n     * @example\n     * // Create many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_orders and only return the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_orders.\n     * @param {shopping_ordersDeleteArgs} args - Arguments to delete one Shopping_orders.\n     * @example\n     * // Delete one Shopping_orders\n     * const Shopping_orders = await prisma.shopping_orders.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_orders\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_ordersDeleteArgs>(args: SelectSubset<T, shopping_ordersDeleteArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_orders.\n     * @param {shopping_ordersUpdateArgs} args - Arguments to update one Shopping_orders.\n     * @example\n     * // Update one Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_ordersUpdateArgs>(args: SelectSubset<T, shopping_ordersUpdateArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_orders.\n     * @param {shopping_ordersDeleteManyArgs} args - Arguments to filter Shopping_orders to delete.\n     * @example\n     * // Delete a few Shopping_orders\n     * const { count } = await prisma.shopping_orders.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_ordersDeleteManyArgs>(args?: SelectSubset<T, shopping_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_ordersUpdateManyArgs>(args: SelectSubset<T, shopping_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_orders and returns the data updated in the database.\n     * @param {shopping_ordersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_orders.\n     * @example\n     * // Update many Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_orders and only return the `id`\n     * const shopping_ordersWithIdOnly = await prisma.shopping_orders.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_orders.\n     * @param {shopping_ordersUpsertArgs} args - Arguments to update or create a Shopping_orders.\n     * @example\n     * // Update or create a Shopping_orders\n     * const shopping_orders = await prisma.shopping_orders.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_orders\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_orders we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_ordersUpsertArgs>(args: SelectSubset<T, shopping_ordersUpsertArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersCountArgs} args - Arguments to filter Shopping_orders to count.\n     * @example\n     * // Count the number of Shopping_orders\n     * const count = await prisma.shopping_orders.count({\n     *   where: {\n     *     // ... the filter for the Shopping_orders we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_ordersCountArgs>(\n      args?: Subset<T, shopping_ordersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_ordersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_ordersAggregateArgs>(args: Subset<T, Shopping_ordersAggregateArgs>): Prisma.PrismaPromise<GetShopping_ordersAggregateType<T>>\n\n    /**\n     * Group by Shopping_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_ordersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_ordersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_ordersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_ordersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_orders model\n   */\n  readonly fields: shopping_ordersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_orders.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    customer<T extends shopping_customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customersDefaultArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_order_items<T extends shopping_orders$shopping_order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_order_status<T extends shopping_orders$shopping_order_statusArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_order_statusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_order_history<T extends shopping_orders$shopping_order_historyArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_order_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_seller_orders<T extends shopping_orders$shopping_seller_ordersArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_seller_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_payments<T extends shopping_orders$shopping_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    shopping_shipping_tracking<T extends shopping_orders$shopping_shipping_trackingArgs<ExtArgs> = {}>(args?: Subset<T, shopping_orders$shopping_shipping_trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_orders model\n   */\n  interface shopping_ordersFieldRefs {\n    readonly id: FieldRef<\"shopping_orders\", 'String'>\n    readonly shopping_customer_id: FieldRef<\"shopping_orders\", 'String'>\n    readonly order_code: FieldRef<\"shopping_orders\", 'String'>\n    readonly total_amount: FieldRef<\"shopping_orders\", 'Float'>\n    readonly currency: FieldRef<\"shopping_orders\", 'String'>\n    readonly status: FieldRef<\"shopping_orders\", 'String'>\n    readonly payment_method: FieldRef<\"shopping_orders\", 'String'>\n    readonly shipping_method: FieldRef<\"shopping_orders\", 'String'>\n    readonly shipping_address: FieldRef<\"shopping_orders\", 'String'>\n    readonly billing_address: FieldRef<\"shopping_orders\", 'String'>\n    readonly created_at: FieldRef<\"shopping_orders\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_orders\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_orders\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_orders findUnique\n   */\n  export type shopping_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders findUniqueOrThrow\n   */\n  export type shopping_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders findFirst\n   */\n  export type shopping_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_orders.\n     */\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders findFirstOrThrow\n   */\n  export type shopping_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_orders.\n     */\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders findMany\n   */\n  export type shopping_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_orders to fetch.\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_orders to fetch.\n     */\n    orderBy?: shopping_ordersOrderByWithRelationInput | shopping_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_orders.\n     */\n    cursor?: shopping_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_orders.\n     */\n    skip?: number\n    distinct?: Shopping_ordersScalarFieldEnum | Shopping_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders create\n   */\n  export type shopping_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_orders.\n     */\n    data: XOR<shopping_ordersCreateInput, shopping_ordersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_orders createMany\n   */\n  export type shopping_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_orders.\n     */\n    data: shopping_ordersCreateManyInput | shopping_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_orders createManyAndReturn\n   */\n  export type shopping_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_orders.\n     */\n    data: shopping_ordersCreateManyInput | shopping_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_orders update\n   */\n  export type shopping_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateInput, shopping_ordersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_orders to update.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders updateMany\n   */\n  export type shopping_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_orders to update\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_orders updateManyAndReturn\n   */\n  export type shopping_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_orders.\n     */\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_orders to update\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_orders upsert\n   */\n  export type shopping_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_orders to update in case it exists.\n     */\n    where: shopping_ordersWhereUniqueInput\n    /**\n     * In case the shopping_orders found by the `where` argument doesn't exist, create a new shopping_orders with this data.\n     */\n    create: XOR<shopping_ordersCreateInput, shopping_ordersUncheckedCreateInput>\n    /**\n     * In case the shopping_orders was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_ordersUpdateInput, shopping_ordersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_orders delete\n   */\n  export type shopping_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_orders to delete.\n     */\n    where: shopping_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_orders deleteMany\n   */\n  export type shopping_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_orders to delete\n     */\n    where?: shopping_ordersWhereInput\n    /**\n     * Limit how many shopping_orders to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_orders.shopping_order_items\n   */\n  export type shopping_orders$shopping_order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    where?: shopping_order_itemsWhereInput\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    cursor?: shopping_order_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_order_status\n   */\n  export type shopping_orders$shopping_order_statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    where?: shopping_order_statusWhereInput\n    orderBy?: shopping_order_statusOrderByWithRelationInput | shopping_order_statusOrderByWithRelationInput[]\n    cursor?: shopping_order_statusWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_statusScalarFieldEnum | Shopping_order_statusScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_order_history\n   */\n  export type shopping_orders$shopping_order_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    where?: shopping_order_historyWhereInput\n    orderBy?: shopping_order_historyOrderByWithRelationInput | shopping_order_historyOrderByWithRelationInput[]\n    cursor?: shopping_order_historyWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_order_historyScalarFieldEnum | Shopping_order_historyScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_seller_orders\n   */\n  export type shopping_orders$shopping_seller_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    where?: shopping_seller_ordersWhereInput\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_ordersScalarFieldEnum | Shopping_seller_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_payments\n   */\n  export type shopping_orders$shopping_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    where?: shopping_paymentsWhereInput\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    cursor?: shopping_paymentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_paymentsScalarFieldEnum | Shopping_paymentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders.shopping_shipping_tracking\n   */\n  export type shopping_orders$shopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    where?: shopping_shipping_trackingWhereInput\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_orders without action\n   */\n  export type shopping_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_orders\n     */\n    select?: shopping_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_orders\n     */\n    omit?: shopping_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_ordersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_order_items\n   */\n\n  export type AggregateShopping_order_items = {\n    _count: Shopping_order_itemsCountAggregateOutputType | null\n    _avg: Shopping_order_itemsAvgAggregateOutputType | null\n    _sum: Shopping_order_itemsSumAggregateOutputType | null\n    _min: Shopping_order_itemsMinAggregateOutputType | null\n    _max: Shopping_order_itemsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_order_itemsAvgAggregateOutputType = {\n    quantity: number | null\n    unit_price: number | null\n    total_price: number | null\n  }\n\n  export type Shopping_order_itemsSumAggregateOutputType = {\n    quantity: number | null\n    unit_price: number | null\n    total_price: number | null\n  }\n\n  export type Shopping_order_itemsMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    shopping_product_variant_id: string | null\n    quantity: number | null\n    unit_price: number | null\n    total_price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_order_itemsMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    shopping_product_variant_id: string | null\n    quantity: number | null\n    unit_price: number | null\n    total_price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_order_itemsCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    shopping_product_variant_id: number\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_order_itemsAvgAggregateInputType = {\n    quantity?: true\n    unit_price?: true\n    total_price?: true\n  }\n\n  export type Shopping_order_itemsSumAggregateInputType = {\n    quantity?: true\n    unit_price?: true\n    total_price?: true\n  }\n\n  export type Shopping_order_itemsMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    unit_price?: true\n    total_price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_order_itemsMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    unit_price?: true\n    total_price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_order_itemsCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    unit_price?: true\n    total_price?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_order_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_items to aggregate.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_order_items\n    **/\n    _count?: true | Shopping_order_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_order_itemsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_order_itemsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_order_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_order_itemsMaxAggregateInputType\n  }\n\n  export type GetShopping_order_itemsAggregateType<T extends Shopping_order_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_order_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_order_items[P]>\n      : GetScalarType<T[P], AggregateShopping_order_items[P]>\n  }\n\n\n\n\n  export type shopping_order_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_itemsWhereInput\n    orderBy?: shopping_order_itemsOrderByWithAggregationInput | shopping_order_itemsOrderByWithAggregationInput[]\n    by: Shopping_order_itemsScalarFieldEnum[] | Shopping_order_itemsScalarFieldEnum\n    having?: shopping_order_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_order_itemsCountAggregateInputType | true\n    _avg?: Shopping_order_itemsAvgAggregateInputType\n    _sum?: Shopping_order_itemsSumAggregateInputType\n    _min?: Shopping_order_itemsMinAggregateInputType\n    _max?: Shopping_order_itemsMaxAggregateInputType\n  }\n\n  export type Shopping_order_itemsGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_order_itemsCountAggregateOutputType | null\n    _avg: Shopping_order_itemsAvgAggregateOutputType | null\n    _sum: Shopping_order_itemsSumAggregateOutputType | null\n    _min: Shopping_order_itemsMinAggregateOutputType | null\n    _max: Shopping_order_itemsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_order_itemsGroupByPayload<T extends shopping_order_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_order_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_order_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_order_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_order_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_order_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    unit_price?: boolean\n    total_price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    unit_price?: boolean\n    total_price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    unit_price?: boolean\n    total_price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n\n  export type shopping_order_itemsSelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    unit_price?: boolean\n    total_price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_order_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"shopping_product_variant_id\" | \"quantity\" | \"unit_price\" | \"total_price\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_order_items\"]>\n  export type shopping_order_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_order_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_order_items\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n      productVariant: Prisma.$shopping_product_variantsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Order this item belongs to. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * Product variant being ordered. {@link shopping_product_variants.id}.\n       */\n      shopping_product_variant_id: string\n      /**\n       * Number of units ordered.\n       */\n      quantity: number\n      /**\n       * Price per unit at time of order.\n       */\n      unit_price: number\n      /**\n       * Total price for this line item (quantity × unit_price).\n       */\n      total_price: number\n      /**\n       * Timestamp when the order item was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the order item was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_order_items\"]>\n    composites: {}\n  }\n\n  type shopping_order_itemsGetPayload<S extends boolean | null | undefined | shopping_order_itemsDefaultArgs> = $Result.GetResult<Prisma.$shopping_order_itemsPayload, S>\n\n  type shopping_order_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_order_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_order_itemsCountAggregateInputType | true\n    }\n\n  export interface shopping_order_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_order_items'], meta: { name: 'shopping_order_items' } }\n    /**\n     * Find zero or one Shopping_order_items that matches the filter.\n     * @param {shopping_order_itemsFindUniqueArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_order_itemsFindUniqueArgs>(args: SelectSubset<T, shopping_order_itemsFindUniqueArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_order_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_order_itemsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_order_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindFirstArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_order_itemsFindFirstArgs>(args?: SelectSubset<T, shopping_order_itemsFindFirstArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindFirstOrThrowArgs} args - Arguments to find a Shopping_order_items\n     * @example\n     * // Get one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_order_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_order_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_order_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findMany()\n     * \n     * // Get first 10 Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_order_itemsFindManyArgs>(args?: SelectSubset<T, shopping_order_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_order_items.\n     * @param {shopping_order_itemsCreateArgs} args - Arguments to create a Shopping_order_items.\n     * @example\n     * // Create one Shopping_order_items\n     * const Shopping_order_items = await prisma.shopping_order_items.create({\n     *   data: {\n     *     // ... data to create a Shopping_order_items\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_order_itemsCreateArgs>(args: SelectSubset<T, shopping_order_itemsCreateArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_order_items.\n     * @param {shopping_order_itemsCreateManyArgs} args - Arguments to create many Shopping_order_items.\n     * @example\n     * // Create many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_order_itemsCreateManyArgs>(args?: SelectSubset<T, shopping_order_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_order_items and returns the data saved in the database.\n     * @param {shopping_order_itemsCreateManyAndReturnArgs} args - Arguments to create many Shopping_order_items.\n     * @example\n     * // Create many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_order_items and only return the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_order_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_order_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_order_items.\n     * @param {shopping_order_itemsDeleteArgs} args - Arguments to delete one Shopping_order_items.\n     * @example\n     * // Delete one Shopping_order_items\n     * const Shopping_order_items = await prisma.shopping_order_items.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_order_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_order_itemsDeleteArgs>(args: SelectSubset<T, shopping_order_itemsDeleteArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_order_items.\n     * @param {shopping_order_itemsUpdateArgs} args - Arguments to update one Shopping_order_items.\n     * @example\n     * // Update one Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_order_itemsUpdateArgs>(args: SelectSubset<T, shopping_order_itemsUpdateArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_order_items.\n     * @param {shopping_order_itemsDeleteManyArgs} args - Arguments to filter Shopping_order_items to delete.\n     * @example\n     * // Delete a few Shopping_order_items\n     * const { count } = await prisma.shopping_order_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_order_itemsDeleteManyArgs>(args?: SelectSubset<T, shopping_order_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_order_itemsUpdateManyArgs>(args: SelectSubset<T, shopping_order_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_items and returns the data updated in the database.\n     * @param {shopping_order_itemsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_order_items.\n     * @example\n     * // Update many Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_order_items and only return the `id`\n     * const shopping_order_itemsWithIdOnly = await prisma.shopping_order_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_order_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_order_items.\n     * @param {shopping_order_itemsUpsertArgs} args - Arguments to update or create a Shopping_order_items.\n     * @example\n     * // Update or create a Shopping_order_items\n     * const shopping_order_items = await prisma.shopping_order_items.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_order_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_order_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_order_itemsUpsertArgs>(args: SelectSubset<T, shopping_order_itemsUpsertArgs<ExtArgs>>): Prisma__shopping_order_itemsClient<$Result.GetResult<Prisma.$shopping_order_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsCountArgs} args - Arguments to filter Shopping_order_items to count.\n     * @example\n     * // Count the number of Shopping_order_items\n     * const count = await prisma.shopping_order_items.count({\n     *   where: {\n     *     // ... the filter for the Shopping_order_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_order_itemsCountArgs>(\n      args?: Subset<T, shopping_order_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_order_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_order_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_order_itemsAggregateArgs>(args: Subset<T, Shopping_order_itemsAggregateArgs>): Prisma.PrismaPromise<GetShopping_order_itemsAggregateType<T>>\n\n    /**\n     * Group by Shopping_order_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_order_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_order_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_order_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_order_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_order_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_order_items model\n   */\n  readonly fields: shopping_order_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_order_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_order_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    productVariant<T extends shopping_product_variantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variantsDefaultArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_order_items model\n   */\n  interface shopping_order_itemsFieldRefs {\n    readonly id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly shopping_product_variant_id: FieldRef<\"shopping_order_items\", 'String'>\n    readonly quantity: FieldRef<\"shopping_order_items\", 'Int'>\n    readonly unit_price: FieldRef<\"shopping_order_items\", 'Float'>\n    readonly total_price: FieldRef<\"shopping_order_items\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_order_items\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_order_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_order_items findUnique\n   */\n  export type shopping_order_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items findUniqueOrThrow\n   */\n  export type shopping_order_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items findFirst\n   */\n  export type shopping_order_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_items.\n     */\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items findFirstOrThrow\n   */\n  export type shopping_order_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_items.\n     */\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items findMany\n   */\n  export type shopping_order_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_items to fetch.\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_items to fetch.\n     */\n    orderBy?: shopping_order_itemsOrderByWithRelationInput | shopping_order_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_order_items.\n     */\n    cursor?: shopping_order_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_items.\n     */\n    skip?: number\n    distinct?: Shopping_order_itemsScalarFieldEnum | Shopping_order_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_items create\n   */\n  export type shopping_order_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsCreateInput, shopping_order_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_order_items createMany\n   */\n  export type shopping_order_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_order_items.\n     */\n    data: shopping_order_itemsCreateManyInput | shopping_order_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_order_items createManyAndReturn\n   */\n  export type shopping_order_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_order_items.\n     */\n    data: shopping_order_itemsCreateManyInput | shopping_order_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_items update\n   */\n  export type shopping_order_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateInput, shopping_order_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_order_items to update.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items updateMany\n   */\n  export type shopping_order_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_items to update\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_items updateManyAndReturn\n   */\n  export type shopping_order_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_order_items.\n     */\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_items to update\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_items upsert\n   */\n  export type shopping_order_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_order_items to update in case it exists.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n    /**\n     * In case the shopping_order_items found by the `where` argument doesn't exist, create a new shopping_order_items with this data.\n     */\n    create: XOR<shopping_order_itemsCreateInput, shopping_order_itemsUncheckedCreateInput>\n    /**\n     * In case the shopping_order_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_order_itemsUpdateInput, shopping_order_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_order_items delete\n   */\n  export type shopping_order_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_order_items to delete.\n     */\n    where: shopping_order_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_items deleteMany\n   */\n  export type shopping_order_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_items to delete\n     */\n    where?: shopping_order_itemsWhereInput\n    /**\n     * Limit how many shopping_order_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_items without action\n   */\n  export type shopping_order_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_items\n     */\n    select?: shopping_order_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_items\n     */\n    omit?: shopping_order_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_order_status\n   */\n\n  export type AggregateShopping_order_status = {\n    _count: Shopping_order_statusCountAggregateOutputType | null\n    _min: Shopping_order_statusMinAggregateOutputType | null\n    _max: Shopping_order_statusMaxAggregateOutputType | null\n  }\n\n  export type Shopping_order_statusMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    status: string | null\n    changed_at: Date | null\n    changed_by: string | null\n    notes: string | null\n  }\n\n  export type Shopping_order_statusMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    status: string | null\n    changed_at: Date | null\n    changed_by: string | null\n    notes: string | null\n  }\n\n  export type Shopping_order_statusCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    status: number\n    changed_at: number\n    changed_by: number\n    notes: number\n    _all: number\n  }\n\n\n  export type Shopping_order_statusMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    status?: true\n    changed_at?: true\n    changed_by?: true\n    notes?: true\n  }\n\n  export type Shopping_order_statusMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    status?: true\n    changed_at?: true\n    changed_by?: true\n    notes?: true\n  }\n\n  export type Shopping_order_statusCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    status?: true\n    changed_at?: true\n    changed_by?: true\n    notes?: true\n    _all?: true\n  }\n\n  export type Shopping_order_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_status to aggregate.\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_statuses to fetch.\n     */\n    orderBy?: shopping_order_statusOrderByWithRelationInput | shopping_order_statusOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_order_statusWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_statuses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_statuses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_order_statuses\n    **/\n    _count?: true | Shopping_order_statusCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_order_statusMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_order_statusMaxAggregateInputType\n  }\n\n  export type GetShopping_order_statusAggregateType<T extends Shopping_order_statusAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_order_status]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_order_status[P]>\n      : GetScalarType<T[P], AggregateShopping_order_status[P]>\n  }\n\n\n\n\n  export type shopping_order_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_statusWhereInput\n    orderBy?: shopping_order_statusOrderByWithAggregationInput | shopping_order_statusOrderByWithAggregationInput[]\n    by: Shopping_order_statusScalarFieldEnum[] | Shopping_order_statusScalarFieldEnum\n    having?: shopping_order_statusScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_order_statusCountAggregateInputType | true\n    _min?: Shopping_order_statusMinAggregateInputType\n    _max?: Shopping_order_statusMaxAggregateInputType\n  }\n\n  export type Shopping_order_statusGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    status: string\n    changed_at: Date\n    changed_by: string | null\n    notes: string | null\n    _count: Shopping_order_statusCountAggregateOutputType | null\n    _min: Shopping_order_statusMinAggregateOutputType | null\n    _max: Shopping_order_statusMaxAggregateOutputType | null\n  }\n\n  type GetShopping_order_statusGroupByPayload<T extends shopping_order_statusGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_order_statusGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_order_statusGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_order_statusGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_order_statusGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_order_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    status?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    notes?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_status\"]>\n\n  export type shopping_order_statusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    status?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    notes?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_status\"]>\n\n  export type shopping_order_statusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    status?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    notes?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_status\"]>\n\n  export type shopping_order_statusSelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    status?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    notes?: boolean\n  }\n\n  export type shopping_order_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"status\" | \"changed_at\" | \"changed_by\" | \"notes\", ExtArgs[\"result\"][\"shopping_order_status\"]>\n  export type shopping_order_statusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_statusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_statusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_order_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_order_status\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Order this status belongs to. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * Order status at this point in time.\n       */\n      status: string\n      /**\n       * Timestamp when this status was set.\n       */\n      changed_at: Date\n      /**\n       * User or system that changed the status.\n       */\n      changed_by: string | null\n      /**\n       * Additional notes about the status change.\n       */\n      notes: string | null\n    }, ExtArgs[\"result\"][\"shopping_order_status\"]>\n    composites: {}\n  }\n\n  type shopping_order_statusGetPayload<S extends boolean | null | undefined | shopping_order_statusDefaultArgs> = $Result.GetResult<Prisma.$shopping_order_statusPayload, S>\n\n  type shopping_order_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_order_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_order_statusCountAggregateInputType | true\n    }\n\n  export interface shopping_order_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_order_status'], meta: { name: 'shopping_order_status' } }\n    /**\n     * Find zero or one Shopping_order_status that matches the filter.\n     * @param {shopping_order_statusFindUniqueArgs} args - Arguments to find a Shopping_order_status\n     * @example\n     * // Get one Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_order_statusFindUniqueArgs>(args: SelectSubset<T, shopping_order_statusFindUniqueArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_order_status that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_order_statusFindUniqueOrThrowArgs} args - Arguments to find a Shopping_order_status\n     * @example\n     * // Get one Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_order_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_order_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_status that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusFindFirstArgs} args - Arguments to find a Shopping_order_status\n     * @example\n     * // Get one Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_order_statusFindFirstArgs>(args?: SelectSubset<T, shopping_order_statusFindFirstArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_status that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusFindFirstOrThrowArgs} args - Arguments to find a Shopping_order_status\n     * @example\n     * // Get one Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_order_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_order_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_order_statuses that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_order_statuses\n     * const shopping_order_statuses = await prisma.shopping_order_status.findMany()\n     * \n     * // Get first 10 Shopping_order_statuses\n     * const shopping_order_statuses = await prisma.shopping_order_status.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_order_statusWithIdOnly = await prisma.shopping_order_status.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_order_statusFindManyArgs>(args?: SelectSubset<T, shopping_order_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_order_status.\n     * @param {shopping_order_statusCreateArgs} args - Arguments to create a Shopping_order_status.\n     * @example\n     * // Create one Shopping_order_status\n     * const Shopping_order_status = await prisma.shopping_order_status.create({\n     *   data: {\n     *     // ... data to create a Shopping_order_status\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_order_statusCreateArgs>(args: SelectSubset<T, shopping_order_statusCreateArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_order_statuses.\n     * @param {shopping_order_statusCreateManyArgs} args - Arguments to create many Shopping_order_statuses.\n     * @example\n     * // Create many Shopping_order_statuses\n     * const shopping_order_status = await prisma.shopping_order_status.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_order_statusCreateManyArgs>(args?: SelectSubset<T, shopping_order_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_order_statuses and returns the data saved in the database.\n     * @param {shopping_order_statusCreateManyAndReturnArgs} args - Arguments to create many Shopping_order_statuses.\n     * @example\n     * // Create many Shopping_order_statuses\n     * const shopping_order_status = await prisma.shopping_order_status.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_order_statuses and only return the `id`\n     * const shopping_order_statusWithIdOnly = await prisma.shopping_order_status.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_order_statusCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_order_statusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_order_status.\n     * @param {shopping_order_statusDeleteArgs} args - Arguments to delete one Shopping_order_status.\n     * @example\n     * // Delete one Shopping_order_status\n     * const Shopping_order_status = await prisma.shopping_order_status.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_order_status\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_order_statusDeleteArgs>(args: SelectSubset<T, shopping_order_statusDeleteArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_order_status.\n     * @param {shopping_order_statusUpdateArgs} args - Arguments to update one Shopping_order_status.\n     * @example\n     * // Update one Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_order_statusUpdateArgs>(args: SelectSubset<T, shopping_order_statusUpdateArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_order_statuses.\n     * @param {shopping_order_statusDeleteManyArgs} args - Arguments to filter Shopping_order_statuses to delete.\n     * @example\n     * // Delete a few Shopping_order_statuses\n     * const { count } = await prisma.shopping_order_status.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_order_statusDeleteManyArgs>(args?: SelectSubset<T, shopping_order_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_statuses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_order_statuses\n     * const shopping_order_status = await prisma.shopping_order_status.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_order_statusUpdateManyArgs>(args: SelectSubset<T, shopping_order_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_statuses and returns the data updated in the database.\n     * @param {shopping_order_statusUpdateManyAndReturnArgs} args - Arguments to update many Shopping_order_statuses.\n     * @example\n     * // Update many Shopping_order_statuses\n     * const shopping_order_status = await prisma.shopping_order_status.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_order_statuses and only return the `id`\n     * const shopping_order_statusWithIdOnly = await prisma.shopping_order_status.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_order_statusUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_order_statusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_order_status.\n     * @param {shopping_order_statusUpsertArgs} args - Arguments to update or create a Shopping_order_status.\n     * @example\n     * // Update or create a Shopping_order_status\n     * const shopping_order_status = await prisma.shopping_order_status.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_order_status\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_order_status we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_order_statusUpsertArgs>(args: SelectSubset<T, shopping_order_statusUpsertArgs<ExtArgs>>): Prisma__shopping_order_statusClient<$Result.GetResult<Prisma.$shopping_order_statusPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_order_statuses.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusCountArgs} args - Arguments to filter Shopping_order_statuses to count.\n     * @example\n     * // Count the number of Shopping_order_statuses\n     * const count = await prisma.shopping_order_status.count({\n     *   where: {\n     *     // ... the filter for the Shopping_order_statuses we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_order_statusCountArgs>(\n      args?: Subset<T, shopping_order_statusCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_order_statusCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_order_status.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_order_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_order_statusAggregateArgs>(args: Subset<T, Shopping_order_statusAggregateArgs>): Prisma.PrismaPromise<GetShopping_order_statusAggregateType<T>>\n\n    /**\n     * Group by Shopping_order_status.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_statusGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_order_statusGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_order_statusGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_order_statusGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_order_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_order_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_order_status model\n   */\n  readonly fields: shopping_order_statusFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_order_status.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_order_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_order_status model\n   */\n  interface shopping_order_statusFieldRefs {\n    readonly id: FieldRef<\"shopping_order_status\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_order_status\", 'String'>\n    readonly status: FieldRef<\"shopping_order_status\", 'String'>\n    readonly changed_at: FieldRef<\"shopping_order_status\", 'DateTime'>\n    readonly changed_by: FieldRef<\"shopping_order_status\", 'String'>\n    readonly notes: FieldRef<\"shopping_order_status\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_order_status findUnique\n   */\n  export type shopping_order_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_status to fetch.\n     */\n    where: shopping_order_statusWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_status findUniqueOrThrow\n   */\n  export type shopping_order_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_status to fetch.\n     */\n    where: shopping_order_statusWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_status findFirst\n   */\n  export type shopping_order_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_status to fetch.\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_statuses to fetch.\n     */\n    orderBy?: shopping_order_statusOrderByWithRelationInput | shopping_order_statusOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_statuses.\n     */\n    cursor?: shopping_order_statusWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_statuses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_statuses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_statuses.\n     */\n    distinct?: Shopping_order_statusScalarFieldEnum | Shopping_order_statusScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_status findFirstOrThrow\n   */\n  export type shopping_order_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_status to fetch.\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_statuses to fetch.\n     */\n    orderBy?: shopping_order_statusOrderByWithRelationInput | shopping_order_statusOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_statuses.\n     */\n    cursor?: shopping_order_statusWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_statuses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_statuses.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_statuses.\n     */\n    distinct?: Shopping_order_statusScalarFieldEnum | Shopping_order_statusScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_status findMany\n   */\n  export type shopping_order_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_statuses to fetch.\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_statuses to fetch.\n     */\n    orderBy?: shopping_order_statusOrderByWithRelationInput | shopping_order_statusOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_order_statuses.\n     */\n    cursor?: shopping_order_statusWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_statuses from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_statuses.\n     */\n    skip?: number\n    distinct?: Shopping_order_statusScalarFieldEnum | Shopping_order_statusScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_status create\n   */\n  export type shopping_order_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_order_status.\n     */\n    data: XOR<shopping_order_statusCreateInput, shopping_order_statusUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_order_status createMany\n   */\n  export type shopping_order_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_order_statuses.\n     */\n    data: shopping_order_statusCreateManyInput | shopping_order_statusCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_order_status createManyAndReturn\n   */\n  export type shopping_order_statusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_order_statuses.\n     */\n    data: shopping_order_statusCreateManyInput | shopping_order_statusCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_status update\n   */\n  export type shopping_order_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_order_status.\n     */\n    data: XOR<shopping_order_statusUpdateInput, shopping_order_statusUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_order_status to update.\n     */\n    where: shopping_order_statusWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_status updateMany\n   */\n  export type shopping_order_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_order_statuses.\n     */\n    data: XOR<shopping_order_statusUpdateManyMutationInput, shopping_order_statusUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_statuses to update\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * Limit how many shopping_order_statuses to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_status updateManyAndReturn\n   */\n  export type shopping_order_statusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_order_statuses.\n     */\n    data: XOR<shopping_order_statusUpdateManyMutationInput, shopping_order_statusUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_statuses to update\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * Limit how many shopping_order_statuses to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_status upsert\n   */\n  export type shopping_order_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_order_status to update in case it exists.\n     */\n    where: shopping_order_statusWhereUniqueInput\n    /**\n     * In case the shopping_order_status found by the `where` argument doesn't exist, create a new shopping_order_status with this data.\n     */\n    create: XOR<shopping_order_statusCreateInput, shopping_order_statusUncheckedCreateInput>\n    /**\n     * In case the shopping_order_status was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_order_statusUpdateInput, shopping_order_statusUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_order_status delete\n   */\n  export type shopping_order_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_order_status to delete.\n     */\n    where: shopping_order_statusWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_status deleteMany\n   */\n  export type shopping_order_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_statuses to delete\n     */\n    where?: shopping_order_statusWhereInput\n    /**\n     * Limit how many shopping_order_statuses to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_status without action\n   */\n  export type shopping_order_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_status\n     */\n    select?: shopping_order_statusSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_status\n     */\n    omit?: shopping_order_statusOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_statusInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_order_history\n   */\n\n  export type AggregateShopping_order_history = {\n    _count: Shopping_order_historyCountAggregateOutputType | null\n    _min: Shopping_order_historyMinAggregateOutputType | null\n    _max: Shopping_order_historyMaxAggregateOutputType | null\n  }\n\n  export type Shopping_order_historyMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    action: string | null\n    changed_at: Date | null\n    changed_by: string | null\n    details: string | null\n  }\n\n  export type Shopping_order_historyMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    action: string | null\n    changed_at: Date | null\n    changed_by: string | null\n    details: string | null\n  }\n\n  export type Shopping_order_historyCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    action: number\n    changed_at: number\n    changed_by: number\n    details: number\n    _all: number\n  }\n\n\n  export type Shopping_order_historyMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    action?: true\n    changed_at?: true\n    changed_by?: true\n    details?: true\n  }\n\n  export type Shopping_order_historyMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    action?: true\n    changed_at?: true\n    changed_by?: true\n    details?: true\n  }\n\n  export type Shopping_order_historyCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    action?: true\n    changed_at?: true\n    changed_by?: true\n    details?: true\n    _all?: true\n  }\n\n  export type Shopping_order_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_history to aggregate.\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_histories to fetch.\n     */\n    orderBy?: shopping_order_historyOrderByWithRelationInput | shopping_order_historyOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_order_historyWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_histories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_histories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_order_histories\n    **/\n    _count?: true | Shopping_order_historyCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_order_historyMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_order_historyMaxAggregateInputType\n  }\n\n  export type GetShopping_order_historyAggregateType<T extends Shopping_order_historyAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_order_history]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_order_history[P]>\n      : GetScalarType<T[P], AggregateShopping_order_history[P]>\n  }\n\n\n\n\n  export type shopping_order_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_order_historyWhereInput\n    orderBy?: shopping_order_historyOrderByWithAggregationInput | shopping_order_historyOrderByWithAggregationInput[]\n    by: Shopping_order_historyScalarFieldEnum[] | Shopping_order_historyScalarFieldEnum\n    having?: shopping_order_historyScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_order_historyCountAggregateInputType | true\n    _min?: Shopping_order_historyMinAggregateInputType\n    _max?: Shopping_order_historyMaxAggregateInputType\n  }\n\n  export type Shopping_order_historyGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    action: string\n    changed_at: Date\n    changed_by: string | null\n    details: string | null\n    _count: Shopping_order_historyCountAggregateOutputType | null\n    _min: Shopping_order_historyMinAggregateOutputType | null\n    _max: Shopping_order_historyMaxAggregateOutputType | null\n  }\n\n  type GetShopping_order_historyGroupByPayload<T extends shopping_order_historyGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_order_historyGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_order_historyGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_order_historyGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_order_historyGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_order_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    action?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    details?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_history\"]>\n\n  export type shopping_order_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    action?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    details?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_history\"]>\n\n  export type shopping_order_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    action?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    details?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_order_history\"]>\n\n  export type shopping_order_historySelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    action?: boolean\n    changed_at?: boolean\n    changed_by?: boolean\n    details?: boolean\n  }\n\n  export type shopping_order_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"action\" | \"changed_at\" | \"changed_by\" | \"details\", ExtArgs[\"result\"][\"shopping_order_history\"]>\n  export type shopping_order_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_order_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_order_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_order_history\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Order this history record belongs to. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * Action performed on the order (e.g., created, updated, cancelled).\n       */\n      action: string\n      /**\n       * Timestamp when this action occurred.\n       */\n      changed_at: Date\n      /**\n       * User or system that performed the action.\n       */\n      changed_by: string | null\n      /**\n       * JSON object containing order state at time of action.\n       */\n      details: string | null\n    }, ExtArgs[\"result\"][\"shopping_order_history\"]>\n    composites: {}\n  }\n\n  type shopping_order_historyGetPayload<S extends boolean | null | undefined | shopping_order_historyDefaultArgs> = $Result.GetResult<Prisma.$shopping_order_historyPayload, S>\n\n  type shopping_order_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_order_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_order_historyCountAggregateInputType | true\n    }\n\n  export interface shopping_order_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_order_history'], meta: { name: 'shopping_order_history' } }\n    /**\n     * Find zero or one Shopping_order_history that matches the filter.\n     * @param {shopping_order_historyFindUniqueArgs} args - Arguments to find a Shopping_order_history\n     * @example\n     * // Get one Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_order_historyFindUniqueArgs>(args: SelectSubset<T, shopping_order_historyFindUniqueArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_order_history that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_order_historyFindUniqueOrThrowArgs} args - Arguments to find a Shopping_order_history\n     * @example\n     * // Get one Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_order_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_order_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_history that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyFindFirstArgs} args - Arguments to find a Shopping_order_history\n     * @example\n     * // Get one Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_order_historyFindFirstArgs>(args?: SelectSubset<T, shopping_order_historyFindFirstArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_order_history that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyFindFirstOrThrowArgs} args - Arguments to find a Shopping_order_history\n     * @example\n     * // Get one Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_order_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_order_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_order_histories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_order_histories\n     * const shopping_order_histories = await prisma.shopping_order_history.findMany()\n     * \n     * // Get first 10 Shopping_order_histories\n     * const shopping_order_histories = await prisma.shopping_order_history.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_order_historyWithIdOnly = await prisma.shopping_order_history.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_order_historyFindManyArgs>(args?: SelectSubset<T, shopping_order_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_order_history.\n     * @param {shopping_order_historyCreateArgs} args - Arguments to create a Shopping_order_history.\n     * @example\n     * // Create one Shopping_order_history\n     * const Shopping_order_history = await prisma.shopping_order_history.create({\n     *   data: {\n     *     // ... data to create a Shopping_order_history\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_order_historyCreateArgs>(args: SelectSubset<T, shopping_order_historyCreateArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_order_histories.\n     * @param {shopping_order_historyCreateManyArgs} args - Arguments to create many Shopping_order_histories.\n     * @example\n     * // Create many Shopping_order_histories\n     * const shopping_order_history = await prisma.shopping_order_history.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_order_historyCreateManyArgs>(args?: SelectSubset<T, shopping_order_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_order_histories and returns the data saved in the database.\n     * @param {shopping_order_historyCreateManyAndReturnArgs} args - Arguments to create many Shopping_order_histories.\n     * @example\n     * // Create many Shopping_order_histories\n     * const shopping_order_history = await prisma.shopping_order_history.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_order_histories and only return the `id`\n     * const shopping_order_historyWithIdOnly = await prisma.shopping_order_history.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_order_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_order_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_order_history.\n     * @param {shopping_order_historyDeleteArgs} args - Arguments to delete one Shopping_order_history.\n     * @example\n     * // Delete one Shopping_order_history\n     * const Shopping_order_history = await prisma.shopping_order_history.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_order_history\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_order_historyDeleteArgs>(args: SelectSubset<T, shopping_order_historyDeleteArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_order_history.\n     * @param {shopping_order_historyUpdateArgs} args - Arguments to update one Shopping_order_history.\n     * @example\n     * // Update one Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_order_historyUpdateArgs>(args: SelectSubset<T, shopping_order_historyUpdateArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_order_histories.\n     * @param {shopping_order_historyDeleteManyArgs} args - Arguments to filter Shopping_order_histories to delete.\n     * @example\n     * // Delete a few Shopping_order_histories\n     * const { count } = await prisma.shopping_order_history.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_order_historyDeleteManyArgs>(args?: SelectSubset<T, shopping_order_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_histories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_order_histories\n     * const shopping_order_history = await prisma.shopping_order_history.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_order_historyUpdateManyArgs>(args: SelectSubset<T, shopping_order_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_order_histories and returns the data updated in the database.\n     * @param {shopping_order_historyUpdateManyAndReturnArgs} args - Arguments to update many Shopping_order_histories.\n     * @example\n     * // Update many Shopping_order_histories\n     * const shopping_order_history = await prisma.shopping_order_history.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_order_histories and only return the `id`\n     * const shopping_order_historyWithIdOnly = await prisma.shopping_order_history.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_order_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_order_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_order_history.\n     * @param {shopping_order_historyUpsertArgs} args - Arguments to update or create a Shopping_order_history.\n     * @example\n     * // Update or create a Shopping_order_history\n     * const shopping_order_history = await prisma.shopping_order_history.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_order_history\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_order_history we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_order_historyUpsertArgs>(args: SelectSubset<T, shopping_order_historyUpsertArgs<ExtArgs>>): Prisma__shopping_order_historyClient<$Result.GetResult<Prisma.$shopping_order_historyPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_order_histories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyCountArgs} args - Arguments to filter Shopping_order_histories to count.\n     * @example\n     * // Count the number of Shopping_order_histories\n     * const count = await prisma.shopping_order_history.count({\n     *   where: {\n     *     // ... the filter for the Shopping_order_histories we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_order_historyCountArgs>(\n      args?: Subset<T, shopping_order_historyCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_order_historyCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_order_history.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_order_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_order_historyAggregateArgs>(args: Subset<T, Shopping_order_historyAggregateArgs>): Prisma.PrismaPromise<GetShopping_order_historyAggregateType<T>>\n\n    /**\n     * Group by Shopping_order_history.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_order_historyGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_order_historyGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_order_historyGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_order_historyGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_order_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_order_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_order_history model\n   */\n  readonly fields: shopping_order_historyFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_order_history.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_order_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_order_history model\n   */\n  interface shopping_order_historyFieldRefs {\n    readonly id: FieldRef<\"shopping_order_history\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_order_history\", 'String'>\n    readonly action: FieldRef<\"shopping_order_history\", 'String'>\n    readonly changed_at: FieldRef<\"shopping_order_history\", 'DateTime'>\n    readonly changed_by: FieldRef<\"shopping_order_history\", 'String'>\n    readonly details: FieldRef<\"shopping_order_history\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_order_history findUnique\n   */\n  export type shopping_order_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_history to fetch.\n     */\n    where: shopping_order_historyWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_history findUniqueOrThrow\n   */\n  export type shopping_order_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_history to fetch.\n     */\n    where: shopping_order_historyWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_history findFirst\n   */\n  export type shopping_order_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_history to fetch.\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_histories to fetch.\n     */\n    orderBy?: shopping_order_historyOrderByWithRelationInput | shopping_order_historyOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_histories.\n     */\n    cursor?: shopping_order_historyWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_histories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_histories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_histories.\n     */\n    distinct?: Shopping_order_historyScalarFieldEnum | Shopping_order_historyScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_history findFirstOrThrow\n   */\n  export type shopping_order_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_history to fetch.\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_histories to fetch.\n     */\n    orderBy?: shopping_order_historyOrderByWithRelationInput | shopping_order_historyOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_order_histories.\n     */\n    cursor?: shopping_order_historyWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_histories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_histories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_order_histories.\n     */\n    distinct?: Shopping_order_historyScalarFieldEnum | Shopping_order_historyScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_history findMany\n   */\n  export type shopping_order_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_order_histories to fetch.\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_order_histories to fetch.\n     */\n    orderBy?: shopping_order_historyOrderByWithRelationInput | shopping_order_historyOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_order_histories.\n     */\n    cursor?: shopping_order_historyWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_order_histories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_order_histories.\n     */\n    skip?: number\n    distinct?: Shopping_order_historyScalarFieldEnum | Shopping_order_historyScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_order_history create\n   */\n  export type shopping_order_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_order_history.\n     */\n    data: XOR<shopping_order_historyCreateInput, shopping_order_historyUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_order_history createMany\n   */\n  export type shopping_order_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_order_histories.\n     */\n    data: shopping_order_historyCreateManyInput | shopping_order_historyCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_order_history createManyAndReturn\n   */\n  export type shopping_order_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_order_histories.\n     */\n    data: shopping_order_historyCreateManyInput | shopping_order_historyCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_history update\n   */\n  export type shopping_order_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_order_history.\n     */\n    data: XOR<shopping_order_historyUpdateInput, shopping_order_historyUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_order_history to update.\n     */\n    where: shopping_order_historyWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_history updateMany\n   */\n  export type shopping_order_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_order_histories.\n     */\n    data: XOR<shopping_order_historyUpdateManyMutationInput, shopping_order_historyUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_histories to update\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * Limit how many shopping_order_histories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_history updateManyAndReturn\n   */\n  export type shopping_order_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_order_histories.\n     */\n    data: XOR<shopping_order_historyUpdateManyMutationInput, shopping_order_historyUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_order_histories to update\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * Limit how many shopping_order_histories to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_order_history upsert\n   */\n  export type shopping_order_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_order_history to update in case it exists.\n     */\n    where: shopping_order_historyWhereUniqueInput\n    /**\n     * In case the shopping_order_history found by the `where` argument doesn't exist, create a new shopping_order_history with this data.\n     */\n    create: XOR<shopping_order_historyCreateInput, shopping_order_historyUncheckedCreateInput>\n    /**\n     * In case the shopping_order_history was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_order_historyUpdateInput, shopping_order_historyUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_order_history delete\n   */\n  export type shopping_order_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_order_history to delete.\n     */\n    where: shopping_order_historyWhereUniqueInput\n  }\n\n  /**\n   * shopping_order_history deleteMany\n   */\n  export type shopping_order_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_order_histories to delete\n     */\n    where?: shopping_order_historyWhereInput\n    /**\n     * Limit how many shopping_order_histories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_order_history without action\n   */\n  export type shopping_order_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_order_history\n     */\n    select?: shopping_order_historySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_order_history\n     */\n    omit?: shopping_order_historyOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_order_historyInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_shopping_carts\n   */\n\n  export type AggregateShopping_shopping_carts = {\n    _count: Shopping_shopping_cartsCountAggregateOutputType | null\n    _min: Shopping_shopping_cartsMinAggregateOutputType | null\n    _max: Shopping_shopping_cartsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_shopping_cartsMinAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shopping_cartsMaxAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shopping_cartsCountAggregateOutputType = {\n    id: number\n    shopping_customer_id: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_shopping_cartsMinAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shopping_cartsMaxAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shopping_cartsCountAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_shopping_cartsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shopping_carts to aggregate.\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shopping_carts to fetch.\n     */\n    orderBy?: shopping_shopping_cartsOrderByWithRelationInput | shopping_shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_shopping_carts\n    **/\n    _count?: true | Shopping_shopping_cartsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_shopping_cartsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_shopping_cartsMaxAggregateInputType\n  }\n\n  export type GetShopping_shopping_cartsAggregateType<T extends Shopping_shopping_cartsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_shopping_carts]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_shopping_carts[P]>\n      : GetScalarType<T[P], AggregateShopping_shopping_carts[P]>\n  }\n\n\n\n\n  export type shopping_shopping_cartsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shopping_cartsWhereInput\n    orderBy?: shopping_shopping_cartsOrderByWithAggregationInput | shopping_shopping_cartsOrderByWithAggregationInput[]\n    by: Shopping_shopping_cartsScalarFieldEnum[] | Shopping_shopping_cartsScalarFieldEnum\n    having?: shopping_shopping_cartsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_shopping_cartsCountAggregateInputType | true\n    _min?: Shopping_shopping_cartsMinAggregateInputType\n    _max?: Shopping_shopping_cartsMaxAggregateInputType\n  }\n\n  export type Shopping_shopping_cartsGroupByOutputType = {\n    id: string\n    shopping_customer_id: string\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_shopping_cartsCountAggregateOutputType | null\n    _min: Shopping_shopping_cartsMinAggregateOutputType | null\n    _max: Shopping_shopping_cartsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_shopping_cartsGroupByPayload<T extends shopping_shopping_cartsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_shopping_cartsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_shopping_cartsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_shopping_cartsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_shopping_cartsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_shopping_cartsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_shopping_carts$shopping_cart_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_shopping_cartsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shopping_carts\"]>\n\n  export type shopping_shopping_cartsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shopping_carts\"]>\n\n  export type shopping_shopping_cartsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shopping_carts\"]>\n\n  export type shopping_shopping_cartsSelectScalar = {\n    id?: boolean\n    shopping_customer_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_shopping_cartsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_customer_id\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_shopping_carts\"]>\n  export type shopping_shopping_cartsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    shopping_cart_items?: boolean | shopping_shopping_carts$shopping_cart_itemsArgs<ExtArgs>\n    _count?: boolean | Shopping_shopping_cartsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_shopping_cartsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n  export type shopping_shopping_cartsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_shopping_cartsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_shopping_carts\"\n    objects: {\n      customer: Prisma.$shopping_customersPayload<ExtArgs>\n      shopping_cart_items: Prisma.$shopping_cart_itemsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Customer who owns this shopping cart. {@link shopping_customers.id}.\n       */\n      shopping_customer_id: string\n      /**\n       * Timestamp when the shopping cart was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the shopping cart was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_shopping_carts\"]>\n    composites: {}\n  }\n\n  type shopping_shopping_cartsGetPayload<S extends boolean | null | undefined | shopping_shopping_cartsDefaultArgs> = $Result.GetResult<Prisma.$shopping_shopping_cartsPayload, S>\n\n  type shopping_shopping_cartsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_shopping_cartsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_shopping_cartsCountAggregateInputType | true\n    }\n\n  export interface shopping_shopping_cartsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_shopping_carts'], meta: { name: 'shopping_shopping_carts' } }\n    /**\n     * Find zero or one Shopping_shopping_carts that matches the filter.\n     * @param {shopping_shopping_cartsFindUniqueArgs} args - Arguments to find a Shopping_shopping_carts\n     * @example\n     * // Get one Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_shopping_cartsFindUniqueArgs>(args: SelectSubset<T, shopping_shopping_cartsFindUniqueArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_shopping_carts that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_shopping_cartsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_shopping_carts\n     * @example\n     * // Get one Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_shopping_cartsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_shopping_cartsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shopping_carts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsFindFirstArgs} args - Arguments to find a Shopping_shopping_carts\n     * @example\n     * // Get one Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_shopping_cartsFindFirstArgs>(args?: SelectSubset<T, shopping_shopping_cartsFindFirstArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shopping_carts that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsFindFirstOrThrowArgs} args - Arguments to find a Shopping_shopping_carts\n     * @example\n     * // Get one Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_shopping_cartsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_shopping_cartsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_shopping_carts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findMany()\n     * \n     * // Get first 10 Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_shopping_cartsWithIdOnly = await prisma.shopping_shopping_carts.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_shopping_cartsFindManyArgs>(args?: SelectSubset<T, shopping_shopping_cartsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsCreateArgs} args - Arguments to create a Shopping_shopping_carts.\n     * @example\n     * // Create one Shopping_shopping_carts\n     * const Shopping_shopping_carts = await prisma.shopping_shopping_carts.create({\n     *   data: {\n     *     // ... data to create a Shopping_shopping_carts\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_shopping_cartsCreateArgs>(args: SelectSubset<T, shopping_shopping_cartsCreateArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsCreateManyArgs} args - Arguments to create many Shopping_shopping_carts.\n     * @example\n     * // Create many Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_shopping_cartsCreateManyArgs>(args?: SelectSubset<T, shopping_shopping_cartsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_shopping_carts and returns the data saved in the database.\n     * @param {shopping_shopping_cartsCreateManyAndReturnArgs} args - Arguments to create many Shopping_shopping_carts.\n     * @example\n     * // Create many Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_shopping_carts and only return the `id`\n     * const shopping_shopping_cartsWithIdOnly = await prisma.shopping_shopping_carts.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_shopping_cartsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_shopping_cartsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsDeleteArgs} args - Arguments to delete one Shopping_shopping_carts.\n     * @example\n     * // Delete one Shopping_shopping_carts\n     * const Shopping_shopping_carts = await prisma.shopping_shopping_carts.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_shopping_carts\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_shopping_cartsDeleteArgs>(args: SelectSubset<T, shopping_shopping_cartsDeleteArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsUpdateArgs} args - Arguments to update one Shopping_shopping_carts.\n     * @example\n     * // Update one Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_shopping_cartsUpdateArgs>(args: SelectSubset<T, shopping_shopping_cartsUpdateArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsDeleteManyArgs} args - Arguments to filter Shopping_shopping_carts to delete.\n     * @example\n     * // Delete a few Shopping_shopping_carts\n     * const { count } = await prisma.shopping_shopping_carts.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_shopping_cartsDeleteManyArgs>(args?: SelectSubset<T, shopping_shopping_cartsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_shopping_cartsUpdateManyArgs>(args: SelectSubset<T, shopping_shopping_cartsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shopping_carts and returns the data updated in the database.\n     * @param {shopping_shopping_cartsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_shopping_carts.\n     * @example\n     * // Update many Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_shopping_carts and only return the `id`\n     * const shopping_shopping_cartsWithIdOnly = await prisma.shopping_shopping_carts.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_shopping_cartsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_shopping_cartsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_shopping_carts.\n     * @param {shopping_shopping_cartsUpsertArgs} args - Arguments to update or create a Shopping_shopping_carts.\n     * @example\n     * // Update or create a Shopping_shopping_carts\n     * const shopping_shopping_carts = await prisma.shopping_shopping_carts.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_shopping_carts\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_shopping_carts we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_shopping_cartsUpsertArgs>(args: SelectSubset<T, shopping_shopping_cartsUpsertArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsCountArgs} args - Arguments to filter Shopping_shopping_carts to count.\n     * @example\n     * // Count the number of Shopping_shopping_carts\n     * const count = await prisma.shopping_shopping_carts.count({\n     *   where: {\n     *     // ... the filter for the Shopping_shopping_carts we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_shopping_cartsCountArgs>(\n      args?: Subset<T, shopping_shopping_cartsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_shopping_cartsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_shopping_cartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_shopping_cartsAggregateArgs>(args: Subset<T, Shopping_shopping_cartsAggregateArgs>): Prisma.PrismaPromise<GetShopping_shopping_cartsAggregateType<T>>\n\n    /**\n     * Group by Shopping_shopping_carts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shopping_cartsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_shopping_cartsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_shopping_cartsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_shopping_cartsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_shopping_cartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_shopping_cartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_shopping_carts model\n   */\n  readonly fields: shopping_shopping_cartsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_shopping_carts.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_shopping_cartsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    customer<T extends shopping_customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customersDefaultArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_cart_items<T extends shopping_shopping_carts$shopping_cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shopping_carts$shopping_cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_shopping_carts model\n   */\n  interface shopping_shopping_cartsFieldRefs {\n    readonly id: FieldRef<\"shopping_shopping_carts\", 'String'>\n    readonly shopping_customer_id: FieldRef<\"shopping_shopping_carts\", 'String'>\n    readonly created_at: FieldRef<\"shopping_shopping_carts\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_shopping_carts\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_shopping_carts findUnique\n   */\n  export type shopping_shopping_cartsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shopping_carts to fetch.\n     */\n    where: shopping_shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shopping_carts findUniqueOrThrow\n   */\n  export type shopping_shopping_cartsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shopping_carts to fetch.\n     */\n    where: shopping_shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shopping_carts findFirst\n   */\n  export type shopping_shopping_cartsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shopping_carts to fetch.\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shopping_carts to fetch.\n     */\n    orderBy?: shopping_shopping_cartsOrderByWithRelationInput | shopping_shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shopping_carts.\n     */\n    cursor?: shopping_shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shopping_carts.\n     */\n    distinct?: Shopping_shopping_cartsScalarFieldEnum | Shopping_shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shopping_carts findFirstOrThrow\n   */\n  export type shopping_shopping_cartsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shopping_carts to fetch.\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shopping_carts to fetch.\n     */\n    orderBy?: shopping_shopping_cartsOrderByWithRelationInput | shopping_shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shopping_carts.\n     */\n    cursor?: shopping_shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shopping_carts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shopping_carts.\n     */\n    distinct?: Shopping_shopping_cartsScalarFieldEnum | Shopping_shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shopping_carts findMany\n   */\n  export type shopping_shopping_cartsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shopping_carts to fetch.\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shopping_carts to fetch.\n     */\n    orderBy?: shopping_shopping_cartsOrderByWithRelationInput | shopping_shopping_cartsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_shopping_carts.\n     */\n    cursor?: shopping_shopping_cartsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shopping_carts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shopping_carts.\n     */\n    skip?: number\n    distinct?: Shopping_shopping_cartsScalarFieldEnum | Shopping_shopping_cartsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shopping_carts create\n   */\n  export type shopping_shopping_cartsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_shopping_carts.\n     */\n    data: XOR<shopping_shopping_cartsCreateInput, shopping_shopping_cartsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_shopping_carts createMany\n   */\n  export type shopping_shopping_cartsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_shopping_carts.\n     */\n    data: shopping_shopping_cartsCreateManyInput | shopping_shopping_cartsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shopping_carts createManyAndReturn\n   */\n  export type shopping_shopping_cartsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_shopping_carts.\n     */\n    data: shopping_shopping_cartsCreateManyInput | shopping_shopping_cartsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_shopping_carts update\n   */\n  export type shopping_shopping_cartsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_shopping_carts.\n     */\n    data: XOR<shopping_shopping_cartsUpdateInput, shopping_shopping_cartsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_shopping_carts to update.\n     */\n    where: shopping_shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shopping_carts updateMany\n   */\n  export type shopping_shopping_cartsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_shopping_carts.\n     */\n    data: XOR<shopping_shopping_cartsUpdateManyMutationInput, shopping_shopping_cartsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shopping_carts to update\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_shopping_carts to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shopping_carts updateManyAndReturn\n   */\n  export type shopping_shopping_cartsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_shopping_carts.\n     */\n    data: XOR<shopping_shopping_cartsUpdateManyMutationInput, shopping_shopping_cartsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shopping_carts to update\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_shopping_carts to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_shopping_carts upsert\n   */\n  export type shopping_shopping_cartsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_shopping_carts to update in case it exists.\n     */\n    where: shopping_shopping_cartsWhereUniqueInput\n    /**\n     * In case the shopping_shopping_carts found by the `where` argument doesn't exist, create a new shopping_shopping_carts with this data.\n     */\n    create: XOR<shopping_shopping_cartsCreateInput, shopping_shopping_cartsUncheckedCreateInput>\n    /**\n     * In case the shopping_shopping_carts was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_shopping_cartsUpdateInput, shopping_shopping_cartsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_shopping_carts delete\n   */\n  export type shopping_shopping_cartsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_shopping_carts to delete.\n     */\n    where: shopping_shopping_cartsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shopping_carts deleteMany\n   */\n  export type shopping_shopping_cartsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shopping_carts to delete\n     */\n    where?: shopping_shopping_cartsWhereInput\n    /**\n     * Limit how many shopping_shopping_carts to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shopping_carts.shopping_cart_items\n   */\n  export type shopping_shopping_carts$shopping_cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shopping_carts without action\n   */\n  export type shopping_shopping_cartsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shopping_carts\n     */\n    select?: shopping_shopping_cartsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shopping_carts\n     */\n    omit?: shopping_shopping_cartsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shopping_cartsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_cart_items\n   */\n\n  export type AggregateShopping_cart_items = {\n    _count: Shopping_cart_itemsCountAggregateOutputType | null\n    _avg: Shopping_cart_itemsAvgAggregateOutputType | null\n    _sum: Shopping_cart_itemsSumAggregateOutputType | null\n    _min: Shopping_cart_itemsMinAggregateOutputType | null\n    _max: Shopping_cart_itemsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_cart_itemsAvgAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_cart_itemsSumAggregateOutputType = {\n    quantity: number | null\n    price: number | null\n  }\n\n  export type Shopping_cart_itemsMinAggregateOutputType = {\n    id: string | null\n    shopping_shopping_cart_id: string | null\n    shopping_product_variant_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cart_itemsMaxAggregateOutputType = {\n    id: string | null\n    shopping_shopping_cart_id: string | null\n    shopping_product_variant_id: string | null\n    quantity: number | null\n    price: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_cart_itemsCountAggregateOutputType = {\n    id: number\n    shopping_shopping_cart_id: number\n    shopping_product_variant_id: number\n    quantity: number\n    price: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_cart_itemsAvgAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_cart_itemsSumAggregateInputType = {\n    quantity?: true\n    price?: true\n  }\n\n  export type Shopping_cart_itemsMinAggregateInputType = {\n    id?: true\n    shopping_shopping_cart_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cart_itemsMaxAggregateInputType = {\n    id?: true\n    shopping_shopping_cart_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_cart_itemsCountAggregateInputType = {\n    id?: true\n    shopping_shopping_cart_id?: true\n    shopping_product_variant_id?: true\n    quantity?: true\n    price?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_cart_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_cart_items to aggregate.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_cart_items\n    **/\n    _count?: true | Shopping_cart_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_cart_itemsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_cart_itemsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_cart_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_cart_itemsMaxAggregateInputType\n  }\n\n  export type GetShopping_cart_itemsAggregateType<T extends Shopping_cart_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_cart_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_cart_items[P]>\n      : GetScalarType<T[P], AggregateShopping_cart_items[P]>\n  }\n\n\n\n\n  export type shopping_cart_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_cart_itemsWhereInput\n    orderBy?: shopping_cart_itemsOrderByWithAggregationInput | shopping_cart_itemsOrderByWithAggregationInput[]\n    by: Shopping_cart_itemsScalarFieldEnum[] | Shopping_cart_itemsScalarFieldEnum\n    having?: shopping_cart_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_cart_itemsCountAggregateInputType | true\n    _avg?: Shopping_cart_itemsAvgAggregateInputType\n    _sum?: Shopping_cart_itemsSumAggregateInputType\n    _min?: Shopping_cart_itemsMinAggregateInputType\n    _max?: Shopping_cart_itemsMaxAggregateInputType\n  }\n\n  export type Shopping_cart_itemsGroupByOutputType = {\n    id: string\n    shopping_shopping_cart_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    price: number\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_cart_itemsCountAggregateOutputType | null\n    _avg: Shopping_cart_itemsAvgAggregateOutputType | null\n    _sum: Shopping_cart_itemsSumAggregateOutputType | null\n    _min: Shopping_cart_itemsMinAggregateOutputType | null\n    _max: Shopping_cart_itemsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_cart_itemsGroupByPayload<T extends shopping_cart_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_cart_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_cart_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_cart_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_cart_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_cart_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_shopping_cart_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_shopping_cart_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_shopping_cart_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n\n  export type shopping_cart_itemsSelectScalar = {\n    id?: boolean\n    shopping_shopping_cart_id?: boolean\n    shopping_product_variant_id?: boolean\n    quantity?: boolean\n    price?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_cart_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_shopping_cart_id\" | \"shopping_product_variant_id\" | \"quantity\" | \"price\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_cart_items\"]>\n  export type shopping_cart_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_cart_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_cart_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    cart?: boolean | shopping_shopping_cartsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_cart_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_cart_items\"\n    objects: {\n      cart: Prisma.$shopping_shopping_cartsPayload<ExtArgs>\n      productVariant: Prisma.$shopping_product_variantsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Shopping cart that contains this item. {@link shopping_shopping_carts.id}.\n       */\n      shopping_shopping_cart_id: string\n      /**\n       * Product variant referenced by this cart item. {@link\n       * shopping_product_variants.id}.\n       */\n      shopping_product_variant_id: string\n      /**\n       * Quantity of this product variant in the cart.\n       */\n      quantity: number\n      /**\n       * Price of the product variant at the time it was added to the cart.\n       */\n      price: number\n      /**\n       * Timestamp when the cart item was added.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the cart item was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_cart_items\"]>\n    composites: {}\n  }\n\n  type shopping_cart_itemsGetPayload<S extends boolean | null | undefined | shopping_cart_itemsDefaultArgs> = $Result.GetResult<Prisma.$shopping_cart_itemsPayload, S>\n\n  type shopping_cart_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_cart_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_cart_itemsCountAggregateInputType | true\n    }\n\n  export interface shopping_cart_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_cart_items'], meta: { name: 'shopping_cart_items' } }\n    /**\n     * Find zero or one Shopping_cart_items that matches the filter.\n     * @param {shopping_cart_itemsFindUniqueArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_cart_itemsFindUniqueArgs>(args: SelectSubset<T, shopping_cart_itemsFindUniqueArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_cart_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_cart_itemsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_cart_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_cart_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindFirstArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_cart_itemsFindFirstArgs>(args?: SelectSubset<T, shopping_cart_itemsFindFirstArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_cart_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindFirstOrThrowArgs} args - Arguments to find a Shopping_cart_items\n     * @example\n     * // Get one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_cart_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_cart_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findMany()\n     * \n     * // Get first 10 Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_cart_itemsFindManyArgs>(args?: SelectSubset<T, shopping_cart_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_cart_items.\n     * @param {shopping_cart_itemsCreateArgs} args - Arguments to create a Shopping_cart_items.\n     * @example\n     * // Create one Shopping_cart_items\n     * const Shopping_cart_items = await prisma.shopping_cart_items.create({\n     *   data: {\n     *     // ... data to create a Shopping_cart_items\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_cart_itemsCreateArgs>(args: SelectSubset<T, shopping_cart_itemsCreateArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_cart_items.\n     * @param {shopping_cart_itemsCreateManyArgs} args - Arguments to create many Shopping_cart_items.\n     * @example\n     * // Create many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_cart_itemsCreateManyArgs>(args?: SelectSubset<T, shopping_cart_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_cart_items and returns the data saved in the database.\n     * @param {shopping_cart_itemsCreateManyAndReturnArgs} args - Arguments to create many Shopping_cart_items.\n     * @example\n     * // Create many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_cart_items and only return the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_cart_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_cart_items.\n     * @param {shopping_cart_itemsDeleteArgs} args - Arguments to delete one Shopping_cart_items.\n     * @example\n     * // Delete one Shopping_cart_items\n     * const Shopping_cart_items = await prisma.shopping_cart_items.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_cart_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_cart_itemsDeleteArgs>(args: SelectSubset<T, shopping_cart_itemsDeleteArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_cart_items.\n     * @param {shopping_cart_itemsUpdateArgs} args - Arguments to update one Shopping_cart_items.\n     * @example\n     * // Update one Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_cart_itemsUpdateArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_cart_items.\n     * @param {shopping_cart_itemsDeleteManyArgs} args - Arguments to filter Shopping_cart_items to delete.\n     * @example\n     * // Delete a few Shopping_cart_items\n     * const { count } = await prisma.shopping_cart_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_cart_itemsDeleteManyArgs>(args?: SelectSubset<T, shopping_cart_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_cart_itemsUpdateManyArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_cart_items and returns the data updated in the database.\n     * @param {shopping_cart_itemsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_cart_items.\n     * @example\n     * // Update many Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_cart_items and only return the `id`\n     * const shopping_cart_itemsWithIdOnly = await prisma.shopping_cart_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_cart_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_cart_items.\n     * @param {shopping_cart_itemsUpsertArgs} args - Arguments to update or create a Shopping_cart_items.\n     * @example\n     * // Update or create a Shopping_cart_items\n     * const shopping_cart_items = await prisma.shopping_cart_items.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_cart_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_cart_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_cart_itemsUpsertArgs>(args: SelectSubset<T, shopping_cart_itemsUpsertArgs<ExtArgs>>): Prisma__shopping_cart_itemsClient<$Result.GetResult<Prisma.$shopping_cart_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsCountArgs} args - Arguments to filter Shopping_cart_items to count.\n     * @example\n     * // Count the number of Shopping_cart_items\n     * const count = await prisma.shopping_cart_items.count({\n     *   where: {\n     *     // ... the filter for the Shopping_cart_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_cart_itemsCountArgs>(\n      args?: Subset<T, shopping_cart_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_cart_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_cart_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_cart_itemsAggregateArgs>(args: Subset<T, Shopping_cart_itemsAggregateArgs>): Prisma.PrismaPromise<GetShopping_cart_itemsAggregateType<T>>\n\n    /**\n     * Group by Shopping_cart_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_cart_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_cart_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_cart_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_cart_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_cart_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_cart_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_cart_items model\n   */\n  readonly fields: shopping_cart_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_cart_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_cart_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    cart<T extends shopping_shopping_cartsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shopping_cartsDefaultArgs<ExtArgs>>): Prisma__shopping_shopping_cartsClient<$Result.GetResult<Prisma.$shopping_shopping_cartsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    productVariant<T extends shopping_product_variantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variantsDefaultArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_cart_items model\n   */\n  interface shopping_cart_itemsFieldRefs {\n    readonly id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly shopping_shopping_cart_id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly shopping_product_variant_id: FieldRef<\"shopping_cart_items\", 'String'>\n    readonly quantity: FieldRef<\"shopping_cart_items\", 'Int'>\n    readonly price: FieldRef<\"shopping_cart_items\", 'Float'>\n    readonly created_at: FieldRef<\"shopping_cart_items\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_cart_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_cart_items findUnique\n   */\n  export type shopping_cart_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items findUniqueOrThrow\n   */\n  export type shopping_cart_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items findFirst\n   */\n  export type shopping_cart_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_cart_items.\n     */\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items findFirstOrThrow\n   */\n  export type shopping_cart_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_cart_items.\n     */\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items findMany\n   */\n  export type shopping_cart_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_cart_items to fetch.\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_cart_items to fetch.\n     */\n    orderBy?: shopping_cart_itemsOrderByWithRelationInput | shopping_cart_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_cart_items.\n     */\n    cursor?: shopping_cart_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_cart_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_cart_items.\n     */\n    skip?: number\n    distinct?: Shopping_cart_itemsScalarFieldEnum | Shopping_cart_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_cart_items create\n   */\n  export type shopping_cart_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsCreateInput, shopping_cart_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_cart_items createMany\n   */\n  export type shopping_cart_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_cart_items.\n     */\n    data: shopping_cart_itemsCreateManyInput | shopping_cart_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_cart_items createManyAndReturn\n   */\n  export type shopping_cart_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_cart_items.\n     */\n    data: shopping_cart_itemsCreateManyInput | shopping_cart_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_cart_items update\n   */\n  export type shopping_cart_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateInput, shopping_cart_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_cart_items to update.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items updateMany\n   */\n  export type shopping_cart_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_cart_items to update\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_cart_items updateManyAndReturn\n   */\n  export type shopping_cart_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_cart_items.\n     */\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_cart_items to update\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_cart_items upsert\n   */\n  export type shopping_cart_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_cart_items to update in case it exists.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n    /**\n     * In case the shopping_cart_items found by the `where` argument doesn't exist, create a new shopping_cart_items with this data.\n     */\n    create: XOR<shopping_cart_itemsCreateInput, shopping_cart_itemsUncheckedCreateInput>\n    /**\n     * In case the shopping_cart_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_cart_itemsUpdateInput, shopping_cart_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_cart_items delete\n   */\n  export type shopping_cart_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_cart_items to delete.\n     */\n    where: shopping_cart_itemsWhereUniqueInput\n  }\n\n  /**\n   * shopping_cart_items deleteMany\n   */\n  export type shopping_cart_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_cart_items to delete\n     */\n    where?: shopping_cart_itemsWhereInput\n    /**\n     * Limit how many shopping_cart_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_cart_items without action\n   */\n  export type shopping_cart_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_cart_items\n     */\n    select?: shopping_cart_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_cart_items\n     */\n    omit?: shopping_cart_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_cart_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_review_moderation\n   */\n\n  export type AggregateShopping_review_moderation = {\n    _count: Shopping_review_moderationCountAggregateOutputType | null\n    _min: Shopping_review_moderationMinAggregateOutputType | null\n    _max: Shopping_review_moderationMaxAggregateOutputType | null\n  }\n\n  export type Shopping_review_moderationMinAggregateOutputType = {\n    id: string | null\n    shopping_product_review_id: string | null\n    shopping_administrator_id: string | null\n    action_type: string | null\n    reason: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_review_moderationMaxAggregateOutputType = {\n    id: string | null\n    shopping_product_review_id: string | null\n    shopping_administrator_id: string | null\n    action_type: string | null\n    reason: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_review_moderationCountAggregateOutputType = {\n    id: number\n    shopping_product_review_id: number\n    shopping_administrator_id: number\n    action_type: number\n    reason: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_review_moderationMinAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    reason?: true\n    created_at?: true\n  }\n\n  export type Shopping_review_moderationMaxAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    reason?: true\n    created_at?: true\n  }\n\n  export type Shopping_review_moderationCountAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    reason?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_review_moderationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_review_moderation to aggregate.\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_moderations to fetch.\n     */\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_review_moderationWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_moderations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_moderations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_review_moderations\n    **/\n    _count?: true | Shopping_review_moderationCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_review_moderationMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_review_moderationMaxAggregateInputType\n  }\n\n  export type GetShopping_review_moderationAggregateType<T extends Shopping_review_moderationAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_review_moderation]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_review_moderation[P]>\n      : GetScalarType<T[P], AggregateShopping_review_moderation[P]>\n  }\n\n\n\n\n  export type shopping_review_moderationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_review_moderationWhereInput\n    orderBy?: shopping_review_moderationOrderByWithAggregationInput | shopping_review_moderationOrderByWithAggregationInput[]\n    by: Shopping_review_moderationScalarFieldEnum[] | Shopping_review_moderationScalarFieldEnum\n    having?: shopping_review_moderationScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_review_moderationCountAggregateInputType | true\n    _min?: Shopping_review_moderationMinAggregateInputType\n    _max?: Shopping_review_moderationMaxAggregateInputType\n  }\n\n  export type Shopping_review_moderationGroupByOutputType = {\n    id: string\n    shopping_product_review_id: string\n    shopping_administrator_id: string\n    action_type: string\n    reason: string | null\n    created_at: Date\n    _count: Shopping_review_moderationCountAggregateOutputType | null\n    _min: Shopping_review_moderationMinAggregateOutputType | null\n    _max: Shopping_review_moderationMaxAggregateOutputType | null\n  }\n\n  type GetShopping_review_moderationGroupByPayload<T extends shopping_review_moderationGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_review_moderationGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_review_moderationGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_review_moderationGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_review_moderationGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_review_moderationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    reason?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_moderation\"]>\n\n  export type shopping_review_moderationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    reason?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_moderation\"]>\n\n  export type shopping_review_moderationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    reason?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_moderation\"]>\n\n  export type shopping_review_moderationSelectScalar = {\n    id?: boolean\n    shopping_product_review_id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    reason?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_review_moderationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_product_review_id\" | \"shopping_administrator_id\" | \"action_type\" | \"reason\" | \"created_at\", ExtArgs[\"result\"][\"shopping_review_moderation\"]>\n  export type shopping_review_moderationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n  export type shopping_review_moderationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n  export type shopping_review_moderationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_review_moderationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_review_moderation\"\n    objects: {\n      review: Prisma.$shopping_product_reviewsPayload<ExtArgs>\n      administrator: Prisma.$shopping_administratorsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The review being moderated. {@link shopping_product_reviews.id}.\n       */\n      shopping_product_review_id: string\n      /**\n       * The administrator who performed the moderation action. {@link\n       * shopping_administrators.id}.\n       */\n      shopping_administrator_id: string\n      /**\n       * Type of moderation action (approve, reject, flag).\n       */\n      action_type: string\n      /**\n       * Reason for the moderation action.\n       */\n      reason: string | null\n      /**\n       * When the moderation action was performed.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_review_moderation\"]>\n    composites: {}\n  }\n\n  type shopping_review_moderationGetPayload<S extends boolean | null | undefined | shopping_review_moderationDefaultArgs> = $Result.GetResult<Prisma.$shopping_review_moderationPayload, S>\n\n  type shopping_review_moderationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_review_moderationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_review_moderationCountAggregateInputType | true\n    }\n\n  export interface shopping_review_moderationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_review_moderation'], meta: { name: 'shopping_review_moderation' } }\n    /**\n     * Find zero or one Shopping_review_moderation that matches the filter.\n     * @param {shopping_review_moderationFindUniqueArgs} args - Arguments to find a Shopping_review_moderation\n     * @example\n     * // Get one Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_review_moderationFindUniqueArgs>(args: SelectSubset<T, shopping_review_moderationFindUniqueArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_review_moderation that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_review_moderationFindUniqueOrThrowArgs} args - Arguments to find a Shopping_review_moderation\n     * @example\n     * // Get one Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_review_moderationFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_review_moderationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_review_moderation that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationFindFirstArgs} args - Arguments to find a Shopping_review_moderation\n     * @example\n     * // Get one Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_review_moderationFindFirstArgs>(args?: SelectSubset<T, shopping_review_moderationFindFirstArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_review_moderation that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationFindFirstOrThrowArgs} args - Arguments to find a Shopping_review_moderation\n     * @example\n     * // Get one Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_review_moderationFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_review_moderationFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_review_moderations that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_review_moderations\n     * const shopping_review_moderations = await prisma.shopping_review_moderation.findMany()\n     * \n     * // Get first 10 Shopping_review_moderations\n     * const shopping_review_moderations = await prisma.shopping_review_moderation.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_review_moderationWithIdOnly = await prisma.shopping_review_moderation.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_review_moderationFindManyArgs>(args?: SelectSubset<T, shopping_review_moderationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_review_moderation.\n     * @param {shopping_review_moderationCreateArgs} args - Arguments to create a Shopping_review_moderation.\n     * @example\n     * // Create one Shopping_review_moderation\n     * const Shopping_review_moderation = await prisma.shopping_review_moderation.create({\n     *   data: {\n     *     // ... data to create a Shopping_review_moderation\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_review_moderationCreateArgs>(args: SelectSubset<T, shopping_review_moderationCreateArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_review_moderations.\n     * @param {shopping_review_moderationCreateManyArgs} args - Arguments to create many Shopping_review_moderations.\n     * @example\n     * // Create many Shopping_review_moderations\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_review_moderationCreateManyArgs>(args?: SelectSubset<T, shopping_review_moderationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_review_moderations and returns the data saved in the database.\n     * @param {shopping_review_moderationCreateManyAndReturnArgs} args - Arguments to create many Shopping_review_moderations.\n     * @example\n     * // Create many Shopping_review_moderations\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_review_moderations and only return the `id`\n     * const shopping_review_moderationWithIdOnly = await prisma.shopping_review_moderation.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_review_moderationCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_review_moderationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_review_moderation.\n     * @param {shopping_review_moderationDeleteArgs} args - Arguments to delete one Shopping_review_moderation.\n     * @example\n     * // Delete one Shopping_review_moderation\n     * const Shopping_review_moderation = await prisma.shopping_review_moderation.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_review_moderation\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_review_moderationDeleteArgs>(args: SelectSubset<T, shopping_review_moderationDeleteArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_review_moderation.\n     * @param {shopping_review_moderationUpdateArgs} args - Arguments to update one Shopping_review_moderation.\n     * @example\n     * // Update one Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_review_moderationUpdateArgs>(args: SelectSubset<T, shopping_review_moderationUpdateArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_review_moderations.\n     * @param {shopping_review_moderationDeleteManyArgs} args - Arguments to filter Shopping_review_moderations to delete.\n     * @example\n     * // Delete a few Shopping_review_moderations\n     * const { count } = await prisma.shopping_review_moderation.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_review_moderationDeleteManyArgs>(args?: SelectSubset<T, shopping_review_moderationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_review_moderations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_review_moderations\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_review_moderationUpdateManyArgs>(args: SelectSubset<T, shopping_review_moderationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_review_moderations and returns the data updated in the database.\n     * @param {shopping_review_moderationUpdateManyAndReturnArgs} args - Arguments to update many Shopping_review_moderations.\n     * @example\n     * // Update many Shopping_review_moderations\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_review_moderations and only return the `id`\n     * const shopping_review_moderationWithIdOnly = await prisma.shopping_review_moderation.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_review_moderationUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_review_moderationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_review_moderation.\n     * @param {shopping_review_moderationUpsertArgs} args - Arguments to update or create a Shopping_review_moderation.\n     * @example\n     * // Update or create a Shopping_review_moderation\n     * const shopping_review_moderation = await prisma.shopping_review_moderation.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_review_moderation\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_review_moderation we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_review_moderationUpsertArgs>(args: SelectSubset<T, shopping_review_moderationUpsertArgs<ExtArgs>>): Prisma__shopping_review_moderationClient<$Result.GetResult<Prisma.$shopping_review_moderationPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_review_moderations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationCountArgs} args - Arguments to filter Shopping_review_moderations to count.\n     * @example\n     * // Count the number of Shopping_review_moderations\n     * const count = await prisma.shopping_review_moderation.count({\n     *   where: {\n     *     // ... the filter for the Shopping_review_moderations we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_review_moderationCountArgs>(\n      args?: Subset<T, shopping_review_moderationCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_review_moderationCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_review_moderation.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_review_moderationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_review_moderationAggregateArgs>(args: Subset<T, Shopping_review_moderationAggregateArgs>): Prisma.PrismaPromise<GetShopping_review_moderationAggregateType<T>>\n\n    /**\n     * Group by Shopping_review_moderation.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_moderationGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_review_moderationGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_review_moderationGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_review_moderationGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_review_moderationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_review_moderationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_review_moderation model\n   */\n  readonly fields: shopping_review_moderationFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_review_moderation.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_review_moderationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    review<T extends shopping_product_reviewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_reviewsDefaultArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    administrator<T extends shopping_administratorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_administratorsDefaultArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_review_moderation model\n   */\n  interface shopping_review_moderationFieldRefs {\n    readonly id: FieldRef<\"shopping_review_moderation\", 'String'>\n    readonly shopping_product_review_id: FieldRef<\"shopping_review_moderation\", 'String'>\n    readonly shopping_administrator_id: FieldRef<\"shopping_review_moderation\", 'String'>\n    readonly action_type: FieldRef<\"shopping_review_moderation\", 'String'>\n    readonly reason: FieldRef<\"shopping_review_moderation\", 'String'>\n    readonly created_at: FieldRef<\"shopping_review_moderation\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_review_moderation findUnique\n   */\n  export type shopping_review_moderationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_moderation to fetch.\n     */\n    where: shopping_review_moderationWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_moderation findUniqueOrThrow\n   */\n  export type shopping_review_moderationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_moderation to fetch.\n     */\n    where: shopping_review_moderationWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_moderation findFirst\n   */\n  export type shopping_review_moderationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_moderation to fetch.\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_moderations to fetch.\n     */\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_review_moderations.\n     */\n    cursor?: shopping_review_moderationWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_moderations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_moderations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_review_moderations.\n     */\n    distinct?: Shopping_review_moderationScalarFieldEnum | Shopping_review_moderationScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_moderation findFirstOrThrow\n   */\n  export type shopping_review_moderationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_moderation to fetch.\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_moderations to fetch.\n     */\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_review_moderations.\n     */\n    cursor?: shopping_review_moderationWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_moderations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_moderations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_review_moderations.\n     */\n    distinct?: Shopping_review_moderationScalarFieldEnum | Shopping_review_moderationScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_moderation findMany\n   */\n  export type shopping_review_moderationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_moderations to fetch.\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_moderations to fetch.\n     */\n    orderBy?: shopping_review_moderationOrderByWithRelationInput | shopping_review_moderationOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_review_moderations.\n     */\n    cursor?: shopping_review_moderationWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_moderations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_moderations.\n     */\n    skip?: number\n    distinct?: Shopping_review_moderationScalarFieldEnum | Shopping_review_moderationScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_moderation create\n   */\n  export type shopping_review_moderationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_review_moderation.\n     */\n    data: XOR<shopping_review_moderationCreateInput, shopping_review_moderationUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_review_moderation createMany\n   */\n  export type shopping_review_moderationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_review_moderations.\n     */\n    data: shopping_review_moderationCreateManyInput | shopping_review_moderationCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_review_moderation createManyAndReturn\n   */\n  export type shopping_review_moderationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_review_moderations.\n     */\n    data: shopping_review_moderationCreateManyInput | shopping_review_moderationCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_review_moderation update\n   */\n  export type shopping_review_moderationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_review_moderation.\n     */\n    data: XOR<shopping_review_moderationUpdateInput, shopping_review_moderationUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_review_moderation to update.\n     */\n    where: shopping_review_moderationWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_moderation updateMany\n   */\n  export type shopping_review_moderationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_review_moderations.\n     */\n    data: XOR<shopping_review_moderationUpdateManyMutationInput, shopping_review_moderationUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_review_moderations to update\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * Limit how many shopping_review_moderations to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_review_moderation updateManyAndReturn\n   */\n  export type shopping_review_moderationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_review_moderations.\n     */\n    data: XOR<shopping_review_moderationUpdateManyMutationInput, shopping_review_moderationUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_review_moderations to update\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * Limit how many shopping_review_moderations to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_review_moderation upsert\n   */\n  export type shopping_review_moderationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_review_moderation to update in case it exists.\n     */\n    where: shopping_review_moderationWhereUniqueInput\n    /**\n     * In case the shopping_review_moderation found by the `where` argument doesn't exist, create a new shopping_review_moderation with this data.\n     */\n    create: XOR<shopping_review_moderationCreateInput, shopping_review_moderationUncheckedCreateInput>\n    /**\n     * In case the shopping_review_moderation was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_review_moderationUpdateInput, shopping_review_moderationUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_review_moderation delete\n   */\n  export type shopping_review_moderationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_review_moderation to delete.\n     */\n    where: shopping_review_moderationWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_moderation deleteMany\n   */\n  export type shopping_review_moderationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_review_moderations to delete\n     */\n    where?: shopping_review_moderationWhereInput\n    /**\n     * Limit how many shopping_review_moderations to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_review_moderation without action\n   */\n  export type shopping_review_moderationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_moderation\n     */\n    select?: shopping_review_moderationSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_moderation\n     */\n    omit?: shopping_review_moderationOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_moderationInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_review_ratings\n   */\n\n  export type AggregateShopping_review_ratings = {\n    _count: Shopping_review_ratingsCountAggregateOutputType | null\n    _avg: Shopping_review_ratingsAvgAggregateOutputType | null\n    _sum: Shopping_review_ratingsSumAggregateOutputType | null\n    _min: Shopping_review_ratingsMinAggregateOutputType | null\n    _max: Shopping_review_ratingsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_review_ratingsAvgAggregateOutputType = {\n    quality_rating: number | null\n    value_rating: number | null\n    service_rating: number | null\n  }\n\n  export type Shopping_review_ratingsSumAggregateOutputType = {\n    quality_rating: number | null\n    value_rating: number | null\n    service_rating: number | null\n  }\n\n  export type Shopping_review_ratingsMinAggregateOutputType = {\n    id: string | null\n    shopping_product_review_id: string | null\n    quality_rating: number | null\n    value_rating: number | null\n    service_rating: number | null\n    created_at: Date | null\n  }\n\n  export type Shopping_review_ratingsMaxAggregateOutputType = {\n    id: string | null\n    shopping_product_review_id: string | null\n    quality_rating: number | null\n    value_rating: number | null\n    service_rating: number | null\n    created_at: Date | null\n  }\n\n  export type Shopping_review_ratingsCountAggregateOutputType = {\n    id: number\n    shopping_product_review_id: number\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_review_ratingsAvgAggregateInputType = {\n    quality_rating?: true\n    value_rating?: true\n    service_rating?: true\n  }\n\n  export type Shopping_review_ratingsSumAggregateInputType = {\n    quality_rating?: true\n    value_rating?: true\n    service_rating?: true\n  }\n\n  export type Shopping_review_ratingsMinAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    quality_rating?: true\n    value_rating?: true\n    service_rating?: true\n    created_at?: true\n  }\n\n  export type Shopping_review_ratingsMaxAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    quality_rating?: true\n    value_rating?: true\n    service_rating?: true\n    created_at?: true\n  }\n\n  export type Shopping_review_ratingsCountAggregateInputType = {\n    id?: true\n    shopping_product_review_id?: true\n    quality_rating?: true\n    value_rating?: true\n    service_rating?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_review_ratingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_review_ratings to aggregate.\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_ratings to fetch.\n     */\n    orderBy?: shopping_review_ratingsOrderByWithRelationInput | shopping_review_ratingsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_review_ratingsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_ratings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_ratings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_review_ratings\n    **/\n    _count?: true | Shopping_review_ratingsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_review_ratingsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_review_ratingsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_review_ratingsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_review_ratingsMaxAggregateInputType\n  }\n\n  export type GetShopping_review_ratingsAggregateType<T extends Shopping_review_ratingsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_review_ratings]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_review_ratings[P]>\n      : GetScalarType<T[P], AggregateShopping_review_ratings[P]>\n  }\n\n\n\n\n  export type shopping_review_ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_review_ratingsWhereInput\n    orderBy?: shopping_review_ratingsOrderByWithAggregationInput | shopping_review_ratingsOrderByWithAggregationInput[]\n    by: Shopping_review_ratingsScalarFieldEnum[] | Shopping_review_ratingsScalarFieldEnum\n    having?: shopping_review_ratingsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_review_ratingsCountAggregateInputType | true\n    _avg?: Shopping_review_ratingsAvgAggregateInputType\n    _sum?: Shopping_review_ratingsSumAggregateInputType\n    _min?: Shopping_review_ratingsMinAggregateInputType\n    _max?: Shopping_review_ratingsMaxAggregateInputType\n  }\n\n  export type Shopping_review_ratingsGroupByOutputType = {\n    id: string\n    shopping_product_review_id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date\n    _count: Shopping_review_ratingsCountAggregateOutputType | null\n    _avg: Shopping_review_ratingsAvgAggregateOutputType | null\n    _sum: Shopping_review_ratingsSumAggregateOutputType | null\n    _min: Shopping_review_ratingsMinAggregateOutputType | null\n    _max: Shopping_review_ratingsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_review_ratingsGroupByPayload<T extends shopping_review_ratingsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_review_ratingsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_review_ratingsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_review_ratingsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_review_ratingsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_review_ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    quality_rating?: boolean\n    value_rating?: boolean\n    service_rating?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_ratings\"]>\n\n  export type shopping_review_ratingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    quality_rating?: boolean\n    value_rating?: boolean\n    service_rating?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_ratings\"]>\n\n  export type shopping_review_ratingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_product_review_id?: boolean\n    quality_rating?: boolean\n    value_rating?: boolean\n    service_rating?: boolean\n    created_at?: boolean\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_review_ratings\"]>\n\n  export type shopping_review_ratingsSelectScalar = {\n    id?: boolean\n    shopping_product_review_id?: boolean\n    quality_rating?: boolean\n    value_rating?: boolean\n    service_rating?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_review_ratingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_product_review_id\" | \"quality_rating\" | \"value_rating\" | \"service_rating\" | \"created_at\", ExtArgs[\"result\"][\"shopping_review_ratings\"]>\n  export type shopping_review_ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }\n  export type shopping_review_ratingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }\n  export type shopping_review_ratingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    review?: boolean | shopping_product_reviewsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_review_ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_review_ratings\"\n    objects: {\n      review: Prisma.$shopping_product_reviewsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The review this rating belongs to. {@link shopping_product_reviews.id}.\n       */\n      shopping_product_review_id: string\n      /**\n       * Rating for product quality (1-5).\n       */\n      quality_rating: number\n      /**\n       * Rating for product value (1-5).\n       */\n      value_rating: number\n      /**\n       * Rating for service experience (1-5).\n       */\n      service_rating: number\n      /**\n       * When the rating was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_review_ratings\"]>\n    composites: {}\n  }\n\n  type shopping_review_ratingsGetPayload<S extends boolean | null | undefined | shopping_review_ratingsDefaultArgs> = $Result.GetResult<Prisma.$shopping_review_ratingsPayload, S>\n\n  type shopping_review_ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_review_ratingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_review_ratingsCountAggregateInputType | true\n    }\n\n  export interface shopping_review_ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_review_ratings'], meta: { name: 'shopping_review_ratings' } }\n    /**\n     * Find zero or one Shopping_review_ratings that matches the filter.\n     * @param {shopping_review_ratingsFindUniqueArgs} args - Arguments to find a Shopping_review_ratings\n     * @example\n     * // Get one Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_review_ratingsFindUniqueArgs>(args: SelectSubset<T, shopping_review_ratingsFindUniqueArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_review_ratings that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_review_ratingsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_review_ratings\n     * @example\n     * // Get one Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_review_ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_review_ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_review_ratings that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsFindFirstArgs} args - Arguments to find a Shopping_review_ratings\n     * @example\n     * // Get one Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_review_ratingsFindFirstArgs>(args?: SelectSubset<T, shopping_review_ratingsFindFirstArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_review_ratings that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsFindFirstOrThrowArgs} args - Arguments to find a Shopping_review_ratings\n     * @example\n     * // Get one Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_review_ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_review_ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_review_ratings that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findMany()\n     * \n     * // Get first 10 Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_review_ratingsWithIdOnly = await prisma.shopping_review_ratings.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_review_ratingsFindManyArgs>(args?: SelectSubset<T, shopping_review_ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_review_ratings.\n     * @param {shopping_review_ratingsCreateArgs} args - Arguments to create a Shopping_review_ratings.\n     * @example\n     * // Create one Shopping_review_ratings\n     * const Shopping_review_ratings = await prisma.shopping_review_ratings.create({\n     *   data: {\n     *     // ... data to create a Shopping_review_ratings\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_review_ratingsCreateArgs>(args: SelectSubset<T, shopping_review_ratingsCreateArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_review_ratings.\n     * @param {shopping_review_ratingsCreateManyArgs} args - Arguments to create many Shopping_review_ratings.\n     * @example\n     * // Create many Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_review_ratingsCreateManyArgs>(args?: SelectSubset<T, shopping_review_ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_review_ratings and returns the data saved in the database.\n     * @param {shopping_review_ratingsCreateManyAndReturnArgs} args - Arguments to create many Shopping_review_ratings.\n     * @example\n     * // Create many Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_review_ratings and only return the `id`\n     * const shopping_review_ratingsWithIdOnly = await prisma.shopping_review_ratings.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_review_ratingsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_review_ratingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_review_ratings.\n     * @param {shopping_review_ratingsDeleteArgs} args - Arguments to delete one Shopping_review_ratings.\n     * @example\n     * // Delete one Shopping_review_ratings\n     * const Shopping_review_ratings = await prisma.shopping_review_ratings.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_review_ratings\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_review_ratingsDeleteArgs>(args: SelectSubset<T, shopping_review_ratingsDeleteArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_review_ratings.\n     * @param {shopping_review_ratingsUpdateArgs} args - Arguments to update one Shopping_review_ratings.\n     * @example\n     * // Update one Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_review_ratingsUpdateArgs>(args: SelectSubset<T, shopping_review_ratingsUpdateArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_review_ratings.\n     * @param {shopping_review_ratingsDeleteManyArgs} args - Arguments to filter Shopping_review_ratings to delete.\n     * @example\n     * // Delete a few Shopping_review_ratings\n     * const { count } = await prisma.shopping_review_ratings.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_review_ratingsDeleteManyArgs>(args?: SelectSubset<T, shopping_review_ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_review_ratings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_review_ratingsUpdateManyArgs>(args: SelectSubset<T, shopping_review_ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_review_ratings and returns the data updated in the database.\n     * @param {shopping_review_ratingsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_review_ratings.\n     * @example\n     * // Update many Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_review_ratings and only return the `id`\n     * const shopping_review_ratingsWithIdOnly = await prisma.shopping_review_ratings.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_review_ratingsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_review_ratingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_review_ratings.\n     * @param {shopping_review_ratingsUpsertArgs} args - Arguments to update or create a Shopping_review_ratings.\n     * @example\n     * // Update or create a Shopping_review_ratings\n     * const shopping_review_ratings = await prisma.shopping_review_ratings.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_review_ratings\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_review_ratings we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_review_ratingsUpsertArgs>(args: SelectSubset<T, shopping_review_ratingsUpsertArgs<ExtArgs>>): Prisma__shopping_review_ratingsClient<$Result.GetResult<Prisma.$shopping_review_ratingsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_review_ratings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsCountArgs} args - Arguments to filter Shopping_review_ratings to count.\n     * @example\n     * // Count the number of Shopping_review_ratings\n     * const count = await prisma.shopping_review_ratings.count({\n     *   where: {\n     *     // ... the filter for the Shopping_review_ratings we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_review_ratingsCountArgs>(\n      args?: Subset<T, shopping_review_ratingsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_review_ratingsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_review_ratings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_review_ratingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_review_ratingsAggregateArgs>(args: Subset<T, Shopping_review_ratingsAggregateArgs>): Prisma.PrismaPromise<GetShopping_review_ratingsAggregateType<T>>\n\n    /**\n     * Group by Shopping_review_ratings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_review_ratingsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_review_ratingsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_review_ratingsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_review_ratingsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_review_ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_review_ratingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_review_ratings model\n   */\n  readonly fields: shopping_review_ratingsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_review_ratings.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_review_ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    review<T extends shopping_product_reviewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_reviewsDefaultArgs<ExtArgs>>): Prisma__shopping_product_reviewsClient<$Result.GetResult<Prisma.$shopping_product_reviewsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_review_ratings model\n   */\n  interface shopping_review_ratingsFieldRefs {\n    readonly id: FieldRef<\"shopping_review_ratings\", 'String'>\n    readonly shopping_product_review_id: FieldRef<\"shopping_review_ratings\", 'String'>\n    readonly quality_rating: FieldRef<\"shopping_review_ratings\", 'Int'>\n    readonly value_rating: FieldRef<\"shopping_review_ratings\", 'Int'>\n    readonly service_rating: FieldRef<\"shopping_review_ratings\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_review_ratings\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_review_ratings findUnique\n   */\n  export type shopping_review_ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_ratings to fetch.\n     */\n    where: shopping_review_ratingsWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_ratings findUniqueOrThrow\n   */\n  export type shopping_review_ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_ratings to fetch.\n     */\n    where: shopping_review_ratingsWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_ratings findFirst\n   */\n  export type shopping_review_ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_ratings to fetch.\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_ratings to fetch.\n     */\n    orderBy?: shopping_review_ratingsOrderByWithRelationInput | shopping_review_ratingsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_review_ratings.\n     */\n    cursor?: shopping_review_ratingsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_ratings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_ratings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_review_ratings.\n     */\n    distinct?: Shopping_review_ratingsScalarFieldEnum | Shopping_review_ratingsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_ratings findFirstOrThrow\n   */\n  export type shopping_review_ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_ratings to fetch.\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_ratings to fetch.\n     */\n    orderBy?: shopping_review_ratingsOrderByWithRelationInput | shopping_review_ratingsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_review_ratings.\n     */\n    cursor?: shopping_review_ratingsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_ratings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_ratings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_review_ratings.\n     */\n    distinct?: Shopping_review_ratingsScalarFieldEnum | Shopping_review_ratingsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_ratings findMany\n   */\n  export type shopping_review_ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_review_ratings to fetch.\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_review_ratings to fetch.\n     */\n    orderBy?: shopping_review_ratingsOrderByWithRelationInput | shopping_review_ratingsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_review_ratings.\n     */\n    cursor?: shopping_review_ratingsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_review_ratings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_review_ratings.\n     */\n    skip?: number\n    distinct?: Shopping_review_ratingsScalarFieldEnum | Shopping_review_ratingsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_review_ratings create\n   */\n  export type shopping_review_ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_review_ratings.\n     */\n    data: XOR<shopping_review_ratingsCreateInput, shopping_review_ratingsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_review_ratings createMany\n   */\n  export type shopping_review_ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_review_ratings.\n     */\n    data: shopping_review_ratingsCreateManyInput | shopping_review_ratingsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_review_ratings createManyAndReturn\n   */\n  export type shopping_review_ratingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_review_ratings.\n     */\n    data: shopping_review_ratingsCreateManyInput | shopping_review_ratingsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_review_ratings update\n   */\n  export type shopping_review_ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_review_ratings.\n     */\n    data: XOR<shopping_review_ratingsUpdateInput, shopping_review_ratingsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_review_ratings to update.\n     */\n    where: shopping_review_ratingsWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_ratings updateMany\n   */\n  export type shopping_review_ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_review_ratings.\n     */\n    data: XOR<shopping_review_ratingsUpdateManyMutationInput, shopping_review_ratingsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_review_ratings to update\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * Limit how many shopping_review_ratings to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_review_ratings updateManyAndReturn\n   */\n  export type shopping_review_ratingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_review_ratings.\n     */\n    data: XOR<shopping_review_ratingsUpdateManyMutationInput, shopping_review_ratingsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_review_ratings to update\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * Limit how many shopping_review_ratings to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_review_ratings upsert\n   */\n  export type shopping_review_ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_review_ratings to update in case it exists.\n     */\n    where: shopping_review_ratingsWhereUniqueInput\n    /**\n     * In case the shopping_review_ratings found by the `where` argument doesn't exist, create a new shopping_review_ratings with this data.\n     */\n    create: XOR<shopping_review_ratingsCreateInput, shopping_review_ratingsUncheckedCreateInput>\n    /**\n     * In case the shopping_review_ratings was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_review_ratingsUpdateInput, shopping_review_ratingsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_review_ratings delete\n   */\n  export type shopping_review_ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_review_ratings to delete.\n     */\n    where: shopping_review_ratingsWhereUniqueInput\n  }\n\n  /**\n   * shopping_review_ratings deleteMany\n   */\n  export type shopping_review_ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_review_ratings to delete\n     */\n    where?: shopping_review_ratingsWhereInput\n    /**\n     * Limit how many shopping_review_ratings to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_review_ratings without action\n   */\n  export type shopping_review_ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_review_ratings\n     */\n    select?: shopping_review_ratingsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_review_ratings\n     */\n    omit?: shopping_review_ratingsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_review_ratingsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_seller_products\n   */\n\n  export type AggregateShopping_seller_products = {\n    _count: Shopping_seller_productsCountAggregateOutputType | null\n    _avg: Shopping_seller_productsAvgAggregateOutputType | null\n    _sum: Shopping_seller_productsSumAggregateOutputType | null\n    _min: Shopping_seller_productsMinAggregateOutputType | null\n    _max: Shopping_seller_productsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_seller_productsAvgAggregateOutputType = {\n    price: number | null\n    quantity_available: number | null\n  }\n\n  export type Shopping_seller_productsSumAggregateOutputType = {\n    price: number | null\n    quantity_available: number | null\n  }\n\n  export type Shopping_seller_productsMinAggregateOutputType = {\n    id: string | null\n    shopping_seller_id: string | null\n    shopping_product_id: string | null\n    seller_product_code: string | null\n    price: number | null\n    quantity_available: number | null\n    status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_productsMaxAggregateOutputType = {\n    id: string | null\n    shopping_seller_id: string | null\n    shopping_product_id: string | null\n    seller_product_code: string | null\n    price: number | null\n    quantity_available: number | null\n    status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_productsCountAggregateOutputType = {\n    id: number\n    shopping_seller_id: number\n    shopping_product_id: number\n    seller_product_code: number\n    price: number\n    quantity_available: number\n    status: number\n    business_status: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_seller_productsAvgAggregateInputType = {\n    price?: true\n    quantity_available?: true\n  }\n\n  export type Shopping_seller_productsSumAggregateInputType = {\n    price?: true\n    quantity_available?: true\n  }\n\n  export type Shopping_seller_productsMinAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_product_id?: true\n    seller_product_code?: true\n    price?: true\n    quantity_available?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_productsMaxAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_product_id?: true\n    seller_product_code?: true\n    price?: true\n    quantity_available?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_productsCountAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_product_id?: true\n    seller_product_code?: true\n    price?: true\n    quantity_available?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_seller_productsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_products to aggregate.\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_products to fetch.\n     */\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_seller_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_seller_products\n    **/\n    _count?: true | Shopping_seller_productsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_seller_productsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_seller_productsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_seller_productsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_seller_productsMaxAggregateInputType\n  }\n\n  export type GetShopping_seller_productsAggregateType<T extends Shopping_seller_productsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_seller_products]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_seller_products[P]>\n      : GetScalarType<T[P], AggregateShopping_seller_products[P]>\n  }\n\n\n\n\n  export type shopping_seller_productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_productsWhereInput\n    orderBy?: shopping_seller_productsOrderByWithAggregationInput | shopping_seller_productsOrderByWithAggregationInput[]\n    by: Shopping_seller_productsScalarFieldEnum[] | Shopping_seller_productsScalarFieldEnum\n    having?: shopping_seller_productsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_seller_productsCountAggregateInputType | true\n    _avg?: Shopping_seller_productsAvgAggregateInputType\n    _sum?: Shopping_seller_productsSumAggregateInputType\n    _min?: Shopping_seller_productsMinAggregateInputType\n    _max?: Shopping_seller_productsMaxAggregateInputType\n  }\n\n  export type Shopping_seller_productsGroupByOutputType = {\n    id: string\n    shopping_seller_id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_seller_productsCountAggregateOutputType | null\n    _avg: Shopping_seller_productsAvgAggregateOutputType | null\n    _sum: Shopping_seller_productsSumAggregateOutputType | null\n    _min: Shopping_seller_productsMinAggregateOutputType | null\n    _max: Shopping_seller_productsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_seller_productsGroupByPayload<T extends shopping_seller_productsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_seller_productsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_seller_productsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_seller_productsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_seller_productsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_seller_productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_product_id?: boolean\n    seller_product_code?: boolean\n    price?: boolean\n    quantity_available?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    shopping_seller_inventory?: boolean | shopping_seller_products$shopping_seller_inventoryArgs<ExtArgs>\n    _count?: boolean | Shopping_seller_productsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_products\"]>\n\n  export type shopping_seller_productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_product_id?: boolean\n    seller_product_code?: boolean\n    price?: boolean\n    quantity_available?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_products\"]>\n\n  export type shopping_seller_productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_product_id?: boolean\n    seller_product_code?: boolean\n    price?: boolean\n    quantity_available?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_products\"]>\n\n  export type shopping_seller_productsSelectScalar = {\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_product_id?: boolean\n    seller_product_code?: boolean\n    price?: boolean\n    quantity_available?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_seller_productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_seller_id\" | \"shopping_product_id\" | \"seller_product_code\" | \"price\" | \"quantity_available\" | \"status\" | \"business_status\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_seller_products\"]>\n  export type shopping_seller_productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n    shopping_seller_inventory?: boolean | shopping_seller_products$shopping_seller_inventoryArgs<ExtArgs>\n    _count?: boolean | Shopping_seller_productsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    product?: boolean | shopping_productsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_seller_productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_seller_products\"\n    objects: {\n      seller: Prisma.$shopping_sellersPayload<ExtArgs>\n      product: Prisma.$shopping_productsPayload<ExtArgs>\n      shopping_seller_inventory: Prisma.$shopping_seller_inventoryPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the seller who owns this product. {@link\n       * shopping_sellers.id}.\n       */\n      shopping_seller_id: string\n      /**\n       * Reference to the main product in the catalog. {@link\n       * shopping_products.id}.\n       */\n      shopping_product_id: string\n      /**\n       * Seller-specific product code for internal management.\n       */\n      seller_product_code: string\n      /**\n       * Seller's price for the product.\n       */\n      price: number\n      /**\n       * Current available quantity for this product.\n       */\n      quantity_available: number\n      /**\n       * Status of the product (e.g., active, draft, archived).\n       */\n      status: string\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n      /**\n       * Timestamp when the seller product was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the seller product was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the seller product was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_seller_products\"]>\n    composites: {}\n  }\n\n  type shopping_seller_productsGetPayload<S extends boolean | null | undefined | shopping_seller_productsDefaultArgs> = $Result.GetResult<Prisma.$shopping_seller_productsPayload, S>\n\n  type shopping_seller_productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_seller_productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_seller_productsCountAggregateInputType | true\n    }\n\n  export interface shopping_seller_productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_seller_products'], meta: { name: 'shopping_seller_products' } }\n    /**\n     * Find zero or one Shopping_seller_products that matches the filter.\n     * @param {shopping_seller_productsFindUniqueArgs} args - Arguments to find a Shopping_seller_products\n     * @example\n     * // Get one Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_seller_productsFindUniqueArgs>(args: SelectSubset<T, shopping_seller_productsFindUniqueArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_seller_products that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_seller_productsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_seller_products\n     * @example\n     * // Get one Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_seller_productsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_seller_productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_products that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsFindFirstArgs} args - Arguments to find a Shopping_seller_products\n     * @example\n     * // Get one Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_seller_productsFindFirstArgs>(args?: SelectSubset<T, shopping_seller_productsFindFirstArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_products that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsFindFirstOrThrowArgs} args - Arguments to find a Shopping_seller_products\n     * @example\n     * // Get one Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_seller_productsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_seller_productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_seller_products that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findMany()\n     * \n     * // Get first 10 Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_seller_productsWithIdOnly = await prisma.shopping_seller_products.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_seller_productsFindManyArgs>(args?: SelectSubset<T, shopping_seller_productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_seller_products.\n     * @param {shopping_seller_productsCreateArgs} args - Arguments to create a Shopping_seller_products.\n     * @example\n     * // Create one Shopping_seller_products\n     * const Shopping_seller_products = await prisma.shopping_seller_products.create({\n     *   data: {\n     *     // ... data to create a Shopping_seller_products\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_seller_productsCreateArgs>(args: SelectSubset<T, shopping_seller_productsCreateArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_seller_products.\n     * @param {shopping_seller_productsCreateManyArgs} args - Arguments to create many Shopping_seller_products.\n     * @example\n     * // Create many Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_seller_productsCreateManyArgs>(args?: SelectSubset<T, shopping_seller_productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_seller_products and returns the data saved in the database.\n     * @param {shopping_seller_productsCreateManyAndReturnArgs} args - Arguments to create many Shopping_seller_products.\n     * @example\n     * // Create many Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_seller_products and only return the `id`\n     * const shopping_seller_productsWithIdOnly = await prisma.shopping_seller_products.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_seller_productsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_seller_productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_seller_products.\n     * @param {shopping_seller_productsDeleteArgs} args - Arguments to delete one Shopping_seller_products.\n     * @example\n     * // Delete one Shopping_seller_products\n     * const Shopping_seller_products = await prisma.shopping_seller_products.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_seller_products\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_seller_productsDeleteArgs>(args: SelectSubset<T, shopping_seller_productsDeleteArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_seller_products.\n     * @param {shopping_seller_productsUpdateArgs} args - Arguments to update one Shopping_seller_products.\n     * @example\n     * // Update one Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_seller_productsUpdateArgs>(args: SelectSubset<T, shopping_seller_productsUpdateArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_seller_products.\n     * @param {shopping_seller_productsDeleteManyArgs} args - Arguments to filter Shopping_seller_products to delete.\n     * @example\n     * // Delete a few Shopping_seller_products\n     * const { count } = await prisma.shopping_seller_products.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_seller_productsDeleteManyArgs>(args?: SelectSubset<T, shopping_seller_productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_seller_productsUpdateManyArgs>(args: SelectSubset<T, shopping_seller_productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_products and returns the data updated in the database.\n     * @param {shopping_seller_productsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_seller_products.\n     * @example\n     * // Update many Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_seller_products and only return the `id`\n     * const shopping_seller_productsWithIdOnly = await prisma.shopping_seller_products.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_seller_productsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_seller_productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_seller_products.\n     * @param {shopping_seller_productsUpsertArgs} args - Arguments to update or create a Shopping_seller_products.\n     * @example\n     * // Update or create a Shopping_seller_products\n     * const shopping_seller_products = await prisma.shopping_seller_products.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_seller_products\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_seller_products we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_seller_productsUpsertArgs>(args: SelectSubset<T, shopping_seller_productsUpsertArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_seller_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsCountArgs} args - Arguments to filter Shopping_seller_products to count.\n     * @example\n     * // Count the number of Shopping_seller_products\n     * const count = await prisma.shopping_seller_products.count({\n     *   where: {\n     *     // ... the filter for the Shopping_seller_products we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_seller_productsCountArgs>(\n      args?: Subset<T, shopping_seller_productsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_seller_productsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_seller_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_seller_productsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_seller_productsAggregateArgs>(args: Subset<T, Shopping_seller_productsAggregateArgs>): Prisma.PrismaPromise<GetShopping_seller_productsAggregateType<T>>\n\n    /**\n     * Group by Shopping_seller_products.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_productsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_seller_productsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_seller_productsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_seller_productsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_seller_productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_seller_productsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_seller_products model\n   */\n  readonly fields: shopping_seller_productsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_seller_products.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_seller_productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    seller<T extends shopping_sellersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sellersDefaultArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    product<T extends shopping_productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_productsDefaultArgs<ExtArgs>>): Prisma__shopping_productsClient<$Result.GetResult<Prisma.$shopping_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_seller_inventory<T extends shopping_seller_products$shopping_seller_inventoryArgs<ExtArgs> = {}>(args?: Subset<T, shopping_seller_products$shopping_seller_inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_seller_products model\n   */\n  interface shopping_seller_productsFieldRefs {\n    readonly id: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly shopping_seller_id: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly shopping_product_id: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly seller_product_code: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly price: FieldRef<\"shopping_seller_products\", 'Float'>\n    readonly quantity_available: FieldRef<\"shopping_seller_products\", 'Int'>\n    readonly status: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly business_status: FieldRef<\"shopping_seller_products\", 'String'>\n    readonly created_at: FieldRef<\"shopping_seller_products\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_seller_products\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_seller_products\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_seller_products findUnique\n   */\n  export type shopping_seller_productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_products to fetch.\n     */\n    where: shopping_seller_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_products findUniqueOrThrow\n   */\n  export type shopping_seller_productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_products to fetch.\n     */\n    where: shopping_seller_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_products findFirst\n   */\n  export type shopping_seller_productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_products to fetch.\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_products to fetch.\n     */\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_products.\n     */\n    cursor?: shopping_seller_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_products.\n     */\n    distinct?: Shopping_seller_productsScalarFieldEnum | Shopping_seller_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_products findFirstOrThrow\n   */\n  export type shopping_seller_productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_products to fetch.\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_products to fetch.\n     */\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_products.\n     */\n    cursor?: shopping_seller_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_products.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_products.\n     */\n    distinct?: Shopping_seller_productsScalarFieldEnum | Shopping_seller_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_products findMany\n   */\n  export type shopping_seller_productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_products to fetch.\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_products to fetch.\n     */\n    orderBy?: shopping_seller_productsOrderByWithRelationInput | shopping_seller_productsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_seller_products.\n     */\n    cursor?: shopping_seller_productsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_products from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_products.\n     */\n    skip?: number\n    distinct?: Shopping_seller_productsScalarFieldEnum | Shopping_seller_productsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_products create\n   */\n  export type shopping_seller_productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_seller_products.\n     */\n    data: XOR<shopping_seller_productsCreateInput, shopping_seller_productsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_seller_products createMany\n   */\n  export type shopping_seller_productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_seller_products.\n     */\n    data: shopping_seller_productsCreateManyInput | shopping_seller_productsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_seller_products createManyAndReturn\n   */\n  export type shopping_seller_productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_seller_products.\n     */\n    data: shopping_seller_productsCreateManyInput | shopping_seller_productsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_products update\n   */\n  export type shopping_seller_productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_seller_products.\n     */\n    data: XOR<shopping_seller_productsUpdateInput, shopping_seller_productsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_seller_products to update.\n     */\n    where: shopping_seller_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_products updateMany\n   */\n  export type shopping_seller_productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_seller_products.\n     */\n    data: XOR<shopping_seller_productsUpdateManyMutationInput, shopping_seller_productsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_products to update\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * Limit how many shopping_seller_products to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_products updateManyAndReturn\n   */\n  export type shopping_seller_productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_seller_products.\n     */\n    data: XOR<shopping_seller_productsUpdateManyMutationInput, shopping_seller_productsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_products to update\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * Limit how many shopping_seller_products to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_products upsert\n   */\n  export type shopping_seller_productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_seller_products to update in case it exists.\n     */\n    where: shopping_seller_productsWhereUniqueInput\n    /**\n     * In case the shopping_seller_products found by the `where` argument doesn't exist, create a new shopping_seller_products with this data.\n     */\n    create: XOR<shopping_seller_productsCreateInput, shopping_seller_productsUncheckedCreateInput>\n    /**\n     * In case the shopping_seller_products was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_seller_productsUpdateInput, shopping_seller_productsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_seller_products delete\n   */\n  export type shopping_seller_productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_seller_products to delete.\n     */\n    where: shopping_seller_productsWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_products deleteMany\n   */\n  export type shopping_seller_productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_products to delete\n     */\n    where?: shopping_seller_productsWhereInput\n    /**\n     * Limit how many shopping_seller_products to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_products.shopping_seller_inventory\n   */\n  export type shopping_seller_products$shopping_seller_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    where?: shopping_seller_inventoryWhereInput\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_seller_inventoryScalarFieldEnum | Shopping_seller_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_products without action\n   */\n  export type shopping_seller_productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_products\n     */\n    select?: shopping_seller_productsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_products\n     */\n    omit?: shopping_seller_productsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_productsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_seller_inventory\n   */\n\n  export type AggregateShopping_seller_inventory = {\n    _count: Shopping_seller_inventoryCountAggregateOutputType | null\n    _avg: Shopping_seller_inventoryAvgAggregateOutputType | null\n    _sum: Shopping_seller_inventorySumAggregateOutputType | null\n    _min: Shopping_seller_inventoryMinAggregateOutputType | null\n    _max: Shopping_seller_inventoryMaxAggregateOutputType | null\n  }\n\n  export type Shopping_seller_inventoryAvgAggregateOutputType = {\n    stock_quantity: number | null\n    low_stock_threshold: number | null\n  }\n\n  export type Shopping_seller_inventorySumAggregateOutputType = {\n    stock_quantity: number | null\n    low_stock_threshold: number | null\n  }\n\n  export type Shopping_seller_inventoryMinAggregateOutputType = {\n    id: string | null\n    shopping_seller_product_id: string | null\n    shopping_product_variant_id: string | null\n    stock_quantity: number | null\n    low_stock_threshold: number | null\n    status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_inventoryMaxAggregateOutputType = {\n    id: string | null\n    shopping_seller_product_id: string | null\n    shopping_product_variant_id: string | null\n    stock_quantity: number | null\n    low_stock_threshold: number | null\n    status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_inventoryCountAggregateOutputType = {\n    id: number\n    shopping_seller_product_id: number\n    shopping_product_variant_id: number\n    stock_quantity: number\n    low_stock_threshold: number\n    status: number\n    business_status: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_seller_inventoryAvgAggregateInputType = {\n    stock_quantity?: true\n    low_stock_threshold?: true\n  }\n\n  export type Shopping_seller_inventorySumAggregateInputType = {\n    stock_quantity?: true\n    low_stock_threshold?: true\n  }\n\n  export type Shopping_seller_inventoryMinAggregateInputType = {\n    id?: true\n    shopping_seller_product_id?: true\n    shopping_product_variant_id?: true\n    stock_quantity?: true\n    low_stock_threshold?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_inventoryMaxAggregateInputType = {\n    id?: true\n    shopping_seller_product_id?: true\n    shopping_product_variant_id?: true\n    stock_quantity?: true\n    low_stock_threshold?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_inventoryCountAggregateInputType = {\n    id?: true\n    shopping_seller_product_id?: true\n    shopping_product_variant_id?: true\n    stock_quantity?: true\n    low_stock_threshold?: true\n    status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_seller_inventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_inventory to aggregate.\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_inventories to fetch.\n     */\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_seller_inventories\n    **/\n    _count?: true | Shopping_seller_inventoryCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_seller_inventoryAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_seller_inventorySumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_seller_inventoryMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_seller_inventoryMaxAggregateInputType\n  }\n\n  export type GetShopping_seller_inventoryAggregateType<T extends Shopping_seller_inventoryAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_seller_inventory]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_seller_inventory[P]>\n      : GetScalarType<T[P], AggregateShopping_seller_inventory[P]>\n  }\n\n\n\n\n  export type shopping_seller_inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_inventoryWhereInput\n    orderBy?: shopping_seller_inventoryOrderByWithAggregationInput | shopping_seller_inventoryOrderByWithAggregationInput[]\n    by: Shopping_seller_inventoryScalarFieldEnum[] | Shopping_seller_inventoryScalarFieldEnum\n    having?: shopping_seller_inventoryScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_seller_inventoryCountAggregateInputType | true\n    _avg?: Shopping_seller_inventoryAvgAggregateInputType\n    _sum?: Shopping_seller_inventorySumAggregateInputType\n    _min?: Shopping_seller_inventoryMinAggregateInputType\n    _max?: Shopping_seller_inventoryMaxAggregateInputType\n  }\n\n  export type Shopping_seller_inventoryGroupByOutputType = {\n    id: string\n    shopping_seller_product_id: string\n    shopping_product_variant_id: string\n    stock_quantity: number\n    low_stock_threshold: number | null\n    status: string\n    business_status: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_seller_inventoryCountAggregateOutputType | null\n    _avg: Shopping_seller_inventoryAvgAggregateOutputType | null\n    _sum: Shopping_seller_inventorySumAggregateOutputType | null\n    _min: Shopping_seller_inventoryMinAggregateOutputType | null\n    _max: Shopping_seller_inventoryMaxAggregateOutputType | null\n  }\n\n  type GetShopping_seller_inventoryGroupByPayload<T extends shopping_seller_inventoryGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_seller_inventoryGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_seller_inventoryGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_seller_inventoryGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_seller_inventoryGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_seller_inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_product_id?: boolean\n    shopping_product_variant_id?: boolean\n    stock_quantity?: boolean\n    low_stock_threshold?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_inventory\"]>\n\n  export type shopping_seller_inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_product_id?: boolean\n    shopping_product_variant_id?: boolean\n    stock_quantity?: boolean\n    low_stock_threshold?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_inventory\"]>\n\n  export type shopping_seller_inventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_product_id?: boolean\n    shopping_product_variant_id?: boolean\n    stock_quantity?: boolean\n    low_stock_threshold?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_inventory\"]>\n\n  export type shopping_seller_inventorySelectScalar = {\n    id?: boolean\n    shopping_seller_product_id?: boolean\n    shopping_product_variant_id?: boolean\n    stock_quantity?: boolean\n    low_stock_threshold?: boolean\n    status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_seller_inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_seller_product_id\" | \"shopping_product_variant_id\" | \"stock_quantity\" | \"low_stock_threshold\" | \"status\" | \"business_status\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_seller_inventory\"]>\n  export type shopping_seller_inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_inventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sellerProduct?: boolean | shopping_seller_productsDefaultArgs<ExtArgs>\n    productVariant?: boolean | shopping_product_variantsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_seller_inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_seller_inventory\"\n    objects: {\n      sellerProduct: Prisma.$shopping_seller_productsPayload<ExtArgs>\n      productVariant: Prisma.$shopping_product_variantsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the seller product. {@link shopping_seller_products.id}.\n       */\n      shopping_seller_product_id: string\n      /**\n       * Reference to the specific product variant. {@link\n       * shopping_product_variants.id}.\n       */\n      shopping_product_variant_id: string\n      /**\n       * Current stock quantity for this inventory item.\n       */\n      stock_quantity: number\n      /**\n       * Threshold for low stock alerts.\n       */\n      low_stock_threshold: number | null\n      /**\n       * Status of the inventory item (e.g., in_stock, low_stock, out_of_stock).\n       */\n      status: string\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n      /**\n       * Timestamp when the inventory record was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the inventory record was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the inventory record was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_seller_inventory\"]>\n    composites: {}\n  }\n\n  type shopping_seller_inventoryGetPayload<S extends boolean | null | undefined | shopping_seller_inventoryDefaultArgs> = $Result.GetResult<Prisma.$shopping_seller_inventoryPayload, S>\n\n  type shopping_seller_inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_seller_inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_seller_inventoryCountAggregateInputType | true\n    }\n\n  export interface shopping_seller_inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_seller_inventory'], meta: { name: 'shopping_seller_inventory' } }\n    /**\n     * Find zero or one Shopping_seller_inventory that matches the filter.\n     * @param {shopping_seller_inventoryFindUniqueArgs} args - Arguments to find a Shopping_seller_inventory\n     * @example\n     * // Get one Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_seller_inventoryFindUniqueArgs>(args: SelectSubset<T, shopping_seller_inventoryFindUniqueArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_seller_inventory that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_seller_inventoryFindUniqueOrThrowArgs} args - Arguments to find a Shopping_seller_inventory\n     * @example\n     * // Get one Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_seller_inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_seller_inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_inventory that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryFindFirstArgs} args - Arguments to find a Shopping_seller_inventory\n     * @example\n     * // Get one Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_seller_inventoryFindFirstArgs>(args?: SelectSubset<T, shopping_seller_inventoryFindFirstArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_inventory that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryFindFirstOrThrowArgs} args - Arguments to find a Shopping_seller_inventory\n     * @example\n     * // Get one Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_seller_inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_seller_inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_seller_inventories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_seller_inventories\n     * const shopping_seller_inventories = await prisma.shopping_seller_inventory.findMany()\n     * \n     * // Get first 10 Shopping_seller_inventories\n     * const shopping_seller_inventories = await prisma.shopping_seller_inventory.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_seller_inventoryWithIdOnly = await prisma.shopping_seller_inventory.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_seller_inventoryFindManyArgs>(args?: SelectSubset<T, shopping_seller_inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_seller_inventory.\n     * @param {shopping_seller_inventoryCreateArgs} args - Arguments to create a Shopping_seller_inventory.\n     * @example\n     * // Create one Shopping_seller_inventory\n     * const Shopping_seller_inventory = await prisma.shopping_seller_inventory.create({\n     *   data: {\n     *     // ... data to create a Shopping_seller_inventory\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_seller_inventoryCreateArgs>(args: SelectSubset<T, shopping_seller_inventoryCreateArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_seller_inventories.\n     * @param {shopping_seller_inventoryCreateManyArgs} args - Arguments to create many Shopping_seller_inventories.\n     * @example\n     * // Create many Shopping_seller_inventories\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_seller_inventoryCreateManyArgs>(args?: SelectSubset<T, shopping_seller_inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_seller_inventories and returns the data saved in the database.\n     * @param {shopping_seller_inventoryCreateManyAndReturnArgs} args - Arguments to create many Shopping_seller_inventories.\n     * @example\n     * // Create many Shopping_seller_inventories\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_seller_inventories and only return the `id`\n     * const shopping_seller_inventoryWithIdOnly = await prisma.shopping_seller_inventory.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_seller_inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_seller_inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_seller_inventory.\n     * @param {shopping_seller_inventoryDeleteArgs} args - Arguments to delete one Shopping_seller_inventory.\n     * @example\n     * // Delete one Shopping_seller_inventory\n     * const Shopping_seller_inventory = await prisma.shopping_seller_inventory.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_seller_inventory\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_seller_inventoryDeleteArgs>(args: SelectSubset<T, shopping_seller_inventoryDeleteArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_seller_inventory.\n     * @param {shopping_seller_inventoryUpdateArgs} args - Arguments to update one Shopping_seller_inventory.\n     * @example\n     * // Update one Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_seller_inventoryUpdateArgs>(args: SelectSubset<T, shopping_seller_inventoryUpdateArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_seller_inventories.\n     * @param {shopping_seller_inventoryDeleteManyArgs} args - Arguments to filter Shopping_seller_inventories to delete.\n     * @example\n     * // Delete a few Shopping_seller_inventories\n     * const { count } = await prisma.shopping_seller_inventory.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_seller_inventoryDeleteManyArgs>(args?: SelectSubset<T, shopping_seller_inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_inventories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_seller_inventories\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_seller_inventoryUpdateManyArgs>(args: SelectSubset<T, shopping_seller_inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_inventories and returns the data updated in the database.\n     * @param {shopping_seller_inventoryUpdateManyAndReturnArgs} args - Arguments to update many Shopping_seller_inventories.\n     * @example\n     * // Update many Shopping_seller_inventories\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_seller_inventories and only return the `id`\n     * const shopping_seller_inventoryWithIdOnly = await prisma.shopping_seller_inventory.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_seller_inventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_seller_inventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_seller_inventory.\n     * @param {shopping_seller_inventoryUpsertArgs} args - Arguments to update or create a Shopping_seller_inventory.\n     * @example\n     * // Update or create a Shopping_seller_inventory\n     * const shopping_seller_inventory = await prisma.shopping_seller_inventory.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_seller_inventory\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_seller_inventory we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_seller_inventoryUpsertArgs>(args: SelectSubset<T, shopping_seller_inventoryUpsertArgs<ExtArgs>>): Prisma__shopping_seller_inventoryClient<$Result.GetResult<Prisma.$shopping_seller_inventoryPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_seller_inventories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryCountArgs} args - Arguments to filter Shopping_seller_inventories to count.\n     * @example\n     * // Count the number of Shopping_seller_inventories\n     * const count = await prisma.shopping_seller_inventory.count({\n     *   where: {\n     *     // ... the filter for the Shopping_seller_inventories we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_seller_inventoryCountArgs>(\n      args?: Subset<T, shopping_seller_inventoryCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_seller_inventoryCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_seller_inventory.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_seller_inventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_seller_inventoryAggregateArgs>(args: Subset<T, Shopping_seller_inventoryAggregateArgs>): Prisma.PrismaPromise<GetShopping_seller_inventoryAggregateType<T>>\n\n    /**\n     * Group by Shopping_seller_inventory.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_inventoryGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_seller_inventoryGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_seller_inventoryGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_seller_inventoryGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_seller_inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_seller_inventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_seller_inventory model\n   */\n  readonly fields: shopping_seller_inventoryFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_seller_inventory.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_seller_inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    sellerProduct<T extends shopping_seller_productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_seller_productsDefaultArgs<ExtArgs>>): Prisma__shopping_seller_productsClient<$Result.GetResult<Prisma.$shopping_seller_productsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    productVariant<T extends shopping_product_variantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_product_variantsDefaultArgs<ExtArgs>>): Prisma__shopping_product_variantsClient<$Result.GetResult<Prisma.$shopping_product_variantsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_seller_inventory model\n   */\n  interface shopping_seller_inventoryFieldRefs {\n    readonly id: FieldRef<\"shopping_seller_inventory\", 'String'>\n    readonly shopping_seller_product_id: FieldRef<\"shopping_seller_inventory\", 'String'>\n    readonly shopping_product_variant_id: FieldRef<\"shopping_seller_inventory\", 'String'>\n    readonly stock_quantity: FieldRef<\"shopping_seller_inventory\", 'Int'>\n    readonly low_stock_threshold: FieldRef<\"shopping_seller_inventory\", 'Int'>\n    readonly status: FieldRef<\"shopping_seller_inventory\", 'String'>\n    readonly business_status: FieldRef<\"shopping_seller_inventory\", 'String'>\n    readonly created_at: FieldRef<\"shopping_seller_inventory\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_seller_inventory\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_seller_inventory\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_seller_inventory findUnique\n   */\n  export type shopping_seller_inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_inventory to fetch.\n     */\n    where: shopping_seller_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_inventory findUniqueOrThrow\n   */\n  export type shopping_seller_inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_inventory to fetch.\n     */\n    where: shopping_seller_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_inventory findFirst\n   */\n  export type shopping_seller_inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_inventory to fetch.\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_inventories to fetch.\n     */\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_inventories.\n     */\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_inventories.\n     */\n    distinct?: Shopping_seller_inventoryScalarFieldEnum | Shopping_seller_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_inventory findFirstOrThrow\n   */\n  export type shopping_seller_inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_inventory to fetch.\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_inventories to fetch.\n     */\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_inventories.\n     */\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_inventories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_inventories.\n     */\n    distinct?: Shopping_seller_inventoryScalarFieldEnum | Shopping_seller_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_inventory findMany\n   */\n  export type shopping_seller_inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_inventories to fetch.\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_inventories to fetch.\n     */\n    orderBy?: shopping_seller_inventoryOrderByWithRelationInput | shopping_seller_inventoryOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_seller_inventories.\n     */\n    cursor?: shopping_seller_inventoryWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_inventories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_inventories.\n     */\n    skip?: number\n    distinct?: Shopping_seller_inventoryScalarFieldEnum | Shopping_seller_inventoryScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_inventory create\n   */\n  export type shopping_seller_inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_seller_inventory.\n     */\n    data: XOR<shopping_seller_inventoryCreateInput, shopping_seller_inventoryUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_seller_inventory createMany\n   */\n  export type shopping_seller_inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_seller_inventories.\n     */\n    data: shopping_seller_inventoryCreateManyInput | shopping_seller_inventoryCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_seller_inventory createManyAndReturn\n   */\n  export type shopping_seller_inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_seller_inventories.\n     */\n    data: shopping_seller_inventoryCreateManyInput | shopping_seller_inventoryCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_inventory update\n   */\n  export type shopping_seller_inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_seller_inventory.\n     */\n    data: XOR<shopping_seller_inventoryUpdateInput, shopping_seller_inventoryUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_seller_inventory to update.\n     */\n    where: shopping_seller_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_inventory updateMany\n   */\n  export type shopping_seller_inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_seller_inventories.\n     */\n    data: XOR<shopping_seller_inventoryUpdateManyMutationInput, shopping_seller_inventoryUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_inventories to update\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * Limit how many shopping_seller_inventories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_inventory updateManyAndReturn\n   */\n  export type shopping_seller_inventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_seller_inventories.\n     */\n    data: XOR<shopping_seller_inventoryUpdateManyMutationInput, shopping_seller_inventoryUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_inventories to update\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * Limit how many shopping_seller_inventories to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_inventory upsert\n   */\n  export type shopping_seller_inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_seller_inventory to update in case it exists.\n     */\n    where: shopping_seller_inventoryWhereUniqueInput\n    /**\n     * In case the shopping_seller_inventory found by the `where` argument doesn't exist, create a new shopping_seller_inventory with this data.\n     */\n    create: XOR<shopping_seller_inventoryCreateInput, shopping_seller_inventoryUncheckedCreateInput>\n    /**\n     * In case the shopping_seller_inventory was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_seller_inventoryUpdateInput, shopping_seller_inventoryUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_seller_inventory delete\n   */\n  export type shopping_seller_inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_seller_inventory to delete.\n     */\n    where: shopping_seller_inventoryWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_inventory deleteMany\n   */\n  export type shopping_seller_inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_inventories to delete\n     */\n    where?: shopping_seller_inventoryWhereInput\n    /**\n     * Limit how many shopping_seller_inventories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_inventory without action\n   */\n  export type shopping_seller_inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_inventory\n     */\n    select?: shopping_seller_inventorySelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_inventory\n     */\n    omit?: shopping_seller_inventoryOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_inventoryInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_seller_orders\n   */\n\n  export type AggregateShopping_seller_orders = {\n    _count: Shopping_seller_ordersCountAggregateOutputType | null\n    _min: Shopping_seller_ordersMinAggregateOutputType | null\n    _max: Shopping_seller_ordersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_seller_ordersMinAggregateOutputType = {\n    id: string | null\n    shopping_seller_id: string | null\n    shopping_order_id: string | null\n    seller_order_code: string | null\n    fulfillment_status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_ordersMaxAggregateOutputType = {\n    id: string | null\n    shopping_seller_id: string | null\n    shopping_order_id: string | null\n    seller_order_code: string | null\n    fulfillment_status: string | null\n    business_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_seller_ordersCountAggregateOutputType = {\n    id: number\n    shopping_seller_id: number\n    shopping_order_id: number\n    seller_order_code: number\n    fulfillment_status: number\n    business_status: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_seller_ordersMinAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_order_id?: true\n    seller_order_code?: true\n    fulfillment_status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_ordersMaxAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_order_id?: true\n    seller_order_code?: true\n    fulfillment_status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_seller_ordersCountAggregateInputType = {\n    id?: true\n    shopping_seller_id?: true\n    shopping_order_id?: true\n    seller_order_code?: true\n    fulfillment_status?: true\n    business_status?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_seller_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_orders to aggregate.\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_orders to fetch.\n     */\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_seller_orders\n    **/\n    _count?: true | Shopping_seller_ordersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_seller_ordersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_seller_ordersMaxAggregateInputType\n  }\n\n  export type GetShopping_seller_ordersAggregateType<T extends Shopping_seller_ordersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_seller_orders]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_seller_orders[P]>\n      : GetScalarType<T[P], AggregateShopping_seller_orders[P]>\n  }\n\n\n\n\n  export type shopping_seller_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_seller_ordersWhereInput\n    orderBy?: shopping_seller_ordersOrderByWithAggregationInput | shopping_seller_ordersOrderByWithAggregationInput[]\n    by: Shopping_seller_ordersScalarFieldEnum[] | Shopping_seller_ordersScalarFieldEnum\n    having?: shopping_seller_ordersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_seller_ordersCountAggregateInputType | true\n    _min?: Shopping_seller_ordersMinAggregateInputType\n    _max?: Shopping_seller_ordersMaxAggregateInputType\n  }\n\n  export type Shopping_seller_ordersGroupByOutputType = {\n    id: string\n    shopping_seller_id: string\n    shopping_order_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_seller_ordersCountAggregateOutputType | null\n    _min: Shopping_seller_ordersMinAggregateOutputType | null\n    _max: Shopping_seller_ordersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_seller_ordersGroupByPayload<T extends shopping_seller_ordersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_seller_ordersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_seller_ordersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_seller_ordersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_seller_ordersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_seller_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_order_id?: boolean\n    seller_order_code?: boolean\n    fulfillment_status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_orders\"]>\n\n  export type shopping_seller_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_order_id?: boolean\n    seller_order_code?: boolean\n    fulfillment_status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_orders\"]>\n\n  export type shopping_seller_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_order_id?: boolean\n    seller_order_code?: boolean\n    fulfillment_status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_seller_orders\"]>\n\n  export type shopping_seller_ordersSelectScalar = {\n    id?: boolean\n    shopping_seller_id?: boolean\n    shopping_order_id?: boolean\n    seller_order_code?: boolean\n    fulfillment_status?: boolean\n    business_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_seller_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_seller_id\" | \"shopping_order_id\" | \"seller_order_code\" | \"fulfillment_status\" | \"business_status\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_seller_orders\"]>\n  export type shopping_seller_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_seller_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    seller?: boolean | shopping_sellersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_seller_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_seller_orders\"\n    objects: {\n      seller: Prisma.$shopping_sellersPayload<ExtArgs>\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the seller who owns this order. {@link shopping_sellers.id}.\n       */\n      shopping_seller_id: string\n      /**\n       * Reference to the main order. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * Seller-specific order code for internal management.\n       */\n      seller_order_code: string\n      /**\n       * Current fulfillment status of the order (e.g., pending, processing,\n       * shipped, delivered).\n       */\n      fulfillment_status: string\n      /**\n       * Business-specific status for workflow management.\n       */\n      business_status: string | null\n      /**\n       * Timestamp when the seller order was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the seller order was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the seller order was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_seller_orders\"]>\n    composites: {}\n  }\n\n  type shopping_seller_ordersGetPayload<S extends boolean | null | undefined | shopping_seller_ordersDefaultArgs> = $Result.GetResult<Prisma.$shopping_seller_ordersPayload, S>\n\n  type shopping_seller_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_seller_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_seller_ordersCountAggregateInputType | true\n    }\n\n  export interface shopping_seller_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_seller_orders'], meta: { name: 'shopping_seller_orders' } }\n    /**\n     * Find zero or one Shopping_seller_orders that matches the filter.\n     * @param {shopping_seller_ordersFindUniqueArgs} args - Arguments to find a Shopping_seller_orders\n     * @example\n     * // Get one Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_seller_ordersFindUniqueArgs>(args: SelectSubset<T, shopping_seller_ordersFindUniqueArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_seller_orders that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_seller_ordersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_seller_orders\n     * @example\n     * // Get one Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_seller_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_seller_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersFindFirstArgs} args - Arguments to find a Shopping_seller_orders\n     * @example\n     * // Get one Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_seller_ordersFindFirstArgs>(args?: SelectSubset<T, shopping_seller_ordersFindFirstArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_seller_orders that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersFindFirstOrThrowArgs} args - Arguments to find a Shopping_seller_orders\n     * @example\n     * // Get one Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_seller_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_seller_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_seller_orders that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findMany()\n     * \n     * // Get first 10 Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_seller_ordersWithIdOnly = await prisma.shopping_seller_orders.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_seller_ordersFindManyArgs>(args?: SelectSubset<T, shopping_seller_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_seller_orders.\n     * @param {shopping_seller_ordersCreateArgs} args - Arguments to create a Shopping_seller_orders.\n     * @example\n     * // Create one Shopping_seller_orders\n     * const Shopping_seller_orders = await prisma.shopping_seller_orders.create({\n     *   data: {\n     *     // ... data to create a Shopping_seller_orders\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_seller_ordersCreateArgs>(args: SelectSubset<T, shopping_seller_ordersCreateArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_seller_orders.\n     * @param {shopping_seller_ordersCreateManyArgs} args - Arguments to create many Shopping_seller_orders.\n     * @example\n     * // Create many Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_seller_ordersCreateManyArgs>(args?: SelectSubset<T, shopping_seller_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_seller_orders and returns the data saved in the database.\n     * @param {shopping_seller_ordersCreateManyAndReturnArgs} args - Arguments to create many Shopping_seller_orders.\n     * @example\n     * // Create many Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_seller_orders and only return the `id`\n     * const shopping_seller_ordersWithIdOnly = await prisma.shopping_seller_orders.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_seller_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_seller_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_seller_orders.\n     * @param {shopping_seller_ordersDeleteArgs} args - Arguments to delete one Shopping_seller_orders.\n     * @example\n     * // Delete one Shopping_seller_orders\n     * const Shopping_seller_orders = await prisma.shopping_seller_orders.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_seller_orders\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_seller_ordersDeleteArgs>(args: SelectSubset<T, shopping_seller_ordersDeleteArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_seller_orders.\n     * @param {shopping_seller_ordersUpdateArgs} args - Arguments to update one Shopping_seller_orders.\n     * @example\n     * // Update one Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_seller_ordersUpdateArgs>(args: SelectSubset<T, shopping_seller_ordersUpdateArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_seller_orders.\n     * @param {shopping_seller_ordersDeleteManyArgs} args - Arguments to filter Shopping_seller_orders to delete.\n     * @example\n     * // Delete a few Shopping_seller_orders\n     * const { count } = await prisma.shopping_seller_orders.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_seller_ordersDeleteManyArgs>(args?: SelectSubset<T, shopping_seller_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_seller_ordersUpdateManyArgs>(args: SelectSubset<T, shopping_seller_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_seller_orders and returns the data updated in the database.\n     * @param {shopping_seller_ordersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_seller_orders.\n     * @example\n     * // Update many Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_seller_orders and only return the `id`\n     * const shopping_seller_ordersWithIdOnly = await prisma.shopping_seller_orders.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_seller_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_seller_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_seller_orders.\n     * @param {shopping_seller_ordersUpsertArgs} args - Arguments to update or create a Shopping_seller_orders.\n     * @example\n     * // Update or create a Shopping_seller_orders\n     * const shopping_seller_orders = await prisma.shopping_seller_orders.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_seller_orders\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_seller_orders we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_seller_ordersUpsertArgs>(args: SelectSubset<T, shopping_seller_ordersUpsertArgs<ExtArgs>>): Prisma__shopping_seller_ordersClient<$Result.GetResult<Prisma.$shopping_seller_ordersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_seller_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersCountArgs} args - Arguments to filter Shopping_seller_orders to count.\n     * @example\n     * // Count the number of Shopping_seller_orders\n     * const count = await prisma.shopping_seller_orders.count({\n     *   where: {\n     *     // ... the filter for the Shopping_seller_orders we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_seller_ordersCountArgs>(\n      args?: Subset<T, shopping_seller_ordersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_seller_ordersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_seller_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_seller_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_seller_ordersAggregateArgs>(args: Subset<T, Shopping_seller_ordersAggregateArgs>): Prisma.PrismaPromise<GetShopping_seller_ordersAggregateType<T>>\n\n    /**\n     * Group by Shopping_seller_orders.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_seller_ordersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_seller_ordersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_seller_ordersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_seller_ordersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_seller_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_seller_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_seller_orders model\n   */\n  readonly fields: shopping_seller_ordersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_seller_orders.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_seller_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    seller<T extends shopping_sellersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_sellersDefaultArgs<ExtArgs>>): Prisma__shopping_sellersClient<$Result.GetResult<Prisma.$shopping_sellersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_seller_orders model\n   */\n  interface shopping_seller_ordersFieldRefs {\n    readonly id: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly shopping_seller_id: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly seller_order_code: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly fulfillment_status: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly business_status: FieldRef<\"shopping_seller_orders\", 'String'>\n    readonly created_at: FieldRef<\"shopping_seller_orders\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_seller_orders\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_seller_orders\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_seller_orders findUnique\n   */\n  export type shopping_seller_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_orders to fetch.\n     */\n    where: shopping_seller_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_orders findUniqueOrThrow\n   */\n  export type shopping_seller_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_orders to fetch.\n     */\n    where: shopping_seller_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_orders findFirst\n   */\n  export type shopping_seller_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_orders to fetch.\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_orders to fetch.\n     */\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_orders.\n     */\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_orders.\n     */\n    distinct?: Shopping_seller_ordersScalarFieldEnum | Shopping_seller_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_orders findFirstOrThrow\n   */\n  export type shopping_seller_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_orders to fetch.\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_orders to fetch.\n     */\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_seller_orders.\n     */\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_orders.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_seller_orders.\n     */\n    distinct?: Shopping_seller_ordersScalarFieldEnum | Shopping_seller_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_orders findMany\n   */\n  export type shopping_seller_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_seller_orders to fetch.\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_seller_orders to fetch.\n     */\n    orderBy?: shopping_seller_ordersOrderByWithRelationInput | shopping_seller_ordersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_seller_orders.\n     */\n    cursor?: shopping_seller_ordersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_seller_orders from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_seller_orders.\n     */\n    skip?: number\n    distinct?: Shopping_seller_ordersScalarFieldEnum | Shopping_seller_ordersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_seller_orders create\n   */\n  export type shopping_seller_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_seller_orders.\n     */\n    data: XOR<shopping_seller_ordersCreateInput, shopping_seller_ordersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_seller_orders createMany\n   */\n  export type shopping_seller_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_seller_orders.\n     */\n    data: shopping_seller_ordersCreateManyInput | shopping_seller_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_seller_orders createManyAndReturn\n   */\n  export type shopping_seller_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_seller_orders.\n     */\n    data: shopping_seller_ordersCreateManyInput | shopping_seller_ordersCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_orders update\n   */\n  export type shopping_seller_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_seller_orders.\n     */\n    data: XOR<shopping_seller_ordersUpdateInput, shopping_seller_ordersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_seller_orders to update.\n     */\n    where: shopping_seller_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_orders updateMany\n   */\n  export type shopping_seller_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_seller_orders.\n     */\n    data: XOR<shopping_seller_ordersUpdateManyMutationInput, shopping_seller_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_orders to update\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * Limit how many shopping_seller_orders to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_orders updateManyAndReturn\n   */\n  export type shopping_seller_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_seller_orders.\n     */\n    data: XOR<shopping_seller_ordersUpdateManyMutationInput, shopping_seller_ordersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_seller_orders to update\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * Limit how many shopping_seller_orders to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_seller_orders upsert\n   */\n  export type shopping_seller_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_seller_orders to update in case it exists.\n     */\n    where: shopping_seller_ordersWhereUniqueInput\n    /**\n     * In case the shopping_seller_orders found by the `where` argument doesn't exist, create a new shopping_seller_orders with this data.\n     */\n    create: XOR<shopping_seller_ordersCreateInput, shopping_seller_ordersUncheckedCreateInput>\n    /**\n     * In case the shopping_seller_orders was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_seller_ordersUpdateInput, shopping_seller_ordersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_seller_orders delete\n   */\n  export type shopping_seller_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_seller_orders to delete.\n     */\n    where: shopping_seller_ordersWhereUniqueInput\n  }\n\n  /**\n   * shopping_seller_orders deleteMany\n   */\n  export type shopping_seller_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_seller_orders to delete\n     */\n    where?: shopping_seller_ordersWhereInput\n    /**\n     * Limit how many shopping_seller_orders to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_seller_orders without action\n   */\n  export type shopping_seller_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_seller_orders\n     */\n    select?: shopping_seller_ordersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_seller_orders\n     */\n    omit?: shopping_seller_ordersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_seller_ordersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_admin_actions\n   */\n\n  export type AggregateShopping_admin_actions = {\n    _count: Shopping_admin_actionsCountAggregateOutputType | null\n    _min: Shopping_admin_actionsMinAggregateOutputType | null\n    _max: Shopping_admin_actionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_admin_actionsMinAggregateOutputType = {\n    id: string | null\n    shopping_administrator_id: string | null\n    action_type: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_admin_actionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_administrator_id: string | null\n    action_type: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_admin_actionsCountAggregateOutputType = {\n    id: number\n    shopping_administrator_id: number\n    action_type: number\n    description: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_admin_actionsMinAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type Shopping_admin_actionsMaxAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type Shopping_admin_actionsCountAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    action_type?: true\n    description?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_admin_actionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_admin_actions to aggregate.\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_actions to fetch.\n     */\n    orderBy?: shopping_admin_actionsOrderByWithRelationInput | shopping_admin_actionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_admin_actionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_actions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_actions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_admin_actions\n    **/\n    _count?: true | Shopping_admin_actionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_admin_actionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_admin_actionsMaxAggregateInputType\n  }\n\n  export type GetShopping_admin_actionsAggregateType<T extends Shopping_admin_actionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_admin_actions]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_admin_actions[P]>\n      : GetScalarType<T[P], AggregateShopping_admin_actions[P]>\n  }\n\n\n\n\n  export type shopping_admin_actionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_admin_actionsWhereInput\n    orderBy?: shopping_admin_actionsOrderByWithAggregationInput | shopping_admin_actionsOrderByWithAggregationInput[]\n    by: Shopping_admin_actionsScalarFieldEnum[] | Shopping_admin_actionsScalarFieldEnum\n    having?: shopping_admin_actionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_admin_actionsCountAggregateInputType | true\n    _min?: Shopping_admin_actionsMinAggregateInputType\n    _max?: Shopping_admin_actionsMaxAggregateInputType\n  }\n\n  export type Shopping_admin_actionsGroupByOutputType = {\n    id: string\n    shopping_administrator_id: string\n    action_type: string\n    description: string\n    created_at: Date\n    _count: Shopping_admin_actionsCountAggregateOutputType | null\n    _min: Shopping_admin_actionsMinAggregateOutputType | null\n    _max: Shopping_admin_actionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_admin_actionsGroupByPayload<T extends shopping_admin_actionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_admin_actionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_admin_actionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_admin_actionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_admin_actionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_admin_actionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_actions\"]>\n\n  export type shopping_admin_actionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_actions\"]>\n\n  export type shopping_admin_actionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    description?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_actions\"]>\n\n  export type shopping_admin_actionsSelectScalar = {\n    id?: boolean\n    shopping_administrator_id?: boolean\n    action_type?: boolean\n    description?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_admin_actionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_administrator_id\" | \"action_type\" | \"description\" | \"created_at\", ExtArgs[\"result\"][\"shopping_admin_actions\"]>\n  export type shopping_admin_actionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n  export type shopping_admin_actionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n  export type shopping_admin_actionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_administratorsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_admin_actionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_admin_actions\"\n    objects: {\n      administrator: Prisma.$shopping_administratorsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Administrator who performed the action. {@link\n       * shopping_administrators.id}.\n       */\n      shopping_administrator_id: string\n      /**\n       * Type of action performed (e.g., 'user_management', 'product_approval',\n       * 'order_update').\n       */\n      action_type: string\n      /**\n       * Detailed description of the action performed.\n       */\n      description: string\n      /**\n       * Timestamp when the action was performed.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_admin_actions\"]>\n    composites: {}\n  }\n\n  type shopping_admin_actionsGetPayload<S extends boolean | null | undefined | shopping_admin_actionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_admin_actionsPayload, S>\n\n  type shopping_admin_actionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_admin_actionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_admin_actionsCountAggregateInputType | true\n    }\n\n  export interface shopping_admin_actionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_admin_actions'], meta: { name: 'shopping_admin_actions' } }\n    /**\n     * Find zero or one Shopping_admin_actions that matches the filter.\n     * @param {shopping_admin_actionsFindUniqueArgs} args - Arguments to find a Shopping_admin_actions\n     * @example\n     * // Get one Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_admin_actionsFindUniqueArgs>(args: SelectSubset<T, shopping_admin_actionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_admin_actions that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_admin_actionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_admin_actions\n     * @example\n     * // Get one Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_admin_actionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_admin_actionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_admin_actions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsFindFirstArgs} args - Arguments to find a Shopping_admin_actions\n     * @example\n     * // Get one Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_admin_actionsFindFirstArgs>(args?: SelectSubset<T, shopping_admin_actionsFindFirstArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_admin_actions that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_admin_actions\n     * @example\n     * // Get one Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_admin_actionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_admin_actionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_admin_actions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findMany()\n     * \n     * // Get first 10 Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_admin_actionsWithIdOnly = await prisma.shopping_admin_actions.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_admin_actionsFindManyArgs>(args?: SelectSubset<T, shopping_admin_actionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_admin_actions.\n     * @param {shopping_admin_actionsCreateArgs} args - Arguments to create a Shopping_admin_actions.\n     * @example\n     * // Create one Shopping_admin_actions\n     * const Shopping_admin_actions = await prisma.shopping_admin_actions.create({\n     *   data: {\n     *     // ... data to create a Shopping_admin_actions\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_admin_actionsCreateArgs>(args: SelectSubset<T, shopping_admin_actionsCreateArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_admin_actions.\n     * @param {shopping_admin_actionsCreateManyArgs} args - Arguments to create many Shopping_admin_actions.\n     * @example\n     * // Create many Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_admin_actionsCreateManyArgs>(args?: SelectSubset<T, shopping_admin_actionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_admin_actions and returns the data saved in the database.\n     * @param {shopping_admin_actionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_admin_actions.\n     * @example\n     * // Create many Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_admin_actions and only return the `id`\n     * const shopping_admin_actionsWithIdOnly = await prisma.shopping_admin_actions.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_admin_actionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_admin_actionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_admin_actions.\n     * @param {shopping_admin_actionsDeleteArgs} args - Arguments to delete one Shopping_admin_actions.\n     * @example\n     * // Delete one Shopping_admin_actions\n     * const Shopping_admin_actions = await prisma.shopping_admin_actions.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_admin_actions\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_admin_actionsDeleteArgs>(args: SelectSubset<T, shopping_admin_actionsDeleteArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_admin_actions.\n     * @param {shopping_admin_actionsUpdateArgs} args - Arguments to update one Shopping_admin_actions.\n     * @example\n     * // Update one Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_admin_actionsUpdateArgs>(args: SelectSubset<T, shopping_admin_actionsUpdateArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_admin_actions.\n     * @param {shopping_admin_actionsDeleteManyArgs} args - Arguments to filter Shopping_admin_actions to delete.\n     * @example\n     * // Delete a few Shopping_admin_actions\n     * const { count } = await prisma.shopping_admin_actions.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_admin_actionsDeleteManyArgs>(args?: SelectSubset<T, shopping_admin_actionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_admin_actions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_admin_actionsUpdateManyArgs>(args: SelectSubset<T, shopping_admin_actionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_admin_actions and returns the data updated in the database.\n     * @param {shopping_admin_actionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_admin_actions.\n     * @example\n     * // Update many Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_admin_actions and only return the `id`\n     * const shopping_admin_actionsWithIdOnly = await prisma.shopping_admin_actions.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_admin_actionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_admin_actionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_admin_actions.\n     * @param {shopping_admin_actionsUpsertArgs} args - Arguments to update or create a Shopping_admin_actions.\n     * @example\n     * // Update or create a Shopping_admin_actions\n     * const shopping_admin_actions = await prisma.shopping_admin_actions.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_admin_actions\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_admin_actions we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_admin_actionsUpsertArgs>(args: SelectSubset<T, shopping_admin_actionsUpsertArgs<ExtArgs>>): Prisma__shopping_admin_actionsClient<$Result.GetResult<Prisma.$shopping_admin_actionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_admin_actions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsCountArgs} args - Arguments to filter Shopping_admin_actions to count.\n     * @example\n     * // Count the number of Shopping_admin_actions\n     * const count = await prisma.shopping_admin_actions.count({\n     *   where: {\n     *     // ... the filter for the Shopping_admin_actions we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_admin_actionsCountArgs>(\n      args?: Subset<T, shopping_admin_actionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_admin_actionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_admin_actions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_admin_actionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_admin_actionsAggregateArgs>(args: Subset<T, Shopping_admin_actionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_admin_actionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_admin_actions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_actionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_admin_actionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_admin_actionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_admin_actionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_admin_actionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_admin_actionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_admin_actions model\n   */\n  readonly fields: shopping_admin_actionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_admin_actions.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_admin_actionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    administrator<T extends shopping_administratorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_administratorsDefaultArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_admin_actions model\n   */\n  interface shopping_admin_actionsFieldRefs {\n    readonly id: FieldRef<\"shopping_admin_actions\", 'String'>\n    readonly shopping_administrator_id: FieldRef<\"shopping_admin_actions\", 'String'>\n    readonly action_type: FieldRef<\"shopping_admin_actions\", 'String'>\n    readonly description: FieldRef<\"shopping_admin_actions\", 'String'>\n    readonly created_at: FieldRef<\"shopping_admin_actions\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_admin_actions findUnique\n   */\n  export type shopping_admin_actionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_actions to fetch.\n     */\n    where: shopping_admin_actionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_actions findUniqueOrThrow\n   */\n  export type shopping_admin_actionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_actions to fetch.\n     */\n    where: shopping_admin_actionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_actions findFirst\n   */\n  export type shopping_admin_actionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_actions to fetch.\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_actions to fetch.\n     */\n    orderBy?: shopping_admin_actionsOrderByWithRelationInput | shopping_admin_actionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_admin_actions.\n     */\n    cursor?: shopping_admin_actionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_actions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_actions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_admin_actions.\n     */\n    distinct?: Shopping_admin_actionsScalarFieldEnum | Shopping_admin_actionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_actions findFirstOrThrow\n   */\n  export type shopping_admin_actionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_actions to fetch.\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_actions to fetch.\n     */\n    orderBy?: shopping_admin_actionsOrderByWithRelationInput | shopping_admin_actionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_admin_actions.\n     */\n    cursor?: shopping_admin_actionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_actions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_actions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_admin_actions.\n     */\n    distinct?: Shopping_admin_actionsScalarFieldEnum | Shopping_admin_actionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_actions findMany\n   */\n  export type shopping_admin_actionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_actions to fetch.\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_actions to fetch.\n     */\n    orderBy?: shopping_admin_actionsOrderByWithRelationInput | shopping_admin_actionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_admin_actions.\n     */\n    cursor?: shopping_admin_actionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_actions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_actions.\n     */\n    skip?: number\n    distinct?: Shopping_admin_actionsScalarFieldEnum | Shopping_admin_actionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_actions create\n   */\n  export type shopping_admin_actionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_admin_actions.\n     */\n    data: XOR<shopping_admin_actionsCreateInput, shopping_admin_actionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_admin_actions createMany\n   */\n  export type shopping_admin_actionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_admin_actions.\n     */\n    data: shopping_admin_actionsCreateManyInput | shopping_admin_actionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_admin_actions createManyAndReturn\n   */\n  export type shopping_admin_actionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_admin_actions.\n     */\n    data: shopping_admin_actionsCreateManyInput | shopping_admin_actionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_admin_actions update\n   */\n  export type shopping_admin_actionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_admin_actions.\n     */\n    data: XOR<shopping_admin_actionsUpdateInput, shopping_admin_actionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_admin_actions to update.\n     */\n    where: shopping_admin_actionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_actions updateMany\n   */\n  export type shopping_admin_actionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_admin_actions.\n     */\n    data: XOR<shopping_admin_actionsUpdateManyMutationInput, shopping_admin_actionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_admin_actions to update\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * Limit how many shopping_admin_actions to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_admin_actions updateManyAndReturn\n   */\n  export type shopping_admin_actionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_admin_actions.\n     */\n    data: XOR<shopping_admin_actionsUpdateManyMutationInput, shopping_admin_actionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_admin_actions to update\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * Limit how many shopping_admin_actions to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_admin_actions upsert\n   */\n  export type shopping_admin_actionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_admin_actions to update in case it exists.\n     */\n    where: shopping_admin_actionsWhereUniqueInput\n    /**\n     * In case the shopping_admin_actions found by the `where` argument doesn't exist, create a new shopping_admin_actions with this data.\n     */\n    create: XOR<shopping_admin_actionsCreateInput, shopping_admin_actionsUncheckedCreateInput>\n    /**\n     * In case the shopping_admin_actions was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_admin_actionsUpdateInput, shopping_admin_actionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_admin_actions delete\n   */\n  export type shopping_admin_actionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_admin_actions to delete.\n     */\n    where: shopping_admin_actionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_actions deleteMany\n   */\n  export type shopping_admin_actionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_admin_actions to delete\n     */\n    where?: shopping_admin_actionsWhereInput\n    /**\n     * Limit how many shopping_admin_actions to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_admin_actions without action\n   */\n  export type shopping_admin_actionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_actions\n     */\n    select?: shopping_admin_actionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_actions\n     */\n    omit?: shopping_admin_actionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_actionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_admin_logs\n   */\n\n  export type AggregateShopping_admin_logs = {\n    _count: Shopping_admin_logsCountAggregateOutputType | null\n    _min: Shopping_admin_logsMinAggregateOutputType | null\n    _max: Shopping_admin_logsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_admin_logsMinAggregateOutputType = {\n    id: string | null\n    shopping_administrator_id: string | null\n    log_type: string | null\n    message: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_admin_logsMaxAggregateOutputType = {\n    id: string | null\n    shopping_administrator_id: string | null\n    log_type: string | null\n    message: string | null\n    created_at: Date | null\n  }\n\n  export type Shopping_admin_logsCountAggregateOutputType = {\n    id: number\n    shopping_administrator_id: number\n    log_type: number\n    message: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Shopping_admin_logsMinAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    log_type?: true\n    message?: true\n    created_at?: true\n  }\n\n  export type Shopping_admin_logsMaxAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    log_type?: true\n    message?: true\n    created_at?: true\n  }\n\n  export type Shopping_admin_logsCountAggregateInputType = {\n    id?: true\n    shopping_administrator_id?: true\n    log_type?: true\n    message?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Shopping_admin_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_admin_logs to aggregate.\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_logs to fetch.\n     */\n    orderBy?: shopping_admin_logsOrderByWithRelationInput | shopping_admin_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_admin_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_admin_logs\n    **/\n    _count?: true | Shopping_admin_logsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_admin_logsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_admin_logsMaxAggregateInputType\n  }\n\n  export type GetShopping_admin_logsAggregateType<T extends Shopping_admin_logsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_admin_logs]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_admin_logs[P]>\n      : GetScalarType<T[P], AggregateShopping_admin_logs[P]>\n  }\n\n\n\n\n  export type shopping_admin_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_admin_logsWhereInput\n    orderBy?: shopping_admin_logsOrderByWithAggregationInput | shopping_admin_logsOrderByWithAggregationInput[]\n    by: Shopping_admin_logsScalarFieldEnum[] | Shopping_admin_logsScalarFieldEnum\n    having?: shopping_admin_logsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_admin_logsCountAggregateInputType | true\n    _min?: Shopping_admin_logsMinAggregateInputType\n    _max?: Shopping_admin_logsMaxAggregateInputType\n  }\n\n  export type Shopping_admin_logsGroupByOutputType = {\n    id: string\n    shopping_administrator_id: string | null\n    log_type: string\n    message: string\n    created_at: Date\n    _count: Shopping_admin_logsCountAggregateOutputType | null\n    _min: Shopping_admin_logsMinAggregateOutputType | null\n    _max: Shopping_admin_logsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_admin_logsGroupByPayload<T extends shopping_admin_logsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_admin_logsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_admin_logsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_admin_logsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_admin_logsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_admin_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    log_type?: boolean\n    message?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_logs\"]>\n\n  export type shopping_admin_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    log_type?: boolean\n    message?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_logs\"]>\n\n  export type shopping_admin_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_administrator_id?: boolean\n    log_type?: boolean\n    message?: boolean\n    created_at?: boolean\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_admin_logs\"]>\n\n  export type shopping_admin_logsSelectScalar = {\n    id?: boolean\n    shopping_administrator_id?: boolean\n    log_type?: boolean\n    message?: boolean\n    created_at?: boolean\n  }\n\n  export type shopping_admin_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_administrator_id\" | \"log_type\" | \"message\" | \"created_at\", ExtArgs[\"result\"][\"shopping_admin_logs\"]>\n  export type shopping_admin_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }\n  export type shopping_admin_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }\n  export type shopping_admin_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    administrator?: boolean | shopping_admin_logs$administratorArgs<ExtArgs>\n  }\n\n  export type $shopping_admin_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_admin_logs\"\n    objects: {\n      administrator: Prisma.$shopping_administratorsPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Administrator associated with the log entry (if applicable). {@link\n       * shopping_administrators.id}.\n       */\n      shopping_administrator_id: string | null\n      /**\n       * Type of log entry (e.g., 'system_event', 'security_event', 'data_change').\n       */\n      log_type: string\n      /**\n       * Detailed log message describing the event.\n       */\n      message: string\n      /**\n       * Timestamp when the log entry was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"shopping_admin_logs\"]>\n    composites: {}\n  }\n\n  type shopping_admin_logsGetPayload<S extends boolean | null | undefined | shopping_admin_logsDefaultArgs> = $Result.GetResult<Prisma.$shopping_admin_logsPayload, S>\n\n  type shopping_admin_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_admin_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_admin_logsCountAggregateInputType | true\n    }\n\n  export interface shopping_admin_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_admin_logs'], meta: { name: 'shopping_admin_logs' } }\n    /**\n     * Find zero or one Shopping_admin_logs that matches the filter.\n     * @param {shopping_admin_logsFindUniqueArgs} args - Arguments to find a Shopping_admin_logs\n     * @example\n     * // Get one Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_admin_logsFindUniqueArgs>(args: SelectSubset<T, shopping_admin_logsFindUniqueArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_admin_logs that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_admin_logsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_admin_logs\n     * @example\n     * // Get one Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_admin_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_admin_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_admin_logs that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsFindFirstArgs} args - Arguments to find a Shopping_admin_logs\n     * @example\n     * // Get one Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_admin_logsFindFirstArgs>(args?: SelectSubset<T, shopping_admin_logsFindFirstArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_admin_logs that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsFindFirstOrThrowArgs} args - Arguments to find a Shopping_admin_logs\n     * @example\n     * // Get one Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_admin_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_admin_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_admin_logs that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findMany()\n     * \n     * // Get first 10 Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_admin_logsWithIdOnly = await prisma.shopping_admin_logs.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_admin_logsFindManyArgs>(args?: SelectSubset<T, shopping_admin_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_admin_logs.\n     * @param {shopping_admin_logsCreateArgs} args - Arguments to create a Shopping_admin_logs.\n     * @example\n     * // Create one Shopping_admin_logs\n     * const Shopping_admin_logs = await prisma.shopping_admin_logs.create({\n     *   data: {\n     *     // ... data to create a Shopping_admin_logs\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_admin_logsCreateArgs>(args: SelectSubset<T, shopping_admin_logsCreateArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_admin_logs.\n     * @param {shopping_admin_logsCreateManyArgs} args - Arguments to create many Shopping_admin_logs.\n     * @example\n     * // Create many Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_admin_logsCreateManyArgs>(args?: SelectSubset<T, shopping_admin_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_admin_logs and returns the data saved in the database.\n     * @param {shopping_admin_logsCreateManyAndReturnArgs} args - Arguments to create many Shopping_admin_logs.\n     * @example\n     * // Create many Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_admin_logs and only return the `id`\n     * const shopping_admin_logsWithIdOnly = await prisma.shopping_admin_logs.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_admin_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_admin_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_admin_logs.\n     * @param {shopping_admin_logsDeleteArgs} args - Arguments to delete one Shopping_admin_logs.\n     * @example\n     * // Delete one Shopping_admin_logs\n     * const Shopping_admin_logs = await prisma.shopping_admin_logs.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_admin_logs\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_admin_logsDeleteArgs>(args: SelectSubset<T, shopping_admin_logsDeleteArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_admin_logs.\n     * @param {shopping_admin_logsUpdateArgs} args - Arguments to update one Shopping_admin_logs.\n     * @example\n     * // Update one Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_admin_logsUpdateArgs>(args: SelectSubset<T, shopping_admin_logsUpdateArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_admin_logs.\n     * @param {shopping_admin_logsDeleteManyArgs} args - Arguments to filter Shopping_admin_logs to delete.\n     * @example\n     * // Delete a few Shopping_admin_logs\n     * const { count } = await prisma.shopping_admin_logs.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_admin_logsDeleteManyArgs>(args?: SelectSubset<T, shopping_admin_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_admin_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_admin_logsUpdateManyArgs>(args: SelectSubset<T, shopping_admin_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_admin_logs and returns the data updated in the database.\n     * @param {shopping_admin_logsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_admin_logs.\n     * @example\n     * // Update many Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_admin_logs and only return the `id`\n     * const shopping_admin_logsWithIdOnly = await prisma.shopping_admin_logs.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_admin_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_admin_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_admin_logs.\n     * @param {shopping_admin_logsUpsertArgs} args - Arguments to update or create a Shopping_admin_logs.\n     * @example\n     * // Update or create a Shopping_admin_logs\n     * const shopping_admin_logs = await prisma.shopping_admin_logs.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_admin_logs\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_admin_logs we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_admin_logsUpsertArgs>(args: SelectSubset<T, shopping_admin_logsUpsertArgs<ExtArgs>>): Prisma__shopping_admin_logsClient<$Result.GetResult<Prisma.$shopping_admin_logsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_admin_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsCountArgs} args - Arguments to filter Shopping_admin_logs to count.\n     * @example\n     * // Count the number of Shopping_admin_logs\n     * const count = await prisma.shopping_admin_logs.count({\n     *   where: {\n     *     // ... the filter for the Shopping_admin_logs we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_admin_logsCountArgs>(\n      args?: Subset<T, shopping_admin_logsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_admin_logsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_admin_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_admin_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_admin_logsAggregateArgs>(args: Subset<T, Shopping_admin_logsAggregateArgs>): Prisma.PrismaPromise<GetShopping_admin_logsAggregateType<T>>\n\n    /**\n     * Group by Shopping_admin_logs.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_admin_logsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_admin_logsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_admin_logsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_admin_logsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_admin_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_admin_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_admin_logs model\n   */\n  readonly fields: shopping_admin_logsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_admin_logs.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_admin_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    administrator<T extends shopping_admin_logs$administratorArgs<ExtArgs> = {}>(args?: Subset<T, shopping_admin_logs$administratorArgs<ExtArgs>>): Prisma__shopping_administratorsClient<$Result.GetResult<Prisma.$shopping_administratorsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_admin_logs model\n   */\n  interface shopping_admin_logsFieldRefs {\n    readonly id: FieldRef<\"shopping_admin_logs\", 'String'>\n    readonly shopping_administrator_id: FieldRef<\"shopping_admin_logs\", 'String'>\n    readonly log_type: FieldRef<\"shopping_admin_logs\", 'String'>\n    readonly message: FieldRef<\"shopping_admin_logs\", 'String'>\n    readonly created_at: FieldRef<\"shopping_admin_logs\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_admin_logs findUnique\n   */\n  export type shopping_admin_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_logs to fetch.\n     */\n    where: shopping_admin_logsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_logs findUniqueOrThrow\n   */\n  export type shopping_admin_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_logs to fetch.\n     */\n    where: shopping_admin_logsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_logs findFirst\n   */\n  export type shopping_admin_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_logs to fetch.\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_logs to fetch.\n     */\n    orderBy?: shopping_admin_logsOrderByWithRelationInput | shopping_admin_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_admin_logs.\n     */\n    cursor?: shopping_admin_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_admin_logs.\n     */\n    distinct?: Shopping_admin_logsScalarFieldEnum | Shopping_admin_logsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_logs findFirstOrThrow\n   */\n  export type shopping_admin_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_logs to fetch.\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_logs to fetch.\n     */\n    orderBy?: shopping_admin_logsOrderByWithRelationInput | shopping_admin_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_admin_logs.\n     */\n    cursor?: shopping_admin_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_logs.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_admin_logs.\n     */\n    distinct?: Shopping_admin_logsScalarFieldEnum | Shopping_admin_logsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_logs findMany\n   */\n  export type shopping_admin_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_admin_logs to fetch.\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_admin_logs to fetch.\n     */\n    orderBy?: shopping_admin_logsOrderByWithRelationInput | shopping_admin_logsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_admin_logs.\n     */\n    cursor?: shopping_admin_logsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_admin_logs from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_admin_logs.\n     */\n    skip?: number\n    distinct?: Shopping_admin_logsScalarFieldEnum | Shopping_admin_logsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_admin_logs create\n   */\n  export type shopping_admin_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_admin_logs.\n     */\n    data: XOR<shopping_admin_logsCreateInput, shopping_admin_logsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_admin_logs createMany\n   */\n  export type shopping_admin_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_admin_logs.\n     */\n    data: shopping_admin_logsCreateManyInput | shopping_admin_logsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_admin_logs createManyAndReturn\n   */\n  export type shopping_admin_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_admin_logs.\n     */\n    data: shopping_admin_logsCreateManyInput | shopping_admin_logsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_admin_logs update\n   */\n  export type shopping_admin_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_admin_logs.\n     */\n    data: XOR<shopping_admin_logsUpdateInput, shopping_admin_logsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_admin_logs to update.\n     */\n    where: shopping_admin_logsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_logs updateMany\n   */\n  export type shopping_admin_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_admin_logs.\n     */\n    data: XOR<shopping_admin_logsUpdateManyMutationInput, shopping_admin_logsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_admin_logs to update\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * Limit how many shopping_admin_logs to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_admin_logs updateManyAndReturn\n   */\n  export type shopping_admin_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_admin_logs.\n     */\n    data: XOR<shopping_admin_logsUpdateManyMutationInput, shopping_admin_logsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_admin_logs to update\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * Limit how many shopping_admin_logs to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_admin_logs upsert\n   */\n  export type shopping_admin_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_admin_logs to update in case it exists.\n     */\n    where: shopping_admin_logsWhereUniqueInput\n    /**\n     * In case the shopping_admin_logs found by the `where` argument doesn't exist, create a new shopping_admin_logs with this data.\n     */\n    create: XOR<shopping_admin_logsCreateInput, shopping_admin_logsUncheckedCreateInput>\n    /**\n     * In case the shopping_admin_logs was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_admin_logsUpdateInput, shopping_admin_logsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_admin_logs delete\n   */\n  export type shopping_admin_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_admin_logs to delete.\n     */\n    where: shopping_admin_logsWhereUniqueInput\n  }\n\n  /**\n   * shopping_admin_logs deleteMany\n   */\n  export type shopping_admin_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_admin_logs to delete\n     */\n    where?: shopping_admin_logsWhereInput\n    /**\n     * Limit how many shopping_admin_logs to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_admin_logs.administrator\n   */\n  export type shopping_admin_logs$administratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_administrators\n     */\n    select?: shopping_administratorsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_administrators\n     */\n    omit?: shopping_administratorsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_administratorsInclude<ExtArgs> | null\n    where?: shopping_administratorsWhereInput\n  }\n\n  /**\n   * shopping_admin_logs without action\n   */\n  export type shopping_admin_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_admin_logs\n     */\n    select?: shopping_admin_logsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_admin_logs\n     */\n    omit?: shopping_admin_logsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_admin_logsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_payments\n   */\n\n  export type AggregateShopping_payments = {\n    _count: Shopping_paymentsCountAggregateOutputType | null\n    _avg: Shopping_paymentsAvgAggregateOutputType | null\n    _sum: Shopping_paymentsSumAggregateOutputType | null\n    _min: Shopping_paymentsMinAggregateOutputType | null\n    _max: Shopping_paymentsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_paymentsAvgAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_paymentsSumAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_paymentsMinAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    shopping_order_id: string | null\n    payment_method_id: string | null\n    amount: number | null\n    currency: string | null\n    status: string | null\n    transaction_id: string | null\n    payment_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_paymentsMaxAggregateOutputType = {\n    id: string | null\n    shopping_customer_id: string | null\n    shopping_order_id: string | null\n    payment_method_id: string | null\n    amount: number | null\n    currency: string | null\n    status: string | null\n    transaction_id: string | null\n    payment_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_paymentsCountAggregateOutputType = {\n    id: number\n    shopping_customer_id: number\n    shopping_order_id: number\n    payment_method_id: number\n    amount: number\n    currency: number\n    status: number\n    transaction_id: number\n    payment_date: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_paymentsAvgAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_paymentsSumAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_paymentsMinAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    shopping_order_id?: true\n    payment_method_id?: true\n    amount?: true\n    currency?: true\n    status?: true\n    transaction_id?: true\n    payment_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_paymentsMaxAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    shopping_order_id?: true\n    payment_method_id?: true\n    amount?: true\n    currency?: true\n    status?: true\n    transaction_id?: true\n    payment_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_paymentsCountAggregateInputType = {\n    id?: true\n    shopping_customer_id?: true\n    shopping_order_id?: true\n    payment_method_id?: true\n    amount?: true\n    currency?: true\n    status?: true\n    transaction_id?: true\n    payment_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_paymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payments to aggregate.\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payments to fetch.\n     */\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_paymentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_payments\n    **/\n    _count?: true | Shopping_paymentsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_paymentsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_paymentsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_paymentsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_paymentsMaxAggregateInputType\n  }\n\n  export type GetShopping_paymentsAggregateType<T extends Shopping_paymentsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_payments]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_payments[P]>\n      : GetScalarType<T[P], AggregateShopping_payments[P]>\n  }\n\n\n\n\n  export type shopping_paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_paymentsWhereInput\n    orderBy?: shopping_paymentsOrderByWithAggregationInput | shopping_paymentsOrderByWithAggregationInput[]\n    by: Shopping_paymentsScalarFieldEnum[] | Shopping_paymentsScalarFieldEnum\n    having?: shopping_paymentsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_paymentsCountAggregateInputType | true\n    _avg?: Shopping_paymentsAvgAggregateInputType\n    _sum?: Shopping_paymentsSumAggregateInputType\n    _min?: Shopping_paymentsMinAggregateInputType\n    _max?: Shopping_paymentsMaxAggregateInputType\n  }\n\n  export type Shopping_paymentsGroupByOutputType = {\n    id: string\n    shopping_customer_id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id: string | null\n    payment_date: Date\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_paymentsCountAggregateOutputType | null\n    _avg: Shopping_paymentsAvgAggregateOutputType | null\n    _sum: Shopping_paymentsSumAggregateOutputType | null\n    _min: Shopping_paymentsMinAggregateOutputType | null\n    _max: Shopping_paymentsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_paymentsGroupByPayload<T extends shopping_paymentsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_paymentsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_paymentsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_paymentsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_paymentsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    shopping_order_id?: boolean\n    payment_method_id?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    transaction_id?: boolean\n    payment_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    shopping_payment_transactions?: boolean | shopping_payments$shopping_payment_transactionsArgs<ExtArgs>\n    _count?: boolean | Shopping_paymentsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payments\"]>\n\n  export type shopping_paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    shopping_order_id?: boolean\n    payment_method_id?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    transaction_id?: boolean\n    payment_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payments\"]>\n\n  export type shopping_paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_customer_id?: boolean\n    shopping_order_id?: boolean\n    payment_method_id?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    transaction_id?: boolean\n    payment_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payments\"]>\n\n  export type shopping_paymentsSelectScalar = {\n    id?: boolean\n    shopping_customer_id?: boolean\n    shopping_order_id?: boolean\n    payment_method_id?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    transaction_id?: boolean\n    payment_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_customer_id\" | \"shopping_order_id\" | \"payment_method_id\" | \"amount\" | \"currency\" | \"status\" | \"transaction_id\" | \"payment_date\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_payments\"]>\n  export type shopping_paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    shopping_payment_transactions?: boolean | shopping_payments$shopping_payment_transactionsArgs<ExtArgs>\n    _count?: boolean | Shopping_paymentsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n  export type shopping_paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    customer?: boolean | shopping_customersDefaultArgs<ExtArgs>\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_payments\"\n    objects: {\n      customer: Prisma.$shopping_customersPayload<ExtArgs>\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n      shopping_payment_transactions: Prisma.$shopping_payment_transactionsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Customer who made the payment. {@link shopping_customers.id}.\n       */\n      shopping_customer_id: string\n      /**\n       * Order associated with this payment. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * Payment method used for this transaction. {@link\n       * shopping_payment_methods.id}.\n       */\n      payment_method_id: string\n      /**\n       * Total amount paid in this transaction.\n       */\n      amount: number\n      /**\n       * Currency used for the payment (e.g., USD, EUR).\n       */\n      currency: string\n      /**\n       * Current status of the payment (e.g., pending, completed, failed,\n       * refunded).\n       */\n      status: string\n      /**\n       * External transaction ID from payment gateway.\n       */\n      transaction_id: string | null\n      /**\n       * Date and time when the payment was processed.\n       */\n      payment_date: Date\n      /**\n       * Record creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Record last update timestamp.\n       */\n      updated_at: Date\n      /**\n       * Soft delete timestamp.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_payments\"]>\n    composites: {}\n  }\n\n  type shopping_paymentsGetPayload<S extends boolean | null | undefined | shopping_paymentsDefaultArgs> = $Result.GetResult<Prisma.$shopping_paymentsPayload, S>\n\n  type shopping_paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_paymentsCountAggregateInputType | true\n    }\n\n  export interface shopping_paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_payments'], meta: { name: 'shopping_payments' } }\n    /**\n     * Find zero or one Shopping_payments that matches the filter.\n     * @param {shopping_paymentsFindUniqueArgs} args - Arguments to find a Shopping_payments\n     * @example\n     * // Get one Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_paymentsFindUniqueArgs>(args: SelectSubset<T, shopping_paymentsFindUniqueArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_payments that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_paymentsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_payments\n     * @example\n     * // Get one Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsFindFirstArgs} args - Arguments to find a Shopping_payments\n     * @example\n     * // Get one Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_paymentsFindFirstArgs>(args?: SelectSubset<T, shopping_paymentsFindFirstArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payments that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsFindFirstOrThrowArgs} args - Arguments to find a Shopping_payments\n     * @example\n     * // Get one Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_payments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findMany()\n     * \n     * // Get first 10 Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_paymentsWithIdOnly = await prisma.shopping_payments.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_paymentsFindManyArgs>(args?: SelectSubset<T, shopping_paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_payments.\n     * @param {shopping_paymentsCreateArgs} args - Arguments to create a Shopping_payments.\n     * @example\n     * // Create one Shopping_payments\n     * const Shopping_payments = await prisma.shopping_payments.create({\n     *   data: {\n     *     // ... data to create a Shopping_payments\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_paymentsCreateArgs>(args: SelectSubset<T, shopping_paymentsCreateArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_payments.\n     * @param {shopping_paymentsCreateManyArgs} args - Arguments to create many Shopping_payments.\n     * @example\n     * // Create many Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_paymentsCreateManyArgs>(args?: SelectSubset<T, shopping_paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_payments and returns the data saved in the database.\n     * @param {shopping_paymentsCreateManyAndReturnArgs} args - Arguments to create many Shopping_payments.\n     * @example\n     * // Create many Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_payments and only return the `id`\n     * const shopping_paymentsWithIdOnly = await prisma.shopping_payments.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_payments.\n     * @param {shopping_paymentsDeleteArgs} args - Arguments to delete one Shopping_payments.\n     * @example\n     * // Delete one Shopping_payments\n     * const Shopping_payments = await prisma.shopping_payments.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_payments\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_paymentsDeleteArgs>(args: SelectSubset<T, shopping_paymentsDeleteArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_payments.\n     * @param {shopping_paymentsUpdateArgs} args - Arguments to update one Shopping_payments.\n     * @example\n     * // Update one Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_paymentsUpdateArgs>(args: SelectSubset<T, shopping_paymentsUpdateArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_payments.\n     * @param {shopping_paymentsDeleteManyArgs} args - Arguments to filter Shopping_payments to delete.\n     * @example\n     * // Delete a few Shopping_payments\n     * const { count } = await prisma.shopping_payments.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_paymentsDeleteManyArgs>(args?: SelectSubset<T, shopping_paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_paymentsUpdateManyArgs>(args: SelectSubset<T, shopping_paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payments and returns the data updated in the database.\n     * @param {shopping_paymentsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_payments.\n     * @example\n     * // Update many Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_payments and only return the `id`\n     * const shopping_paymentsWithIdOnly = await prisma.shopping_payments.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_payments.\n     * @param {shopping_paymentsUpsertArgs} args - Arguments to update or create a Shopping_payments.\n     * @example\n     * // Update or create a Shopping_payments\n     * const shopping_payments = await prisma.shopping_payments.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_payments\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_payments we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_paymentsUpsertArgs>(args: SelectSubset<T, shopping_paymentsUpsertArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_payments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsCountArgs} args - Arguments to filter Shopping_payments to count.\n     * @example\n     * // Count the number of Shopping_payments\n     * const count = await prisma.shopping_payments.count({\n     *   where: {\n     *     // ... the filter for the Shopping_payments we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_paymentsCountArgs>(\n      args?: Subset<T, shopping_paymentsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_paymentsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_payments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_paymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_paymentsAggregateArgs>(args: Subset<T, Shopping_paymentsAggregateArgs>): Prisma.PrismaPromise<GetShopping_paymentsAggregateType<T>>\n\n    /**\n     * Group by Shopping_payments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_paymentsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_paymentsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_paymentsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_paymentsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_paymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_payments model\n   */\n  readonly fields: shopping_paymentsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_payments.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    customer<T extends shopping_customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_customersDefaultArgs<ExtArgs>>): Prisma__shopping_customersClient<$Result.GetResult<Prisma.$shopping_customersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    shopping_payment_transactions<T extends shopping_payments$shopping_payment_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, shopping_payments$shopping_payment_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_payments model\n   */\n  interface shopping_paymentsFieldRefs {\n    readonly id: FieldRef<\"shopping_payments\", 'String'>\n    readonly shopping_customer_id: FieldRef<\"shopping_payments\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_payments\", 'String'>\n    readonly payment_method_id: FieldRef<\"shopping_payments\", 'String'>\n    readonly amount: FieldRef<\"shopping_payments\", 'Float'>\n    readonly currency: FieldRef<\"shopping_payments\", 'String'>\n    readonly status: FieldRef<\"shopping_payments\", 'String'>\n    readonly transaction_id: FieldRef<\"shopping_payments\", 'String'>\n    readonly payment_date: FieldRef<\"shopping_payments\", 'DateTime'>\n    readonly created_at: FieldRef<\"shopping_payments\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_payments\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_payments\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_payments findUnique\n   */\n  export type shopping_paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payments to fetch.\n     */\n    where: shopping_paymentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payments findUniqueOrThrow\n   */\n  export type shopping_paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payments to fetch.\n     */\n    where: shopping_paymentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payments findFirst\n   */\n  export type shopping_paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payments to fetch.\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payments to fetch.\n     */\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payments.\n     */\n    cursor?: shopping_paymentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payments.\n     */\n    distinct?: Shopping_paymentsScalarFieldEnum | Shopping_paymentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payments findFirstOrThrow\n   */\n  export type shopping_paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payments to fetch.\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payments to fetch.\n     */\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payments.\n     */\n    cursor?: shopping_paymentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payments.\n     */\n    distinct?: Shopping_paymentsScalarFieldEnum | Shopping_paymentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payments findMany\n   */\n  export type shopping_paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payments to fetch.\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payments to fetch.\n     */\n    orderBy?: shopping_paymentsOrderByWithRelationInput | shopping_paymentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_payments.\n     */\n    cursor?: shopping_paymentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payments.\n     */\n    skip?: number\n    distinct?: Shopping_paymentsScalarFieldEnum | Shopping_paymentsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payments create\n   */\n  export type shopping_paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_payments.\n     */\n    data: XOR<shopping_paymentsCreateInput, shopping_paymentsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_payments createMany\n   */\n  export type shopping_paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_payments.\n     */\n    data: shopping_paymentsCreateManyInput | shopping_paymentsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_payments createManyAndReturn\n   */\n  export type shopping_paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_payments.\n     */\n    data: shopping_paymentsCreateManyInput | shopping_paymentsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_payments update\n   */\n  export type shopping_paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_payments.\n     */\n    data: XOR<shopping_paymentsUpdateInput, shopping_paymentsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_payments to update.\n     */\n    where: shopping_paymentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payments updateMany\n   */\n  export type shopping_paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_payments.\n     */\n    data: XOR<shopping_paymentsUpdateManyMutationInput, shopping_paymentsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payments to update\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * Limit how many shopping_payments to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payments updateManyAndReturn\n   */\n  export type shopping_paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_payments.\n     */\n    data: XOR<shopping_paymentsUpdateManyMutationInput, shopping_paymentsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payments to update\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * Limit how many shopping_payments to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_payments upsert\n   */\n  export type shopping_paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_payments to update in case it exists.\n     */\n    where: shopping_paymentsWhereUniqueInput\n    /**\n     * In case the shopping_payments found by the `where` argument doesn't exist, create a new shopping_payments with this data.\n     */\n    create: XOR<shopping_paymentsCreateInput, shopping_paymentsUncheckedCreateInput>\n    /**\n     * In case the shopping_payments was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_paymentsUpdateInput, shopping_paymentsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_payments delete\n   */\n  export type shopping_paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_payments to delete.\n     */\n    where: shopping_paymentsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payments deleteMany\n   */\n  export type shopping_paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payments to delete\n     */\n    where?: shopping_paymentsWhereInput\n    /**\n     * Limit how many shopping_payments to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payments.shopping_payment_transactions\n   */\n  export type shopping_payments$shopping_payment_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    where?: shopping_payment_transactionsWhereInput\n    orderBy?: shopping_payment_transactionsOrderByWithRelationInput | shopping_payment_transactionsOrderByWithRelationInput[]\n    cursor?: shopping_payment_transactionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_payment_transactionsScalarFieldEnum | Shopping_payment_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payments without action\n   */\n  export type shopping_paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payments\n     */\n    select?: shopping_paymentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payments\n     */\n    omit?: shopping_paymentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_paymentsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_payment_methods\n   */\n\n  export type AggregateShopping_payment_methods = {\n    _count: Shopping_payment_methodsCountAggregateOutputType | null\n    _min: Shopping_payment_methodsMinAggregateOutputType | null\n    _max: Shopping_payment_methodsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_payment_methodsMinAggregateOutputType = {\n    id: string | null\n    method_name: string | null\n    method_type: string | null\n    provider: string | null\n    is_active: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_payment_methodsMaxAggregateOutputType = {\n    id: string | null\n    method_name: string | null\n    method_type: string | null\n    provider: string | null\n    is_active: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_payment_methodsCountAggregateOutputType = {\n    id: number\n    method_name: number\n    method_type: number\n    provider: number\n    is_active: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_payment_methodsMinAggregateInputType = {\n    id?: true\n    method_name?: true\n    method_type?: true\n    provider?: true\n    is_active?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_payment_methodsMaxAggregateInputType = {\n    id?: true\n    method_name?: true\n    method_type?: true\n    provider?: true\n    is_active?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_payment_methodsCountAggregateInputType = {\n    id?: true\n    method_name?: true\n    method_type?: true\n    provider?: true\n    is_active?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payment_methods to aggregate.\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_methods to fetch.\n     */\n    orderBy?: shopping_payment_methodsOrderByWithRelationInput | shopping_payment_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_payment_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_payment_methods\n    **/\n    _count?: true | Shopping_payment_methodsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_payment_methodsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_payment_methodsMaxAggregateInputType\n  }\n\n  export type GetShopping_payment_methodsAggregateType<T extends Shopping_payment_methodsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_payment_methods]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_payment_methods[P]>\n      : GetScalarType<T[P], AggregateShopping_payment_methods[P]>\n  }\n\n\n\n\n  export type shopping_payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_payment_methodsWhereInput\n    orderBy?: shopping_payment_methodsOrderByWithAggregationInput | shopping_payment_methodsOrderByWithAggregationInput[]\n    by: Shopping_payment_methodsScalarFieldEnum[] | Shopping_payment_methodsScalarFieldEnum\n    having?: shopping_payment_methodsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_payment_methodsCountAggregateInputType | true\n    _min?: Shopping_payment_methodsMinAggregateInputType\n    _max?: Shopping_payment_methodsMaxAggregateInputType\n  }\n\n  export type Shopping_payment_methodsGroupByOutputType = {\n    id: string\n    method_name: string\n    method_type: string\n    provider: string | null\n    is_active: boolean\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_payment_methodsCountAggregateOutputType | null\n    _min: Shopping_payment_methodsMinAggregateOutputType | null\n    _max: Shopping_payment_methodsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_payment_methodsGroupByPayload<T extends shopping_payment_methodsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_payment_methodsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_payment_methodsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_payment_methodsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_payment_methodsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    method_name?: boolean\n    method_type?: boolean\n    provider?: boolean\n    is_active?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_payment_methods\"]>\n\n  export type shopping_payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    method_name?: boolean\n    method_type?: boolean\n    provider?: boolean\n    is_active?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_payment_methods\"]>\n\n  export type shopping_payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    method_name?: boolean\n    method_type?: boolean\n    provider?: boolean\n    is_active?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_payment_methods\"]>\n\n  export type shopping_payment_methodsSelectScalar = {\n    id?: boolean\n    method_name?: boolean\n    method_type?: boolean\n    provider?: boolean\n    is_active?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"method_name\" | \"method_type\" | \"provider\" | \"is_active\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_payment_methods\"]>\n\n  export type $shopping_payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_payment_methods\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Name of the payment method (e.g., Credit Card, PayPal, Apple Pay).\n       */\n      method_name: string\n      /**\n       * Type of payment method (e.g., card, digital_wallet, bank_transfer).\n       */\n      method_type: string\n      /**\n       * Payment provider name (e.g., Stripe, PayPal, Visa).\n       */\n      provider: string | null\n      /**\n       * Whether this payment method is currently active and available.\n       */\n      is_active: boolean\n      /**\n       * Record creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Record last update timestamp.\n       */\n      updated_at: Date\n      /**\n       * Soft delete timestamp.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_payment_methods\"]>\n    composites: {}\n  }\n\n  type shopping_payment_methodsGetPayload<S extends boolean | null | undefined | shopping_payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$shopping_payment_methodsPayload, S>\n\n  type shopping_payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_payment_methodsCountAggregateInputType | true\n    }\n\n  export interface shopping_payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_payment_methods'], meta: { name: 'shopping_payment_methods' } }\n    /**\n     * Find zero or one Shopping_payment_methods that matches the filter.\n     * @param {shopping_payment_methodsFindUniqueArgs} args - Arguments to find a Shopping_payment_methods\n     * @example\n     * // Get one Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_payment_methodsFindUniqueArgs>(args: SelectSubset<T, shopping_payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_payment_methods that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_payment_methods\n     * @example\n     * // Get one Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payment_methods that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsFindFirstArgs} args - Arguments to find a Shopping_payment_methods\n     * @example\n     * // Get one Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_payment_methodsFindFirstArgs>(args?: SelectSubset<T, shopping_payment_methodsFindFirstArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payment_methods that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsFindFirstOrThrowArgs} args - Arguments to find a Shopping_payment_methods\n     * @example\n     * // Get one Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_payment_methods that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findMany()\n     * \n     * // Get first 10 Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_payment_methodsWithIdOnly = await prisma.shopping_payment_methods.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_payment_methodsFindManyArgs>(args?: SelectSubset<T, shopping_payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_payment_methods.\n     * @param {shopping_payment_methodsCreateArgs} args - Arguments to create a Shopping_payment_methods.\n     * @example\n     * // Create one Shopping_payment_methods\n     * const Shopping_payment_methods = await prisma.shopping_payment_methods.create({\n     *   data: {\n     *     // ... data to create a Shopping_payment_methods\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_payment_methodsCreateArgs>(args: SelectSubset<T, shopping_payment_methodsCreateArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_payment_methods.\n     * @param {shopping_payment_methodsCreateManyArgs} args - Arguments to create many Shopping_payment_methods.\n     * @example\n     * // Create many Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_payment_methodsCreateManyArgs>(args?: SelectSubset<T, shopping_payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_payment_methods and returns the data saved in the database.\n     * @param {shopping_payment_methodsCreateManyAndReturnArgs} args - Arguments to create many Shopping_payment_methods.\n     * @example\n     * // Create many Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_payment_methods and only return the `id`\n     * const shopping_payment_methodsWithIdOnly = await prisma.shopping_payment_methods.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_payment_methods.\n     * @param {shopping_payment_methodsDeleteArgs} args - Arguments to delete one Shopping_payment_methods.\n     * @example\n     * // Delete one Shopping_payment_methods\n     * const Shopping_payment_methods = await prisma.shopping_payment_methods.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_payment_methods\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_payment_methodsDeleteArgs>(args: SelectSubset<T, shopping_payment_methodsDeleteArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_payment_methods.\n     * @param {shopping_payment_methodsUpdateArgs} args - Arguments to update one Shopping_payment_methods.\n     * @example\n     * // Update one Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_payment_methodsUpdateArgs>(args: SelectSubset<T, shopping_payment_methodsUpdateArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_payment_methods.\n     * @param {shopping_payment_methodsDeleteManyArgs} args - Arguments to filter Shopping_payment_methods to delete.\n     * @example\n     * // Delete a few Shopping_payment_methods\n     * const { count } = await prisma.shopping_payment_methods.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_payment_methodsDeleteManyArgs>(args?: SelectSubset<T, shopping_payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payment_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_payment_methodsUpdateManyArgs>(args: SelectSubset<T, shopping_payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payment_methods and returns the data updated in the database.\n     * @param {shopping_payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_payment_methods.\n     * @example\n     * // Update many Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_payment_methods and only return the `id`\n     * const shopping_payment_methodsWithIdOnly = await prisma.shopping_payment_methods.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_payment_methods.\n     * @param {shopping_payment_methodsUpsertArgs} args - Arguments to update or create a Shopping_payment_methods.\n     * @example\n     * // Update or create a Shopping_payment_methods\n     * const shopping_payment_methods = await prisma.shopping_payment_methods.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_payment_methods\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_payment_methods we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_payment_methodsUpsertArgs>(args: SelectSubset<T, shopping_payment_methodsUpsertArgs<ExtArgs>>): Prisma__shopping_payment_methodsClient<$Result.GetResult<Prisma.$shopping_payment_methodsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_payment_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsCountArgs} args - Arguments to filter Shopping_payment_methods to count.\n     * @example\n     * // Count the number of Shopping_payment_methods\n     * const count = await prisma.shopping_payment_methods.count({\n     *   where: {\n     *     // ... the filter for the Shopping_payment_methods we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_payment_methodsCountArgs>(\n      args?: Subset<T, shopping_payment_methodsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_payment_methodsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_payment_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_payment_methodsAggregateArgs>(args: Subset<T, Shopping_payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetShopping_payment_methodsAggregateType<T>>\n\n    /**\n     * Group by Shopping_payment_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_methodsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_payment_methodsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_payment_methodsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_payment_methodsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_payment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_payment_methods model\n   */\n  readonly fields: shopping_payment_methodsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_payment_methods.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_payment_methods model\n   */\n  interface shopping_payment_methodsFieldRefs {\n    readonly id: FieldRef<\"shopping_payment_methods\", 'String'>\n    readonly method_name: FieldRef<\"shopping_payment_methods\", 'String'>\n    readonly method_type: FieldRef<\"shopping_payment_methods\", 'String'>\n    readonly provider: FieldRef<\"shopping_payment_methods\", 'String'>\n    readonly is_active: FieldRef<\"shopping_payment_methods\", 'Boolean'>\n    readonly created_at: FieldRef<\"shopping_payment_methods\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_payment_methods\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_payment_methods\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_payment_methods findUnique\n   */\n  export type shopping_payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_methods to fetch.\n     */\n    where: shopping_payment_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_methods findUniqueOrThrow\n   */\n  export type shopping_payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_methods to fetch.\n     */\n    where: shopping_payment_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_methods findFirst\n   */\n  export type shopping_payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_methods to fetch.\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_methods to fetch.\n     */\n    orderBy?: shopping_payment_methodsOrderByWithRelationInput | shopping_payment_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payment_methods.\n     */\n    cursor?: shopping_payment_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payment_methods.\n     */\n    distinct?: Shopping_payment_methodsScalarFieldEnum | Shopping_payment_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_methods findFirstOrThrow\n   */\n  export type shopping_payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_methods to fetch.\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_methods to fetch.\n     */\n    orderBy?: shopping_payment_methodsOrderByWithRelationInput | shopping_payment_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payment_methods.\n     */\n    cursor?: shopping_payment_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payment_methods.\n     */\n    distinct?: Shopping_payment_methodsScalarFieldEnum | Shopping_payment_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_methods findMany\n   */\n  export type shopping_payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_methods to fetch.\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_methods to fetch.\n     */\n    orderBy?: shopping_payment_methodsOrderByWithRelationInput | shopping_payment_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_payment_methods.\n     */\n    cursor?: shopping_payment_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_methods.\n     */\n    skip?: number\n    distinct?: Shopping_payment_methodsScalarFieldEnum | Shopping_payment_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_methods create\n   */\n  export type shopping_payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_payment_methods.\n     */\n    data: XOR<shopping_payment_methodsCreateInput, shopping_payment_methodsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_payment_methods createMany\n   */\n  export type shopping_payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_payment_methods.\n     */\n    data: shopping_payment_methodsCreateManyInput | shopping_payment_methodsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_payment_methods createManyAndReturn\n   */\n  export type shopping_payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_payment_methods.\n     */\n    data: shopping_payment_methodsCreateManyInput | shopping_payment_methodsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_payment_methods update\n   */\n  export type shopping_payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_payment_methods.\n     */\n    data: XOR<shopping_payment_methodsUpdateInput, shopping_payment_methodsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_payment_methods to update.\n     */\n    where: shopping_payment_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_methods updateMany\n   */\n  export type shopping_payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_payment_methods.\n     */\n    data: XOR<shopping_payment_methodsUpdateManyMutationInput, shopping_payment_methodsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payment_methods to update\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * Limit how many shopping_payment_methods to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payment_methods updateManyAndReturn\n   */\n  export type shopping_payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_payment_methods.\n     */\n    data: XOR<shopping_payment_methodsUpdateManyMutationInput, shopping_payment_methodsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payment_methods to update\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * Limit how many shopping_payment_methods to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payment_methods upsert\n   */\n  export type shopping_payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_payment_methods to update in case it exists.\n     */\n    where: shopping_payment_methodsWhereUniqueInput\n    /**\n     * In case the shopping_payment_methods found by the `where` argument doesn't exist, create a new shopping_payment_methods with this data.\n     */\n    create: XOR<shopping_payment_methodsCreateInput, shopping_payment_methodsUncheckedCreateInput>\n    /**\n     * In case the shopping_payment_methods was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_payment_methodsUpdateInput, shopping_payment_methodsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_payment_methods delete\n   */\n  export type shopping_payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n    /**\n     * Filter which shopping_payment_methods to delete.\n     */\n    where: shopping_payment_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_methods deleteMany\n   */\n  export type shopping_payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payment_methods to delete\n     */\n    where?: shopping_payment_methodsWhereInput\n    /**\n     * Limit how many shopping_payment_methods to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payment_methods without action\n   */\n  export type shopping_payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_methods\n     */\n    select?: shopping_payment_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_methods\n     */\n    omit?: shopping_payment_methodsOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_payment_transactions\n   */\n\n  export type AggregateShopping_payment_transactions = {\n    _count: Shopping_payment_transactionsCountAggregateOutputType | null\n    _avg: Shopping_payment_transactionsAvgAggregateOutputType | null\n    _sum: Shopping_payment_transactionsSumAggregateOutputType | null\n    _min: Shopping_payment_transactionsMinAggregateOutputType | null\n    _max: Shopping_payment_transactionsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_payment_transactionsAvgAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_payment_transactionsSumAggregateOutputType = {\n    amount: number | null\n  }\n\n  export type Shopping_payment_transactionsMinAggregateOutputType = {\n    id: string | null\n    shopping_payment_id: string | null\n    transaction_type: string | null\n    amount: number | null\n    currency: string | null\n    status: string | null\n    gateway_response: string | null\n    transaction_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_payment_transactionsMaxAggregateOutputType = {\n    id: string | null\n    shopping_payment_id: string | null\n    transaction_type: string | null\n    amount: number | null\n    currency: string | null\n    status: string | null\n    gateway_response: string | null\n    transaction_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Shopping_payment_transactionsCountAggregateOutputType = {\n    id: number\n    shopping_payment_id: number\n    transaction_type: number\n    amount: number\n    currency: number\n    status: number\n    gateway_response: number\n    transaction_date: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Shopping_payment_transactionsAvgAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_payment_transactionsSumAggregateInputType = {\n    amount?: true\n  }\n\n  export type Shopping_payment_transactionsMinAggregateInputType = {\n    id?: true\n    shopping_payment_id?: true\n    transaction_type?: true\n    amount?: true\n    currency?: true\n    status?: true\n    gateway_response?: true\n    transaction_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_payment_transactionsMaxAggregateInputType = {\n    id?: true\n    shopping_payment_id?: true\n    transaction_type?: true\n    amount?: true\n    currency?: true\n    status?: true\n    gateway_response?: true\n    transaction_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Shopping_payment_transactionsCountAggregateInputType = {\n    id?: true\n    shopping_payment_id?: true\n    transaction_type?: true\n    amount?: true\n    currency?: true\n    status?: true\n    gateway_response?: true\n    transaction_date?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Shopping_payment_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payment_transactions to aggregate.\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_transactions to fetch.\n     */\n    orderBy?: shopping_payment_transactionsOrderByWithRelationInput | shopping_payment_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_payment_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_payment_transactions\n    **/\n    _count?: true | Shopping_payment_transactionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_payment_transactionsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_payment_transactionsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_payment_transactionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_payment_transactionsMaxAggregateInputType\n  }\n\n  export type GetShopping_payment_transactionsAggregateType<T extends Shopping_payment_transactionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_payment_transactions]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_payment_transactions[P]>\n      : GetScalarType<T[P], AggregateShopping_payment_transactions[P]>\n  }\n\n\n\n\n  export type shopping_payment_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_payment_transactionsWhereInput\n    orderBy?: shopping_payment_transactionsOrderByWithAggregationInput | shopping_payment_transactionsOrderByWithAggregationInput[]\n    by: Shopping_payment_transactionsScalarFieldEnum[] | Shopping_payment_transactionsScalarFieldEnum\n    having?: shopping_payment_transactionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_payment_transactionsCountAggregateInputType | true\n    _avg?: Shopping_payment_transactionsAvgAggregateInputType\n    _sum?: Shopping_payment_transactionsSumAggregateInputType\n    _min?: Shopping_payment_transactionsMinAggregateInputType\n    _max?: Shopping_payment_transactionsMaxAggregateInputType\n  }\n\n  export type Shopping_payment_transactionsGroupByOutputType = {\n    id: string\n    shopping_payment_id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response: string | null\n    transaction_date: Date\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Shopping_payment_transactionsCountAggregateOutputType | null\n    _avg: Shopping_payment_transactionsAvgAggregateOutputType | null\n    _sum: Shopping_payment_transactionsSumAggregateOutputType | null\n    _min: Shopping_payment_transactionsMinAggregateOutputType | null\n    _max: Shopping_payment_transactionsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_payment_transactionsGroupByPayload<T extends shopping_payment_transactionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_payment_transactionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_payment_transactionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_payment_transactionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_payment_transactionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_payment_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_payment_id?: boolean\n    transaction_type?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    gateway_response?: boolean\n    transaction_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payment_transactions\"]>\n\n  export type shopping_payment_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_payment_id?: boolean\n    transaction_type?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    gateway_response?: boolean\n    transaction_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payment_transactions\"]>\n\n  export type shopping_payment_transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_payment_id?: boolean\n    transaction_type?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    gateway_response?: boolean\n    transaction_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_payment_transactions\"]>\n\n  export type shopping_payment_transactionsSelectScalar = {\n    id?: boolean\n    shopping_payment_id?: boolean\n    transaction_type?: boolean\n    amount?: boolean\n    currency?: boolean\n    status?: boolean\n    gateway_response?: boolean\n    transaction_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type shopping_payment_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_payment_id\" | \"transaction_type\" | \"amount\" | \"currency\" | \"status\" | \"gateway_response\" | \"transaction_date\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"shopping_payment_transactions\"]>\n  export type shopping_payment_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }\n  export type shopping_payment_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }\n  export type shopping_payment_transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    payment?: boolean | shopping_paymentsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_payment_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_payment_transactions\"\n    objects: {\n      payment: Prisma.$shopping_paymentsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Payment record this transaction belongs to. {@link shopping_payments.id}.\n       */\n      shopping_payment_id: string\n      /**\n       * Type of transaction (e.g., authorization, capture, refund, chargeback).\n       */\n      transaction_type: string\n      /**\n       * Amount involved in this transaction.\n       */\n      amount: number\n      /**\n       * Currency used for this transaction.\n       */\n      currency: string\n      /**\n       * Current status of this transaction.\n       */\n      status: string\n      /**\n       * Raw response from payment gateway.\n       */\n      gateway_response: string | null\n      /**\n       * Date and time when this transaction occurred.\n       */\n      transaction_date: Date\n      /**\n       * Record creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Record last update timestamp.\n       */\n      updated_at: Date\n      /**\n       * Soft delete timestamp.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"shopping_payment_transactions\"]>\n    composites: {}\n  }\n\n  type shopping_payment_transactionsGetPayload<S extends boolean | null | undefined | shopping_payment_transactionsDefaultArgs> = $Result.GetResult<Prisma.$shopping_payment_transactionsPayload, S>\n\n  type shopping_payment_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_payment_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_payment_transactionsCountAggregateInputType | true\n    }\n\n  export interface shopping_payment_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_payment_transactions'], meta: { name: 'shopping_payment_transactions' } }\n    /**\n     * Find zero or one Shopping_payment_transactions that matches the filter.\n     * @param {shopping_payment_transactionsFindUniqueArgs} args - Arguments to find a Shopping_payment_transactions\n     * @example\n     * // Get one Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_payment_transactionsFindUniqueArgs>(args: SelectSubset<T, shopping_payment_transactionsFindUniqueArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_payment_transactions that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_payment_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_payment_transactions\n     * @example\n     * // Get one Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_payment_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_payment_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payment_transactions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsFindFirstArgs} args - Arguments to find a Shopping_payment_transactions\n     * @example\n     * // Get one Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_payment_transactionsFindFirstArgs>(args?: SelectSubset<T, shopping_payment_transactionsFindFirstArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_payment_transactions that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsFindFirstOrThrowArgs} args - Arguments to find a Shopping_payment_transactions\n     * @example\n     * // Get one Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_payment_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_payment_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_payment_transactions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findMany()\n     * \n     * // Get first 10 Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_payment_transactionsWithIdOnly = await prisma.shopping_payment_transactions.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_payment_transactionsFindManyArgs>(args?: SelectSubset<T, shopping_payment_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsCreateArgs} args - Arguments to create a Shopping_payment_transactions.\n     * @example\n     * // Create one Shopping_payment_transactions\n     * const Shopping_payment_transactions = await prisma.shopping_payment_transactions.create({\n     *   data: {\n     *     // ... data to create a Shopping_payment_transactions\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_payment_transactionsCreateArgs>(args: SelectSubset<T, shopping_payment_transactionsCreateArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsCreateManyArgs} args - Arguments to create many Shopping_payment_transactions.\n     * @example\n     * // Create many Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_payment_transactionsCreateManyArgs>(args?: SelectSubset<T, shopping_payment_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_payment_transactions and returns the data saved in the database.\n     * @param {shopping_payment_transactionsCreateManyAndReturnArgs} args - Arguments to create many Shopping_payment_transactions.\n     * @example\n     * // Create many Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_payment_transactions and only return the `id`\n     * const shopping_payment_transactionsWithIdOnly = await prisma.shopping_payment_transactions.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_payment_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_payment_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsDeleteArgs} args - Arguments to delete one Shopping_payment_transactions.\n     * @example\n     * // Delete one Shopping_payment_transactions\n     * const Shopping_payment_transactions = await prisma.shopping_payment_transactions.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_payment_transactions\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_payment_transactionsDeleteArgs>(args: SelectSubset<T, shopping_payment_transactionsDeleteArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsUpdateArgs} args - Arguments to update one Shopping_payment_transactions.\n     * @example\n     * // Update one Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_payment_transactionsUpdateArgs>(args: SelectSubset<T, shopping_payment_transactionsUpdateArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsDeleteManyArgs} args - Arguments to filter Shopping_payment_transactions to delete.\n     * @example\n     * // Delete a few Shopping_payment_transactions\n     * const { count } = await prisma.shopping_payment_transactions.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_payment_transactionsDeleteManyArgs>(args?: SelectSubset<T, shopping_payment_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payment_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_payment_transactionsUpdateManyArgs>(args: SelectSubset<T, shopping_payment_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_payment_transactions and returns the data updated in the database.\n     * @param {shopping_payment_transactionsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_payment_transactions.\n     * @example\n     * // Update many Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_payment_transactions and only return the `id`\n     * const shopping_payment_transactionsWithIdOnly = await prisma.shopping_payment_transactions.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_payment_transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_payment_transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_payment_transactions.\n     * @param {shopping_payment_transactionsUpsertArgs} args - Arguments to update or create a Shopping_payment_transactions.\n     * @example\n     * // Update or create a Shopping_payment_transactions\n     * const shopping_payment_transactions = await prisma.shopping_payment_transactions.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_payment_transactions\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_payment_transactions we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_payment_transactionsUpsertArgs>(args: SelectSubset<T, shopping_payment_transactionsUpsertArgs<ExtArgs>>): Prisma__shopping_payment_transactionsClient<$Result.GetResult<Prisma.$shopping_payment_transactionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_payment_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsCountArgs} args - Arguments to filter Shopping_payment_transactions to count.\n     * @example\n     * // Count the number of Shopping_payment_transactions\n     * const count = await prisma.shopping_payment_transactions.count({\n     *   where: {\n     *     // ... the filter for the Shopping_payment_transactions we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_payment_transactionsCountArgs>(\n      args?: Subset<T, shopping_payment_transactionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_payment_transactionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_payment_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_payment_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_payment_transactionsAggregateArgs>(args: Subset<T, Shopping_payment_transactionsAggregateArgs>): Prisma.PrismaPromise<GetShopping_payment_transactionsAggregateType<T>>\n\n    /**\n     * Group by Shopping_payment_transactions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_payment_transactionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_payment_transactionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_payment_transactionsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_payment_transactionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_payment_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_payment_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_payment_transactions model\n   */\n  readonly fields: shopping_payment_transactionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_payment_transactions.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_payment_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    payment<T extends shopping_paymentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_paymentsDefaultArgs<ExtArgs>>): Prisma__shopping_paymentsClient<$Result.GetResult<Prisma.$shopping_paymentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_payment_transactions model\n   */\n  interface shopping_payment_transactionsFieldRefs {\n    readonly id: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly shopping_payment_id: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly transaction_type: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly amount: FieldRef<\"shopping_payment_transactions\", 'Float'>\n    readonly currency: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly status: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly gateway_response: FieldRef<\"shopping_payment_transactions\", 'String'>\n    readonly transaction_date: FieldRef<\"shopping_payment_transactions\", 'DateTime'>\n    readonly created_at: FieldRef<\"shopping_payment_transactions\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_payment_transactions\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"shopping_payment_transactions\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_payment_transactions findUnique\n   */\n  export type shopping_payment_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_transactions to fetch.\n     */\n    where: shopping_payment_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_transactions findUniqueOrThrow\n   */\n  export type shopping_payment_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_transactions to fetch.\n     */\n    where: shopping_payment_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_transactions findFirst\n   */\n  export type shopping_payment_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_transactions to fetch.\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_transactions to fetch.\n     */\n    orderBy?: shopping_payment_transactionsOrderByWithRelationInput | shopping_payment_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payment_transactions.\n     */\n    cursor?: shopping_payment_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payment_transactions.\n     */\n    distinct?: Shopping_payment_transactionsScalarFieldEnum | Shopping_payment_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_transactions findFirstOrThrow\n   */\n  export type shopping_payment_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_transactions to fetch.\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_transactions to fetch.\n     */\n    orderBy?: shopping_payment_transactionsOrderByWithRelationInput | shopping_payment_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_payment_transactions.\n     */\n    cursor?: shopping_payment_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_transactions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_payment_transactions.\n     */\n    distinct?: Shopping_payment_transactionsScalarFieldEnum | Shopping_payment_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_transactions findMany\n   */\n  export type shopping_payment_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_payment_transactions to fetch.\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_payment_transactions to fetch.\n     */\n    orderBy?: shopping_payment_transactionsOrderByWithRelationInput | shopping_payment_transactionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_payment_transactions.\n     */\n    cursor?: shopping_payment_transactionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_payment_transactions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_payment_transactions.\n     */\n    skip?: number\n    distinct?: Shopping_payment_transactionsScalarFieldEnum | Shopping_payment_transactionsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_payment_transactions create\n   */\n  export type shopping_payment_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_payment_transactions.\n     */\n    data: XOR<shopping_payment_transactionsCreateInput, shopping_payment_transactionsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_payment_transactions createMany\n   */\n  export type shopping_payment_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_payment_transactions.\n     */\n    data: shopping_payment_transactionsCreateManyInput | shopping_payment_transactionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_payment_transactions createManyAndReturn\n   */\n  export type shopping_payment_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_payment_transactions.\n     */\n    data: shopping_payment_transactionsCreateManyInput | shopping_payment_transactionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_payment_transactions update\n   */\n  export type shopping_payment_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_payment_transactions.\n     */\n    data: XOR<shopping_payment_transactionsUpdateInput, shopping_payment_transactionsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_payment_transactions to update.\n     */\n    where: shopping_payment_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_transactions updateMany\n   */\n  export type shopping_payment_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_payment_transactions.\n     */\n    data: XOR<shopping_payment_transactionsUpdateManyMutationInput, shopping_payment_transactionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payment_transactions to update\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * Limit how many shopping_payment_transactions to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payment_transactions updateManyAndReturn\n   */\n  export type shopping_payment_transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_payment_transactions.\n     */\n    data: XOR<shopping_payment_transactionsUpdateManyMutationInput, shopping_payment_transactionsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_payment_transactions to update\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * Limit how many shopping_payment_transactions to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_payment_transactions upsert\n   */\n  export type shopping_payment_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_payment_transactions to update in case it exists.\n     */\n    where: shopping_payment_transactionsWhereUniqueInput\n    /**\n     * In case the shopping_payment_transactions found by the `where` argument doesn't exist, create a new shopping_payment_transactions with this data.\n     */\n    create: XOR<shopping_payment_transactionsCreateInput, shopping_payment_transactionsUncheckedCreateInput>\n    /**\n     * In case the shopping_payment_transactions was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_payment_transactionsUpdateInput, shopping_payment_transactionsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_payment_transactions delete\n   */\n  export type shopping_payment_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_payment_transactions to delete.\n     */\n    where: shopping_payment_transactionsWhereUniqueInput\n  }\n\n  /**\n   * shopping_payment_transactions deleteMany\n   */\n  export type shopping_payment_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_payment_transactions to delete\n     */\n    where?: shopping_payment_transactionsWhereInput\n    /**\n     * Limit how many shopping_payment_transactions to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_payment_transactions without action\n   */\n  export type shopping_payment_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_payment_transactions\n     */\n    select?: shopping_payment_transactionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_payment_transactions\n     */\n    omit?: shopping_payment_transactionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_payment_transactionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_shipping_methods\n   */\n\n  export type AggregateShopping_shipping_methods = {\n    _count: Shopping_shipping_methodsCountAggregateOutputType | null\n    _avg: Shopping_shipping_methodsAvgAggregateOutputType | null\n    _sum: Shopping_shipping_methodsSumAggregateOutputType | null\n    _min: Shopping_shipping_methodsMinAggregateOutputType | null\n    _max: Shopping_shipping_methodsMaxAggregateOutputType | null\n  }\n\n  export type Shopping_shipping_methodsAvgAggregateOutputType = {\n    cost: number | null\n    estimated_delivery_days: number | null\n  }\n\n  export type Shopping_shipping_methodsSumAggregateOutputType = {\n    cost: number | null\n    estimated_delivery_days: number | null\n  }\n\n  export type Shopping_shipping_methodsMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    cost: number | null\n    estimated_delivery_days: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_methodsMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    cost: number | null\n    estimated_delivery_days: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_methodsCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    cost: number\n    estimated_delivery_days: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_shipping_methodsAvgAggregateInputType = {\n    cost?: true\n    estimated_delivery_days?: true\n  }\n\n  export type Shopping_shipping_methodsSumAggregateInputType = {\n    cost?: true\n    estimated_delivery_days?: true\n  }\n\n  export type Shopping_shipping_methodsMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    cost?: true\n    estimated_delivery_days?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_methodsMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    cost?: true\n    estimated_delivery_days?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_methodsCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    cost?: true\n    estimated_delivery_days?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_shipping_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_methods to aggregate.\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_methods to fetch.\n     */\n    orderBy?: shopping_shipping_methodsOrderByWithRelationInput | shopping_shipping_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_shipping_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_shipping_methods\n    **/\n    _count?: true | Shopping_shipping_methodsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Shopping_shipping_methodsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Shopping_shipping_methodsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_shipping_methodsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_shipping_methodsMaxAggregateInputType\n  }\n\n  export type GetShopping_shipping_methodsAggregateType<T extends Shopping_shipping_methodsAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_shipping_methods]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_shipping_methods[P]>\n      : GetScalarType<T[P], AggregateShopping_shipping_methods[P]>\n  }\n\n\n\n\n  export type shopping_shipping_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_methodsWhereInput\n    orderBy?: shopping_shipping_methodsOrderByWithAggregationInput | shopping_shipping_methodsOrderByWithAggregationInput[]\n    by: Shopping_shipping_methodsScalarFieldEnum[] | Shopping_shipping_methodsScalarFieldEnum\n    having?: shopping_shipping_methodsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_shipping_methodsCountAggregateInputType | true\n    _avg?: Shopping_shipping_methodsAvgAggregateInputType\n    _sum?: Shopping_shipping_methodsSumAggregateInputType\n    _min?: Shopping_shipping_methodsMinAggregateInputType\n    _max?: Shopping_shipping_methodsMaxAggregateInputType\n  }\n\n  export type Shopping_shipping_methodsGroupByOutputType = {\n    id: string\n    name: string\n    description: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_shipping_methodsCountAggregateOutputType | null\n    _avg: Shopping_shipping_methodsAvgAggregateOutputType | null\n    _sum: Shopping_shipping_methodsSumAggregateOutputType | null\n    _min: Shopping_shipping_methodsMinAggregateOutputType | null\n    _max: Shopping_shipping_methodsMaxAggregateOutputType | null\n  }\n\n  type GetShopping_shipping_methodsGroupByPayload<T extends shopping_shipping_methodsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_shipping_methodsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_shipping_methodsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_shipping_methodsGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_shipping_methodsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_shipping_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    cost?: boolean\n    estimated_delivery_days?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    shopping_shipping_tracking?: boolean | shopping_shipping_methods$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_shipping_methodsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shipping_methods\"]>\n\n  export type shopping_shipping_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    cost?: boolean\n    estimated_delivery_days?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_shipping_methods\"]>\n\n  export type shopping_shipping_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    cost?: boolean\n    estimated_delivery_days?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_shipping_methods\"]>\n\n  export type shopping_shipping_methodsSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    cost?: boolean\n    estimated_delivery_days?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_shipping_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\" | \"cost\" | \"estimated_delivery_days\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_shipping_methods\"]>\n  export type shopping_shipping_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_shipping_tracking?: boolean | shopping_shipping_methods$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_shipping_methodsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_shipping_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_shipping_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_shipping_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_shipping_methods\"\n    objects: {\n      shopping_shipping_tracking: Prisma.$shopping_shipping_trackingPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Name of the shipping method (e.g., Standard, Express, Overnight).\n       */\n      name: string\n      /**\n       * Detailed description of the shipping method.\n       */\n      description: string | null\n      /**\n       * Base cost of the shipping method.\n       */\n      cost: number\n      /**\n       * Estimated number of days for delivery.\n       */\n      estimated_delivery_days: number\n      /**\n       * Timestamp when the shipping method was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the shipping method was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_shipping_methods\"]>\n    composites: {}\n  }\n\n  type shopping_shipping_methodsGetPayload<S extends boolean | null | undefined | shopping_shipping_methodsDefaultArgs> = $Result.GetResult<Prisma.$shopping_shipping_methodsPayload, S>\n\n  type shopping_shipping_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_shipping_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_shipping_methodsCountAggregateInputType | true\n    }\n\n  export interface shopping_shipping_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_shipping_methods'], meta: { name: 'shopping_shipping_methods' } }\n    /**\n     * Find zero or one Shopping_shipping_methods that matches the filter.\n     * @param {shopping_shipping_methodsFindUniqueArgs} args - Arguments to find a Shopping_shipping_methods\n     * @example\n     * // Get one Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_shipping_methodsFindUniqueArgs>(args: SelectSubset<T, shopping_shipping_methodsFindUniqueArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_shipping_methods that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_shipping_methodsFindUniqueOrThrowArgs} args - Arguments to find a Shopping_shipping_methods\n     * @example\n     * // Get one Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_shipping_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_shipping_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_methods that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsFindFirstArgs} args - Arguments to find a Shopping_shipping_methods\n     * @example\n     * // Get one Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_shipping_methodsFindFirstArgs>(args?: SelectSubset<T, shopping_shipping_methodsFindFirstArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_methods that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsFindFirstOrThrowArgs} args - Arguments to find a Shopping_shipping_methods\n     * @example\n     * // Get one Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_shipping_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_shipping_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_shipping_methods that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findMany()\n     * \n     * // Get first 10 Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_shipping_methodsWithIdOnly = await prisma.shopping_shipping_methods.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_shipping_methodsFindManyArgs>(args?: SelectSubset<T, shopping_shipping_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsCreateArgs} args - Arguments to create a Shopping_shipping_methods.\n     * @example\n     * // Create one Shopping_shipping_methods\n     * const Shopping_shipping_methods = await prisma.shopping_shipping_methods.create({\n     *   data: {\n     *     // ... data to create a Shopping_shipping_methods\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_shipping_methodsCreateArgs>(args: SelectSubset<T, shopping_shipping_methodsCreateArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsCreateManyArgs} args - Arguments to create many Shopping_shipping_methods.\n     * @example\n     * // Create many Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_shipping_methodsCreateManyArgs>(args?: SelectSubset<T, shopping_shipping_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_shipping_methods and returns the data saved in the database.\n     * @param {shopping_shipping_methodsCreateManyAndReturnArgs} args - Arguments to create many Shopping_shipping_methods.\n     * @example\n     * // Create many Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_shipping_methods and only return the `id`\n     * const shopping_shipping_methodsWithIdOnly = await prisma.shopping_shipping_methods.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_shipping_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_shipping_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsDeleteArgs} args - Arguments to delete one Shopping_shipping_methods.\n     * @example\n     * // Delete one Shopping_shipping_methods\n     * const Shopping_shipping_methods = await prisma.shopping_shipping_methods.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_shipping_methods\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_shipping_methodsDeleteArgs>(args: SelectSubset<T, shopping_shipping_methodsDeleteArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsUpdateArgs} args - Arguments to update one Shopping_shipping_methods.\n     * @example\n     * // Update one Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_shipping_methodsUpdateArgs>(args: SelectSubset<T, shopping_shipping_methodsUpdateArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsDeleteManyArgs} args - Arguments to filter Shopping_shipping_methods to delete.\n     * @example\n     * // Delete a few Shopping_shipping_methods\n     * const { count } = await prisma.shopping_shipping_methods.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_shipping_methodsDeleteManyArgs>(args?: SelectSubset<T, shopping_shipping_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_shipping_methodsUpdateManyArgs>(args: SelectSubset<T, shopping_shipping_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_methods and returns the data updated in the database.\n     * @param {shopping_shipping_methodsUpdateManyAndReturnArgs} args - Arguments to update many Shopping_shipping_methods.\n     * @example\n     * // Update many Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_shipping_methods and only return the `id`\n     * const shopping_shipping_methodsWithIdOnly = await prisma.shopping_shipping_methods.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_shipping_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_shipping_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_shipping_methods.\n     * @param {shopping_shipping_methodsUpsertArgs} args - Arguments to update or create a Shopping_shipping_methods.\n     * @example\n     * // Update or create a Shopping_shipping_methods\n     * const shopping_shipping_methods = await prisma.shopping_shipping_methods.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_shipping_methods\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_methods we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_shipping_methodsUpsertArgs>(args: SelectSubset<T, shopping_shipping_methodsUpsertArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_shipping_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsCountArgs} args - Arguments to filter Shopping_shipping_methods to count.\n     * @example\n     * // Count the number of Shopping_shipping_methods\n     * const count = await prisma.shopping_shipping_methods.count({\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_methods we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_shipping_methodsCountArgs>(\n      args?: Subset<T, shopping_shipping_methodsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_shipping_methodsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_shipping_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_shipping_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_shipping_methodsAggregateArgs>(args: Subset<T, Shopping_shipping_methodsAggregateArgs>): Prisma.PrismaPromise<GetShopping_shipping_methodsAggregateType<T>>\n\n    /**\n     * Group by Shopping_shipping_methods.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_methodsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_shipping_methodsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_shipping_methodsGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_shipping_methodsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_shipping_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_shipping_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_shipping_methods model\n   */\n  readonly fields: shopping_shipping_methodsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_shipping_methods.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_shipping_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_shipping_tracking<T extends shopping_shipping_methods$shopping_shipping_trackingArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shipping_methods$shopping_shipping_trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_shipping_methods model\n   */\n  interface shopping_shipping_methodsFieldRefs {\n    readonly id: FieldRef<\"shopping_shipping_methods\", 'String'>\n    readonly name: FieldRef<\"shopping_shipping_methods\", 'String'>\n    readonly description: FieldRef<\"shopping_shipping_methods\", 'String'>\n    readonly cost: FieldRef<\"shopping_shipping_methods\", 'Float'>\n    readonly estimated_delivery_days: FieldRef<\"shopping_shipping_methods\", 'Int'>\n    readonly created_at: FieldRef<\"shopping_shipping_methods\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_shipping_methods\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_shipping_methods findUnique\n   */\n  export type shopping_shipping_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_methods to fetch.\n     */\n    where: shopping_shipping_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_methods findUniqueOrThrow\n   */\n  export type shopping_shipping_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_methods to fetch.\n     */\n    where: shopping_shipping_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_methods findFirst\n   */\n  export type shopping_shipping_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_methods to fetch.\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_methods to fetch.\n     */\n    orderBy?: shopping_shipping_methodsOrderByWithRelationInput | shopping_shipping_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_methods.\n     */\n    cursor?: shopping_shipping_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_methods.\n     */\n    distinct?: Shopping_shipping_methodsScalarFieldEnum | Shopping_shipping_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_methods findFirstOrThrow\n   */\n  export type shopping_shipping_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_methods to fetch.\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_methods to fetch.\n     */\n    orderBy?: shopping_shipping_methodsOrderByWithRelationInput | shopping_shipping_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_methods.\n     */\n    cursor?: shopping_shipping_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_methods.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_methods.\n     */\n    distinct?: Shopping_shipping_methodsScalarFieldEnum | Shopping_shipping_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_methods findMany\n   */\n  export type shopping_shipping_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_methods to fetch.\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_methods to fetch.\n     */\n    orderBy?: shopping_shipping_methodsOrderByWithRelationInput | shopping_shipping_methodsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_shipping_methods.\n     */\n    cursor?: shopping_shipping_methodsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_methods from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_methods.\n     */\n    skip?: number\n    distinct?: Shopping_shipping_methodsScalarFieldEnum | Shopping_shipping_methodsScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_methods create\n   */\n  export type shopping_shipping_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_shipping_methods.\n     */\n    data: XOR<shopping_shipping_methodsCreateInput, shopping_shipping_methodsUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_shipping_methods createMany\n   */\n  export type shopping_shipping_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_shipping_methods.\n     */\n    data: shopping_shipping_methodsCreateManyInput | shopping_shipping_methodsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shipping_methods createManyAndReturn\n   */\n  export type shopping_shipping_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_shipping_methods.\n     */\n    data: shopping_shipping_methodsCreateManyInput | shopping_shipping_methodsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shipping_methods update\n   */\n  export type shopping_shipping_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_shipping_methods.\n     */\n    data: XOR<shopping_shipping_methodsUpdateInput, shopping_shipping_methodsUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_shipping_methods to update.\n     */\n    where: shopping_shipping_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_methods updateMany\n   */\n  export type shopping_shipping_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_shipping_methods.\n     */\n    data: XOR<shopping_shipping_methodsUpdateManyMutationInput, shopping_shipping_methodsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_methods to update\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * Limit how many shopping_shipping_methods to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_methods updateManyAndReturn\n   */\n  export type shopping_shipping_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_shipping_methods.\n     */\n    data: XOR<shopping_shipping_methodsUpdateManyMutationInput, shopping_shipping_methodsUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_methods to update\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * Limit how many shopping_shipping_methods to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_methods upsert\n   */\n  export type shopping_shipping_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_shipping_methods to update in case it exists.\n     */\n    where: shopping_shipping_methodsWhereUniqueInput\n    /**\n     * In case the shopping_shipping_methods found by the `where` argument doesn't exist, create a new shopping_shipping_methods with this data.\n     */\n    create: XOR<shopping_shipping_methodsCreateInput, shopping_shipping_methodsUncheckedCreateInput>\n    /**\n     * In case the shopping_shipping_methods was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_shipping_methodsUpdateInput, shopping_shipping_methodsUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_shipping_methods delete\n   */\n  export type shopping_shipping_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_shipping_methods to delete.\n     */\n    where: shopping_shipping_methodsWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_methods deleteMany\n   */\n  export type shopping_shipping_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_methods to delete\n     */\n    where?: shopping_shipping_methodsWhereInput\n    /**\n     * Limit how many shopping_shipping_methods to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_methods.shopping_shipping_tracking\n   */\n  export type shopping_shipping_methods$shopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    where?: shopping_shipping_trackingWhereInput\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_methods without action\n   */\n  export type shopping_shipping_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_methods\n     */\n    select?: shopping_shipping_methodsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_methods\n     */\n    omit?: shopping_shipping_methodsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_methodsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_shipping_carriers\n   */\n\n  export type AggregateShopping_shipping_carriers = {\n    _count: Shopping_shipping_carriersCountAggregateOutputType | null\n    _min: Shopping_shipping_carriersMinAggregateOutputType | null\n    _max: Shopping_shipping_carriersMaxAggregateOutputType | null\n  }\n\n  export type Shopping_shipping_carriersMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    tracking_url_template: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_carriersMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    tracking_url_template: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_carriersCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    tracking_url_template: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_shipping_carriersMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    tracking_url_template?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_carriersMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    tracking_url_template?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_carriersCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    tracking_url_template?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_shipping_carriersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_carriers to aggregate.\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_carriers to fetch.\n     */\n    orderBy?: shopping_shipping_carriersOrderByWithRelationInput | shopping_shipping_carriersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_shipping_carriersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_carriers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_carriers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_shipping_carriers\n    **/\n    _count?: true | Shopping_shipping_carriersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_shipping_carriersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_shipping_carriersMaxAggregateInputType\n  }\n\n  export type GetShopping_shipping_carriersAggregateType<T extends Shopping_shipping_carriersAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_shipping_carriers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_shipping_carriers[P]>\n      : GetScalarType<T[P], AggregateShopping_shipping_carriers[P]>\n  }\n\n\n\n\n  export type shopping_shipping_carriersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_carriersWhereInput\n    orderBy?: shopping_shipping_carriersOrderByWithAggregationInput | shopping_shipping_carriersOrderByWithAggregationInput[]\n    by: Shopping_shipping_carriersScalarFieldEnum[] | Shopping_shipping_carriersScalarFieldEnum\n    having?: shopping_shipping_carriersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_shipping_carriersCountAggregateInputType | true\n    _min?: Shopping_shipping_carriersMinAggregateInputType\n    _max?: Shopping_shipping_carriersMaxAggregateInputType\n  }\n\n  export type Shopping_shipping_carriersGroupByOutputType = {\n    id: string\n    name: string\n    description: string | null\n    tracking_url_template: string | null\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_shipping_carriersCountAggregateOutputType | null\n    _min: Shopping_shipping_carriersMinAggregateOutputType | null\n    _max: Shopping_shipping_carriersMaxAggregateOutputType | null\n  }\n\n  type GetShopping_shipping_carriersGroupByPayload<T extends shopping_shipping_carriersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_shipping_carriersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_shipping_carriersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_shipping_carriersGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_shipping_carriersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_shipping_carriersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    tracking_url_template?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    shopping_shipping_tracking?: boolean | shopping_shipping_carriers$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_shipping_carriersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shipping_carriers\"]>\n\n  export type shopping_shipping_carriersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    tracking_url_template?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_shipping_carriers\"]>\n\n  export type shopping_shipping_carriersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    tracking_url_template?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"shopping_shipping_carriers\"]>\n\n  export type shopping_shipping_carriersSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    tracking_url_template?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_shipping_carriersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\" | \"tracking_url_template\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_shipping_carriers\"]>\n  export type shopping_shipping_carriersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    shopping_shipping_tracking?: boolean | shopping_shipping_carriers$shopping_shipping_trackingArgs<ExtArgs>\n    _count?: boolean | Shopping_shipping_carriersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type shopping_shipping_carriersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type shopping_shipping_carriersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $shopping_shipping_carriersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_shipping_carriers\"\n    objects: {\n      shopping_shipping_tracking: Prisma.$shopping_shipping_trackingPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Name of the shipping carrier (e.g., UPS, FedEx, DHL).\n       */\n      name: string\n      /**\n       * Detailed description of the shipping carrier.\n       */\n      description: string | null\n      /**\n       * URL template for tracking shipments with this carrier.\n       */\n      tracking_url_template: string | null\n      /**\n       * Timestamp when the shipping carrier was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the shipping carrier was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_shipping_carriers\"]>\n    composites: {}\n  }\n\n  type shopping_shipping_carriersGetPayload<S extends boolean | null | undefined | shopping_shipping_carriersDefaultArgs> = $Result.GetResult<Prisma.$shopping_shipping_carriersPayload, S>\n\n  type shopping_shipping_carriersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_shipping_carriersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_shipping_carriersCountAggregateInputType | true\n    }\n\n  export interface shopping_shipping_carriersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_shipping_carriers'], meta: { name: 'shopping_shipping_carriers' } }\n    /**\n     * Find zero or one Shopping_shipping_carriers that matches the filter.\n     * @param {shopping_shipping_carriersFindUniqueArgs} args - Arguments to find a Shopping_shipping_carriers\n     * @example\n     * // Get one Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_shipping_carriersFindUniqueArgs>(args: SelectSubset<T, shopping_shipping_carriersFindUniqueArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_shipping_carriers that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_shipping_carriersFindUniqueOrThrowArgs} args - Arguments to find a Shopping_shipping_carriers\n     * @example\n     * // Get one Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_shipping_carriersFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_shipping_carriersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_carriers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersFindFirstArgs} args - Arguments to find a Shopping_shipping_carriers\n     * @example\n     * // Get one Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_shipping_carriersFindFirstArgs>(args?: SelectSubset<T, shopping_shipping_carriersFindFirstArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_carriers that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersFindFirstOrThrowArgs} args - Arguments to find a Shopping_shipping_carriers\n     * @example\n     * // Get one Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_shipping_carriersFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_shipping_carriersFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_shipping_carriers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findMany()\n     * \n     * // Get first 10 Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_shipping_carriersWithIdOnly = await prisma.shopping_shipping_carriers.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_shipping_carriersFindManyArgs>(args?: SelectSubset<T, shopping_shipping_carriersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersCreateArgs} args - Arguments to create a Shopping_shipping_carriers.\n     * @example\n     * // Create one Shopping_shipping_carriers\n     * const Shopping_shipping_carriers = await prisma.shopping_shipping_carriers.create({\n     *   data: {\n     *     // ... data to create a Shopping_shipping_carriers\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_shipping_carriersCreateArgs>(args: SelectSubset<T, shopping_shipping_carriersCreateArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersCreateManyArgs} args - Arguments to create many Shopping_shipping_carriers.\n     * @example\n     * // Create many Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_shipping_carriersCreateManyArgs>(args?: SelectSubset<T, shopping_shipping_carriersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_shipping_carriers and returns the data saved in the database.\n     * @param {shopping_shipping_carriersCreateManyAndReturnArgs} args - Arguments to create many Shopping_shipping_carriers.\n     * @example\n     * // Create many Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_shipping_carriers and only return the `id`\n     * const shopping_shipping_carriersWithIdOnly = await prisma.shopping_shipping_carriers.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_shipping_carriersCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_shipping_carriersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersDeleteArgs} args - Arguments to delete one Shopping_shipping_carriers.\n     * @example\n     * // Delete one Shopping_shipping_carriers\n     * const Shopping_shipping_carriers = await prisma.shopping_shipping_carriers.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_shipping_carriers\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_shipping_carriersDeleteArgs>(args: SelectSubset<T, shopping_shipping_carriersDeleteArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersUpdateArgs} args - Arguments to update one Shopping_shipping_carriers.\n     * @example\n     * // Update one Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_shipping_carriersUpdateArgs>(args: SelectSubset<T, shopping_shipping_carriersUpdateArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersDeleteManyArgs} args - Arguments to filter Shopping_shipping_carriers to delete.\n     * @example\n     * // Delete a few Shopping_shipping_carriers\n     * const { count } = await prisma.shopping_shipping_carriers.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_shipping_carriersDeleteManyArgs>(args?: SelectSubset<T, shopping_shipping_carriersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_carriers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_shipping_carriersUpdateManyArgs>(args: SelectSubset<T, shopping_shipping_carriersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_carriers and returns the data updated in the database.\n     * @param {shopping_shipping_carriersUpdateManyAndReturnArgs} args - Arguments to update many Shopping_shipping_carriers.\n     * @example\n     * // Update many Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_shipping_carriers and only return the `id`\n     * const shopping_shipping_carriersWithIdOnly = await prisma.shopping_shipping_carriers.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_shipping_carriersUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_shipping_carriersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_shipping_carriers.\n     * @param {shopping_shipping_carriersUpsertArgs} args - Arguments to update or create a Shopping_shipping_carriers.\n     * @example\n     * // Update or create a Shopping_shipping_carriers\n     * const shopping_shipping_carriers = await prisma.shopping_shipping_carriers.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_shipping_carriers\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_carriers we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_shipping_carriersUpsertArgs>(args: SelectSubset<T, shopping_shipping_carriersUpsertArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_shipping_carriers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersCountArgs} args - Arguments to filter Shopping_shipping_carriers to count.\n     * @example\n     * // Count the number of Shopping_shipping_carriers\n     * const count = await prisma.shopping_shipping_carriers.count({\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_carriers we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_shipping_carriersCountArgs>(\n      args?: Subset<T, shopping_shipping_carriersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_shipping_carriersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_shipping_carriers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_shipping_carriersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_shipping_carriersAggregateArgs>(args: Subset<T, Shopping_shipping_carriersAggregateArgs>): Prisma.PrismaPromise<GetShopping_shipping_carriersAggregateType<T>>\n\n    /**\n     * Group by Shopping_shipping_carriers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_carriersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_shipping_carriersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_shipping_carriersGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_shipping_carriersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_shipping_carriersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_shipping_carriersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_shipping_carriers model\n   */\n  readonly fields: shopping_shipping_carriersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_shipping_carriers.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_shipping_carriersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    shopping_shipping_tracking<T extends shopping_shipping_carriers$shopping_shipping_trackingArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shipping_carriers$shopping_shipping_trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_shipping_carriers model\n   */\n  interface shopping_shipping_carriersFieldRefs {\n    readonly id: FieldRef<\"shopping_shipping_carriers\", 'String'>\n    readonly name: FieldRef<\"shopping_shipping_carriers\", 'String'>\n    readonly description: FieldRef<\"shopping_shipping_carriers\", 'String'>\n    readonly tracking_url_template: FieldRef<\"shopping_shipping_carriers\", 'String'>\n    readonly created_at: FieldRef<\"shopping_shipping_carriers\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_shipping_carriers\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_shipping_carriers findUnique\n   */\n  export type shopping_shipping_carriersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_carriers to fetch.\n     */\n    where: shopping_shipping_carriersWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_carriers findUniqueOrThrow\n   */\n  export type shopping_shipping_carriersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_carriers to fetch.\n     */\n    where: shopping_shipping_carriersWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_carriers findFirst\n   */\n  export type shopping_shipping_carriersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_carriers to fetch.\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_carriers to fetch.\n     */\n    orderBy?: shopping_shipping_carriersOrderByWithRelationInput | shopping_shipping_carriersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_carriers.\n     */\n    cursor?: shopping_shipping_carriersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_carriers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_carriers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_carriers.\n     */\n    distinct?: Shopping_shipping_carriersScalarFieldEnum | Shopping_shipping_carriersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_carriers findFirstOrThrow\n   */\n  export type shopping_shipping_carriersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_carriers to fetch.\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_carriers to fetch.\n     */\n    orderBy?: shopping_shipping_carriersOrderByWithRelationInput | shopping_shipping_carriersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_carriers.\n     */\n    cursor?: shopping_shipping_carriersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_carriers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_carriers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_carriers.\n     */\n    distinct?: Shopping_shipping_carriersScalarFieldEnum | Shopping_shipping_carriersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_carriers findMany\n   */\n  export type shopping_shipping_carriersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_carriers to fetch.\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_carriers to fetch.\n     */\n    orderBy?: shopping_shipping_carriersOrderByWithRelationInput | shopping_shipping_carriersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_shipping_carriers.\n     */\n    cursor?: shopping_shipping_carriersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_carriers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_carriers.\n     */\n    skip?: number\n    distinct?: Shopping_shipping_carriersScalarFieldEnum | Shopping_shipping_carriersScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_carriers create\n   */\n  export type shopping_shipping_carriersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_shipping_carriers.\n     */\n    data: XOR<shopping_shipping_carriersCreateInput, shopping_shipping_carriersUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_shipping_carriers createMany\n   */\n  export type shopping_shipping_carriersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_shipping_carriers.\n     */\n    data: shopping_shipping_carriersCreateManyInput | shopping_shipping_carriersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shipping_carriers createManyAndReturn\n   */\n  export type shopping_shipping_carriersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_shipping_carriers.\n     */\n    data: shopping_shipping_carriersCreateManyInput | shopping_shipping_carriersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shipping_carriers update\n   */\n  export type shopping_shipping_carriersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_shipping_carriers.\n     */\n    data: XOR<shopping_shipping_carriersUpdateInput, shopping_shipping_carriersUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_shipping_carriers to update.\n     */\n    where: shopping_shipping_carriersWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_carriers updateMany\n   */\n  export type shopping_shipping_carriersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_shipping_carriers.\n     */\n    data: XOR<shopping_shipping_carriersUpdateManyMutationInput, shopping_shipping_carriersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_carriers to update\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * Limit how many shopping_shipping_carriers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_carriers updateManyAndReturn\n   */\n  export type shopping_shipping_carriersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_shipping_carriers.\n     */\n    data: XOR<shopping_shipping_carriersUpdateManyMutationInput, shopping_shipping_carriersUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_carriers to update\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * Limit how many shopping_shipping_carriers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_carriers upsert\n   */\n  export type shopping_shipping_carriersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_shipping_carriers to update in case it exists.\n     */\n    where: shopping_shipping_carriersWhereUniqueInput\n    /**\n     * In case the shopping_shipping_carriers found by the `where` argument doesn't exist, create a new shopping_shipping_carriers with this data.\n     */\n    create: XOR<shopping_shipping_carriersCreateInput, shopping_shipping_carriersUncheckedCreateInput>\n    /**\n     * In case the shopping_shipping_carriers was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_shipping_carriersUpdateInput, shopping_shipping_carriersUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_shipping_carriers delete\n   */\n  export type shopping_shipping_carriersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_shipping_carriers to delete.\n     */\n    where: shopping_shipping_carriersWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_carriers deleteMany\n   */\n  export type shopping_shipping_carriersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_carriers to delete\n     */\n    where?: shopping_shipping_carriersWhereInput\n    /**\n     * Limit how many shopping_shipping_carriers to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_carriers.shopping_shipping_tracking\n   */\n  export type shopping_shipping_carriers$shopping_shipping_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    where?: shopping_shipping_trackingWhereInput\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_carriers without action\n   */\n  export type shopping_shipping_carriersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_carriers\n     */\n    select?: shopping_shipping_carriersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_carriers\n     */\n    omit?: shopping_shipping_carriersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_carriersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model shopping_shipping_tracking\n   */\n\n  export type AggregateShopping_shipping_tracking = {\n    _count: Shopping_shipping_trackingCountAggregateOutputType | null\n    _min: Shopping_shipping_trackingMinAggregateOutputType | null\n    _max: Shopping_shipping_trackingMaxAggregateOutputType | null\n  }\n\n  export type Shopping_shipping_trackingMinAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    shopping_shipping_carrier_id: string | null\n    shopping_shipping_method_id: string | null\n    tracking_number: string | null\n    status: string | null\n    estimated_delivery_date: Date | null\n    actual_delivery_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_trackingMaxAggregateOutputType = {\n    id: string | null\n    shopping_order_id: string | null\n    shopping_shipping_carrier_id: string | null\n    shopping_shipping_method_id: string | null\n    tracking_number: string | null\n    status: string | null\n    estimated_delivery_date: Date | null\n    actual_delivery_date: Date | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Shopping_shipping_trackingCountAggregateOutputType = {\n    id: number\n    shopping_order_id: number\n    shopping_shipping_carrier_id: number\n    shopping_shipping_method_id: number\n    tracking_number: number\n    status: number\n    estimated_delivery_date: number\n    actual_delivery_date: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Shopping_shipping_trackingMinAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_shipping_carrier_id?: true\n    shopping_shipping_method_id?: true\n    tracking_number?: true\n    status?: true\n    estimated_delivery_date?: true\n    actual_delivery_date?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_trackingMaxAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_shipping_carrier_id?: true\n    shopping_shipping_method_id?: true\n    tracking_number?: true\n    status?: true\n    estimated_delivery_date?: true\n    actual_delivery_date?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Shopping_shipping_trackingCountAggregateInputType = {\n    id?: true\n    shopping_order_id?: true\n    shopping_shipping_carrier_id?: true\n    shopping_shipping_method_id?: true\n    tracking_number?: true\n    status?: true\n    estimated_delivery_date?: true\n    actual_delivery_date?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Shopping_shipping_trackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_tracking to aggregate.\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_trackings to fetch.\n     */\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_trackings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_trackings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned shopping_shipping_trackings\n    **/\n    _count?: true | Shopping_shipping_trackingCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Shopping_shipping_trackingMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Shopping_shipping_trackingMaxAggregateInputType\n  }\n\n  export type GetShopping_shipping_trackingAggregateType<T extends Shopping_shipping_trackingAggregateArgs> = {\n        [P in keyof T & keyof AggregateShopping_shipping_tracking]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateShopping_shipping_tracking[P]>\n      : GetScalarType<T[P], AggregateShopping_shipping_tracking[P]>\n  }\n\n\n\n\n  export type shopping_shipping_trackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: shopping_shipping_trackingWhereInput\n    orderBy?: shopping_shipping_trackingOrderByWithAggregationInput | shopping_shipping_trackingOrderByWithAggregationInput[]\n    by: Shopping_shipping_trackingScalarFieldEnum[] | Shopping_shipping_trackingScalarFieldEnum\n    having?: shopping_shipping_trackingScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Shopping_shipping_trackingCountAggregateInputType | true\n    _min?: Shopping_shipping_trackingMinAggregateInputType\n    _max?: Shopping_shipping_trackingMaxAggregateInputType\n  }\n\n  export type Shopping_shipping_trackingGroupByOutputType = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_carrier_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date: Date | null\n    actual_delivery_date: Date | null\n    created_at: Date\n    updated_at: Date\n    _count: Shopping_shipping_trackingCountAggregateOutputType | null\n    _min: Shopping_shipping_trackingMinAggregateOutputType | null\n    _max: Shopping_shipping_trackingMaxAggregateOutputType | null\n  }\n\n  type GetShopping_shipping_trackingGroupByPayload<T extends shopping_shipping_trackingGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Shopping_shipping_trackingGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Shopping_shipping_trackingGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Shopping_shipping_trackingGroupByOutputType[P]>\n            : GetScalarType<T[P], Shopping_shipping_trackingGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type shopping_shipping_trackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_shipping_carrier_id?: boolean\n    shopping_shipping_method_id?: boolean\n    tracking_number?: boolean\n    status?: boolean\n    estimated_delivery_date?: boolean\n    actual_delivery_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shipping_tracking\"]>\n\n  export type shopping_shipping_trackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_shipping_carrier_id?: boolean\n    shopping_shipping_method_id?: boolean\n    tracking_number?: boolean\n    status?: boolean\n    estimated_delivery_date?: boolean\n    actual_delivery_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shipping_tracking\"]>\n\n  export type shopping_shipping_trackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_shipping_carrier_id?: boolean\n    shopping_shipping_method_id?: boolean\n    tracking_number?: boolean\n    status?: boolean\n    estimated_delivery_date?: boolean\n    actual_delivery_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"shopping_shipping_tracking\"]>\n\n  export type shopping_shipping_trackingSelectScalar = {\n    id?: boolean\n    shopping_order_id?: boolean\n    shopping_shipping_carrier_id?: boolean\n    shopping_shipping_method_id?: boolean\n    tracking_number?: boolean\n    status?: boolean\n    estimated_delivery_date?: boolean\n    actual_delivery_date?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type shopping_shipping_trackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"shopping_order_id\" | \"shopping_shipping_carrier_id\" | \"shopping_shipping_method_id\" | \"tracking_number\" | \"status\" | \"estimated_delivery_date\" | \"actual_delivery_date\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"shopping_shipping_tracking\"]>\n  export type shopping_shipping_trackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }\n  export type shopping_shipping_trackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }\n  export type shopping_shipping_trackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    order?: boolean | shopping_ordersDefaultArgs<ExtArgs>\n    carrier?: boolean | shopping_shipping_carriersDefaultArgs<ExtArgs>\n    method?: boolean | shopping_shipping_methodsDefaultArgs<ExtArgs>\n  }\n\n  export type $shopping_shipping_trackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"shopping_shipping_tracking\"\n    objects: {\n      order: Prisma.$shopping_ordersPayload<ExtArgs>\n      carrier: Prisma.$shopping_shipping_carriersPayload<ExtArgs>\n      method: Prisma.$shopping_shipping_methodsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The order being tracked. {@link shopping_orders.id}.\n       */\n      shopping_order_id: string\n      /**\n       * The carrier handling the shipment. {@link shopping_shipping_carriers.id}.\n       */\n      shopping_shipping_carrier_id: string\n      /**\n       * The shipping method used for this shipment. {@link\n       * shopping_shipping_methods.id}.\n       */\n      shopping_shipping_method_id: string\n      /**\n       * Tracking number provided by the carrier.\n       */\n      tracking_number: string\n      /**\n       * Current status of the shipment (e.g., Processing, Shipped, Delivered).\n       */\n      status: string\n      /**\n       * Estimated delivery date for the shipment.\n       */\n      estimated_delivery_date: Date | null\n      /**\n       * Actual delivery date when the shipment was delivered.\n       */\n      actual_delivery_date: Date | null\n      /**\n       * Timestamp when the tracking information was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the tracking information was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"shopping_shipping_tracking\"]>\n    composites: {}\n  }\n\n  type shopping_shipping_trackingGetPayload<S extends boolean | null | undefined | shopping_shipping_trackingDefaultArgs> = $Result.GetResult<Prisma.$shopping_shipping_trackingPayload, S>\n\n  type shopping_shipping_trackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<shopping_shipping_trackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Shopping_shipping_trackingCountAggregateInputType | true\n    }\n\n  export interface shopping_shipping_trackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopping_shipping_tracking'], meta: { name: 'shopping_shipping_tracking' } }\n    /**\n     * Find zero or one Shopping_shipping_tracking that matches the filter.\n     * @param {shopping_shipping_trackingFindUniqueArgs} args - Arguments to find a Shopping_shipping_tracking\n     * @example\n     * // Get one Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends shopping_shipping_trackingFindUniqueArgs>(args: SelectSubset<T, shopping_shipping_trackingFindUniqueArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Shopping_shipping_tracking that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {shopping_shipping_trackingFindUniqueOrThrowArgs} args - Arguments to find a Shopping_shipping_tracking\n     * @example\n     * // Get one Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends shopping_shipping_trackingFindUniqueOrThrowArgs>(args: SelectSubset<T, shopping_shipping_trackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_tracking that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingFindFirstArgs} args - Arguments to find a Shopping_shipping_tracking\n     * @example\n     * // Get one Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends shopping_shipping_trackingFindFirstArgs>(args?: SelectSubset<T, shopping_shipping_trackingFindFirstArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Shopping_shipping_tracking that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingFindFirstOrThrowArgs} args - Arguments to find a Shopping_shipping_tracking\n     * @example\n     * // Get one Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends shopping_shipping_trackingFindFirstOrThrowArgs>(args?: SelectSubset<T, shopping_shipping_trackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Shopping_shipping_trackings that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Shopping_shipping_trackings\n     * const shopping_shipping_trackings = await prisma.shopping_shipping_tracking.findMany()\n     * \n     * // Get first 10 Shopping_shipping_trackings\n     * const shopping_shipping_trackings = await prisma.shopping_shipping_tracking.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const shopping_shipping_trackingWithIdOnly = await prisma.shopping_shipping_tracking.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends shopping_shipping_trackingFindManyArgs>(args?: SelectSubset<T, shopping_shipping_trackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Shopping_shipping_tracking.\n     * @param {shopping_shipping_trackingCreateArgs} args - Arguments to create a Shopping_shipping_tracking.\n     * @example\n     * // Create one Shopping_shipping_tracking\n     * const Shopping_shipping_tracking = await prisma.shopping_shipping_tracking.create({\n     *   data: {\n     *     // ... data to create a Shopping_shipping_tracking\n     *   }\n     * })\n     * \n     */\n    create<T extends shopping_shipping_trackingCreateArgs>(args: SelectSubset<T, shopping_shipping_trackingCreateArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Shopping_shipping_trackings.\n     * @param {shopping_shipping_trackingCreateManyArgs} args - Arguments to create many Shopping_shipping_trackings.\n     * @example\n     * // Create many Shopping_shipping_trackings\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends shopping_shipping_trackingCreateManyArgs>(args?: SelectSubset<T, shopping_shipping_trackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Shopping_shipping_trackings and returns the data saved in the database.\n     * @param {shopping_shipping_trackingCreateManyAndReturnArgs} args - Arguments to create many Shopping_shipping_trackings.\n     * @example\n     * // Create many Shopping_shipping_trackings\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Shopping_shipping_trackings and only return the `id`\n     * const shopping_shipping_trackingWithIdOnly = await prisma.shopping_shipping_tracking.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends shopping_shipping_trackingCreateManyAndReturnArgs>(args?: SelectSubset<T, shopping_shipping_trackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Shopping_shipping_tracking.\n     * @param {shopping_shipping_trackingDeleteArgs} args - Arguments to delete one Shopping_shipping_tracking.\n     * @example\n     * // Delete one Shopping_shipping_tracking\n     * const Shopping_shipping_tracking = await prisma.shopping_shipping_tracking.delete({\n     *   where: {\n     *     // ... filter to delete one Shopping_shipping_tracking\n     *   }\n     * })\n     * \n     */\n    delete<T extends shopping_shipping_trackingDeleteArgs>(args: SelectSubset<T, shopping_shipping_trackingDeleteArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Shopping_shipping_tracking.\n     * @param {shopping_shipping_trackingUpdateArgs} args - Arguments to update one Shopping_shipping_tracking.\n     * @example\n     * // Update one Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends shopping_shipping_trackingUpdateArgs>(args: SelectSubset<T, shopping_shipping_trackingUpdateArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Shopping_shipping_trackings.\n     * @param {shopping_shipping_trackingDeleteManyArgs} args - Arguments to filter Shopping_shipping_trackings to delete.\n     * @example\n     * // Delete a few Shopping_shipping_trackings\n     * const { count } = await prisma.shopping_shipping_tracking.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends shopping_shipping_trackingDeleteManyArgs>(args?: SelectSubset<T, shopping_shipping_trackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_trackings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Shopping_shipping_trackings\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends shopping_shipping_trackingUpdateManyArgs>(args: SelectSubset<T, shopping_shipping_trackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Shopping_shipping_trackings and returns the data updated in the database.\n     * @param {shopping_shipping_trackingUpdateManyAndReturnArgs} args - Arguments to update many Shopping_shipping_trackings.\n     * @example\n     * // Update many Shopping_shipping_trackings\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Shopping_shipping_trackings and only return the `id`\n     * const shopping_shipping_trackingWithIdOnly = await prisma.shopping_shipping_tracking.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends shopping_shipping_trackingUpdateManyAndReturnArgs>(args: SelectSubset<T, shopping_shipping_trackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Shopping_shipping_tracking.\n     * @param {shopping_shipping_trackingUpsertArgs} args - Arguments to update or create a Shopping_shipping_tracking.\n     * @example\n     * // Update or create a Shopping_shipping_tracking\n     * const shopping_shipping_tracking = await prisma.shopping_shipping_tracking.upsert({\n     *   create: {\n     *     // ... data to create a Shopping_shipping_tracking\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_tracking we want to update\n     *   }\n     * })\n     */\n    upsert<T extends shopping_shipping_trackingUpsertArgs>(args: SelectSubset<T, shopping_shipping_trackingUpsertArgs<ExtArgs>>): Prisma__shopping_shipping_trackingClient<$Result.GetResult<Prisma.$shopping_shipping_trackingPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Shopping_shipping_trackings.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingCountArgs} args - Arguments to filter Shopping_shipping_trackings to count.\n     * @example\n     * // Count the number of Shopping_shipping_trackings\n     * const count = await prisma.shopping_shipping_tracking.count({\n     *   where: {\n     *     // ... the filter for the Shopping_shipping_trackings we want to count\n     *   }\n     * })\n    **/\n    count<T extends shopping_shipping_trackingCountArgs>(\n      args?: Subset<T, shopping_shipping_trackingCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Shopping_shipping_trackingCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Shopping_shipping_tracking.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Shopping_shipping_trackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Shopping_shipping_trackingAggregateArgs>(args: Subset<T, Shopping_shipping_trackingAggregateArgs>): Prisma.PrismaPromise<GetShopping_shipping_trackingAggregateType<T>>\n\n    /**\n     * Group by Shopping_shipping_tracking.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {shopping_shipping_trackingGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends shopping_shipping_trackingGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: shopping_shipping_trackingGroupByArgs['orderBy'] }\n        : { orderBy?: shopping_shipping_trackingGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, shopping_shipping_trackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_shipping_trackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the shopping_shipping_tracking model\n   */\n  readonly fields: shopping_shipping_trackingFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for shopping_shipping_tracking.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__shopping_shipping_trackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    order<T extends shopping_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_ordersDefaultArgs<ExtArgs>>): Prisma__shopping_ordersClient<$Result.GetResult<Prisma.$shopping_ordersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    carrier<T extends shopping_shipping_carriersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shipping_carriersDefaultArgs<ExtArgs>>): Prisma__shopping_shipping_carriersClient<$Result.GetResult<Prisma.$shopping_shipping_carriersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    method<T extends shopping_shipping_methodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shopping_shipping_methodsDefaultArgs<ExtArgs>>): Prisma__shopping_shipping_methodsClient<$Result.GetResult<Prisma.$shopping_shipping_methodsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the shopping_shipping_tracking model\n   */\n  interface shopping_shipping_trackingFieldRefs {\n    readonly id: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly shopping_order_id: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly shopping_shipping_carrier_id: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly shopping_shipping_method_id: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly tracking_number: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly status: FieldRef<\"shopping_shipping_tracking\", 'String'>\n    readonly estimated_delivery_date: FieldRef<\"shopping_shipping_tracking\", 'DateTime'>\n    readonly actual_delivery_date: FieldRef<\"shopping_shipping_tracking\", 'DateTime'>\n    readonly created_at: FieldRef<\"shopping_shipping_tracking\", 'DateTime'>\n    readonly updated_at: FieldRef<\"shopping_shipping_tracking\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * shopping_shipping_tracking findUnique\n   */\n  export type shopping_shipping_trackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_tracking to fetch.\n     */\n    where: shopping_shipping_trackingWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_tracking findUniqueOrThrow\n   */\n  export type shopping_shipping_trackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_tracking to fetch.\n     */\n    where: shopping_shipping_trackingWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_tracking findFirst\n   */\n  export type shopping_shipping_trackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_tracking to fetch.\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_trackings to fetch.\n     */\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_trackings.\n     */\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_trackings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_trackings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_trackings.\n     */\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_tracking findFirstOrThrow\n   */\n  export type shopping_shipping_trackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_tracking to fetch.\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_trackings to fetch.\n     */\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for shopping_shipping_trackings.\n     */\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_trackings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_trackings.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of shopping_shipping_trackings.\n     */\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_tracking findMany\n   */\n  export type shopping_shipping_trackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter, which shopping_shipping_trackings to fetch.\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of shopping_shipping_trackings to fetch.\n     */\n    orderBy?: shopping_shipping_trackingOrderByWithRelationInput | shopping_shipping_trackingOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing shopping_shipping_trackings.\n     */\n    cursor?: shopping_shipping_trackingWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` shopping_shipping_trackings from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` shopping_shipping_trackings.\n     */\n    skip?: number\n    distinct?: Shopping_shipping_trackingScalarFieldEnum | Shopping_shipping_trackingScalarFieldEnum[]\n  }\n\n  /**\n   * shopping_shipping_tracking create\n   */\n  export type shopping_shipping_trackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * The data needed to create a shopping_shipping_tracking.\n     */\n    data: XOR<shopping_shipping_trackingCreateInput, shopping_shipping_trackingUncheckedCreateInput>\n  }\n\n  /**\n   * shopping_shipping_tracking createMany\n   */\n  export type shopping_shipping_trackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many shopping_shipping_trackings.\n     */\n    data: shopping_shipping_trackingCreateManyInput | shopping_shipping_trackingCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * shopping_shipping_tracking createManyAndReturn\n   */\n  export type shopping_shipping_trackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * The data used to create many shopping_shipping_trackings.\n     */\n    data: shopping_shipping_trackingCreateManyInput | shopping_shipping_trackingCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_shipping_tracking update\n   */\n  export type shopping_shipping_trackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * The data needed to update a shopping_shipping_tracking.\n     */\n    data: XOR<shopping_shipping_trackingUpdateInput, shopping_shipping_trackingUncheckedUpdateInput>\n    /**\n     * Choose, which shopping_shipping_tracking to update.\n     */\n    where: shopping_shipping_trackingWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_tracking updateMany\n   */\n  export type shopping_shipping_trackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update shopping_shipping_trackings.\n     */\n    data: XOR<shopping_shipping_trackingUpdateManyMutationInput, shopping_shipping_trackingUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_trackings to update\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * Limit how many shopping_shipping_trackings to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_tracking updateManyAndReturn\n   */\n  export type shopping_shipping_trackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * The data used to update shopping_shipping_trackings.\n     */\n    data: XOR<shopping_shipping_trackingUpdateManyMutationInput, shopping_shipping_trackingUncheckedUpdateManyInput>\n    /**\n     * Filter which shopping_shipping_trackings to update\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * Limit how many shopping_shipping_trackings to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * shopping_shipping_tracking upsert\n   */\n  export type shopping_shipping_trackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * The filter to search for the shopping_shipping_tracking to update in case it exists.\n     */\n    where: shopping_shipping_trackingWhereUniqueInput\n    /**\n     * In case the shopping_shipping_tracking found by the `where` argument doesn't exist, create a new shopping_shipping_tracking with this data.\n     */\n    create: XOR<shopping_shipping_trackingCreateInput, shopping_shipping_trackingUncheckedCreateInput>\n    /**\n     * In case the shopping_shipping_tracking was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<shopping_shipping_trackingUpdateInput, shopping_shipping_trackingUncheckedUpdateInput>\n  }\n\n  /**\n   * shopping_shipping_tracking delete\n   */\n  export type shopping_shipping_trackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n    /**\n     * Filter which shopping_shipping_tracking to delete.\n     */\n    where: shopping_shipping_trackingWhereUniqueInput\n  }\n\n  /**\n   * shopping_shipping_tracking deleteMany\n   */\n  export type shopping_shipping_trackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which shopping_shipping_trackings to delete\n     */\n    where?: shopping_shipping_trackingWhereInput\n    /**\n     * Limit how many shopping_shipping_trackings to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * shopping_shipping_tracking without action\n   */\n  export type shopping_shipping_trackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the shopping_shipping_tracking\n     */\n    select?: shopping_shipping_trackingSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the shopping_shipping_tracking\n     */\n    omit?: shopping_shipping_trackingOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: shopping_shipping_trackingInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Shopping_channelsScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_channelsScalarFieldEnum = (typeof Shopping_channelsScalarFieldEnum)[keyof typeof Shopping_channelsScalarFieldEnum]\n\n\n  export const Shopping_sectionsScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_sectionsScalarFieldEnum = (typeof Shopping_sectionsScalarFieldEnum)[keyof typeof Shopping_sectionsScalarFieldEnum]\n\n\n  export const Shopping_channel_categoriesScalarFieldEnum: {\n    id: 'id',\n    shopping_channel_id: 'shopping_channel_id',\n    shopping_section_id: 'shopping_section_id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_channel_categoriesScalarFieldEnum = (typeof Shopping_channel_categoriesScalarFieldEnum)[keyof typeof Shopping_channel_categoriesScalarFieldEnum]\n\n\n  export const Shopping_customersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    phone: 'phone',\n    address: 'address'\n  };\n\n  export type Shopping_customersScalarFieldEnum = (typeof Shopping_customersScalarFieldEnum)[keyof typeof Shopping_customersScalarFieldEnum]\n\n\n  export const Shopping_sellersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    business_name: 'business_name',\n    contact_name: 'contact_name',\n    phone: 'phone',\n    address: 'address',\n    tax_id: 'tax_id'\n  };\n\n  export type Shopping_sellersScalarFieldEnum = (typeof Shopping_sellersScalarFieldEnum)[keyof typeof Shopping_sellersScalarFieldEnum]\n\n\n  export const Shopping_administratorsScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    name: 'name',\n    phone: 'phone',\n    role: 'role'\n  };\n\n  export type Shopping_administratorsScalarFieldEnum = (typeof Shopping_administratorsScalarFieldEnum)[keyof typeof Shopping_administratorsScalarFieldEnum]\n\n\n  export const Shopping_productsScalarFieldEnum: {\n    id: 'id',\n    shopping_category_id: 'shopping_category_id',\n    name: 'name',\n    description: 'description',\n    price: 'price',\n    sku: 'sku',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    password_hash: 'password_hash',\n    business_status: 'business_status'\n  };\n\n  export type Shopping_productsScalarFieldEnum = (typeof Shopping_productsScalarFieldEnum)[keyof typeof Shopping_productsScalarFieldEnum]\n\n\n  export const Shopping_product_variantsScalarFieldEnum: {\n    id: 'id',\n    shopping_product_id: 'shopping_product_id',\n    sku: 'sku',\n    option_name: 'option_name',\n    option_value: 'option_value',\n    price_adjustment: 'price_adjustment',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    business_status: 'business_status'\n  };\n\n  export type Shopping_product_variantsScalarFieldEnum = (typeof Shopping_product_variantsScalarFieldEnum)[keyof typeof Shopping_product_variantsScalarFieldEnum]\n\n\n  export const Shopping_categoriesScalarFieldEnum: {\n    id: 'id',\n    parent_id: 'parent_id',\n    name: 'name',\n    description: 'description',\n    code: 'code',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    business_status: 'business_status'\n  };\n\n  export type Shopping_categoriesScalarFieldEnum = (typeof Shopping_categoriesScalarFieldEnum)[keyof typeof Shopping_categoriesScalarFieldEnum]\n\n\n  export const Shopping_inventoryScalarFieldEnum: {\n    id: 'id',\n    shopping_product_variant_id: 'shopping_product_variant_id',\n    shopping_product_id: 'shopping_product_id',\n    quantity: 'quantity',\n    reserved_quantity: 'reserved_quantity',\n    low_stock_threshold: 'low_stock_threshold',\n    last_stock_update: 'last_stock_update',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    business_status: 'business_status'\n  };\n\n  export type Shopping_inventoryScalarFieldEnum = (typeof Shopping_inventoryScalarFieldEnum)[keyof typeof Shopping_inventoryScalarFieldEnum]\n\n\n  export const Shopping_product_reviewsScalarFieldEnum: {\n    id: 'id',\n    shopping_product_id: 'shopping_product_id',\n    shopping_customer_id: 'shopping_customer_id',\n    rating: 'rating',\n    title: 'title',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    business_status: 'business_status'\n  };\n\n  export type Shopping_product_reviewsScalarFieldEnum = (typeof Shopping_product_reviewsScalarFieldEnum)[keyof typeof Shopping_product_reviewsScalarFieldEnum]\n\n\n  export const Shopping_ordersScalarFieldEnum: {\n    id: 'id',\n    shopping_customer_id: 'shopping_customer_id',\n    order_code: 'order_code',\n    total_amount: 'total_amount',\n    currency: 'currency',\n    status: 'status',\n    payment_method: 'payment_method',\n    shipping_method: 'shipping_method',\n    shipping_address: 'shipping_address',\n    billing_address: 'billing_address',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_ordersScalarFieldEnum = (typeof Shopping_ordersScalarFieldEnum)[keyof typeof Shopping_ordersScalarFieldEnum]\n\n\n  export const Shopping_order_itemsScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    shopping_product_variant_id: 'shopping_product_variant_id',\n    quantity: 'quantity',\n    unit_price: 'unit_price',\n    total_price: 'total_price',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_order_itemsScalarFieldEnum = (typeof Shopping_order_itemsScalarFieldEnum)[keyof typeof Shopping_order_itemsScalarFieldEnum]\n\n\n  export const Shopping_order_statusScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    status: 'status',\n    changed_at: 'changed_at',\n    changed_by: 'changed_by',\n    notes: 'notes'\n  };\n\n  export type Shopping_order_statusScalarFieldEnum = (typeof Shopping_order_statusScalarFieldEnum)[keyof typeof Shopping_order_statusScalarFieldEnum]\n\n\n  export const Shopping_order_historyScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    action: 'action',\n    changed_at: 'changed_at',\n    changed_by: 'changed_by',\n    details: 'details'\n  };\n\n  export type Shopping_order_historyScalarFieldEnum = (typeof Shopping_order_historyScalarFieldEnum)[keyof typeof Shopping_order_historyScalarFieldEnum]\n\n\n  export const Shopping_shopping_cartsScalarFieldEnum: {\n    id: 'id',\n    shopping_customer_id: 'shopping_customer_id',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_shopping_cartsScalarFieldEnum = (typeof Shopping_shopping_cartsScalarFieldEnum)[keyof typeof Shopping_shopping_cartsScalarFieldEnum]\n\n\n  export const Shopping_cart_itemsScalarFieldEnum: {\n    id: 'id',\n    shopping_shopping_cart_id: 'shopping_shopping_cart_id',\n    shopping_product_variant_id: 'shopping_product_variant_id',\n    quantity: 'quantity',\n    price: 'price',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_cart_itemsScalarFieldEnum = (typeof Shopping_cart_itemsScalarFieldEnum)[keyof typeof Shopping_cart_itemsScalarFieldEnum]\n\n\n  export const Shopping_review_moderationScalarFieldEnum: {\n    id: 'id',\n    shopping_product_review_id: 'shopping_product_review_id',\n    shopping_administrator_id: 'shopping_administrator_id',\n    action_type: 'action_type',\n    reason: 'reason',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_review_moderationScalarFieldEnum = (typeof Shopping_review_moderationScalarFieldEnum)[keyof typeof Shopping_review_moderationScalarFieldEnum]\n\n\n  export const Shopping_review_ratingsScalarFieldEnum: {\n    id: 'id',\n    shopping_product_review_id: 'shopping_product_review_id',\n    quality_rating: 'quality_rating',\n    value_rating: 'value_rating',\n    service_rating: 'service_rating',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_review_ratingsScalarFieldEnum = (typeof Shopping_review_ratingsScalarFieldEnum)[keyof typeof Shopping_review_ratingsScalarFieldEnum]\n\n\n  export const Shopping_seller_productsScalarFieldEnum: {\n    id: 'id',\n    shopping_seller_id: 'shopping_seller_id',\n    shopping_product_id: 'shopping_product_id',\n    seller_product_code: 'seller_product_code',\n    price: 'price',\n    quantity_available: 'quantity_available',\n    status: 'status',\n    business_status: 'business_status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_seller_productsScalarFieldEnum = (typeof Shopping_seller_productsScalarFieldEnum)[keyof typeof Shopping_seller_productsScalarFieldEnum]\n\n\n  export const Shopping_seller_inventoryScalarFieldEnum: {\n    id: 'id',\n    shopping_seller_product_id: 'shopping_seller_product_id',\n    shopping_product_variant_id: 'shopping_product_variant_id',\n    stock_quantity: 'stock_quantity',\n    low_stock_threshold: 'low_stock_threshold',\n    status: 'status',\n    business_status: 'business_status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_seller_inventoryScalarFieldEnum = (typeof Shopping_seller_inventoryScalarFieldEnum)[keyof typeof Shopping_seller_inventoryScalarFieldEnum]\n\n\n  export const Shopping_seller_ordersScalarFieldEnum: {\n    id: 'id',\n    shopping_seller_id: 'shopping_seller_id',\n    shopping_order_id: 'shopping_order_id',\n    seller_order_code: 'seller_order_code',\n    fulfillment_status: 'fulfillment_status',\n    business_status: 'business_status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_seller_ordersScalarFieldEnum = (typeof Shopping_seller_ordersScalarFieldEnum)[keyof typeof Shopping_seller_ordersScalarFieldEnum]\n\n\n  export const Shopping_admin_actionsScalarFieldEnum: {\n    id: 'id',\n    shopping_administrator_id: 'shopping_administrator_id',\n    action_type: 'action_type',\n    description: 'description',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_admin_actionsScalarFieldEnum = (typeof Shopping_admin_actionsScalarFieldEnum)[keyof typeof Shopping_admin_actionsScalarFieldEnum]\n\n\n  export const Shopping_admin_logsScalarFieldEnum: {\n    id: 'id',\n    shopping_administrator_id: 'shopping_administrator_id',\n    log_type: 'log_type',\n    message: 'message',\n    created_at: 'created_at'\n  };\n\n  export type Shopping_admin_logsScalarFieldEnum = (typeof Shopping_admin_logsScalarFieldEnum)[keyof typeof Shopping_admin_logsScalarFieldEnum]\n\n\n  export const Shopping_paymentsScalarFieldEnum: {\n    id: 'id',\n    shopping_customer_id: 'shopping_customer_id',\n    shopping_order_id: 'shopping_order_id',\n    payment_method_id: 'payment_method_id',\n    amount: 'amount',\n    currency: 'currency',\n    status: 'status',\n    transaction_id: 'transaction_id',\n    payment_date: 'payment_date',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_paymentsScalarFieldEnum = (typeof Shopping_paymentsScalarFieldEnum)[keyof typeof Shopping_paymentsScalarFieldEnum]\n\n\n  export const Shopping_payment_methodsScalarFieldEnum: {\n    id: 'id',\n    method_name: 'method_name',\n    method_type: 'method_type',\n    provider: 'provider',\n    is_active: 'is_active',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_payment_methodsScalarFieldEnum = (typeof Shopping_payment_methodsScalarFieldEnum)[keyof typeof Shopping_payment_methodsScalarFieldEnum]\n\n\n  export const Shopping_payment_transactionsScalarFieldEnum: {\n    id: 'id',\n    shopping_payment_id: 'shopping_payment_id',\n    transaction_type: 'transaction_type',\n    amount: 'amount',\n    currency: 'currency',\n    status: 'status',\n    gateway_response: 'gateway_response',\n    transaction_date: 'transaction_date',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Shopping_payment_transactionsScalarFieldEnum = (typeof Shopping_payment_transactionsScalarFieldEnum)[keyof typeof Shopping_payment_transactionsScalarFieldEnum]\n\n\n  export const Shopping_shipping_methodsScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description',\n    cost: 'cost',\n    estimated_delivery_days: 'estimated_delivery_days',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_shipping_methodsScalarFieldEnum = (typeof Shopping_shipping_methodsScalarFieldEnum)[keyof typeof Shopping_shipping_methodsScalarFieldEnum]\n\n\n  export const Shopping_shipping_carriersScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description',\n    tracking_url_template: 'tracking_url_template',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_shipping_carriersScalarFieldEnum = (typeof Shopping_shipping_carriersScalarFieldEnum)[keyof typeof Shopping_shipping_carriersScalarFieldEnum]\n\n\n  export const Shopping_shipping_trackingScalarFieldEnum: {\n    id: 'id',\n    shopping_order_id: 'shopping_order_id',\n    shopping_shipping_carrier_id: 'shopping_shipping_carrier_id',\n    shopping_shipping_method_id: 'shopping_shipping_method_id',\n    tracking_number: 'tracking_number',\n    status: 'status',\n    estimated_delivery_date: 'estimated_delivery_date',\n    actual_delivery_date: 'actual_delivery_date',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Shopping_shipping_trackingScalarFieldEnum = (typeof Shopping_shipping_trackingScalarFieldEnum)[keyof typeof Shopping_shipping_trackingScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type shopping_channelsWhereInput = {\n    AND?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    OR?: shopping_channelsWhereInput[]\n    NOT?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    id?: UuidFilter<\"shopping_channels\"> | string\n    name?: StringFilter<\"shopping_channels\"> | string\n    description?: StringNullableFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channels\"> | Date | string | null\n    shopping_sections?: Shopping_sectionsListRelationFilter\n    shopping_channel_categories?: Shopping_channel_categoriesListRelationFilter\n  }\n\n  export type shopping_channelsOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    shopping_sections?: shopping_sectionsOrderByRelationAggregateInput\n    shopping_channel_categories?: shopping_channel_categoriesOrderByRelationAggregateInput\n  }\n\n  export type shopping_channelsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    OR?: shopping_channelsWhereInput[]\n    NOT?: shopping_channelsWhereInput | shopping_channelsWhereInput[]\n    description?: StringNullableFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channels\"> | Date | string | null\n    shopping_sections?: Shopping_sectionsListRelationFilter\n    shopping_channel_categories?: Shopping_channel_categoriesListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type shopping_channelsOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_channelsCountOrderByAggregateInput\n    _max?: shopping_channelsMaxOrderByAggregateInput\n    _min?: shopping_channelsMinOrderByAggregateInput\n  }\n\n  export type shopping_channelsScalarWhereWithAggregatesInput = {\n    AND?: shopping_channelsScalarWhereWithAggregatesInput | shopping_channelsScalarWhereWithAggregatesInput[]\n    OR?: shopping_channelsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_channelsScalarWhereWithAggregatesInput | shopping_channelsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_channels\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_channels\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_channels\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_channels\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_channels\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_channels\"> | Date | string | null\n  }\n\n  export type shopping_sectionsWhereInput = {\n    AND?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    OR?: shopping_sectionsWhereInput[]\n    NOT?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    id?: UuidFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    shopping_channel_categories?: Shopping_channel_categoriesListRelationFilter\n  }\n\n  export type shopping_sectionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    shopping_channel_categories?: shopping_channel_categoriesOrderByRelationAggregateInput\n  }\n\n  export type shopping_sectionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_channel_id_name?: shopping_sectionsShopping_channel_idNameCompoundUniqueInput\n    AND?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    OR?: shopping_sectionsWhereInput[]\n    NOT?: shopping_sectionsWhereInput | shopping_sectionsWhereInput[]\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    shopping_channel_categories?: Shopping_channel_categoriesListRelationFilter\n  }, \"id\" | \"shopping_channel_id_name\">\n\n  export type shopping_sectionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_sectionsCountOrderByAggregateInput\n    _max?: shopping_sectionsMaxOrderByAggregateInput\n    _min?: shopping_sectionsMinOrderByAggregateInput\n  }\n\n  export type shopping_sectionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_sectionsScalarWhereWithAggregatesInput | shopping_sectionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_sectionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sectionsScalarWhereWithAggregatesInput | shopping_sectionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidWithAggregatesFilter<\"shopping_sections\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_sections\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_sections\"> | Date | string | null\n  }\n\n  export type shopping_channel_categoriesWhereInput = {\n    AND?: shopping_channel_categoriesWhereInput | shopping_channel_categoriesWhereInput[]\n    OR?: shopping_channel_categoriesWhereInput[]\n    NOT?: shopping_channel_categoriesWhereInput | shopping_channel_categoriesWhereInput[]\n    id?: UuidFilter<\"shopping_channel_categories\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    name?: StringFilter<\"shopping_channel_categories\"> | string\n    description?: StringNullableFilter<\"shopping_channel_categories\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channel_categories\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n  }\n\n  export type shopping_channel_categoriesOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    channel?: shopping_channelsOrderByWithRelationInput\n    section?: shopping_sectionsOrderByWithRelationInput\n  }\n\n  export type shopping_channel_categoriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_channel_id_shopping_section_id_name?: shopping_channel_categoriesShopping_channel_idShopping_section_idNameCompoundUniqueInput\n    AND?: shopping_channel_categoriesWhereInput | shopping_channel_categoriesWhereInput[]\n    OR?: shopping_channel_categoriesWhereInput[]\n    NOT?: shopping_channel_categoriesWhereInput | shopping_channel_categoriesWhereInput[]\n    shopping_channel_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    name?: StringFilter<\"shopping_channel_categories\"> | string\n    description?: StringNullableFilter<\"shopping_channel_categories\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channel_categories\"> | Date | string | null\n    channel?: XOR<Shopping_channelsScalarRelationFilter, shopping_channelsWhereInput>\n    section?: XOR<Shopping_sectionsScalarRelationFilter, shopping_sectionsWhereInput>\n  }, \"id\" | \"shopping_channel_id_shopping_section_id_name\">\n\n  export type shopping_channel_categoriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_channel_categoriesCountOrderByAggregateInput\n    _max?: shopping_channel_categoriesMaxOrderByAggregateInput\n    _min?: shopping_channel_categoriesMinOrderByAggregateInput\n  }\n\n  export type shopping_channel_categoriesScalarWhereWithAggregatesInput = {\n    AND?: shopping_channel_categoriesScalarWhereWithAggregatesInput | shopping_channel_categoriesScalarWhereWithAggregatesInput[]\n    OR?: shopping_channel_categoriesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_channel_categoriesScalarWhereWithAggregatesInput | shopping_channel_categoriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_channel_categories\"> | string\n    shopping_channel_id?: UuidWithAggregatesFilter<\"shopping_channel_categories\"> | string\n    shopping_section_id?: UuidWithAggregatesFilter<\"shopping_channel_categories\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_channel_categories\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_channel_categories\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_channel_categories\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_channel_categories\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_channel_categories\"> | Date | string | null\n  }\n\n  export type shopping_customersWhereInput = {\n    AND?: shopping_customersWhereInput | shopping_customersWhereInput[]\n    OR?: shopping_customersWhereInput[]\n    NOT?: shopping_customersWhereInput | shopping_customersWhereInput[]\n    id?: UuidFilter<\"shopping_customers\"> | string\n    email?: StringFilter<\"shopping_customers\"> | string\n    password_hash?: StringFilter<\"shopping_customers\"> | string\n    name?: StringFilter<\"shopping_customers\"> | string\n    phone?: StringNullableFilter<\"shopping_customers\"> | string | null\n    address?: StringNullableFilter<\"shopping_customers\"> | string | null\n    shopping_product_reviews?: Shopping_product_reviewsListRelationFilter\n    shopping_orders?: Shopping_ordersListRelationFilter\n    shopping_shopping_carts?: Shopping_shopping_cartsListRelationFilter\n    shopping_payments?: Shopping_paymentsListRelationFilter\n  }\n\n  export type shopping_customersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    shopping_product_reviews?: shopping_product_reviewsOrderByRelationAggregateInput\n    shopping_orders?: shopping_ordersOrderByRelationAggregateInput\n    shopping_shopping_carts?: shopping_shopping_cartsOrderByRelationAggregateInput\n    shopping_payments?: shopping_paymentsOrderByRelationAggregateInput\n  }\n\n  export type shopping_customersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: shopping_customersWhereInput | shopping_customersWhereInput[]\n    OR?: shopping_customersWhereInput[]\n    NOT?: shopping_customersWhereInput | shopping_customersWhereInput[]\n    password_hash?: StringFilter<\"shopping_customers\"> | string\n    name?: StringFilter<\"shopping_customers\"> | string\n    phone?: StringNullableFilter<\"shopping_customers\"> | string | null\n    address?: StringNullableFilter<\"shopping_customers\"> | string | null\n    shopping_product_reviews?: Shopping_product_reviewsListRelationFilter\n    shopping_orders?: Shopping_ordersListRelationFilter\n    shopping_shopping_carts?: Shopping_shopping_cartsListRelationFilter\n    shopping_payments?: Shopping_paymentsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type shopping_customersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    _count?: shopping_customersCountOrderByAggregateInput\n    _max?: shopping_customersMaxOrderByAggregateInput\n    _min?: shopping_customersMinOrderByAggregateInput\n  }\n\n  export type shopping_customersScalarWhereWithAggregatesInput = {\n    AND?: shopping_customersScalarWhereWithAggregatesInput | shopping_customersScalarWhereWithAggregatesInput[]\n    OR?: shopping_customersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_customersScalarWhereWithAggregatesInput | shopping_customersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_customers\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_customers\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_customers\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_customers\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_customers\"> | string | null\n    address?: StringNullableWithAggregatesFilter<\"shopping_customers\"> | string | null\n  }\n\n  export type shopping_sellersWhereInput = {\n    AND?: shopping_sellersWhereInput | shopping_sellersWhereInput[]\n    OR?: shopping_sellersWhereInput[]\n    NOT?: shopping_sellersWhereInput | shopping_sellersWhereInput[]\n    id?: UuidFilter<\"shopping_sellers\"> | string\n    email?: StringFilter<\"shopping_sellers\"> | string\n    password_hash?: StringFilter<\"shopping_sellers\"> | string\n    business_name?: StringFilter<\"shopping_sellers\"> | string\n    contact_name?: StringFilter<\"shopping_sellers\"> | string\n    phone?: StringNullableFilter<\"shopping_sellers\"> | string | null\n    address?: StringNullableFilter<\"shopping_sellers\"> | string | null\n    tax_id?: StringNullableFilter<\"shopping_sellers\"> | string | null\n    shopping_seller_products?: Shopping_seller_productsListRelationFilter\n    shopping_seller_orders?: Shopping_seller_ordersListRelationFilter\n  }\n\n  export type shopping_sellersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    business_name?: SortOrder\n    contact_name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    tax_id?: SortOrderInput | SortOrder\n    shopping_seller_products?: shopping_seller_productsOrderByRelationAggregateInput\n    shopping_seller_orders?: shopping_seller_ordersOrderByRelationAggregateInput\n  }\n\n  export type shopping_sellersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    tax_id?: string\n    AND?: shopping_sellersWhereInput | shopping_sellersWhereInput[]\n    OR?: shopping_sellersWhereInput[]\n    NOT?: shopping_sellersWhereInput | shopping_sellersWhereInput[]\n    password_hash?: StringFilter<\"shopping_sellers\"> | string\n    business_name?: StringFilter<\"shopping_sellers\"> | string\n    contact_name?: StringFilter<\"shopping_sellers\"> | string\n    phone?: StringNullableFilter<\"shopping_sellers\"> | string | null\n    address?: StringNullableFilter<\"shopping_sellers\"> | string | null\n    shopping_seller_products?: Shopping_seller_productsListRelationFilter\n    shopping_seller_orders?: Shopping_seller_ordersListRelationFilter\n  }, \"id\" | \"email\" | \"tax_id\">\n\n  export type shopping_sellersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    business_name?: SortOrder\n    contact_name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    address?: SortOrderInput | SortOrder\n    tax_id?: SortOrderInput | SortOrder\n    _count?: shopping_sellersCountOrderByAggregateInput\n    _max?: shopping_sellersMaxOrderByAggregateInput\n    _min?: shopping_sellersMinOrderByAggregateInput\n  }\n\n  export type shopping_sellersScalarWhereWithAggregatesInput = {\n    AND?: shopping_sellersScalarWhereWithAggregatesInput | shopping_sellersScalarWhereWithAggregatesInput[]\n    OR?: shopping_sellersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_sellersScalarWhereWithAggregatesInput | shopping_sellersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_sellers\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_sellers\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_sellers\"> | string\n    business_name?: StringWithAggregatesFilter<\"shopping_sellers\"> | string\n    contact_name?: StringWithAggregatesFilter<\"shopping_sellers\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_sellers\"> | string | null\n    address?: StringNullableWithAggregatesFilter<\"shopping_sellers\"> | string | null\n    tax_id?: StringNullableWithAggregatesFilter<\"shopping_sellers\"> | string | null\n  }\n\n  export type shopping_administratorsWhereInput = {\n    AND?: shopping_administratorsWhereInput | shopping_administratorsWhereInput[]\n    OR?: shopping_administratorsWhereInput[]\n    NOT?: shopping_administratorsWhereInput | shopping_administratorsWhereInput[]\n    id?: UuidFilter<\"shopping_administrators\"> | string\n    email?: StringFilter<\"shopping_administrators\"> | string\n    password_hash?: StringFilter<\"shopping_administrators\"> | string\n    name?: StringFilter<\"shopping_administrators\"> | string\n    phone?: StringNullableFilter<\"shopping_administrators\"> | string | null\n    role?: StringFilter<\"shopping_administrators\"> | string\n    shopping_review_moderation?: Shopping_review_moderationListRelationFilter\n    shopping_admin_actions?: Shopping_admin_actionsListRelationFilter\n    shopping_admin_logs?: Shopping_admin_logsListRelationFilter\n  }\n\n  export type shopping_administratorsOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    role?: SortOrder\n    shopping_review_moderation?: shopping_review_moderationOrderByRelationAggregateInput\n    shopping_admin_actions?: shopping_admin_actionsOrderByRelationAggregateInput\n    shopping_admin_logs?: shopping_admin_logsOrderByRelationAggregateInput\n  }\n\n  export type shopping_administratorsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: shopping_administratorsWhereInput | shopping_administratorsWhereInput[]\n    OR?: shopping_administratorsWhereInput[]\n    NOT?: shopping_administratorsWhereInput | shopping_administratorsWhereInput[]\n    password_hash?: StringFilter<\"shopping_administrators\"> | string\n    name?: StringFilter<\"shopping_administrators\"> | string\n    phone?: StringNullableFilter<\"shopping_administrators\"> | string | null\n    role?: StringFilter<\"shopping_administrators\"> | string\n    shopping_review_moderation?: Shopping_review_moderationListRelationFilter\n    shopping_admin_actions?: Shopping_admin_actionsListRelationFilter\n    shopping_admin_logs?: Shopping_admin_logsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type shopping_administratorsOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrderInput | SortOrder\n    role?: SortOrder\n    _count?: shopping_administratorsCountOrderByAggregateInput\n    _max?: shopping_administratorsMaxOrderByAggregateInput\n    _min?: shopping_administratorsMinOrderByAggregateInput\n  }\n\n  export type shopping_administratorsScalarWhereWithAggregatesInput = {\n    AND?: shopping_administratorsScalarWhereWithAggregatesInput | shopping_administratorsScalarWhereWithAggregatesInput[]\n    OR?: shopping_administratorsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_administratorsScalarWhereWithAggregatesInput | shopping_administratorsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_administrators\"> | string\n    email?: StringWithAggregatesFilter<\"shopping_administrators\"> | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_administrators\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_administrators\"> | string\n    phone?: StringNullableWithAggregatesFilter<\"shopping_administrators\"> | string | null\n    role?: StringWithAggregatesFilter<\"shopping_administrators\"> | string\n  }\n\n  export type shopping_productsWhereInput = {\n    AND?: shopping_productsWhereInput | shopping_productsWhereInput[]\n    OR?: shopping_productsWhereInput[]\n    NOT?: shopping_productsWhereInput | shopping_productsWhereInput[]\n    id?: UuidFilter<\"shopping_products\"> | string\n    shopping_category_id?: UuidNullableFilter<\"shopping_products\"> | string | null\n    name?: StringFilter<\"shopping_products\"> | string\n    description?: StringNullableFilter<\"shopping_products\"> | string | null\n    price?: FloatFilter<\"shopping_products\"> | number\n    sku?: StringFilter<\"shopping_products\"> | string\n    created_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    password_hash?: StringFilter<\"shopping_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_products\"> | string | null\n    category?: XOR<Shopping_categoriesNullableScalarRelationFilter, shopping_categoriesWhereInput> | null\n    shopping_product_variants?: Shopping_product_variantsListRelationFilter\n    shopping_inventory?: Shopping_inventoryListRelationFilter\n    shopping_product_reviews?: Shopping_product_reviewsListRelationFilter\n    shopping_seller_products?: Shopping_seller_productsListRelationFilter\n  }\n\n  export type shopping_productsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_category_id?: SortOrderInput | SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    sku?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    password_hash?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    category?: shopping_categoriesOrderByWithRelationInput\n    shopping_product_variants?: shopping_product_variantsOrderByRelationAggregateInput\n    shopping_inventory?: shopping_inventoryOrderByRelationAggregateInput\n    shopping_product_reviews?: shopping_product_reviewsOrderByRelationAggregateInput\n    shopping_seller_products?: shopping_seller_productsOrderByRelationAggregateInput\n  }\n\n  export type shopping_productsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    sku?: string\n    AND?: shopping_productsWhereInput | shopping_productsWhereInput[]\n    OR?: shopping_productsWhereInput[]\n    NOT?: shopping_productsWhereInput | shopping_productsWhereInput[]\n    shopping_category_id?: UuidNullableFilter<\"shopping_products\"> | string | null\n    name?: StringFilter<\"shopping_products\"> | string\n    description?: StringNullableFilter<\"shopping_products\"> | string | null\n    price?: FloatFilter<\"shopping_products\"> | number\n    created_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    password_hash?: StringFilter<\"shopping_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_products\"> | string | null\n    category?: XOR<Shopping_categoriesNullableScalarRelationFilter, shopping_categoriesWhereInput> | null\n    shopping_product_variants?: Shopping_product_variantsListRelationFilter\n    shopping_inventory?: Shopping_inventoryListRelationFilter\n    shopping_product_reviews?: Shopping_product_reviewsListRelationFilter\n    shopping_seller_products?: Shopping_seller_productsListRelationFilter\n  }, \"id\" | \"sku\">\n\n  export type shopping_productsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_category_id?: SortOrderInput | SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    price?: SortOrder\n    sku?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    password_hash?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    _count?: shopping_productsCountOrderByAggregateInput\n    _avg?: shopping_productsAvgOrderByAggregateInput\n    _max?: shopping_productsMaxOrderByAggregateInput\n    _min?: shopping_productsMinOrderByAggregateInput\n    _sum?: shopping_productsSumOrderByAggregateInput\n  }\n\n  export type shopping_productsScalarWhereWithAggregatesInput = {\n    AND?: shopping_productsScalarWhereWithAggregatesInput | shopping_productsScalarWhereWithAggregatesInput[]\n    OR?: shopping_productsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_productsScalarWhereWithAggregatesInput | shopping_productsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_products\"> | string\n    shopping_category_id?: UuidNullableWithAggregatesFilter<\"shopping_products\"> | string | null\n    name?: StringWithAggregatesFilter<\"shopping_products\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_products\"> | string | null\n    price?: FloatWithAggregatesFilter<\"shopping_products\"> | number\n    sku?: StringWithAggregatesFilter<\"shopping_products\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_products\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_products\"> | Date | string\n    password_hash?: StringWithAggregatesFilter<\"shopping_products\"> | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_products\"> | string | null\n  }\n\n  export type shopping_product_variantsWhereInput = {\n    AND?: shopping_product_variantsWhereInput | shopping_product_variantsWhereInput[]\n    OR?: shopping_product_variantsWhereInput[]\n    NOT?: shopping_product_variantsWhereInput | shopping_product_variantsWhereInput[]\n    id?: UuidFilter<\"shopping_product_variants\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_product_variants\"> | string\n    sku?: StringFilter<\"shopping_product_variants\"> | string\n    option_name?: StringFilter<\"shopping_product_variants\"> | string\n    option_value?: StringFilter<\"shopping_product_variants\"> | string\n    price_adjustment?: FloatNullableFilter<\"shopping_product_variants\"> | number | null\n    created_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_variants\"> | string | null\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    shopping_inventory?: XOR<Shopping_inventoryNullableScalarRelationFilter, shopping_inventoryWhereInput> | null\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n    shopping_seller_inventory?: Shopping_seller_inventoryListRelationFilter\n  }\n\n  export type shopping_product_variantsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    sku?: SortOrder\n    option_name?: SortOrder\n    option_value?: SortOrder\n    price_adjustment?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    product?: shopping_productsOrderByWithRelationInput\n    shopping_inventory?: shopping_inventoryOrderByWithRelationInput\n    shopping_order_items?: shopping_order_itemsOrderByRelationAggregateInput\n    shopping_cart_items?: shopping_cart_itemsOrderByRelationAggregateInput\n    shopping_seller_inventory?: shopping_seller_inventoryOrderByRelationAggregateInput\n  }\n\n  export type shopping_product_variantsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    sku?: string\n    AND?: shopping_product_variantsWhereInput | shopping_product_variantsWhereInput[]\n    OR?: shopping_product_variantsWhereInput[]\n    NOT?: shopping_product_variantsWhereInput | shopping_product_variantsWhereInput[]\n    shopping_product_id?: UuidFilter<\"shopping_product_variants\"> | string\n    option_name?: StringFilter<\"shopping_product_variants\"> | string\n    option_value?: StringFilter<\"shopping_product_variants\"> | string\n    price_adjustment?: FloatNullableFilter<\"shopping_product_variants\"> | number | null\n    created_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_variants\"> | string | null\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    shopping_inventory?: XOR<Shopping_inventoryNullableScalarRelationFilter, shopping_inventoryWhereInput> | null\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n    shopping_seller_inventory?: Shopping_seller_inventoryListRelationFilter\n  }, \"id\" | \"sku\">\n\n  export type shopping_product_variantsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    sku?: SortOrder\n    option_name?: SortOrder\n    option_value?: SortOrder\n    price_adjustment?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    _count?: shopping_product_variantsCountOrderByAggregateInput\n    _avg?: shopping_product_variantsAvgOrderByAggregateInput\n    _max?: shopping_product_variantsMaxOrderByAggregateInput\n    _min?: shopping_product_variantsMinOrderByAggregateInput\n    _sum?: shopping_product_variantsSumOrderByAggregateInput\n  }\n\n  export type shopping_product_variantsScalarWhereWithAggregatesInput = {\n    AND?: shopping_product_variantsScalarWhereWithAggregatesInput | shopping_product_variantsScalarWhereWithAggregatesInput[]\n    OR?: shopping_product_variantsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_product_variantsScalarWhereWithAggregatesInput | shopping_product_variantsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_product_variants\"> | string\n    shopping_product_id?: UuidWithAggregatesFilter<\"shopping_product_variants\"> | string\n    sku?: StringWithAggregatesFilter<\"shopping_product_variants\"> | string\n    option_name?: StringWithAggregatesFilter<\"shopping_product_variants\"> | string\n    option_value?: StringWithAggregatesFilter<\"shopping_product_variants\"> | string\n    price_adjustment?: FloatNullableWithAggregatesFilter<\"shopping_product_variants\"> | number | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_product_variants\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_product_variants\"> | Date | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_product_variants\"> | string | null\n  }\n\n  export type shopping_categoriesWhereInput = {\n    AND?: shopping_categoriesWhereInput | shopping_categoriesWhereInput[]\n    OR?: shopping_categoriesWhereInput[]\n    NOT?: shopping_categoriesWhereInput | shopping_categoriesWhereInput[]\n    id?: UuidFilter<\"shopping_categories\"> | string\n    parent_id?: UuidNullableFilter<\"shopping_categories\"> | string | null\n    name?: StringFilter<\"shopping_categories\"> | string\n    description?: StringNullableFilter<\"shopping_categories\"> | string | null\n    code?: StringFilter<\"shopping_categories\"> | string\n    created_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_categories\"> | string | null\n    parent?: XOR<Shopping_categoriesNullableScalarRelationFilter, shopping_categoriesWhereInput> | null\n    shopping_products?: Shopping_productsListRelationFilter\n    recursive?: Shopping_categoriesListRelationFilter\n  }\n\n  export type shopping_categoriesOrderByWithRelationInput = {\n    id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    code?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    parent?: shopping_categoriesOrderByWithRelationInput\n    shopping_products?: shopping_productsOrderByRelationAggregateInput\n    recursive?: shopping_categoriesOrderByRelationAggregateInput\n  }\n\n  export type shopping_categoriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    code?: string\n    AND?: shopping_categoriesWhereInput | shopping_categoriesWhereInput[]\n    OR?: shopping_categoriesWhereInput[]\n    NOT?: shopping_categoriesWhereInput | shopping_categoriesWhereInput[]\n    parent_id?: UuidNullableFilter<\"shopping_categories\"> | string | null\n    name?: StringFilter<\"shopping_categories\"> | string\n    description?: StringNullableFilter<\"shopping_categories\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_categories\"> | string | null\n    parent?: XOR<Shopping_categoriesNullableScalarRelationFilter, shopping_categoriesWhereInput> | null\n    shopping_products?: Shopping_productsListRelationFilter\n    recursive?: Shopping_categoriesListRelationFilter\n  }, \"id\" | \"code\">\n\n  export type shopping_categoriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    code?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    _count?: shopping_categoriesCountOrderByAggregateInput\n    _max?: shopping_categoriesMaxOrderByAggregateInput\n    _min?: shopping_categoriesMinOrderByAggregateInput\n  }\n\n  export type shopping_categoriesScalarWhereWithAggregatesInput = {\n    AND?: shopping_categoriesScalarWhereWithAggregatesInput | shopping_categoriesScalarWhereWithAggregatesInput[]\n    OR?: shopping_categoriesScalarWhereWithAggregatesInput[]\n    NOT?: shopping_categoriesScalarWhereWithAggregatesInput | shopping_categoriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_categories\"> | string\n    parent_id?: UuidNullableWithAggregatesFilter<\"shopping_categories\"> | string | null\n    name?: StringWithAggregatesFilter<\"shopping_categories\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_categories\"> | string | null\n    code?: StringWithAggregatesFilter<\"shopping_categories\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_categories\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_categories\"> | Date | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_categories\"> | string | null\n  }\n\n  export type shopping_inventoryWhereInput = {\n    AND?: shopping_inventoryWhereInput | shopping_inventoryWhereInput[]\n    OR?: shopping_inventoryWhereInput[]\n    NOT?: shopping_inventoryWhereInput | shopping_inventoryWhereInput[]\n    id?: UuidFilter<\"shopping_inventory\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_inventory\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_inventory\"> | string\n    quantity?: IntFilter<\"shopping_inventory\"> | number\n    reserved_quantity?: IntFilter<\"shopping_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_inventory\"> | number | null\n    last_stock_update?: DateTimeNullableFilter<\"shopping_inventory\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_inventory\"> | string | null\n    variant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n  }\n\n  export type shopping_inventoryOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    shopping_product_id?: SortOrder\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrderInput | SortOrder\n    last_stock_update?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    variant?: shopping_product_variantsOrderByWithRelationInput\n    product?: shopping_productsOrderByWithRelationInput\n  }\n\n  export type shopping_inventoryWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_product_variant_id?: string\n    AND?: shopping_inventoryWhereInput | shopping_inventoryWhereInput[]\n    OR?: shopping_inventoryWhereInput[]\n    NOT?: shopping_inventoryWhereInput | shopping_inventoryWhereInput[]\n    shopping_product_id?: UuidFilter<\"shopping_inventory\"> | string\n    quantity?: IntFilter<\"shopping_inventory\"> | number\n    reserved_quantity?: IntFilter<\"shopping_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_inventory\"> | number | null\n    last_stock_update?: DateTimeNullableFilter<\"shopping_inventory\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_inventory\"> | string | null\n    variant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n  }, \"id\" | \"shopping_product_variant_id\">\n\n  export type shopping_inventoryOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    shopping_product_id?: SortOrder\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrderInput | SortOrder\n    last_stock_update?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    _count?: shopping_inventoryCountOrderByAggregateInput\n    _avg?: shopping_inventoryAvgOrderByAggregateInput\n    _max?: shopping_inventoryMaxOrderByAggregateInput\n    _min?: shopping_inventoryMinOrderByAggregateInput\n    _sum?: shopping_inventorySumOrderByAggregateInput\n  }\n\n  export type shopping_inventoryScalarWhereWithAggregatesInput = {\n    AND?: shopping_inventoryScalarWhereWithAggregatesInput | shopping_inventoryScalarWhereWithAggregatesInput[]\n    OR?: shopping_inventoryScalarWhereWithAggregatesInput[]\n    NOT?: shopping_inventoryScalarWhereWithAggregatesInput | shopping_inventoryScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_inventory\"> | string\n    shopping_product_variant_id?: UuidWithAggregatesFilter<\"shopping_inventory\"> | string\n    shopping_product_id?: UuidWithAggregatesFilter<\"shopping_inventory\"> | string\n    quantity?: IntWithAggregatesFilter<\"shopping_inventory\"> | number\n    reserved_quantity?: IntWithAggregatesFilter<\"shopping_inventory\"> | number\n    low_stock_threshold?: IntNullableWithAggregatesFilter<\"shopping_inventory\"> | number | null\n    last_stock_update?: DateTimeNullableWithAggregatesFilter<\"shopping_inventory\"> | Date | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_inventory\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_inventory\"> | Date | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_inventory\"> | string | null\n  }\n\n  export type shopping_product_reviewsWhereInput = {\n    AND?: shopping_product_reviewsWhereInput | shopping_product_reviewsWhereInput[]\n    OR?: shopping_product_reviewsWhereInput[]\n    NOT?: shopping_product_reviewsWhereInput | shopping_product_reviewsWhereInput[]\n    id?: UuidFilter<\"shopping_product_reviews\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    rating?: IntFilter<\"shopping_product_reviews\"> | number\n    title?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n    content?: StringFilter<\"shopping_product_reviews\"> | string\n    created_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_review_moderation?: Shopping_review_moderationListRelationFilter\n    shopping_review_ratings?: Shopping_review_ratingsListRelationFilter\n  }\n\n  export type shopping_product_reviewsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    shopping_customer_id?: SortOrder\n    rating?: SortOrder\n    title?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    product?: shopping_productsOrderByWithRelationInput\n    customer?: shopping_customersOrderByWithRelationInput\n    shopping_review_moderation?: shopping_review_moderationOrderByRelationAggregateInput\n    shopping_review_ratings?: shopping_review_ratingsOrderByRelationAggregateInput\n  }\n\n  export type shopping_product_reviewsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_product_reviewsWhereInput | shopping_product_reviewsWhereInput[]\n    OR?: shopping_product_reviewsWhereInput[]\n    NOT?: shopping_product_reviewsWhereInput | shopping_product_reviewsWhereInput[]\n    shopping_product_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    rating?: IntFilter<\"shopping_product_reviews\"> | number\n    title?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n    content?: StringFilter<\"shopping_product_reviews\"> | string\n    created_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_review_moderation?: Shopping_review_moderationListRelationFilter\n    shopping_review_ratings?: Shopping_review_ratingsListRelationFilter\n  }, \"id\">\n\n  export type shopping_product_reviewsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    shopping_customer_id?: SortOrder\n    rating?: SortOrder\n    title?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    _count?: shopping_product_reviewsCountOrderByAggregateInput\n    _avg?: shopping_product_reviewsAvgOrderByAggregateInput\n    _max?: shopping_product_reviewsMaxOrderByAggregateInput\n    _min?: shopping_product_reviewsMinOrderByAggregateInput\n    _sum?: shopping_product_reviewsSumOrderByAggregateInput\n  }\n\n  export type shopping_product_reviewsScalarWhereWithAggregatesInput = {\n    AND?: shopping_product_reviewsScalarWhereWithAggregatesInput | shopping_product_reviewsScalarWhereWithAggregatesInput[]\n    OR?: shopping_product_reviewsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_product_reviewsScalarWhereWithAggregatesInput | shopping_product_reviewsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_product_reviews\"> | string\n    shopping_product_id?: UuidWithAggregatesFilter<\"shopping_product_reviews\"> | string\n    shopping_customer_id?: UuidWithAggregatesFilter<\"shopping_product_reviews\"> | string\n    rating?: IntWithAggregatesFilter<\"shopping_product_reviews\"> | number\n    title?: StringNullableWithAggregatesFilter<\"shopping_product_reviews\"> | string | null\n    content?: StringWithAggregatesFilter<\"shopping_product_reviews\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_product_reviews\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_product_reviews\"> | Date | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_product_reviews\"> | string | null\n  }\n\n  export type shopping_ordersWhereInput = {\n    AND?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    OR?: shopping_ordersWhereInput[]\n    NOT?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    id?: UuidFilter<\"shopping_orders\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_orders\"> | string\n    order_code?: StringFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    currency?: StringFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    billing_address?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_order_status?: Shopping_order_statusListRelationFilter\n    shopping_order_history?: Shopping_order_historyListRelationFilter\n    shopping_seller_orders?: Shopping_seller_ordersListRelationFilter\n    shopping_payments?: Shopping_paymentsListRelationFilter\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }\n\n  export type shopping_ordersOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    order_code?: SortOrder\n    total_amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    payment_method?: SortOrder\n    shipping_method?: SortOrder\n    shipping_address?: SortOrder\n    billing_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    customer?: shopping_customersOrderByWithRelationInput\n    shopping_order_items?: shopping_order_itemsOrderByRelationAggregateInput\n    shopping_order_status?: shopping_order_statusOrderByRelationAggregateInput\n    shopping_order_history?: shopping_order_historyOrderByRelationAggregateInput\n    shopping_seller_orders?: shopping_seller_ordersOrderByRelationAggregateInput\n    shopping_payments?: shopping_paymentsOrderByRelationAggregateInput\n    shopping_shipping_tracking?: shopping_shipping_trackingOrderByRelationAggregateInput\n  }\n\n  export type shopping_ordersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    order_code?: string\n    AND?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    OR?: shopping_ordersWhereInput[]\n    NOT?: shopping_ordersWhereInput | shopping_ordersWhereInput[]\n    shopping_customer_id?: UuidFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    currency?: StringFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    billing_address?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_order_items?: Shopping_order_itemsListRelationFilter\n    shopping_order_status?: Shopping_order_statusListRelationFilter\n    shopping_order_history?: Shopping_order_historyListRelationFilter\n    shopping_seller_orders?: Shopping_seller_ordersListRelationFilter\n    shopping_payments?: Shopping_paymentsListRelationFilter\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }, \"id\" | \"order_code\">\n\n  export type shopping_ordersOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    order_code?: SortOrder\n    total_amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    payment_method?: SortOrder\n    shipping_method?: SortOrder\n    shipping_address?: SortOrder\n    billing_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_ordersCountOrderByAggregateInput\n    _avg?: shopping_ordersAvgOrderByAggregateInput\n    _max?: shopping_ordersMaxOrderByAggregateInput\n    _min?: shopping_ordersMinOrderByAggregateInput\n    _sum?: shopping_ordersSumOrderByAggregateInput\n  }\n\n  export type shopping_ordersScalarWhereWithAggregatesInput = {\n    AND?: shopping_ordersScalarWhereWithAggregatesInput | shopping_ordersScalarWhereWithAggregatesInput[]\n    OR?: shopping_ordersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_ordersScalarWhereWithAggregatesInput | shopping_ordersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_orders\"> | string\n    shopping_customer_id?: UuidWithAggregatesFilter<\"shopping_orders\"> | string\n    order_code?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    total_amount?: FloatWithAggregatesFilter<\"shopping_orders\"> | number\n    currency?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    payment_method?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    shipping_method?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    shipping_address?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    billing_address?: StringWithAggregatesFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_orders\"> | Date | string | null\n  }\n\n  export type shopping_order_itemsWhereInput = {\n    AND?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    OR?: shopping_order_itemsWhereInput[]\n    NOT?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    unit_price?: FloatFilter<\"shopping_order_items\"> | number\n    total_price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }\n\n  export type shopping_order_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n    productVariant?: shopping_product_variantsOrderByWithRelationInput\n  }\n\n  export type shopping_order_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    OR?: shopping_order_itemsWhereInput[]\n    NOT?: shopping_order_itemsWhereInput | shopping_order_itemsWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    unit_price?: FloatFilter<\"shopping_order_items\"> | number\n    total_price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }, \"id\">\n\n  export type shopping_order_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_order_itemsCountOrderByAggregateInput\n    _avg?: shopping_order_itemsAvgOrderByAggregateInput\n    _max?: shopping_order_itemsMaxOrderByAggregateInput\n    _min?: shopping_order_itemsMinOrderByAggregateInput\n    _sum?: shopping_order_itemsSumOrderByAggregateInput\n  }\n\n  export type shopping_order_itemsScalarWhereWithAggregatesInput = {\n    AND?: shopping_order_itemsScalarWhereWithAggregatesInput | shopping_order_itemsScalarWhereWithAggregatesInput[]\n    OR?: shopping_order_itemsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_order_itemsScalarWhereWithAggregatesInput | shopping_order_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    shopping_product_variant_id?: UuidWithAggregatesFilter<\"shopping_order_items\"> | string\n    quantity?: IntWithAggregatesFilter<\"shopping_order_items\"> | number\n    unit_price?: FloatWithAggregatesFilter<\"shopping_order_items\"> | number\n    total_price?: FloatWithAggregatesFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_order_items\"> | Date | string\n  }\n\n  export type shopping_order_statusWhereInput = {\n    AND?: shopping_order_statusWhereInput | shopping_order_statusWhereInput[]\n    OR?: shopping_order_statusWhereInput[]\n    NOT?: shopping_order_statusWhereInput | shopping_order_statusWhereInput[]\n    id?: UuidFilter<\"shopping_order_status\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_status\"> | string\n    status?: StringFilter<\"shopping_order_status\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_status\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_status\"> | string | null\n    notes?: StringNullableFilter<\"shopping_order_status\"> | string | null\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }\n\n  export type shopping_order_statusOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    status?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrderInput | SortOrder\n    notes?: SortOrderInput | SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_order_statusWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_order_statusWhereInput | shopping_order_statusWhereInput[]\n    OR?: shopping_order_statusWhereInput[]\n    NOT?: shopping_order_statusWhereInput | shopping_order_statusWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_order_status\"> | string\n    status?: StringFilter<\"shopping_order_status\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_status\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_status\"> | string | null\n    notes?: StringNullableFilter<\"shopping_order_status\"> | string | null\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }, \"id\">\n\n  export type shopping_order_statusOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    status?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrderInput | SortOrder\n    notes?: SortOrderInput | SortOrder\n    _count?: shopping_order_statusCountOrderByAggregateInput\n    _max?: shopping_order_statusMaxOrderByAggregateInput\n    _min?: shopping_order_statusMinOrderByAggregateInput\n  }\n\n  export type shopping_order_statusScalarWhereWithAggregatesInput = {\n    AND?: shopping_order_statusScalarWhereWithAggregatesInput | shopping_order_statusScalarWhereWithAggregatesInput[]\n    OR?: shopping_order_statusScalarWhereWithAggregatesInput[]\n    NOT?: shopping_order_statusScalarWhereWithAggregatesInput | shopping_order_statusScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_order_status\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_order_status\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_order_status\"> | string\n    changed_at?: DateTimeWithAggregatesFilter<\"shopping_order_status\"> | Date | string\n    changed_by?: StringNullableWithAggregatesFilter<\"shopping_order_status\"> | string | null\n    notes?: StringNullableWithAggregatesFilter<\"shopping_order_status\"> | string | null\n  }\n\n  export type shopping_order_historyWhereInput = {\n    AND?: shopping_order_historyWhereInput | shopping_order_historyWhereInput[]\n    OR?: shopping_order_historyWhereInput[]\n    NOT?: shopping_order_historyWhereInput | shopping_order_historyWhereInput[]\n    id?: UuidFilter<\"shopping_order_history\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_history\"> | string\n    action?: StringFilter<\"shopping_order_history\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_history\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_history\"> | string | null\n    details?: StringNullableFilter<\"shopping_order_history\"> | string | null\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }\n\n  export type shopping_order_historyOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    action?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrderInput | SortOrder\n    details?: SortOrderInput | SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_order_historyWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_order_historyWhereInput | shopping_order_historyWhereInput[]\n    OR?: shopping_order_historyWhereInput[]\n    NOT?: shopping_order_historyWhereInput | shopping_order_historyWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_order_history\"> | string\n    action?: StringFilter<\"shopping_order_history\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_history\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_history\"> | string | null\n    details?: StringNullableFilter<\"shopping_order_history\"> | string | null\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }, \"id\">\n\n  export type shopping_order_historyOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    action?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrderInput | SortOrder\n    details?: SortOrderInput | SortOrder\n    _count?: shopping_order_historyCountOrderByAggregateInput\n    _max?: shopping_order_historyMaxOrderByAggregateInput\n    _min?: shopping_order_historyMinOrderByAggregateInput\n  }\n\n  export type shopping_order_historyScalarWhereWithAggregatesInput = {\n    AND?: shopping_order_historyScalarWhereWithAggregatesInput | shopping_order_historyScalarWhereWithAggregatesInput[]\n    OR?: shopping_order_historyScalarWhereWithAggregatesInput[]\n    NOT?: shopping_order_historyScalarWhereWithAggregatesInput | shopping_order_historyScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_order_history\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_order_history\"> | string\n    action?: StringWithAggregatesFilter<\"shopping_order_history\"> | string\n    changed_at?: DateTimeWithAggregatesFilter<\"shopping_order_history\"> | Date | string\n    changed_by?: StringNullableWithAggregatesFilter<\"shopping_order_history\"> | string | null\n    details?: StringNullableWithAggregatesFilter<\"shopping_order_history\"> | string | null\n  }\n\n  export type shopping_shopping_cartsWhereInput = {\n    AND?: shopping_shopping_cartsWhereInput | shopping_shopping_cartsWhereInput[]\n    OR?: shopping_shopping_cartsWhereInput[]\n    NOT?: shopping_shopping_cartsWhereInput | shopping_shopping_cartsWhereInput[]\n    id?: UuidFilter<\"shopping_shopping_carts\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_shopping_carts\"> | string\n    created_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n  }\n\n  export type shopping_shopping_cartsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    customer?: shopping_customersOrderByWithRelationInput\n    shopping_cart_items?: shopping_cart_itemsOrderByRelationAggregateInput\n  }\n\n  export type shopping_shopping_cartsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_customer_id?: string\n    AND?: shopping_shopping_cartsWhereInput | shopping_shopping_cartsWhereInput[]\n    OR?: shopping_shopping_cartsWhereInput[]\n    NOT?: shopping_shopping_cartsWhereInput | shopping_shopping_cartsWhereInput[]\n    created_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    shopping_cart_items?: Shopping_cart_itemsListRelationFilter\n  }, \"id\" | \"shopping_customer_id\">\n\n  export type shopping_shopping_cartsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_shopping_cartsCountOrderByAggregateInput\n    _max?: shopping_shopping_cartsMaxOrderByAggregateInput\n    _min?: shopping_shopping_cartsMinOrderByAggregateInput\n  }\n\n  export type shopping_shopping_cartsScalarWhereWithAggregatesInput = {\n    AND?: shopping_shopping_cartsScalarWhereWithAggregatesInput | shopping_shopping_cartsScalarWhereWithAggregatesInput[]\n    OR?: shopping_shopping_cartsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_shopping_cartsScalarWhereWithAggregatesInput | shopping_shopping_cartsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_shopping_carts\"> | string\n    shopping_customer_id?: UuidWithAggregatesFilter<\"shopping_shopping_carts\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_shopping_carts\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_shopping_carts\"> | Date | string\n  }\n\n  export type shopping_cart_itemsWhereInput = {\n    AND?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    OR?: shopping_cart_itemsWhereInput[]\n    NOT?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    cart?: XOR<Shopping_shopping_cartsScalarRelationFilter, shopping_shopping_cartsWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }\n\n  export type shopping_cart_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_shopping_cart_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    cart?: shopping_shopping_cartsOrderByWithRelationInput\n    productVariant?: shopping_product_variantsOrderByWithRelationInput\n  }\n\n  export type shopping_cart_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_shopping_cart_id_shopping_product_variant_id?: shopping_cart_itemsShopping_shopping_cart_idShopping_product_variant_idCompoundUniqueInput\n    AND?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    OR?: shopping_cart_itemsWhereInput[]\n    NOT?: shopping_cart_itemsWhereInput | shopping_cart_itemsWhereInput[]\n    shopping_shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    cart?: XOR<Shopping_shopping_cartsScalarRelationFilter, shopping_shopping_cartsWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }, \"id\" | \"shopping_shopping_cart_id_shopping_product_variant_id\">\n\n  export type shopping_cart_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_shopping_cart_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_cart_itemsCountOrderByAggregateInput\n    _avg?: shopping_cart_itemsAvgOrderByAggregateInput\n    _max?: shopping_cart_itemsMaxOrderByAggregateInput\n    _min?: shopping_cart_itemsMinOrderByAggregateInput\n    _sum?: shopping_cart_itemsSumOrderByAggregateInput\n  }\n\n  export type shopping_cart_itemsScalarWhereWithAggregatesInput = {\n    AND?: shopping_cart_itemsScalarWhereWithAggregatesInput | shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    OR?: shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_cart_itemsScalarWhereWithAggregatesInput | shopping_cart_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    shopping_shopping_cart_id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    shopping_product_variant_id?: UuidWithAggregatesFilter<\"shopping_cart_items\"> | string\n    quantity?: IntWithAggregatesFilter<\"shopping_cart_items\"> | number\n    price?: FloatWithAggregatesFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_cart_items\"> | Date | string\n  }\n\n  export type shopping_review_moderationWhereInput = {\n    AND?: shopping_review_moderationWhereInput | shopping_review_moderationWhereInput[]\n    OR?: shopping_review_moderationWhereInput[]\n    NOT?: shopping_review_moderationWhereInput | shopping_review_moderationWhereInput[]\n    id?: UuidFilter<\"shopping_review_moderation\"> | string\n    shopping_product_review_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    shopping_administrator_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    action_type?: StringFilter<\"shopping_review_moderation\"> | string\n    reason?: StringNullableFilter<\"shopping_review_moderation\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_review_moderation\"> | Date | string\n    review?: XOR<Shopping_product_reviewsScalarRelationFilter, shopping_product_reviewsWhereInput>\n    administrator?: XOR<Shopping_administratorsScalarRelationFilter, shopping_administratorsWhereInput>\n  }\n\n  export type shopping_review_moderationOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    reason?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    review?: shopping_product_reviewsOrderByWithRelationInput\n    administrator?: shopping_administratorsOrderByWithRelationInput\n  }\n\n  export type shopping_review_moderationWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_review_moderationWhereInput | shopping_review_moderationWhereInput[]\n    OR?: shopping_review_moderationWhereInput[]\n    NOT?: shopping_review_moderationWhereInput | shopping_review_moderationWhereInput[]\n    shopping_product_review_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    shopping_administrator_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    action_type?: StringFilter<\"shopping_review_moderation\"> | string\n    reason?: StringNullableFilter<\"shopping_review_moderation\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_review_moderation\"> | Date | string\n    review?: XOR<Shopping_product_reviewsScalarRelationFilter, shopping_product_reviewsWhereInput>\n    administrator?: XOR<Shopping_administratorsScalarRelationFilter, shopping_administratorsWhereInput>\n  }, \"id\">\n\n  export type shopping_review_moderationOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    reason?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    _count?: shopping_review_moderationCountOrderByAggregateInput\n    _max?: shopping_review_moderationMaxOrderByAggregateInput\n    _min?: shopping_review_moderationMinOrderByAggregateInput\n  }\n\n  export type shopping_review_moderationScalarWhereWithAggregatesInput = {\n    AND?: shopping_review_moderationScalarWhereWithAggregatesInput | shopping_review_moderationScalarWhereWithAggregatesInput[]\n    OR?: shopping_review_moderationScalarWhereWithAggregatesInput[]\n    NOT?: shopping_review_moderationScalarWhereWithAggregatesInput | shopping_review_moderationScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_review_moderation\"> | string\n    shopping_product_review_id?: UuidWithAggregatesFilter<\"shopping_review_moderation\"> | string\n    shopping_administrator_id?: UuidWithAggregatesFilter<\"shopping_review_moderation\"> | string\n    action_type?: StringWithAggregatesFilter<\"shopping_review_moderation\"> | string\n    reason?: StringNullableWithAggregatesFilter<\"shopping_review_moderation\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_review_moderation\"> | Date | string\n  }\n\n  export type shopping_review_ratingsWhereInput = {\n    AND?: shopping_review_ratingsWhereInput | shopping_review_ratingsWhereInput[]\n    OR?: shopping_review_ratingsWhereInput[]\n    NOT?: shopping_review_ratingsWhereInput | shopping_review_ratingsWhereInput[]\n    id?: UuidFilter<\"shopping_review_ratings\"> | string\n    shopping_product_review_id?: UuidFilter<\"shopping_review_ratings\"> | string\n    quality_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    value_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    service_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    created_at?: DateTimeFilter<\"shopping_review_ratings\"> | Date | string\n    review?: XOR<Shopping_product_reviewsScalarRelationFilter, shopping_product_reviewsWhereInput>\n  }\n\n  export type shopping_review_ratingsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n    created_at?: SortOrder\n    review?: shopping_product_reviewsOrderByWithRelationInput\n  }\n\n  export type shopping_review_ratingsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_product_review_id?: string\n    AND?: shopping_review_ratingsWhereInput | shopping_review_ratingsWhereInput[]\n    OR?: shopping_review_ratingsWhereInput[]\n    NOT?: shopping_review_ratingsWhereInput | shopping_review_ratingsWhereInput[]\n    quality_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    value_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    service_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    created_at?: DateTimeFilter<\"shopping_review_ratings\"> | Date | string\n    review?: XOR<Shopping_product_reviewsScalarRelationFilter, shopping_product_reviewsWhereInput>\n  }, \"id\" | \"shopping_product_review_id\">\n\n  export type shopping_review_ratingsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_review_ratingsCountOrderByAggregateInput\n    _avg?: shopping_review_ratingsAvgOrderByAggregateInput\n    _max?: shopping_review_ratingsMaxOrderByAggregateInput\n    _min?: shopping_review_ratingsMinOrderByAggregateInput\n    _sum?: shopping_review_ratingsSumOrderByAggregateInput\n  }\n\n  export type shopping_review_ratingsScalarWhereWithAggregatesInput = {\n    AND?: shopping_review_ratingsScalarWhereWithAggregatesInput | shopping_review_ratingsScalarWhereWithAggregatesInput[]\n    OR?: shopping_review_ratingsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_review_ratingsScalarWhereWithAggregatesInput | shopping_review_ratingsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_review_ratings\"> | string\n    shopping_product_review_id?: UuidWithAggregatesFilter<\"shopping_review_ratings\"> | string\n    quality_rating?: IntWithAggregatesFilter<\"shopping_review_ratings\"> | number\n    value_rating?: IntWithAggregatesFilter<\"shopping_review_ratings\"> | number\n    service_rating?: IntWithAggregatesFilter<\"shopping_review_ratings\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_review_ratings\"> | Date | string\n  }\n\n  export type shopping_seller_productsWhereInput = {\n    AND?: shopping_seller_productsWhereInput | shopping_seller_productsWhereInput[]\n    OR?: shopping_seller_productsWhereInput[]\n    NOT?: shopping_seller_productsWhereInput | shopping_seller_productsWhereInput[]\n    id?: UuidFilter<\"shopping_seller_products\"> | string\n    shopping_seller_id?: UuidFilter<\"shopping_seller_products\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_seller_products\"> | string\n    seller_product_code?: StringFilter<\"shopping_seller_products\"> | string\n    price?: FloatFilter<\"shopping_seller_products\"> | number\n    quantity_available?: IntFilter<\"shopping_seller_products\"> | number\n    status?: StringFilter<\"shopping_seller_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_products\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_products\"> | Date | string | null\n    seller?: XOR<Shopping_sellersScalarRelationFilter, shopping_sellersWhereInput>\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    shopping_seller_inventory?: Shopping_seller_inventoryListRelationFilter\n  }\n\n  export type shopping_seller_productsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_product_id?: SortOrder\n    seller_product_code?: SortOrder\n    price?: SortOrder\n    quantity_available?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    seller?: shopping_sellersOrderByWithRelationInput\n    product?: shopping_productsOrderByWithRelationInput\n    shopping_seller_inventory?: shopping_seller_inventoryOrderByRelationAggregateInput\n  }\n\n  export type shopping_seller_productsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_seller_id_seller_product_code?: shopping_seller_productsShopping_seller_idSeller_product_codeCompoundUniqueInput\n    AND?: shopping_seller_productsWhereInput | shopping_seller_productsWhereInput[]\n    OR?: shopping_seller_productsWhereInput[]\n    NOT?: shopping_seller_productsWhereInput | shopping_seller_productsWhereInput[]\n    shopping_seller_id?: UuidFilter<\"shopping_seller_products\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_seller_products\"> | string\n    seller_product_code?: StringFilter<\"shopping_seller_products\"> | string\n    price?: FloatFilter<\"shopping_seller_products\"> | number\n    quantity_available?: IntFilter<\"shopping_seller_products\"> | number\n    status?: StringFilter<\"shopping_seller_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_products\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_products\"> | Date | string | null\n    seller?: XOR<Shopping_sellersScalarRelationFilter, shopping_sellersWhereInput>\n    product?: XOR<Shopping_productsScalarRelationFilter, shopping_productsWhereInput>\n    shopping_seller_inventory?: Shopping_seller_inventoryListRelationFilter\n  }, \"id\" | \"shopping_seller_id_seller_product_code\">\n\n  export type shopping_seller_productsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_product_id?: SortOrder\n    seller_product_code?: SortOrder\n    price?: SortOrder\n    quantity_available?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_seller_productsCountOrderByAggregateInput\n    _avg?: shopping_seller_productsAvgOrderByAggregateInput\n    _max?: shopping_seller_productsMaxOrderByAggregateInput\n    _min?: shopping_seller_productsMinOrderByAggregateInput\n    _sum?: shopping_seller_productsSumOrderByAggregateInput\n  }\n\n  export type shopping_seller_productsScalarWhereWithAggregatesInput = {\n    AND?: shopping_seller_productsScalarWhereWithAggregatesInput | shopping_seller_productsScalarWhereWithAggregatesInput[]\n    OR?: shopping_seller_productsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_seller_productsScalarWhereWithAggregatesInput | shopping_seller_productsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_seller_products\"> | string\n    shopping_seller_id?: UuidWithAggregatesFilter<\"shopping_seller_products\"> | string\n    shopping_product_id?: UuidWithAggregatesFilter<\"shopping_seller_products\"> | string\n    seller_product_code?: StringWithAggregatesFilter<\"shopping_seller_products\"> | string\n    price?: FloatWithAggregatesFilter<\"shopping_seller_products\"> | number\n    quantity_available?: IntWithAggregatesFilter<\"shopping_seller_products\"> | number\n    status?: StringWithAggregatesFilter<\"shopping_seller_products\"> | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_seller_products\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_seller_products\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_seller_products\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_seller_products\"> | Date | string | null\n  }\n\n  export type shopping_seller_inventoryWhereInput = {\n    AND?: shopping_seller_inventoryWhereInput | shopping_seller_inventoryWhereInput[]\n    OR?: shopping_seller_inventoryWhereInput[]\n    NOT?: shopping_seller_inventoryWhereInput | shopping_seller_inventoryWhereInput[]\n    id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    shopping_seller_product_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    stock_quantity?: IntFilter<\"shopping_seller_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_seller_inventory\"> | number | null\n    status?: StringFilter<\"shopping_seller_inventory\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_inventory\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_inventory\"> | Date | string | null\n    sellerProduct?: XOR<Shopping_seller_productsScalarRelationFilter, shopping_seller_productsWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }\n\n  export type shopping_seller_inventoryOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_seller_product_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrderInput | SortOrder\n    status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    sellerProduct?: shopping_seller_productsOrderByWithRelationInput\n    productVariant?: shopping_product_variantsOrderByWithRelationInput\n  }\n\n  export type shopping_seller_inventoryWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_seller_product_id_shopping_product_variant_id?: shopping_seller_inventoryShopping_seller_product_idShopping_product_variant_idCompoundUniqueInput\n    AND?: shopping_seller_inventoryWhereInput | shopping_seller_inventoryWhereInput[]\n    OR?: shopping_seller_inventoryWhereInput[]\n    NOT?: shopping_seller_inventoryWhereInput | shopping_seller_inventoryWhereInput[]\n    shopping_seller_product_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    stock_quantity?: IntFilter<\"shopping_seller_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_seller_inventory\"> | number | null\n    status?: StringFilter<\"shopping_seller_inventory\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_inventory\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_inventory\"> | Date | string | null\n    sellerProduct?: XOR<Shopping_seller_productsScalarRelationFilter, shopping_seller_productsWhereInput>\n    productVariant?: XOR<Shopping_product_variantsScalarRelationFilter, shopping_product_variantsWhereInput>\n  }, \"id\" | \"shopping_seller_product_id_shopping_product_variant_id\">\n\n  export type shopping_seller_inventoryOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_seller_product_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrderInput | SortOrder\n    status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_seller_inventoryCountOrderByAggregateInput\n    _avg?: shopping_seller_inventoryAvgOrderByAggregateInput\n    _max?: shopping_seller_inventoryMaxOrderByAggregateInput\n    _min?: shopping_seller_inventoryMinOrderByAggregateInput\n    _sum?: shopping_seller_inventorySumOrderByAggregateInput\n  }\n\n  export type shopping_seller_inventoryScalarWhereWithAggregatesInput = {\n    AND?: shopping_seller_inventoryScalarWhereWithAggregatesInput | shopping_seller_inventoryScalarWhereWithAggregatesInput[]\n    OR?: shopping_seller_inventoryScalarWhereWithAggregatesInput[]\n    NOT?: shopping_seller_inventoryScalarWhereWithAggregatesInput | shopping_seller_inventoryScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_seller_inventory\"> | string\n    shopping_seller_product_id?: UuidWithAggregatesFilter<\"shopping_seller_inventory\"> | string\n    shopping_product_variant_id?: UuidWithAggregatesFilter<\"shopping_seller_inventory\"> | string\n    stock_quantity?: IntWithAggregatesFilter<\"shopping_seller_inventory\"> | number\n    low_stock_threshold?: IntNullableWithAggregatesFilter<\"shopping_seller_inventory\"> | number | null\n    status?: StringWithAggregatesFilter<\"shopping_seller_inventory\"> | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_seller_inventory\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_seller_inventory\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_seller_inventory\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_seller_inventory\"> | Date | string | null\n  }\n\n  export type shopping_seller_ordersWhereInput = {\n    AND?: shopping_seller_ordersWhereInput | shopping_seller_ordersWhereInput[]\n    OR?: shopping_seller_ordersWhereInput[]\n    NOT?: shopping_seller_ordersWhereInput | shopping_seller_ordersWhereInput[]\n    id?: UuidFilter<\"shopping_seller_orders\"> | string\n    shopping_seller_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    seller_order_code?: StringFilter<\"shopping_seller_orders\"> | string\n    fulfillment_status?: StringFilter<\"shopping_seller_orders\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_orders\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_orders\"> | Date | string | null\n    seller?: XOR<Shopping_sellersScalarRelationFilter, shopping_sellersWhereInput>\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }\n\n  export type shopping_seller_ordersOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_order_id?: SortOrder\n    seller_order_code?: SortOrder\n    fulfillment_status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    seller?: shopping_sellersOrderByWithRelationInput\n    order?: shopping_ordersOrderByWithRelationInput\n  }\n\n  export type shopping_seller_ordersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    shopping_seller_id_seller_order_code?: shopping_seller_ordersShopping_seller_idSeller_order_codeCompoundUniqueInput\n    AND?: shopping_seller_ordersWhereInput | shopping_seller_ordersWhereInput[]\n    OR?: shopping_seller_ordersWhereInput[]\n    NOT?: shopping_seller_ordersWhereInput | shopping_seller_ordersWhereInput[]\n    shopping_seller_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    seller_order_code?: StringFilter<\"shopping_seller_orders\"> | string\n    fulfillment_status?: StringFilter<\"shopping_seller_orders\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_orders\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_orders\"> | Date | string | null\n    seller?: XOR<Shopping_sellersScalarRelationFilter, shopping_sellersWhereInput>\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n  }, \"id\" | \"shopping_seller_id_seller_order_code\">\n\n  export type shopping_seller_ordersOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_order_id?: SortOrder\n    seller_order_code?: SortOrder\n    fulfillment_status?: SortOrder\n    business_status?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_seller_ordersCountOrderByAggregateInput\n    _max?: shopping_seller_ordersMaxOrderByAggregateInput\n    _min?: shopping_seller_ordersMinOrderByAggregateInput\n  }\n\n  export type shopping_seller_ordersScalarWhereWithAggregatesInput = {\n    AND?: shopping_seller_ordersScalarWhereWithAggregatesInput | shopping_seller_ordersScalarWhereWithAggregatesInput[]\n    OR?: shopping_seller_ordersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_seller_ordersScalarWhereWithAggregatesInput | shopping_seller_ordersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_seller_orders\"> | string\n    shopping_seller_id?: UuidWithAggregatesFilter<\"shopping_seller_orders\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_seller_orders\"> | string\n    seller_order_code?: StringWithAggregatesFilter<\"shopping_seller_orders\"> | string\n    fulfillment_status?: StringWithAggregatesFilter<\"shopping_seller_orders\"> | string\n    business_status?: StringNullableWithAggregatesFilter<\"shopping_seller_orders\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_seller_orders\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_seller_orders\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_seller_orders\"> | Date | string | null\n  }\n\n  export type shopping_admin_actionsWhereInput = {\n    AND?: shopping_admin_actionsWhereInput | shopping_admin_actionsWhereInput[]\n    OR?: shopping_admin_actionsWhereInput[]\n    NOT?: shopping_admin_actionsWhereInput | shopping_admin_actionsWhereInput[]\n    id?: UuidFilter<\"shopping_admin_actions\"> | string\n    shopping_administrator_id?: UuidFilter<\"shopping_admin_actions\"> | string\n    action_type?: StringFilter<\"shopping_admin_actions\"> | string\n    description?: StringFilter<\"shopping_admin_actions\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_actions\"> | Date | string\n    administrator?: XOR<Shopping_administratorsScalarRelationFilter, shopping_administratorsWhereInput>\n  }\n\n  export type shopping_admin_actionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    administrator?: shopping_administratorsOrderByWithRelationInput\n  }\n\n  export type shopping_admin_actionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_admin_actionsWhereInput | shopping_admin_actionsWhereInput[]\n    OR?: shopping_admin_actionsWhereInput[]\n    NOT?: shopping_admin_actionsWhereInput | shopping_admin_actionsWhereInput[]\n    shopping_administrator_id?: UuidFilter<\"shopping_admin_actions\"> | string\n    action_type?: StringFilter<\"shopping_admin_actions\"> | string\n    description?: StringFilter<\"shopping_admin_actions\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_actions\"> | Date | string\n    administrator?: XOR<Shopping_administratorsScalarRelationFilter, shopping_administratorsWhereInput>\n  }, \"id\">\n\n  export type shopping_admin_actionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_admin_actionsCountOrderByAggregateInput\n    _max?: shopping_admin_actionsMaxOrderByAggregateInput\n    _min?: shopping_admin_actionsMinOrderByAggregateInput\n  }\n\n  export type shopping_admin_actionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_admin_actionsScalarWhereWithAggregatesInput | shopping_admin_actionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_admin_actionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_admin_actionsScalarWhereWithAggregatesInput | shopping_admin_actionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_admin_actions\"> | string\n    shopping_administrator_id?: UuidWithAggregatesFilter<\"shopping_admin_actions\"> | string\n    action_type?: StringWithAggregatesFilter<\"shopping_admin_actions\"> | string\n    description?: StringWithAggregatesFilter<\"shopping_admin_actions\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_admin_actions\"> | Date | string\n  }\n\n  export type shopping_admin_logsWhereInput = {\n    AND?: shopping_admin_logsWhereInput | shopping_admin_logsWhereInput[]\n    OR?: shopping_admin_logsWhereInput[]\n    NOT?: shopping_admin_logsWhereInput | shopping_admin_logsWhereInput[]\n    id?: UuidFilter<\"shopping_admin_logs\"> | string\n    shopping_administrator_id?: UuidNullableFilter<\"shopping_admin_logs\"> | string | null\n    log_type?: StringFilter<\"shopping_admin_logs\"> | string\n    message?: StringFilter<\"shopping_admin_logs\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_logs\"> | Date | string\n    administrator?: XOR<Shopping_administratorsNullableScalarRelationFilter, shopping_administratorsWhereInput> | null\n  }\n\n  export type shopping_admin_logsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrderInput | SortOrder\n    log_type?: SortOrder\n    message?: SortOrder\n    created_at?: SortOrder\n    administrator?: shopping_administratorsOrderByWithRelationInput\n  }\n\n  export type shopping_admin_logsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_admin_logsWhereInput | shopping_admin_logsWhereInput[]\n    OR?: shopping_admin_logsWhereInput[]\n    NOT?: shopping_admin_logsWhereInput | shopping_admin_logsWhereInput[]\n    shopping_administrator_id?: UuidNullableFilter<\"shopping_admin_logs\"> | string | null\n    log_type?: StringFilter<\"shopping_admin_logs\"> | string\n    message?: StringFilter<\"shopping_admin_logs\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_logs\"> | Date | string\n    administrator?: XOR<Shopping_administratorsNullableScalarRelationFilter, shopping_administratorsWhereInput> | null\n  }, \"id\">\n\n  export type shopping_admin_logsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrderInput | SortOrder\n    log_type?: SortOrder\n    message?: SortOrder\n    created_at?: SortOrder\n    _count?: shopping_admin_logsCountOrderByAggregateInput\n    _max?: shopping_admin_logsMaxOrderByAggregateInput\n    _min?: shopping_admin_logsMinOrderByAggregateInput\n  }\n\n  export type shopping_admin_logsScalarWhereWithAggregatesInput = {\n    AND?: shopping_admin_logsScalarWhereWithAggregatesInput | shopping_admin_logsScalarWhereWithAggregatesInput[]\n    OR?: shopping_admin_logsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_admin_logsScalarWhereWithAggregatesInput | shopping_admin_logsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_admin_logs\"> | string\n    shopping_administrator_id?: UuidNullableWithAggregatesFilter<\"shopping_admin_logs\"> | string | null\n    log_type?: StringWithAggregatesFilter<\"shopping_admin_logs\"> | string\n    message?: StringWithAggregatesFilter<\"shopping_admin_logs\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_admin_logs\"> | Date | string\n  }\n\n  export type shopping_paymentsWhereInput = {\n    AND?: shopping_paymentsWhereInput | shopping_paymentsWhereInput[]\n    OR?: shopping_paymentsWhereInput[]\n    NOT?: shopping_paymentsWhereInput | shopping_paymentsWhereInput[]\n    id?: UuidFilter<\"shopping_payments\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_payments\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_payments\"> | string\n    payment_method_id?: UuidFilter<\"shopping_payments\"> | string\n    amount?: FloatFilter<\"shopping_payments\"> | number\n    currency?: StringFilter<\"shopping_payments\"> | string\n    status?: StringFilter<\"shopping_payments\"> | string\n    transaction_id?: StringNullableFilter<\"shopping_payments\"> | string | null\n    payment_date?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payments\"> | Date | string | null\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    shopping_payment_transactions?: Shopping_payment_transactionsListRelationFilter\n  }\n\n  export type shopping_paymentsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    shopping_order_id?: SortOrder\n    payment_method_id?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    transaction_id?: SortOrderInput | SortOrder\n    payment_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    customer?: shopping_customersOrderByWithRelationInput\n    order?: shopping_ordersOrderByWithRelationInput\n    shopping_payment_transactions?: shopping_payment_transactionsOrderByRelationAggregateInput\n  }\n\n  export type shopping_paymentsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    transaction_id?: string\n    AND?: shopping_paymentsWhereInput | shopping_paymentsWhereInput[]\n    OR?: shopping_paymentsWhereInput[]\n    NOT?: shopping_paymentsWhereInput | shopping_paymentsWhereInput[]\n    shopping_customer_id?: UuidFilter<\"shopping_payments\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_payments\"> | string\n    payment_method_id?: UuidFilter<\"shopping_payments\"> | string\n    amount?: FloatFilter<\"shopping_payments\"> | number\n    currency?: StringFilter<\"shopping_payments\"> | string\n    status?: StringFilter<\"shopping_payments\"> | string\n    payment_date?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payments\"> | Date | string | null\n    customer?: XOR<Shopping_customersScalarRelationFilter, shopping_customersWhereInput>\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    shopping_payment_transactions?: Shopping_payment_transactionsListRelationFilter\n  }, \"id\" | \"transaction_id\">\n\n  export type shopping_paymentsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    shopping_order_id?: SortOrder\n    payment_method_id?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    transaction_id?: SortOrderInput | SortOrder\n    payment_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_paymentsCountOrderByAggregateInput\n    _avg?: shopping_paymentsAvgOrderByAggregateInput\n    _max?: shopping_paymentsMaxOrderByAggregateInput\n    _min?: shopping_paymentsMinOrderByAggregateInput\n    _sum?: shopping_paymentsSumOrderByAggregateInput\n  }\n\n  export type shopping_paymentsScalarWhereWithAggregatesInput = {\n    AND?: shopping_paymentsScalarWhereWithAggregatesInput | shopping_paymentsScalarWhereWithAggregatesInput[]\n    OR?: shopping_paymentsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_paymentsScalarWhereWithAggregatesInput | shopping_paymentsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_payments\"> | string\n    shopping_customer_id?: UuidWithAggregatesFilter<\"shopping_payments\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_payments\"> | string\n    payment_method_id?: UuidWithAggregatesFilter<\"shopping_payments\"> | string\n    amount?: FloatWithAggregatesFilter<\"shopping_payments\"> | number\n    currency?: StringWithAggregatesFilter<\"shopping_payments\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_payments\"> | string\n    transaction_id?: StringNullableWithAggregatesFilter<\"shopping_payments\"> | string | null\n    payment_date?: DateTimeWithAggregatesFilter<\"shopping_payments\"> | Date | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_payments\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_payments\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_payments\"> | Date | string | null\n  }\n\n  export type shopping_payment_methodsWhereInput = {\n    AND?: shopping_payment_methodsWhereInput | shopping_payment_methodsWhereInput[]\n    OR?: shopping_payment_methodsWhereInput[]\n    NOT?: shopping_payment_methodsWhereInput | shopping_payment_methodsWhereInput[]\n    id?: UuidFilter<\"shopping_payment_methods\"> | string\n    method_name?: StringFilter<\"shopping_payment_methods\"> | string\n    method_type?: StringFilter<\"shopping_payment_methods\"> | string\n    provider?: StringNullableFilter<\"shopping_payment_methods\"> | string | null\n    is_active?: BoolFilter<\"shopping_payment_methods\"> | boolean\n    created_at?: DateTimeFilter<\"shopping_payment_methods\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payment_methods\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payment_methods\"> | Date | string | null\n  }\n\n  export type shopping_payment_methodsOrderByWithRelationInput = {\n    id?: SortOrder\n    method_name?: SortOrder\n    method_type?: SortOrder\n    provider?: SortOrderInput | SortOrder\n    is_active?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n  }\n\n  export type shopping_payment_methodsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    method_name?: string\n    AND?: shopping_payment_methodsWhereInput | shopping_payment_methodsWhereInput[]\n    OR?: shopping_payment_methodsWhereInput[]\n    NOT?: shopping_payment_methodsWhereInput | shopping_payment_methodsWhereInput[]\n    method_type?: StringFilter<\"shopping_payment_methods\"> | string\n    provider?: StringNullableFilter<\"shopping_payment_methods\"> | string | null\n    is_active?: BoolFilter<\"shopping_payment_methods\"> | boolean\n    created_at?: DateTimeFilter<\"shopping_payment_methods\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payment_methods\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payment_methods\"> | Date | string | null\n  }, \"id\" | \"method_name\">\n\n  export type shopping_payment_methodsOrderByWithAggregationInput = {\n    id?: SortOrder\n    method_name?: SortOrder\n    method_type?: SortOrder\n    provider?: SortOrderInput | SortOrder\n    is_active?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_payment_methodsCountOrderByAggregateInput\n    _max?: shopping_payment_methodsMaxOrderByAggregateInput\n    _min?: shopping_payment_methodsMinOrderByAggregateInput\n  }\n\n  export type shopping_payment_methodsScalarWhereWithAggregatesInput = {\n    AND?: shopping_payment_methodsScalarWhereWithAggregatesInput | shopping_payment_methodsScalarWhereWithAggregatesInput[]\n    OR?: shopping_payment_methodsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_payment_methodsScalarWhereWithAggregatesInput | shopping_payment_methodsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_payment_methods\"> | string\n    method_name?: StringWithAggregatesFilter<\"shopping_payment_methods\"> | string\n    method_type?: StringWithAggregatesFilter<\"shopping_payment_methods\"> | string\n    provider?: StringNullableWithAggregatesFilter<\"shopping_payment_methods\"> | string | null\n    is_active?: BoolWithAggregatesFilter<\"shopping_payment_methods\"> | boolean\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_payment_methods\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_payment_methods\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_payment_methods\"> | Date | string | null\n  }\n\n  export type shopping_payment_transactionsWhereInput = {\n    AND?: shopping_payment_transactionsWhereInput | shopping_payment_transactionsWhereInput[]\n    OR?: shopping_payment_transactionsWhereInput[]\n    NOT?: shopping_payment_transactionsWhereInput | shopping_payment_transactionsWhereInput[]\n    id?: UuidFilter<\"shopping_payment_transactions\"> | string\n    shopping_payment_id?: UuidFilter<\"shopping_payment_transactions\"> | string\n    transaction_type?: StringFilter<\"shopping_payment_transactions\"> | string\n    amount?: FloatFilter<\"shopping_payment_transactions\"> | number\n    currency?: StringFilter<\"shopping_payment_transactions\"> | string\n    status?: StringFilter<\"shopping_payment_transactions\"> | string\n    gateway_response?: StringNullableFilter<\"shopping_payment_transactions\"> | string | null\n    transaction_date?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payment_transactions\"> | Date | string | null\n    payment?: XOR<Shopping_paymentsScalarRelationFilter, shopping_paymentsWhereInput>\n  }\n\n  export type shopping_payment_transactionsOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_payment_id?: SortOrder\n    transaction_type?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    gateway_response?: SortOrderInput | SortOrder\n    transaction_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    payment?: shopping_paymentsOrderByWithRelationInput\n  }\n\n  export type shopping_payment_transactionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: shopping_payment_transactionsWhereInput | shopping_payment_transactionsWhereInput[]\n    OR?: shopping_payment_transactionsWhereInput[]\n    NOT?: shopping_payment_transactionsWhereInput | shopping_payment_transactionsWhereInput[]\n    shopping_payment_id?: UuidFilter<\"shopping_payment_transactions\"> | string\n    transaction_type?: StringFilter<\"shopping_payment_transactions\"> | string\n    amount?: FloatFilter<\"shopping_payment_transactions\"> | number\n    currency?: StringFilter<\"shopping_payment_transactions\"> | string\n    status?: StringFilter<\"shopping_payment_transactions\"> | string\n    gateway_response?: StringNullableFilter<\"shopping_payment_transactions\"> | string | null\n    transaction_date?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payment_transactions\"> | Date | string | null\n    payment?: XOR<Shopping_paymentsScalarRelationFilter, shopping_paymentsWhereInput>\n  }, \"id\">\n\n  export type shopping_payment_transactionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_payment_id?: SortOrder\n    transaction_type?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    gateway_response?: SortOrderInput | SortOrder\n    transaction_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: shopping_payment_transactionsCountOrderByAggregateInput\n    _avg?: shopping_payment_transactionsAvgOrderByAggregateInput\n    _max?: shopping_payment_transactionsMaxOrderByAggregateInput\n    _min?: shopping_payment_transactionsMinOrderByAggregateInput\n    _sum?: shopping_payment_transactionsSumOrderByAggregateInput\n  }\n\n  export type shopping_payment_transactionsScalarWhereWithAggregatesInput = {\n    AND?: shopping_payment_transactionsScalarWhereWithAggregatesInput | shopping_payment_transactionsScalarWhereWithAggregatesInput[]\n    OR?: shopping_payment_transactionsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_payment_transactionsScalarWhereWithAggregatesInput | shopping_payment_transactionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_payment_transactions\"> | string\n    shopping_payment_id?: UuidWithAggregatesFilter<\"shopping_payment_transactions\"> | string\n    transaction_type?: StringWithAggregatesFilter<\"shopping_payment_transactions\"> | string\n    amount?: FloatWithAggregatesFilter<\"shopping_payment_transactions\"> | number\n    currency?: StringWithAggregatesFilter<\"shopping_payment_transactions\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_payment_transactions\"> | string\n    gateway_response?: StringNullableWithAggregatesFilter<\"shopping_payment_transactions\"> | string | null\n    transaction_date?: DateTimeWithAggregatesFilter<\"shopping_payment_transactions\"> | Date | string\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_payment_transactions\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_payment_transactions\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"shopping_payment_transactions\"> | Date | string | null\n  }\n\n  export type shopping_shipping_methodsWhereInput = {\n    AND?: shopping_shipping_methodsWhereInput | shopping_shipping_methodsWhereInput[]\n    OR?: shopping_shipping_methodsWhereInput[]\n    NOT?: shopping_shipping_methodsWhereInput | shopping_shipping_methodsWhereInput[]\n    id?: UuidFilter<\"shopping_shipping_methods\"> | string\n    name?: StringFilter<\"shopping_shipping_methods\"> | string\n    description?: StringNullableFilter<\"shopping_shipping_methods\"> | string | null\n    cost?: FloatFilter<\"shopping_shipping_methods\"> | number\n    estimated_delivery_days?: IntFilter<\"shopping_shipping_methods\"> | number\n    created_at?: DateTimeFilter<\"shopping_shipping_methods\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_methods\"> | Date | string\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }\n\n  export type shopping_shipping_methodsOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    shopping_shipping_tracking?: shopping_shipping_trackingOrderByRelationAggregateInput\n  }\n\n  export type shopping_shipping_methodsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: shopping_shipping_methodsWhereInput | shopping_shipping_methodsWhereInput[]\n    OR?: shopping_shipping_methodsWhereInput[]\n    NOT?: shopping_shipping_methodsWhereInput | shopping_shipping_methodsWhereInput[]\n    description?: StringNullableFilter<\"shopping_shipping_methods\"> | string | null\n    cost?: FloatFilter<\"shopping_shipping_methods\"> | number\n    estimated_delivery_days?: IntFilter<\"shopping_shipping_methods\"> | number\n    created_at?: DateTimeFilter<\"shopping_shipping_methods\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_methods\"> | Date | string\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type shopping_shipping_methodsOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_shipping_methodsCountOrderByAggregateInput\n    _avg?: shopping_shipping_methodsAvgOrderByAggregateInput\n    _max?: shopping_shipping_methodsMaxOrderByAggregateInput\n    _min?: shopping_shipping_methodsMinOrderByAggregateInput\n    _sum?: shopping_shipping_methodsSumOrderByAggregateInput\n  }\n\n  export type shopping_shipping_methodsScalarWhereWithAggregatesInput = {\n    AND?: shopping_shipping_methodsScalarWhereWithAggregatesInput | shopping_shipping_methodsScalarWhereWithAggregatesInput[]\n    OR?: shopping_shipping_methodsScalarWhereWithAggregatesInput[]\n    NOT?: shopping_shipping_methodsScalarWhereWithAggregatesInput | shopping_shipping_methodsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_shipping_methods\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_shipping_methods\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_shipping_methods\"> | string | null\n    cost?: FloatWithAggregatesFilter<\"shopping_shipping_methods\"> | number\n    estimated_delivery_days?: IntWithAggregatesFilter<\"shopping_shipping_methods\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_methods\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_methods\"> | Date | string\n  }\n\n  export type shopping_shipping_carriersWhereInput = {\n    AND?: shopping_shipping_carriersWhereInput | shopping_shipping_carriersWhereInput[]\n    OR?: shopping_shipping_carriersWhereInput[]\n    NOT?: shopping_shipping_carriersWhereInput | shopping_shipping_carriersWhereInput[]\n    id?: UuidFilter<\"shopping_shipping_carriers\"> | string\n    name?: StringFilter<\"shopping_shipping_carriers\"> | string\n    description?: StringNullableFilter<\"shopping_shipping_carriers\"> | string | null\n    tracking_url_template?: StringNullableFilter<\"shopping_shipping_carriers\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_shipping_carriers\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_carriers\"> | Date | string\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }\n\n  export type shopping_shipping_carriersOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    tracking_url_template?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    shopping_shipping_tracking?: shopping_shipping_trackingOrderByRelationAggregateInput\n  }\n\n  export type shopping_shipping_carriersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: shopping_shipping_carriersWhereInput | shopping_shipping_carriersWhereInput[]\n    OR?: shopping_shipping_carriersWhereInput[]\n    NOT?: shopping_shipping_carriersWhereInput | shopping_shipping_carriersWhereInput[]\n    description?: StringNullableFilter<\"shopping_shipping_carriers\"> | string | null\n    tracking_url_template?: StringNullableFilter<\"shopping_shipping_carriers\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_shipping_carriers\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_carriers\"> | Date | string\n    shopping_shipping_tracking?: Shopping_shipping_trackingListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type shopping_shipping_carriersOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    tracking_url_template?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_shipping_carriersCountOrderByAggregateInput\n    _max?: shopping_shipping_carriersMaxOrderByAggregateInput\n    _min?: shopping_shipping_carriersMinOrderByAggregateInput\n  }\n\n  export type shopping_shipping_carriersScalarWhereWithAggregatesInput = {\n    AND?: shopping_shipping_carriersScalarWhereWithAggregatesInput | shopping_shipping_carriersScalarWhereWithAggregatesInput[]\n    OR?: shopping_shipping_carriersScalarWhereWithAggregatesInput[]\n    NOT?: shopping_shipping_carriersScalarWhereWithAggregatesInput | shopping_shipping_carriersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_shipping_carriers\"> | string\n    name?: StringWithAggregatesFilter<\"shopping_shipping_carriers\"> | string\n    description?: StringNullableWithAggregatesFilter<\"shopping_shipping_carriers\"> | string | null\n    tracking_url_template?: StringNullableWithAggregatesFilter<\"shopping_shipping_carriers\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_carriers\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_carriers\"> | Date | string\n  }\n\n  export type shopping_shipping_trackingWhereInput = {\n    AND?: shopping_shipping_trackingWhereInput | shopping_shipping_trackingWhereInput[]\n    OR?: shopping_shipping_trackingWhereInput[]\n    NOT?: shopping_shipping_trackingWhereInput | shopping_shipping_trackingWhereInput[]\n    id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_carrier_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_method_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    tracking_number?: StringFilter<\"shopping_shipping_tracking\"> | string\n    status?: StringFilter<\"shopping_shipping_tracking\"> | string\n    estimated_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    actual_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    carrier?: XOR<Shopping_shipping_carriersScalarRelationFilter, shopping_shipping_carriersWhereInput>\n    method?: XOR<Shopping_shipping_methodsScalarRelationFilter, shopping_shipping_methodsWhereInput>\n  }\n\n  export type shopping_shipping_trackingOrderByWithRelationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_shipping_carrier_id?: SortOrder\n    shopping_shipping_method_id?: SortOrder\n    tracking_number?: SortOrder\n    status?: SortOrder\n    estimated_delivery_date?: SortOrderInput | SortOrder\n    actual_delivery_date?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    order?: shopping_ordersOrderByWithRelationInput\n    carrier?: shopping_shipping_carriersOrderByWithRelationInput\n    method?: shopping_shipping_methodsOrderByWithRelationInput\n  }\n\n  export type shopping_shipping_trackingWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    tracking_number?: string\n    AND?: shopping_shipping_trackingWhereInput | shopping_shipping_trackingWhereInput[]\n    OR?: shopping_shipping_trackingWhereInput[]\n    NOT?: shopping_shipping_trackingWhereInput | shopping_shipping_trackingWhereInput[]\n    shopping_order_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_carrier_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_method_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    status?: StringFilter<\"shopping_shipping_tracking\"> | string\n    estimated_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    actual_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n    order?: XOR<Shopping_ordersScalarRelationFilter, shopping_ordersWhereInput>\n    carrier?: XOR<Shopping_shipping_carriersScalarRelationFilter, shopping_shipping_carriersWhereInput>\n    method?: XOR<Shopping_shipping_methodsScalarRelationFilter, shopping_shipping_methodsWhereInput>\n  }, \"id\" | \"tracking_number\">\n\n  export type shopping_shipping_trackingOrderByWithAggregationInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_shipping_carrier_id?: SortOrder\n    shopping_shipping_method_id?: SortOrder\n    tracking_number?: SortOrder\n    status?: SortOrder\n    estimated_delivery_date?: SortOrderInput | SortOrder\n    actual_delivery_date?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: shopping_shipping_trackingCountOrderByAggregateInput\n    _max?: shopping_shipping_trackingMaxOrderByAggregateInput\n    _min?: shopping_shipping_trackingMinOrderByAggregateInput\n  }\n\n  export type shopping_shipping_trackingScalarWhereWithAggregatesInput = {\n    AND?: shopping_shipping_trackingScalarWhereWithAggregatesInput | shopping_shipping_trackingScalarWhereWithAggregatesInput[]\n    OR?: shopping_shipping_trackingScalarWhereWithAggregatesInput[]\n    NOT?: shopping_shipping_trackingScalarWhereWithAggregatesInput | shopping_shipping_trackingScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    shopping_order_id?: UuidWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_carrier_id?: UuidWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_method_id?: UuidWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    tracking_number?: StringWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    status?: StringWithAggregatesFilter<\"shopping_shipping_tracking\"> | string\n    estimated_delivery_date?: DateTimeNullableWithAggregatesFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    actual_delivery_date?: DateTimeNullableWithAggregatesFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_tracking\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"shopping_shipping_tracking\"> | Date | string\n  }\n\n  export type shopping_channelsCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n    shopping_channel_categories?: shopping_channel_categoriesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n    shopping_channel_categories?: shopping_channel_categoriesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsCreateManyInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channelsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channelsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sectionsCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n    shopping_channel_categories?: shopping_channel_categoriesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateInput = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n    shopping_channel_categories?: shopping_channel_categoriesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsCreateManyInput = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_channel_categoriesInput\n    section: shopping_sectionsCreateNestedOneWithoutShopping_channel_categoriesInput\n  }\n\n  export type shopping_channel_categoriesUncheckedCreateInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateManyInput = {\n    id: string\n    shopping_channel_id: string\n    shopping_section_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_customersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n  }\n\n  export type shopping_customersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_customersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_sellersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutSellerInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutSellerInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutSellerNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_sellersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutSellerNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_sellersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n  }\n\n  export type shopping_sellersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_sellersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_administratorsCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutAdministratorInput\n    shopping_admin_actions?: shopping_admin_actionsCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutAdministratorInput\n    shopping_admin_actions?: shopping_admin_actionsUncheckedCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_actions?: shopping_admin_actionsUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_actions?: shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n  }\n\n  export type shopping_administratorsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type shopping_administratorsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type shopping_productsCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    category?: shopping_categoriesCreateNestedOneWithoutShopping_productsInput\n    shopping_product_variants?: shopping_product_variantsCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    category?: shopping_categoriesUpdateOneWithoutShopping_productsNestedInput\n    shopping_product_variants?: shopping_product_variantsUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsCreateManyInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n  }\n\n  export type shopping_productsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_productsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_product_variantsCreateInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_variantsInput\n    shopping_inventory?: shopping_inventoryCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput\n    shopping_inventory?: shopping_inventoryUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsCreateManyInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_product_variantsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_product_variantsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_categoriesCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    parent?: shopping_categoriesCreateNestedOneWithoutRecursiveInput\n    shopping_products?: shopping_productsCreateNestedManyWithoutCategoryInput\n    recursive?: shopping_categoriesCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesUncheckedCreateInput = {\n    id: string\n    parent_id?: string | null\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_products?: shopping_productsUncheckedCreateNestedManyWithoutCategoryInput\n    recursive?: shopping_categoriesUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    parent?: shopping_categoriesUpdateOneWithoutRecursiveNestedInput\n    shopping_products?: shopping_productsUpdateManyWithoutCategoryNestedInput\n    recursive?: shopping_categoriesUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_categoriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_products?: shopping_productsUncheckedUpdateManyWithoutCategoryNestedInput\n    recursive?: shopping_categoriesUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_categoriesCreateManyInput = {\n    id: string\n    parent_id?: string | null\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_categoriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_categoriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_inventoryCreateInput = {\n    id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    variant: shopping_product_variantsCreateNestedOneWithoutShopping_inventoryInput\n    product: shopping_productsCreateNestedOneWithoutShopping_inventoryInput\n  }\n\n  export type shopping_inventoryUncheckedCreateInput = {\n    id: string\n    shopping_product_variant_id: string\n    shopping_product_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_inventoryUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    variant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_inventoryNestedInput\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_inventoryNestedInput\n  }\n\n  export type shopping_inventoryUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_inventoryCreateManyInput = {\n    id: string\n    shopping_product_variant_id: string\n    shopping_product_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_inventoryUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_inventoryUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_product_reviewsCreateInput = {\n    id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_reviewsInput\n    customer: shopping_customersCreateNestedOneWithoutShopping_product_reviewsInput\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUncheckedCreateInput = {\n    id: string\n    shopping_product_id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsCreateManyInput = {\n    id: string\n    shopping_product_id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_product_reviewsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_ordersCreateInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersCreateManyInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_ordersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_ordersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_order_itemsCreateInput = {\n    id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_itemsInput\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_order_itemsInput\n  }\n\n  export type shopping_order_itemsUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_itemsNestedInput\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_order_itemsNestedInput\n  }\n\n  export type shopping_order_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_statusCreateInput = {\n    id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_statusInput\n  }\n\n  export type shopping_order_statusUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n  }\n\n  export type shopping_order_statusUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_statusNestedInput\n  }\n\n  export type shopping_order_statusUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_statusCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n  }\n\n  export type shopping_order_statusUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_statusUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyCreateInput = {\n    id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_historyInput\n  }\n\n  export type shopping_order_historyUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n  }\n\n  export type shopping_order_historyUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_historyNestedInput\n  }\n\n  export type shopping_order_historyUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n  }\n\n  export type shopping_order_historyUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_shopping_cartsCreateInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    customer: shopping_customersCreateNestedOneWithoutShopping_shopping_cartsInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_shopping_cartsUncheckedCreateInput = {\n    id: string\n    shopping_customer_id: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_shopping_cartsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_shopping_cartsNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_shopping_cartsCreateManyInput = {\n    id: string\n    shopping_customer_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shopping_cartsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    cart: shopping_shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateInput = {\n    id: string\n    shopping_shopping_cart_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    cart?: shopping_shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateManyInput = {\n    id: string\n    shopping_shopping_cart_id: string\n    shopping_product_variant_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_moderationCreateInput = {\n    id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n    review: shopping_product_reviewsCreateNestedOneWithoutShopping_review_moderationInput\n    administrator: shopping_administratorsCreateNestedOneWithoutShopping_review_moderationInput\n  }\n\n  export type shopping_review_moderationUncheckedCreateInput = {\n    id: string\n    shopping_product_review_id: string\n    shopping_administrator_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    review?: shopping_product_reviewsUpdateOneRequiredWithoutShopping_review_moderationNestedInput\n    administrator?: shopping_administratorsUpdateOneRequiredWithoutShopping_review_moderationNestedInput\n  }\n\n  export type shopping_review_moderationUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_moderationCreateManyInput = {\n    id: string\n    shopping_product_review_id: string\n    shopping_administrator_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_moderationUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsCreateInput = {\n    id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n    review: shopping_product_reviewsCreateNestedOneWithoutShopping_review_ratingsInput\n  }\n\n  export type shopping_review_ratingsUncheckedCreateInput = {\n    id: string\n    shopping_product_review_id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n  }\n\n  export type shopping_review_ratingsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    review?: shopping_product_reviewsUpdateOneRequiredWithoutShopping_review_ratingsNestedInput\n  }\n\n  export type shopping_review_ratingsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsCreateManyInput = {\n    id: string\n    shopping_product_review_id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n  }\n\n  export type shopping_review_ratingsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_seller_productsCreateInput = {\n    id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    seller: shopping_sellersCreateNestedOneWithoutShopping_seller_productsInput\n    product: shopping_productsCreateNestedOneWithoutShopping_seller_productsInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsUncheckedCreateInput = {\n    id: string\n    shopping_seller_id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    seller?: shopping_sellersUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsCreateManyInput = {\n    id: string\n    shopping_seller_id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_productsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_productsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_inventoryCreateInput = {\n    id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sellerProduct: shopping_seller_productsCreateNestedOneWithoutShopping_seller_inventoryInput\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_seller_inventoryInput\n  }\n\n  export type shopping_seller_inventoryUncheckedCreateInput = {\n    id: string\n    shopping_seller_product_id: string\n    shopping_product_variant_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_inventoryUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sellerProduct?: shopping_seller_productsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_inventoryCreateManyInput = {\n    id: string\n    shopping_seller_product_id: string\n    shopping_product_variant_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_inventoryUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersCreateInput = {\n    id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    seller: shopping_sellersCreateNestedOneWithoutShopping_seller_ordersInput\n    order: shopping_ordersCreateNestedOneWithoutShopping_seller_ordersInput\n  }\n\n  export type shopping_seller_ordersUncheckedCreateInput = {\n    id: string\n    shopping_seller_id: string\n    shopping_order_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_ordersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    seller?: shopping_sellersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersCreateManyInput = {\n    id: string\n    shopping_seller_id: string\n    shopping_order_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_ordersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_admin_actionsCreateInput = {\n    id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n    administrator: shopping_administratorsCreateNestedOneWithoutShopping_admin_actionsInput\n  }\n\n  export type shopping_admin_actionsUncheckedCreateInput = {\n    id: string\n    shopping_administrator_id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_actionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    administrator?: shopping_administratorsUpdateOneRequiredWithoutShopping_admin_actionsNestedInput\n  }\n\n  export type shopping_admin_actionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_actionsCreateManyInput = {\n    id: string\n    shopping_administrator_id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_actionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_actionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsCreateInput = {\n    id: string\n    log_type: string\n    message: string\n    created_at: Date | string\n    administrator?: shopping_administratorsCreateNestedOneWithoutShopping_admin_logsInput\n  }\n\n  export type shopping_admin_logsUncheckedCreateInput = {\n    id: string\n    shopping_administrator_id?: string | null\n    log_type: string\n    message: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_logsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    administrator?: shopping_administratorsUpdateOneWithoutShopping_admin_logsNestedInput\n  }\n\n  export type shopping_admin_logsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: NullableStringFieldUpdateOperationsInput | string | null\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsCreateManyInput = {\n    id: string\n    shopping_administrator_id?: string | null\n    log_type: string\n    message: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_logsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: NullableStringFieldUpdateOperationsInput | string | null\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_paymentsCreateInput = {\n    id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_paymentsInput\n    order: shopping_ordersCreateNestedOneWithoutShopping_paymentsInput\n    shopping_payment_transactions?: shopping_payment_transactionsCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsUncheckedCreateInput = {\n    id: string\n    shopping_customer_id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n    shopping_payment_transactions?: shopping_payment_transactionsUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsCreateManyInput = {\n    id: string\n    shopping_customer_id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_paymentsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_paymentsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_methodsCreateInput = {\n    id: string\n    method_name: string\n    method_type: string\n    provider?: string | null\n    is_active: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_methodsUncheckedCreateInput = {\n    id: string\n    method_name: string\n    method_type: string\n    provider?: string | null\n    is_active: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_methodsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    method_name?: StringFieldUpdateOperationsInput | string\n    method_type?: StringFieldUpdateOperationsInput | string\n    provider?: NullableStringFieldUpdateOperationsInput | string | null\n    is_active?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_methodsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    method_name?: StringFieldUpdateOperationsInput | string\n    method_type?: StringFieldUpdateOperationsInput | string\n    provider?: NullableStringFieldUpdateOperationsInput | string | null\n    is_active?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_methodsCreateManyInput = {\n    id: string\n    method_name: string\n    method_type: string\n    provider?: string | null\n    is_active: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_methodsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    method_name?: StringFieldUpdateOperationsInput | string\n    method_type?: StringFieldUpdateOperationsInput | string\n    provider?: NullableStringFieldUpdateOperationsInput | string | null\n    is_active?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_methodsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    method_name?: StringFieldUpdateOperationsInput | string\n    method_type?: StringFieldUpdateOperationsInput | string\n    provider?: NullableStringFieldUpdateOperationsInput | string | null\n    is_active?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsCreateInput = {\n    id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    payment: shopping_paymentsCreateNestedOneWithoutShopping_payment_transactionsInput\n  }\n\n  export type shopping_payment_transactionsUncheckedCreateInput = {\n    id: string\n    shopping_payment_id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_transactionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    payment?: shopping_paymentsUpdateOneRequiredWithoutShopping_payment_transactionsNestedInput\n  }\n\n  export type shopping_payment_transactionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_payment_id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsCreateManyInput = {\n    id: string\n    shopping_payment_id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_transactionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_payment_id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_shipping_methodsCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutMethodInput\n  }\n\n  export type shopping_shipping_methodsUncheckedCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutMethodInput\n  }\n\n  export type shopping_shipping_methodsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutMethodNestedInput\n  }\n\n  export type shopping_shipping_methodsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutMethodNestedInput\n  }\n\n  export type shopping_shipping_methodsCreateManyInput = {\n    id: string\n    name: string\n    description?: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_methodsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_methodsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_carriersCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    tracking_url_template?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutCarrierInput\n  }\n\n  export type shopping_shipping_carriersUncheckedCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    tracking_url_template?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutCarrierInput\n  }\n\n  export type shopping_shipping_carriersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutCarrierNestedInput\n  }\n\n  export type shopping_shipping_carriersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutCarrierNestedInput\n  }\n\n  export type shopping_shipping_carriersCreateManyInput = {\n    id: string\n    name: string\n    description?: string | null\n    tracking_url_template?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_carriersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_carriersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingCreateInput = {\n    id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_shipping_trackingInput\n    carrier: shopping_shipping_carriersCreateNestedOneWithoutShopping_shipping_trackingInput\n    method: shopping_shipping_methodsCreateNestedOneWithoutShopping_shipping_trackingInput\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_carrier_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n    carrier?: shopping_shipping_carriersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n    method?: shopping_shipping_methodsUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingCreateManyInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_carrier_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type Shopping_sectionsListRelationFilter = {\n    every?: shopping_sectionsWhereInput\n    some?: shopping_sectionsWhereInput\n    none?: shopping_sectionsWhereInput\n  }\n\n  export type Shopping_channel_categoriesListRelationFilter = {\n    every?: shopping_channel_categoriesWhereInput\n    some?: shopping_channel_categoriesWhereInput\n    none?: shopping_channel_categoriesWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type shopping_sectionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_channel_categoriesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_channelsCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channelsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channelsMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type Shopping_channelsScalarRelationFilter = {\n    is?: shopping_channelsWhereInput\n    isNot?: shopping_channelsWhereInput\n  }\n\n  export type shopping_sectionsShopping_channel_idNameCompoundUniqueInput = {\n    shopping_channel_id: string\n    name: string\n  }\n\n  export type shopping_sectionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sectionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_sectionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_sectionsScalarRelationFilter = {\n    is?: shopping_sectionsWhereInput\n    isNot?: shopping_sectionsWhereInput\n  }\n\n  export type shopping_channel_categoriesShopping_channel_idShopping_section_idNameCompoundUniqueInput = {\n    shopping_channel_id: string\n    shopping_section_id: string\n    name: string\n  }\n\n  export type shopping_channel_categoriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channel_categoriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_channel_categoriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_channel_id?: SortOrder\n    shopping_section_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type Shopping_product_reviewsListRelationFilter = {\n    every?: shopping_product_reviewsWhereInput\n    some?: shopping_product_reviewsWhereInput\n    none?: shopping_product_reviewsWhereInput\n  }\n\n  export type Shopping_ordersListRelationFilter = {\n    every?: shopping_ordersWhereInput\n    some?: shopping_ordersWhereInput\n    none?: shopping_ordersWhereInput\n  }\n\n  export type Shopping_shopping_cartsListRelationFilter = {\n    every?: shopping_shopping_cartsWhereInput\n    some?: shopping_shopping_cartsWhereInput\n    none?: shopping_shopping_cartsWhereInput\n  }\n\n  export type Shopping_paymentsListRelationFilter = {\n    every?: shopping_paymentsWhereInput\n    some?: shopping_paymentsWhereInput\n    none?: shopping_paymentsWhereInput\n  }\n\n  export type shopping_product_reviewsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_ordersOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_shopping_cartsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_paymentsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_customersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n  }\n\n  export type shopping_customersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n  }\n\n  export type shopping_customersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n  }\n\n  export type Shopping_seller_productsListRelationFilter = {\n    every?: shopping_seller_productsWhereInput\n    some?: shopping_seller_productsWhereInput\n    none?: shopping_seller_productsWhereInput\n  }\n\n  export type Shopping_seller_ordersListRelationFilter = {\n    every?: shopping_seller_ordersWhereInput\n    some?: shopping_seller_ordersWhereInput\n    none?: shopping_seller_ordersWhereInput\n  }\n\n  export type shopping_seller_productsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_seller_ordersOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_sellersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    business_name?: SortOrder\n    contact_name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    tax_id?: SortOrder\n  }\n\n  export type shopping_sellersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    business_name?: SortOrder\n    contact_name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    tax_id?: SortOrder\n  }\n\n  export type shopping_sellersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    business_name?: SortOrder\n    contact_name?: SortOrder\n    phone?: SortOrder\n    address?: SortOrder\n    tax_id?: SortOrder\n  }\n\n  export type Shopping_review_moderationListRelationFilter = {\n    every?: shopping_review_moderationWhereInput\n    some?: shopping_review_moderationWhereInput\n    none?: shopping_review_moderationWhereInput\n  }\n\n  export type Shopping_admin_actionsListRelationFilter = {\n    every?: shopping_admin_actionsWhereInput\n    some?: shopping_admin_actionsWhereInput\n    none?: shopping_admin_actionsWhereInput\n  }\n\n  export type Shopping_admin_logsListRelationFilter = {\n    every?: shopping_admin_logsWhereInput\n    some?: shopping_admin_logsWhereInput\n    none?: shopping_admin_logsWhereInput\n  }\n\n  export type shopping_review_moderationOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_admin_actionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_admin_logsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_administratorsCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n  }\n\n  export type shopping_administratorsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n  }\n\n  export type shopping_administratorsMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    name?: SortOrder\n    phone?: SortOrder\n    role?: SortOrder\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type FloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type Shopping_categoriesNullableScalarRelationFilter = {\n    is?: shopping_categoriesWhereInput | null\n    isNot?: shopping_categoriesWhereInput | null\n  }\n\n  export type Shopping_product_variantsListRelationFilter = {\n    every?: shopping_product_variantsWhereInput\n    some?: shopping_product_variantsWhereInput\n    none?: shopping_product_variantsWhereInput\n  }\n\n  export type Shopping_inventoryListRelationFilter = {\n    every?: shopping_inventoryWhereInput\n    some?: shopping_inventoryWhereInput\n    none?: shopping_inventoryWhereInput\n  }\n\n  export type shopping_product_variantsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_inventoryOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_productsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_category_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    sku?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    password_hash?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_productsAvgOrderByAggregateInput = {\n    price?: SortOrder\n  }\n\n  export type shopping_productsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_category_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    sku?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    password_hash?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_productsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_category_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    price?: SortOrder\n    sku?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    password_hash?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_productsSumOrderByAggregateInput = {\n    price?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type FloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type FloatNullableFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type Shopping_productsScalarRelationFilter = {\n    is?: shopping_productsWhereInput\n    isNot?: shopping_productsWhereInput\n  }\n\n  export type Shopping_inventoryNullableScalarRelationFilter = {\n    is?: shopping_inventoryWhereInput | null\n    isNot?: shopping_inventoryWhereInput | null\n  }\n\n  export type Shopping_order_itemsListRelationFilter = {\n    every?: shopping_order_itemsWhereInput\n    some?: shopping_order_itemsWhereInput\n    none?: shopping_order_itemsWhereInput\n  }\n\n  export type Shopping_cart_itemsListRelationFilter = {\n    every?: shopping_cart_itemsWhereInput\n    some?: shopping_cart_itemsWhereInput\n    none?: shopping_cart_itemsWhereInput\n  }\n\n  export type Shopping_seller_inventoryListRelationFilter = {\n    every?: shopping_seller_inventoryWhereInput\n    some?: shopping_seller_inventoryWhereInput\n    none?: shopping_seller_inventoryWhereInput\n  }\n\n  export type shopping_order_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_cart_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_seller_inventoryOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_product_variantsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    sku?: SortOrder\n    option_name?: SortOrder\n    option_value?: SortOrder\n    price_adjustment?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_variantsAvgOrderByAggregateInput = {\n    price_adjustment?: SortOrder\n  }\n\n  export type shopping_product_variantsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    sku?: SortOrder\n    option_name?: SortOrder\n    option_value?: SortOrder\n    price_adjustment?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_variantsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    sku?: SortOrder\n    option_name?: SortOrder\n    option_value?: SortOrder\n    price_adjustment?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_variantsSumOrderByAggregateInput = {\n    price_adjustment?: SortOrder\n  }\n\n  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedFloatNullableFilter<$PrismaModel>\n    _min?: NestedFloatNullableFilter<$PrismaModel>\n    _max?: NestedFloatNullableFilter<$PrismaModel>\n  }\n\n  export type Shopping_productsListRelationFilter = {\n    every?: shopping_productsWhereInput\n    some?: shopping_productsWhereInput\n    none?: shopping_productsWhereInput\n  }\n\n  export type Shopping_categoriesListRelationFilter = {\n    every?: shopping_categoriesWhereInput\n    some?: shopping_categoriesWhereInput\n    none?: shopping_categoriesWhereInput\n  }\n\n  export type shopping_productsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_categoriesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_categoriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    parent_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    code?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_categoriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    parent_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    code?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_categoriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    parent_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    code?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type IntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type IntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type Shopping_product_variantsScalarRelationFilter = {\n    is?: shopping_product_variantsWhereInput\n    isNot?: shopping_product_variantsWhereInput\n  }\n\n  export type shopping_inventoryCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    shopping_product_id?: SortOrder\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    last_stock_update?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_inventoryAvgOrderByAggregateInput = {\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n  }\n\n  export type shopping_inventoryMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    shopping_product_id?: SortOrder\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    last_stock_update?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_inventoryMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    shopping_product_id?: SortOrder\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    last_stock_update?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_inventorySumOrderByAggregateInput = {\n    quantity?: SortOrder\n    reserved_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n  }\n\n  export type IntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type Shopping_customersScalarRelationFilter = {\n    is?: shopping_customersWhereInput\n    isNot?: shopping_customersWhereInput\n  }\n\n  export type Shopping_review_ratingsListRelationFilter = {\n    every?: shopping_review_ratingsWhereInput\n    some?: shopping_review_ratingsWhereInput\n    none?: shopping_review_ratingsWhereInput\n  }\n\n  export type shopping_review_ratingsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_product_reviewsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    shopping_customer_id?: SortOrder\n    rating?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_reviewsAvgOrderByAggregateInput = {\n    rating?: SortOrder\n  }\n\n  export type shopping_product_reviewsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    shopping_customer_id?: SortOrder\n    rating?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_reviewsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_id?: SortOrder\n    shopping_customer_id?: SortOrder\n    rating?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    business_status?: SortOrder\n  }\n\n  export type shopping_product_reviewsSumOrderByAggregateInput = {\n    rating?: SortOrder\n  }\n\n  export type Shopping_order_statusListRelationFilter = {\n    every?: shopping_order_statusWhereInput\n    some?: shopping_order_statusWhereInput\n    none?: shopping_order_statusWhereInput\n  }\n\n  export type Shopping_order_historyListRelationFilter = {\n    every?: shopping_order_historyWhereInput\n    some?: shopping_order_historyWhereInput\n    none?: shopping_order_historyWhereInput\n  }\n\n  export type Shopping_shipping_trackingListRelationFilter = {\n    every?: shopping_shipping_trackingWhereInput\n    some?: shopping_shipping_trackingWhereInput\n    none?: shopping_shipping_trackingWhereInput\n  }\n\n  export type shopping_order_statusOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_order_historyOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_shipping_trackingOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_ordersCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    order_code?: SortOrder\n    total_amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    payment_method?: SortOrder\n    shipping_method?: SortOrder\n    shipping_address?: SortOrder\n    billing_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersAvgOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type shopping_ordersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    order_code?: SortOrder\n    total_amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    payment_method?: SortOrder\n    shipping_method?: SortOrder\n    shipping_address?: SortOrder\n    billing_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    order_code?: SortOrder\n    total_amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    payment_method?: SortOrder\n    shipping_method?: SortOrder\n    shipping_address?: SortOrder\n    billing_address?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_ordersSumOrderByAggregateInput = {\n    total_amount?: SortOrder\n  }\n\n  export type Shopping_ordersScalarRelationFilter = {\n    is?: shopping_ordersWhereInput\n    isNot?: shopping_ordersWhereInput\n  }\n\n  export type shopping_order_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsAvgOrderByAggregateInput = {\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n  }\n\n  export type shopping_order_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_order_itemsSumOrderByAggregateInput = {\n    quantity?: SortOrder\n    unit_price?: SortOrder\n    total_price?: SortOrder\n  }\n\n  export type shopping_order_statusCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    status?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    notes?: SortOrder\n  }\n\n  export type shopping_order_statusMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    status?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    notes?: SortOrder\n  }\n\n  export type shopping_order_statusMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    status?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    notes?: SortOrder\n  }\n\n  export type shopping_order_historyCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    action?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    details?: SortOrder\n  }\n\n  export type shopping_order_historyMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    action?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    details?: SortOrder\n  }\n\n  export type shopping_order_historyMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    action?: SortOrder\n    changed_at?: SortOrder\n    changed_by?: SortOrder\n    details?: SortOrder\n  }\n\n  export type shopping_shopping_cartsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shopping_cartsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shopping_cartsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type Shopping_shopping_cartsScalarRelationFilter = {\n    is?: shopping_shopping_cartsWhereInput\n    isNot?: shopping_shopping_cartsWhereInput\n  }\n\n  export type shopping_cart_itemsShopping_shopping_cart_idShopping_product_variant_idCompoundUniqueInput = {\n    shopping_shopping_cart_id: string\n    shopping_product_variant_id: string\n  }\n\n  export type shopping_cart_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_shopping_cart_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsAvgOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type shopping_cart_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_shopping_cart_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_shopping_cart_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    quantity?: SortOrder\n    price?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_cart_itemsSumOrderByAggregateInput = {\n    quantity?: SortOrder\n    price?: SortOrder\n  }\n\n  export type Shopping_product_reviewsScalarRelationFilter = {\n    is?: shopping_product_reviewsWhereInput\n    isNot?: shopping_product_reviewsWhereInput\n  }\n\n  export type Shopping_administratorsScalarRelationFilter = {\n    is?: shopping_administratorsWhereInput\n    isNot?: shopping_administratorsWhereInput\n  }\n\n  export type shopping_review_moderationCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_moderationMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_moderationMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_ratingsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_ratingsAvgOrderByAggregateInput = {\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n  }\n\n  export type shopping_review_ratingsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_ratingsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_product_review_id?: SortOrder\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_review_ratingsSumOrderByAggregateInput = {\n    quality_rating?: SortOrder\n    value_rating?: SortOrder\n    service_rating?: SortOrder\n  }\n\n  export type Shopping_sellersScalarRelationFilter = {\n    is?: shopping_sellersWhereInput\n    isNot?: shopping_sellersWhereInput\n  }\n\n  export type shopping_seller_productsShopping_seller_idSeller_product_codeCompoundUniqueInput = {\n    shopping_seller_id: string\n    seller_product_code: string\n  }\n\n  export type shopping_seller_productsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_product_id?: SortOrder\n    seller_product_code?: SortOrder\n    price?: SortOrder\n    quantity_available?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_productsAvgOrderByAggregateInput = {\n    price?: SortOrder\n    quantity_available?: SortOrder\n  }\n\n  export type shopping_seller_productsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_product_id?: SortOrder\n    seller_product_code?: SortOrder\n    price?: SortOrder\n    quantity_available?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_productsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_product_id?: SortOrder\n    seller_product_code?: SortOrder\n    price?: SortOrder\n    quantity_available?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_productsSumOrderByAggregateInput = {\n    price?: SortOrder\n    quantity_available?: SortOrder\n  }\n\n  export type Shopping_seller_productsScalarRelationFilter = {\n    is?: shopping_seller_productsWhereInput\n    isNot?: shopping_seller_productsWhereInput\n  }\n\n  export type shopping_seller_inventoryShopping_seller_product_idShopping_product_variant_idCompoundUniqueInput = {\n    shopping_seller_product_id: string\n    shopping_product_variant_id: string\n  }\n\n  export type shopping_seller_inventoryCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_product_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_inventoryAvgOrderByAggregateInput = {\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n  }\n\n  export type shopping_seller_inventoryMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_product_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_inventoryMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_product_id?: SortOrder\n    shopping_product_variant_id?: SortOrder\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n    status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_inventorySumOrderByAggregateInput = {\n    stock_quantity?: SortOrder\n    low_stock_threshold?: SortOrder\n  }\n\n  export type shopping_seller_ordersShopping_seller_idSeller_order_codeCompoundUniqueInput = {\n    shopping_seller_id: string\n    seller_order_code: string\n  }\n\n  export type shopping_seller_ordersCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_order_id?: SortOrder\n    seller_order_code?: SortOrder\n    fulfillment_status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_ordersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_order_id?: SortOrder\n    seller_order_code?: SortOrder\n    fulfillment_status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_seller_ordersMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_seller_id?: SortOrder\n    shopping_order_id?: SortOrder\n    seller_order_code?: SortOrder\n    fulfillment_status?: SortOrder\n    business_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_admin_actionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_admin_actionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_admin_actionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    action_type?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type Shopping_administratorsNullableScalarRelationFilter = {\n    is?: shopping_administratorsWhereInput | null\n    isNot?: shopping_administratorsWhereInput | null\n  }\n\n  export type shopping_admin_logsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    log_type?: SortOrder\n    message?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_admin_logsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    log_type?: SortOrder\n    message?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type shopping_admin_logsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_administrator_id?: SortOrder\n    log_type?: SortOrder\n    message?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type Shopping_payment_transactionsListRelationFilter = {\n    every?: shopping_payment_transactionsWhereInput\n    some?: shopping_payment_transactionsWhereInput\n    none?: shopping_payment_transactionsWhereInput\n  }\n\n  export type shopping_payment_transactionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type shopping_paymentsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    shopping_order_id?: SortOrder\n    payment_method_id?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    transaction_id?: SortOrder\n    payment_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_paymentsAvgOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type shopping_paymentsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    shopping_order_id?: SortOrder\n    payment_method_id?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    transaction_id?: SortOrder\n    payment_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_paymentsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_customer_id?: SortOrder\n    shopping_order_id?: SortOrder\n    payment_method_id?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    transaction_id?: SortOrder\n    payment_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_paymentsSumOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type shopping_payment_methodsCountOrderByAggregateInput = {\n    id?: SortOrder\n    method_name?: SortOrder\n    method_type?: SortOrder\n    provider?: SortOrder\n    is_active?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_payment_methodsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    method_name?: SortOrder\n    method_type?: SortOrder\n    provider?: SortOrder\n    is_active?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_payment_methodsMinOrderByAggregateInput = {\n    id?: SortOrder\n    method_name?: SortOrder\n    method_type?: SortOrder\n    provider?: SortOrder\n    is_active?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type Shopping_paymentsScalarRelationFilter = {\n    is?: shopping_paymentsWhereInput\n    isNot?: shopping_paymentsWhereInput\n  }\n\n  export type shopping_payment_transactionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_payment_id?: SortOrder\n    transaction_type?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    gateway_response?: SortOrder\n    transaction_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_payment_transactionsAvgOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type shopping_payment_transactionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_payment_id?: SortOrder\n    transaction_type?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    gateway_response?: SortOrder\n    transaction_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_payment_transactionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_payment_id?: SortOrder\n    transaction_type?: SortOrder\n    amount?: SortOrder\n    currency?: SortOrder\n    status?: SortOrder\n    gateway_response?: SortOrder\n    transaction_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type shopping_payment_transactionsSumOrderByAggregateInput = {\n    amount?: SortOrder\n  }\n\n  export type shopping_shipping_methodsCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_methodsAvgOrderByAggregateInput = {\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n  }\n\n  export type shopping_shipping_methodsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_methodsMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_methodsSumOrderByAggregateInput = {\n    cost?: SortOrder\n    estimated_delivery_days?: SortOrder\n  }\n\n  export type shopping_shipping_carriersCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    tracking_url_template?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_carriersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    tracking_url_template?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_carriersMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    tracking_url_template?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type Shopping_shipping_carriersScalarRelationFilter = {\n    is?: shopping_shipping_carriersWhereInput\n    isNot?: shopping_shipping_carriersWhereInput\n  }\n\n  export type Shopping_shipping_methodsScalarRelationFilter = {\n    is?: shopping_shipping_methodsWhereInput\n    isNot?: shopping_shipping_methodsWhereInput\n  }\n\n  export type shopping_shipping_trackingCountOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_shipping_carrier_id?: SortOrder\n    shopping_shipping_method_id?: SortOrder\n    tracking_number?: SortOrder\n    status?: SortOrder\n    estimated_delivery_date?: SortOrder\n    actual_delivery_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_trackingMaxOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_shipping_carrier_id?: SortOrder\n    shopping_shipping_method_id?: SortOrder\n    tracking_number?: SortOrder\n    status?: SortOrder\n    estimated_delivery_date?: SortOrder\n    actual_delivery_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_shipping_trackingMinOrderByAggregateInput = {\n    id?: SortOrder\n    shopping_order_id?: SortOrder\n    shopping_shipping_carrier_id?: SortOrder\n    shopping_shipping_method_id?: SortOrder\n    tracking_number?: SortOrder\n    status?: SortOrder\n    estimated_delivery_date?: SortOrder\n    actual_delivery_date?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type shopping_sectionsCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n  }\n\n  export type shopping_channel_categoriesCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput> | shopping_channel_categoriesCreateWithoutChannelInput[] | shopping_channel_categoriesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutChannelInput | shopping_channel_categoriesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_channel_categoriesCreateManyChannelInputEnvelope\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n  }\n\n  export type shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n  }\n\n  export type shopping_channel_categoriesUncheckedCreateNestedManyWithoutChannelInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput> | shopping_channel_categoriesCreateWithoutChannelInput[] | shopping_channel_categoriesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutChannelInput | shopping_channel_categoriesCreateOrConnectWithoutChannelInput[]\n    createMany?: shopping_channel_categoriesCreateManyChannelInputEnvelope\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput | shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    set?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    disconnect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    delete?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    update?: shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput | shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_sectionsUpdateManyWithWhereWithoutChannelInput | shopping_sectionsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n  }\n\n  export type shopping_channel_categoriesUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput> | shopping_channel_categoriesCreateWithoutChannelInput[] | shopping_channel_categoriesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutChannelInput | shopping_channel_categoriesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_channel_categoriesUpsertWithWhereUniqueWithoutChannelInput | shopping_channel_categoriesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_channel_categoriesCreateManyChannelInputEnvelope\n    set?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    disconnect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    delete?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    update?: shopping_channel_categoriesUpdateWithWhereUniqueWithoutChannelInput | shopping_channel_categoriesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_channel_categoriesUpdateManyWithWhereWithoutChannelInput | shopping_channel_categoriesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput> | shopping_sectionsCreateWithoutChannelInput[] | shopping_sectionsUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutChannelInput | shopping_sectionsCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput | shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_sectionsCreateManyChannelInputEnvelope\n    set?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    disconnect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    delete?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    connect?: shopping_sectionsWhereUniqueInput | shopping_sectionsWhereUniqueInput[]\n    update?: shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput | shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_sectionsUpdateManyWithWhereWithoutChannelInput | shopping_sectionsUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateManyWithoutChannelNestedInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput> | shopping_channel_categoriesCreateWithoutChannelInput[] | shopping_channel_categoriesUncheckedCreateWithoutChannelInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutChannelInput | shopping_channel_categoriesCreateOrConnectWithoutChannelInput[]\n    upsert?: shopping_channel_categoriesUpsertWithWhereUniqueWithoutChannelInput | shopping_channel_categoriesUpsertWithWhereUniqueWithoutChannelInput[]\n    createMany?: shopping_channel_categoriesCreateManyChannelInputEnvelope\n    set?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    disconnect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    delete?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    update?: shopping_channel_categoriesUpdateWithWhereUniqueWithoutChannelInput | shopping_channel_categoriesUpdateWithWhereUniqueWithoutChannelInput[]\n    updateMany?: shopping_channel_categoriesUpdateManyWithWhereWithoutChannelInput | shopping_channel_categoriesUpdateManyWithWhereWithoutChannelInput[]\n    deleteMany?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_sectionsInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_sectionsInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_channel_categoriesCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput> | shopping_channel_categoriesCreateWithoutSectionInput[] | shopping_channel_categoriesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutSectionInput | shopping_channel_categoriesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_channel_categoriesCreateManySectionInputEnvelope\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n  }\n\n  export type shopping_channel_categoriesUncheckedCreateNestedManyWithoutSectionInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput> | shopping_channel_categoriesCreateWithoutSectionInput[] | shopping_channel_categoriesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutSectionInput | shopping_channel_categoriesCreateOrConnectWithoutSectionInput[]\n    createMany?: shopping_channel_categoriesCreateManySectionInputEnvelope\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n  }\n\n  export type shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_sectionsInput\n    upsert?: shopping_channelsUpsertWithoutShopping_sectionsInput\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_sectionsInput, shopping_channelsUpdateWithoutShopping_sectionsInput>, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_channel_categoriesUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput> | shopping_channel_categoriesCreateWithoutSectionInput[] | shopping_channel_categoriesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutSectionInput | shopping_channel_categoriesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_channel_categoriesUpsertWithWhereUniqueWithoutSectionInput | shopping_channel_categoriesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_channel_categoriesCreateManySectionInputEnvelope\n    set?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    disconnect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    delete?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    update?: shopping_channel_categoriesUpdateWithWhereUniqueWithoutSectionInput | shopping_channel_categoriesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_channel_categoriesUpdateManyWithWhereWithoutSectionInput | shopping_channel_categoriesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateManyWithoutSectionNestedInput = {\n    create?: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput> | shopping_channel_categoriesCreateWithoutSectionInput[] | shopping_channel_categoriesUncheckedCreateWithoutSectionInput[]\n    connectOrCreate?: shopping_channel_categoriesCreateOrConnectWithoutSectionInput | shopping_channel_categoriesCreateOrConnectWithoutSectionInput[]\n    upsert?: shopping_channel_categoriesUpsertWithWhereUniqueWithoutSectionInput | shopping_channel_categoriesUpsertWithWhereUniqueWithoutSectionInput[]\n    createMany?: shopping_channel_categoriesCreateManySectionInputEnvelope\n    set?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    disconnect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    delete?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    connect?: shopping_channel_categoriesWhereUniqueInput | shopping_channel_categoriesWhereUniqueInput[]\n    update?: shopping_channel_categoriesUpdateWithWhereUniqueWithoutSectionInput | shopping_channel_categoriesUpdateWithWhereUniqueWithoutSectionInput[]\n    updateMany?: shopping_channel_categoriesUpdateManyWithWhereWithoutSectionInput | shopping_channel_categoriesUpdateManyWithWhereWithoutSectionInput[]\n    deleteMany?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_channelsCreateNestedOneWithoutShopping_channel_categoriesInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_channel_categoriesInput\n    connect?: shopping_channelsWhereUniqueInput\n  }\n\n  export type shopping_sectionsCreateNestedOneWithoutShopping_channel_categoriesInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_channel_categoriesInput\n    connect?: shopping_sectionsWhereUniqueInput\n  }\n\n  export type shopping_channelsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput = {\n    create?: XOR<shopping_channelsCreateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    connectOrCreate?: shopping_channelsCreateOrConnectWithoutShopping_channel_categoriesInput\n    upsert?: shopping_channelsUpsertWithoutShopping_channel_categoriesInput\n    connect?: shopping_channelsWhereUniqueInput\n    update?: XOR<XOR<shopping_channelsUpdateToOneWithWhereWithoutShopping_channel_categoriesInput, shopping_channelsUpdateWithoutShopping_channel_categoriesInput>, shopping_channelsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_sectionsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput = {\n    create?: XOR<shopping_sectionsCreateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    connectOrCreate?: shopping_sectionsCreateOrConnectWithoutShopping_channel_categoriesInput\n    upsert?: shopping_sectionsUpsertWithoutShopping_channel_categoriesInput\n    connect?: shopping_sectionsWhereUniqueInput\n    update?: XOR<XOR<shopping_sectionsUpdateToOneWithWhereWithoutShopping_channel_categoriesInput, shopping_sectionsUpdateWithoutShopping_channel_categoriesInput>, shopping_sectionsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_product_reviewsCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput> | shopping_product_reviewsCreateWithoutCustomerInput[] | shopping_product_reviewsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutCustomerInput | shopping_product_reviewsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_product_reviewsCreateManyCustomerInputEnvelope\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n  }\n\n  export type shopping_ordersCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput> | shopping_ordersCreateWithoutCustomerInput[] | shopping_ordersUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutCustomerInput | shopping_ordersCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_ordersCreateManyCustomerInputEnvelope\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_shopping_cartsCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput> | shopping_shopping_cartsCreateWithoutCustomerInput[] | shopping_shopping_cartsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutCustomerInput | shopping_shopping_cartsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_shopping_cartsCreateManyCustomerInputEnvelope\n    connect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n  }\n\n  export type shopping_paymentsCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput> | shopping_paymentsCreateWithoutCustomerInput[] | shopping_paymentsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutCustomerInput | shopping_paymentsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_paymentsCreateManyCustomerInputEnvelope\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n  }\n\n  export type shopping_product_reviewsUncheckedCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput> | shopping_product_reviewsCreateWithoutCustomerInput[] | shopping_product_reviewsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutCustomerInput | shopping_product_reviewsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_product_reviewsCreateManyCustomerInputEnvelope\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n  }\n\n  export type shopping_ordersUncheckedCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput> | shopping_ordersCreateWithoutCustomerInput[] | shopping_ordersUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutCustomerInput | shopping_ordersCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_ordersCreateManyCustomerInputEnvelope\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_shopping_cartsUncheckedCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput> | shopping_shopping_cartsCreateWithoutCustomerInput[] | shopping_shopping_cartsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutCustomerInput | shopping_shopping_cartsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_shopping_cartsCreateManyCustomerInputEnvelope\n    connect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n  }\n\n  export type shopping_paymentsUncheckedCreateNestedManyWithoutCustomerInput = {\n    create?: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput> | shopping_paymentsCreateWithoutCustomerInput[] | shopping_paymentsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutCustomerInput | shopping_paymentsCreateOrConnectWithoutCustomerInput[]\n    createMany?: shopping_paymentsCreateManyCustomerInputEnvelope\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n  }\n\n  export type shopping_product_reviewsUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput> | shopping_product_reviewsCreateWithoutCustomerInput[] | shopping_product_reviewsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutCustomerInput | shopping_product_reviewsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_product_reviewsUpsertWithWhereUniqueWithoutCustomerInput | shopping_product_reviewsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_product_reviewsCreateManyCustomerInputEnvelope\n    set?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    disconnect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    delete?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    update?: shopping_product_reviewsUpdateWithWhereUniqueWithoutCustomerInput | shopping_product_reviewsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_product_reviewsUpdateManyWithWhereWithoutCustomerInput | shopping_product_reviewsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n  }\n\n  export type shopping_ordersUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput> | shopping_ordersCreateWithoutCustomerInput[] | shopping_ordersUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutCustomerInput | shopping_ordersCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_ordersUpsertWithWhereUniqueWithoutCustomerInput | shopping_ordersUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_ordersCreateManyCustomerInputEnvelope\n    set?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    disconnect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    delete?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    update?: shopping_ordersUpdateWithWhereUniqueWithoutCustomerInput | shopping_ordersUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_ordersUpdateManyWithWhereWithoutCustomerInput | shopping_ordersUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n  }\n\n  export type shopping_shopping_cartsUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput> | shopping_shopping_cartsCreateWithoutCustomerInput[] | shopping_shopping_cartsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutCustomerInput | shopping_shopping_cartsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_shopping_cartsUpsertWithWhereUniqueWithoutCustomerInput | shopping_shopping_cartsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_shopping_cartsCreateManyCustomerInputEnvelope\n    set?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    disconnect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    delete?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    connect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    update?: shopping_shopping_cartsUpdateWithWhereUniqueWithoutCustomerInput | shopping_shopping_cartsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_shopping_cartsUpdateManyWithWhereWithoutCustomerInput | shopping_shopping_cartsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_shopping_cartsScalarWhereInput | shopping_shopping_cartsScalarWhereInput[]\n  }\n\n  export type shopping_paymentsUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput> | shopping_paymentsCreateWithoutCustomerInput[] | shopping_paymentsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutCustomerInput | shopping_paymentsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_paymentsUpsertWithWhereUniqueWithoutCustomerInput | shopping_paymentsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_paymentsCreateManyCustomerInputEnvelope\n    set?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    disconnect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    delete?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    update?: shopping_paymentsUpdateWithWhereUniqueWithoutCustomerInput | shopping_paymentsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_paymentsUpdateManyWithWhereWithoutCustomerInput | shopping_paymentsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput> | shopping_product_reviewsCreateWithoutCustomerInput[] | shopping_product_reviewsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutCustomerInput | shopping_product_reviewsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_product_reviewsUpsertWithWhereUniqueWithoutCustomerInput | shopping_product_reviewsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_product_reviewsCreateManyCustomerInputEnvelope\n    set?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    disconnect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    delete?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    update?: shopping_product_reviewsUpdateWithWhereUniqueWithoutCustomerInput | shopping_product_reviewsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_product_reviewsUpdateManyWithWhereWithoutCustomerInput | shopping_product_reviewsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n  }\n\n  export type shopping_ordersUncheckedUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput> | shopping_ordersCreateWithoutCustomerInput[] | shopping_ordersUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutCustomerInput | shopping_ordersCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_ordersUpsertWithWhereUniqueWithoutCustomerInput | shopping_ordersUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_ordersCreateManyCustomerInputEnvelope\n    set?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    disconnect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    delete?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    connect?: shopping_ordersWhereUniqueInput | shopping_ordersWhereUniqueInput[]\n    update?: shopping_ordersUpdateWithWhereUniqueWithoutCustomerInput | shopping_ordersUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_ordersUpdateManyWithWhereWithoutCustomerInput | shopping_ordersUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput> | shopping_shopping_cartsCreateWithoutCustomerInput[] | shopping_shopping_cartsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutCustomerInput | shopping_shopping_cartsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_shopping_cartsUpsertWithWhereUniqueWithoutCustomerInput | shopping_shopping_cartsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_shopping_cartsCreateManyCustomerInputEnvelope\n    set?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    disconnect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    delete?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    connect?: shopping_shopping_cartsWhereUniqueInput | shopping_shopping_cartsWhereUniqueInput[]\n    update?: shopping_shopping_cartsUpdateWithWhereUniqueWithoutCustomerInput | shopping_shopping_cartsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_shopping_cartsUpdateManyWithWhereWithoutCustomerInput | shopping_shopping_cartsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_shopping_cartsScalarWhereInput | shopping_shopping_cartsScalarWhereInput[]\n  }\n\n  export type shopping_paymentsUncheckedUpdateManyWithoutCustomerNestedInput = {\n    create?: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput> | shopping_paymentsCreateWithoutCustomerInput[] | shopping_paymentsUncheckedCreateWithoutCustomerInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutCustomerInput | shopping_paymentsCreateOrConnectWithoutCustomerInput[]\n    upsert?: shopping_paymentsUpsertWithWhereUniqueWithoutCustomerInput | shopping_paymentsUpsertWithWhereUniqueWithoutCustomerInput[]\n    createMany?: shopping_paymentsCreateManyCustomerInputEnvelope\n    set?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    disconnect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    delete?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    update?: shopping_paymentsUpdateWithWhereUniqueWithoutCustomerInput | shopping_paymentsUpdateWithWhereUniqueWithoutCustomerInput[]\n    updateMany?: shopping_paymentsUpdateManyWithWhereWithoutCustomerInput | shopping_paymentsUpdateManyWithWhereWithoutCustomerInput[]\n    deleteMany?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n  }\n\n  export type shopping_seller_productsCreateNestedManyWithoutSellerInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput> | shopping_seller_productsCreateWithoutSellerInput[] | shopping_seller_productsUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutSellerInput | shopping_seller_productsCreateOrConnectWithoutSellerInput[]\n    createMany?: shopping_seller_productsCreateManySellerInputEnvelope\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_ordersCreateNestedManyWithoutSellerInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput> | shopping_seller_ordersCreateWithoutSellerInput[] | shopping_seller_ordersUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutSellerInput | shopping_seller_ordersCreateOrConnectWithoutSellerInput[]\n    createMany?: shopping_seller_ordersCreateManySellerInputEnvelope\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_seller_productsUncheckedCreateNestedManyWithoutSellerInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput> | shopping_seller_productsCreateWithoutSellerInput[] | shopping_seller_productsUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutSellerInput | shopping_seller_productsCreateOrConnectWithoutSellerInput[]\n    createMany?: shopping_seller_productsCreateManySellerInputEnvelope\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_ordersUncheckedCreateNestedManyWithoutSellerInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput> | shopping_seller_ordersCreateWithoutSellerInput[] | shopping_seller_ordersUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutSellerInput | shopping_seller_ordersCreateOrConnectWithoutSellerInput[]\n    createMany?: shopping_seller_ordersCreateManySellerInputEnvelope\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_seller_productsUpdateManyWithoutSellerNestedInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput> | shopping_seller_productsCreateWithoutSellerInput[] | shopping_seller_productsUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutSellerInput | shopping_seller_productsCreateOrConnectWithoutSellerInput[]\n    upsert?: shopping_seller_productsUpsertWithWhereUniqueWithoutSellerInput | shopping_seller_productsUpsertWithWhereUniqueWithoutSellerInput[]\n    createMany?: shopping_seller_productsCreateManySellerInputEnvelope\n    set?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    disconnect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    delete?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    update?: shopping_seller_productsUpdateWithWhereUniqueWithoutSellerInput | shopping_seller_productsUpdateWithWhereUniqueWithoutSellerInput[]\n    updateMany?: shopping_seller_productsUpdateManyWithWhereWithoutSellerInput | shopping_seller_productsUpdateManyWithWhereWithoutSellerInput[]\n    deleteMany?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n  }\n\n  export type shopping_seller_ordersUpdateManyWithoutSellerNestedInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput> | shopping_seller_ordersCreateWithoutSellerInput[] | shopping_seller_ordersUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutSellerInput | shopping_seller_ordersCreateOrConnectWithoutSellerInput[]\n    upsert?: shopping_seller_ordersUpsertWithWhereUniqueWithoutSellerInput | shopping_seller_ordersUpsertWithWhereUniqueWithoutSellerInput[]\n    createMany?: shopping_seller_ordersCreateManySellerInputEnvelope\n    set?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    disconnect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    delete?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    update?: shopping_seller_ordersUpdateWithWhereUniqueWithoutSellerInput | shopping_seller_ordersUpdateWithWhereUniqueWithoutSellerInput[]\n    updateMany?: shopping_seller_ordersUpdateManyWithWhereWithoutSellerInput | shopping_seller_ordersUpdateManyWithWhereWithoutSellerInput[]\n    deleteMany?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n  }\n\n  export type shopping_seller_productsUncheckedUpdateManyWithoutSellerNestedInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput> | shopping_seller_productsCreateWithoutSellerInput[] | shopping_seller_productsUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutSellerInput | shopping_seller_productsCreateOrConnectWithoutSellerInput[]\n    upsert?: shopping_seller_productsUpsertWithWhereUniqueWithoutSellerInput | shopping_seller_productsUpsertWithWhereUniqueWithoutSellerInput[]\n    createMany?: shopping_seller_productsCreateManySellerInputEnvelope\n    set?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    disconnect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    delete?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    update?: shopping_seller_productsUpdateWithWhereUniqueWithoutSellerInput | shopping_seller_productsUpdateWithWhereUniqueWithoutSellerInput[]\n    updateMany?: shopping_seller_productsUpdateManyWithWhereWithoutSellerInput | shopping_seller_productsUpdateManyWithWhereWithoutSellerInput[]\n    deleteMany?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateManyWithoutSellerNestedInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput> | shopping_seller_ordersCreateWithoutSellerInput[] | shopping_seller_ordersUncheckedCreateWithoutSellerInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutSellerInput | shopping_seller_ordersCreateOrConnectWithoutSellerInput[]\n    upsert?: shopping_seller_ordersUpsertWithWhereUniqueWithoutSellerInput | shopping_seller_ordersUpsertWithWhereUniqueWithoutSellerInput[]\n    createMany?: shopping_seller_ordersCreateManySellerInputEnvelope\n    set?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    disconnect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    delete?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    update?: shopping_seller_ordersUpdateWithWhereUniqueWithoutSellerInput | shopping_seller_ordersUpdateWithWhereUniqueWithoutSellerInput[]\n    updateMany?: shopping_seller_ordersUpdateManyWithWhereWithoutSellerInput | shopping_seller_ordersUpdateManyWithWhereWithoutSellerInput[]\n    deleteMany?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n  }\n\n  export type shopping_review_moderationCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput> | shopping_review_moderationCreateWithoutAdministratorInput[] | shopping_review_moderationUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutAdministratorInput | shopping_review_moderationCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_review_moderationCreateManyAdministratorInputEnvelope\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n  }\n\n  export type shopping_admin_actionsCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput> | shopping_admin_actionsCreateWithoutAdministratorInput[] | shopping_admin_actionsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_actionsCreateOrConnectWithoutAdministratorInput | shopping_admin_actionsCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_admin_actionsCreateManyAdministratorInputEnvelope\n    connect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n  }\n\n  export type shopping_admin_logsCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput> | shopping_admin_logsCreateWithoutAdministratorInput[] | shopping_admin_logsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_logsCreateOrConnectWithoutAdministratorInput | shopping_admin_logsCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_admin_logsCreateManyAdministratorInputEnvelope\n    connect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n  }\n\n  export type shopping_review_moderationUncheckedCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput> | shopping_review_moderationCreateWithoutAdministratorInput[] | shopping_review_moderationUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutAdministratorInput | shopping_review_moderationCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_review_moderationCreateManyAdministratorInputEnvelope\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n  }\n\n  export type shopping_admin_actionsUncheckedCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput> | shopping_admin_actionsCreateWithoutAdministratorInput[] | shopping_admin_actionsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_actionsCreateOrConnectWithoutAdministratorInput | shopping_admin_actionsCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_admin_actionsCreateManyAdministratorInputEnvelope\n    connect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n  }\n\n  export type shopping_admin_logsUncheckedCreateNestedManyWithoutAdministratorInput = {\n    create?: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput> | shopping_admin_logsCreateWithoutAdministratorInput[] | shopping_admin_logsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_logsCreateOrConnectWithoutAdministratorInput | shopping_admin_logsCreateOrConnectWithoutAdministratorInput[]\n    createMany?: shopping_admin_logsCreateManyAdministratorInputEnvelope\n    connect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n  }\n\n  export type shopping_review_moderationUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput> | shopping_review_moderationCreateWithoutAdministratorInput[] | shopping_review_moderationUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutAdministratorInput | shopping_review_moderationCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_review_moderationUpsertWithWhereUniqueWithoutAdministratorInput | shopping_review_moderationUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_review_moderationCreateManyAdministratorInputEnvelope\n    set?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    disconnect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    delete?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    update?: shopping_review_moderationUpdateWithWhereUniqueWithoutAdministratorInput | shopping_review_moderationUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_review_moderationUpdateManyWithWhereWithoutAdministratorInput | shopping_review_moderationUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n  }\n\n  export type shopping_admin_actionsUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput> | shopping_admin_actionsCreateWithoutAdministratorInput[] | shopping_admin_actionsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_actionsCreateOrConnectWithoutAdministratorInput | shopping_admin_actionsCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_admin_actionsUpsertWithWhereUniqueWithoutAdministratorInput | shopping_admin_actionsUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_admin_actionsCreateManyAdministratorInputEnvelope\n    set?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    disconnect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    delete?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    connect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    update?: shopping_admin_actionsUpdateWithWhereUniqueWithoutAdministratorInput | shopping_admin_actionsUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_admin_actionsUpdateManyWithWhereWithoutAdministratorInput | shopping_admin_actionsUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_admin_actionsScalarWhereInput | shopping_admin_actionsScalarWhereInput[]\n  }\n\n  export type shopping_admin_logsUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput> | shopping_admin_logsCreateWithoutAdministratorInput[] | shopping_admin_logsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_logsCreateOrConnectWithoutAdministratorInput | shopping_admin_logsCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_admin_logsUpsertWithWhereUniqueWithoutAdministratorInput | shopping_admin_logsUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_admin_logsCreateManyAdministratorInputEnvelope\n    set?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    disconnect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    delete?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    connect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    update?: shopping_admin_logsUpdateWithWhereUniqueWithoutAdministratorInput | shopping_admin_logsUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_admin_logsUpdateManyWithWhereWithoutAdministratorInput | shopping_admin_logsUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_admin_logsScalarWhereInput | shopping_admin_logsScalarWhereInput[]\n  }\n\n  export type shopping_review_moderationUncheckedUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput> | shopping_review_moderationCreateWithoutAdministratorInput[] | shopping_review_moderationUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutAdministratorInput | shopping_review_moderationCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_review_moderationUpsertWithWhereUniqueWithoutAdministratorInput | shopping_review_moderationUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_review_moderationCreateManyAdministratorInputEnvelope\n    set?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    disconnect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    delete?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    update?: shopping_review_moderationUpdateWithWhereUniqueWithoutAdministratorInput | shopping_review_moderationUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_review_moderationUpdateManyWithWhereWithoutAdministratorInput | shopping_review_moderationUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n  }\n\n  export type shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput> | shopping_admin_actionsCreateWithoutAdministratorInput[] | shopping_admin_actionsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_actionsCreateOrConnectWithoutAdministratorInput | shopping_admin_actionsCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_admin_actionsUpsertWithWhereUniqueWithoutAdministratorInput | shopping_admin_actionsUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_admin_actionsCreateManyAdministratorInputEnvelope\n    set?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    disconnect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    delete?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    connect?: shopping_admin_actionsWhereUniqueInput | shopping_admin_actionsWhereUniqueInput[]\n    update?: shopping_admin_actionsUpdateWithWhereUniqueWithoutAdministratorInput | shopping_admin_actionsUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_admin_actionsUpdateManyWithWhereWithoutAdministratorInput | shopping_admin_actionsUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_admin_actionsScalarWhereInput | shopping_admin_actionsScalarWhereInput[]\n  }\n\n  export type shopping_admin_logsUncheckedUpdateManyWithoutAdministratorNestedInput = {\n    create?: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput> | shopping_admin_logsCreateWithoutAdministratorInput[] | shopping_admin_logsUncheckedCreateWithoutAdministratorInput[]\n    connectOrCreate?: shopping_admin_logsCreateOrConnectWithoutAdministratorInput | shopping_admin_logsCreateOrConnectWithoutAdministratorInput[]\n    upsert?: shopping_admin_logsUpsertWithWhereUniqueWithoutAdministratorInput | shopping_admin_logsUpsertWithWhereUniqueWithoutAdministratorInput[]\n    createMany?: shopping_admin_logsCreateManyAdministratorInputEnvelope\n    set?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    disconnect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    delete?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    connect?: shopping_admin_logsWhereUniqueInput | shopping_admin_logsWhereUniqueInput[]\n    update?: shopping_admin_logsUpdateWithWhereUniqueWithoutAdministratorInput | shopping_admin_logsUpdateWithWhereUniqueWithoutAdministratorInput[]\n    updateMany?: shopping_admin_logsUpdateManyWithWhereWithoutAdministratorInput | shopping_admin_logsUpdateManyWithWhereWithoutAdministratorInput[]\n    deleteMany?: shopping_admin_logsScalarWhereInput | shopping_admin_logsScalarWhereInput[]\n  }\n\n  export type shopping_categoriesCreateNestedOneWithoutShopping_productsInput = {\n    create?: XOR<shopping_categoriesCreateWithoutShopping_productsInput, shopping_categoriesUncheckedCreateWithoutShopping_productsInput>\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutShopping_productsInput\n    connect?: shopping_categoriesWhereUniqueInput\n  }\n\n  export type shopping_product_variantsCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput> | shopping_product_variantsCreateWithoutProductInput[] | shopping_product_variantsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutProductInput | shopping_product_variantsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_product_variantsCreateManyProductInputEnvelope\n    connect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n  }\n\n  export type shopping_inventoryCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput> | shopping_inventoryCreateWithoutProductInput[] | shopping_inventoryUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutProductInput | shopping_inventoryCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_inventoryCreateManyProductInputEnvelope\n    connect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n  }\n\n  export type shopping_product_reviewsCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput> | shopping_product_reviewsCreateWithoutProductInput[] | shopping_product_reviewsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutProductInput | shopping_product_reviewsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_product_reviewsCreateManyProductInputEnvelope\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_productsCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput> | shopping_seller_productsCreateWithoutProductInput[] | shopping_seller_productsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutProductInput | shopping_seller_productsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_seller_productsCreateManyProductInputEnvelope\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n  }\n\n  export type shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput> | shopping_product_variantsCreateWithoutProductInput[] | shopping_product_variantsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutProductInput | shopping_product_variantsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_product_variantsCreateManyProductInputEnvelope\n    connect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n  }\n\n  export type shopping_inventoryUncheckedCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput> | shopping_inventoryCreateWithoutProductInput[] | shopping_inventoryUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutProductInput | shopping_inventoryCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_inventoryCreateManyProductInputEnvelope\n    connect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n  }\n\n  export type shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput> | shopping_product_reviewsCreateWithoutProductInput[] | shopping_product_reviewsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutProductInput | shopping_product_reviewsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_product_reviewsCreateManyProductInputEnvelope\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput> | shopping_seller_productsCreateWithoutProductInput[] | shopping_seller_productsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutProductInput | shopping_seller_productsCreateOrConnectWithoutProductInput[]\n    createMany?: shopping_seller_productsCreateManyProductInputEnvelope\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n  }\n\n  export type FloatFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type shopping_categoriesUpdateOneWithoutShopping_productsNestedInput = {\n    create?: XOR<shopping_categoriesCreateWithoutShopping_productsInput, shopping_categoriesUncheckedCreateWithoutShopping_productsInput>\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutShopping_productsInput\n    upsert?: shopping_categoriesUpsertWithoutShopping_productsInput\n    disconnect?: shopping_categoriesWhereInput | boolean\n    delete?: shopping_categoriesWhereInput | boolean\n    connect?: shopping_categoriesWhereUniqueInput\n    update?: XOR<XOR<shopping_categoriesUpdateToOneWithWhereWithoutShopping_productsInput, shopping_categoriesUpdateWithoutShopping_productsInput>, shopping_categoriesUncheckedUpdateWithoutShopping_productsInput>\n  }\n\n  export type shopping_product_variantsUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput> | shopping_product_variantsCreateWithoutProductInput[] | shopping_product_variantsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutProductInput | shopping_product_variantsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_product_variantsUpsertWithWhereUniqueWithoutProductInput | shopping_product_variantsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_product_variantsCreateManyProductInputEnvelope\n    set?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    disconnect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    delete?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    connect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    update?: shopping_product_variantsUpdateWithWhereUniqueWithoutProductInput | shopping_product_variantsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_product_variantsUpdateManyWithWhereWithoutProductInput | shopping_product_variantsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_product_variantsScalarWhereInput | shopping_product_variantsScalarWhereInput[]\n  }\n\n  export type shopping_inventoryUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput> | shopping_inventoryCreateWithoutProductInput[] | shopping_inventoryUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutProductInput | shopping_inventoryCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_inventoryUpsertWithWhereUniqueWithoutProductInput | shopping_inventoryUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_inventoryCreateManyProductInputEnvelope\n    set?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    disconnect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    delete?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    connect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    update?: shopping_inventoryUpdateWithWhereUniqueWithoutProductInput | shopping_inventoryUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_inventoryUpdateManyWithWhereWithoutProductInput | shopping_inventoryUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_inventoryScalarWhereInput | shopping_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_product_reviewsUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput> | shopping_product_reviewsCreateWithoutProductInput[] | shopping_product_reviewsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutProductInput | shopping_product_reviewsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_product_reviewsUpsertWithWhereUniqueWithoutProductInput | shopping_product_reviewsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_product_reviewsCreateManyProductInputEnvelope\n    set?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    disconnect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    delete?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    update?: shopping_product_reviewsUpdateWithWhereUniqueWithoutProductInput | shopping_product_reviewsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_product_reviewsUpdateManyWithWhereWithoutProductInput | shopping_product_reviewsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n  }\n\n  export type shopping_seller_productsUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput> | shopping_seller_productsCreateWithoutProductInput[] | shopping_seller_productsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutProductInput | shopping_seller_productsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_seller_productsUpsertWithWhereUniqueWithoutProductInput | shopping_seller_productsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_seller_productsCreateManyProductInputEnvelope\n    set?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    disconnect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    delete?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    update?: shopping_seller_productsUpdateWithWhereUniqueWithoutProductInput | shopping_seller_productsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_seller_productsUpdateManyWithWhereWithoutProductInput | shopping_seller_productsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n  }\n\n  export type shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput> | shopping_product_variantsCreateWithoutProductInput[] | shopping_product_variantsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutProductInput | shopping_product_variantsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_product_variantsUpsertWithWhereUniqueWithoutProductInput | shopping_product_variantsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_product_variantsCreateManyProductInputEnvelope\n    set?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    disconnect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    delete?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    connect?: shopping_product_variantsWhereUniqueInput | shopping_product_variantsWhereUniqueInput[]\n    update?: shopping_product_variantsUpdateWithWhereUniqueWithoutProductInput | shopping_product_variantsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_product_variantsUpdateManyWithWhereWithoutProductInput | shopping_product_variantsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_product_variantsScalarWhereInput | shopping_product_variantsScalarWhereInput[]\n  }\n\n  export type shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput> | shopping_inventoryCreateWithoutProductInput[] | shopping_inventoryUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutProductInput | shopping_inventoryCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_inventoryUpsertWithWhereUniqueWithoutProductInput | shopping_inventoryUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_inventoryCreateManyProductInputEnvelope\n    set?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    disconnect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    delete?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    connect?: shopping_inventoryWhereUniqueInput | shopping_inventoryWhereUniqueInput[]\n    update?: shopping_inventoryUpdateWithWhereUniqueWithoutProductInput | shopping_inventoryUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_inventoryUpdateManyWithWhereWithoutProductInput | shopping_inventoryUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_inventoryScalarWhereInput | shopping_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput> | shopping_product_reviewsCreateWithoutProductInput[] | shopping_product_reviewsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutProductInput | shopping_product_reviewsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_product_reviewsUpsertWithWhereUniqueWithoutProductInput | shopping_product_reviewsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_product_reviewsCreateManyProductInputEnvelope\n    set?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    disconnect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    delete?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    connect?: shopping_product_reviewsWhereUniqueInput | shopping_product_reviewsWhereUniqueInput[]\n    update?: shopping_product_reviewsUpdateWithWhereUniqueWithoutProductInput | shopping_product_reviewsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_product_reviewsUpdateManyWithWhereWithoutProductInput | shopping_product_reviewsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n  }\n\n  export type shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput> | shopping_seller_productsCreateWithoutProductInput[] | shopping_seller_productsUncheckedCreateWithoutProductInput[]\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutProductInput | shopping_seller_productsCreateOrConnectWithoutProductInput[]\n    upsert?: shopping_seller_productsUpsertWithWhereUniqueWithoutProductInput | shopping_seller_productsUpsertWithWhereUniqueWithoutProductInput[]\n    createMany?: shopping_seller_productsCreateManyProductInputEnvelope\n    set?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    disconnect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    delete?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    connect?: shopping_seller_productsWhereUniqueInput | shopping_seller_productsWhereUniqueInput[]\n    update?: shopping_seller_productsUpdateWithWhereUniqueWithoutProductInput | shopping_seller_productsUpdateWithWhereUniqueWithoutProductInput[]\n    updateMany?: shopping_seller_productsUpdateManyWithWhereWithoutProductInput | shopping_seller_productsUpdateManyWithWhereWithoutProductInput[]\n    deleteMany?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n  }\n\n  export type shopping_productsCreateNestedOneWithoutShopping_product_variantsInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_product_variantsInput, shopping_productsUncheckedCreateWithoutShopping_product_variantsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_product_variantsInput\n    connect?: shopping_productsWhereUniqueInput\n  }\n\n  export type shopping_inventoryCreateNestedOneWithoutVariantInput = {\n    create?: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutVariantInput\n    connect?: shopping_inventoryWhereUniqueInput\n  }\n\n  export type shopping_order_itemsCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput> | shopping_order_itemsCreateWithoutProductVariantInput[] | shopping_order_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutProductVariantInput | shopping_order_itemsCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_order_itemsCreateManyProductVariantInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput> | shopping_cart_itemsCreateWithoutProductVariantInput[] | shopping_cart_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutProductVariantInput | shopping_cart_itemsCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_cart_itemsCreateManyProductVariantInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput> | shopping_seller_inventoryCreateWithoutProductVariantInput[] | shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput | shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_seller_inventoryCreateManyProductVariantInputEnvelope\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n  }\n\n  export type shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput = {\n    create?: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutVariantInput\n    connect?: shopping_inventoryWhereUniqueInput\n  }\n\n  export type shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput> | shopping_order_itemsCreateWithoutProductVariantInput[] | shopping_order_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutProductVariantInput | shopping_order_itemsCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_order_itemsCreateManyProductVariantInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput> | shopping_cart_itemsCreateWithoutProductVariantInput[] | shopping_cart_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutProductVariantInput | shopping_cart_itemsCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_cart_itemsCreateManyProductVariantInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput> | shopping_seller_inventoryCreateWithoutProductVariantInput[] | shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput | shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput[]\n    createMany?: shopping_seller_inventoryCreateManyProductVariantInputEnvelope\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n  }\n\n  export type NullableFloatFieldUpdateOperationsInput = {\n    set?: number | null\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_product_variantsInput, shopping_productsUncheckedCreateWithoutShopping_product_variantsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_product_variantsInput\n    upsert?: shopping_productsUpsertWithoutShopping_product_variantsInput\n    connect?: shopping_productsWhereUniqueInput\n    update?: XOR<XOR<shopping_productsUpdateToOneWithWhereWithoutShopping_product_variantsInput, shopping_productsUpdateWithoutShopping_product_variantsInput>, shopping_productsUncheckedUpdateWithoutShopping_product_variantsInput>\n  }\n\n  export type shopping_inventoryUpdateOneWithoutVariantNestedInput = {\n    create?: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutVariantInput\n    upsert?: shopping_inventoryUpsertWithoutVariantInput\n    disconnect?: shopping_inventoryWhereInput | boolean\n    delete?: shopping_inventoryWhereInput | boolean\n    connect?: shopping_inventoryWhereUniqueInput\n    update?: XOR<XOR<shopping_inventoryUpdateToOneWithWhereWithoutVariantInput, shopping_inventoryUpdateWithoutVariantInput>, shopping_inventoryUncheckedUpdateWithoutVariantInput>\n  }\n\n  export type shopping_order_itemsUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput> | shopping_order_itemsCreateWithoutProductVariantInput[] | shopping_order_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutProductVariantInput | shopping_order_itemsCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutProductVariantInput | shopping_order_itemsUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_order_itemsCreateManyProductVariantInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutProductVariantInput | shopping_order_itemsUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutProductVariantInput | shopping_order_itemsUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput> | shopping_cart_itemsCreateWithoutProductVariantInput[] | shopping_cart_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutProductVariantInput | shopping_cart_itemsCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutProductVariantInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_cart_itemsCreateManyProductVariantInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutProductVariantInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutProductVariantInput | shopping_cart_itemsUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput> | shopping_seller_inventoryCreateWithoutProductVariantInput[] | shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput | shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_seller_inventoryUpsertWithWhereUniqueWithoutProductVariantInput | shopping_seller_inventoryUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_seller_inventoryCreateManyProductVariantInputEnvelope\n    set?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    disconnect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    delete?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    update?: shopping_seller_inventoryUpdateWithWhereUniqueWithoutProductVariantInput | shopping_seller_inventoryUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_seller_inventoryUpdateManyWithWhereWithoutProductVariantInput | shopping_seller_inventoryUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput = {\n    create?: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n    connectOrCreate?: shopping_inventoryCreateOrConnectWithoutVariantInput\n    upsert?: shopping_inventoryUpsertWithoutVariantInput\n    disconnect?: shopping_inventoryWhereInput | boolean\n    delete?: shopping_inventoryWhereInput | boolean\n    connect?: shopping_inventoryWhereUniqueInput\n    update?: XOR<XOR<shopping_inventoryUpdateToOneWithWhereWithoutVariantInput, shopping_inventoryUpdateWithoutVariantInput>, shopping_inventoryUncheckedUpdateWithoutVariantInput>\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput> | shopping_order_itemsCreateWithoutProductVariantInput[] | shopping_order_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutProductVariantInput | shopping_order_itemsCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutProductVariantInput | shopping_order_itemsUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_order_itemsCreateManyProductVariantInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutProductVariantInput | shopping_order_itemsUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutProductVariantInput | shopping_order_itemsUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput> | shopping_cart_itemsCreateWithoutProductVariantInput[] | shopping_cart_itemsUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutProductVariantInput | shopping_cart_itemsCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutProductVariantInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_cart_itemsCreateManyProductVariantInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutProductVariantInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutProductVariantInput | shopping_cart_itemsUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput> | shopping_seller_inventoryCreateWithoutProductVariantInput[] | shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput | shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput[]\n    upsert?: shopping_seller_inventoryUpsertWithWhereUniqueWithoutProductVariantInput | shopping_seller_inventoryUpsertWithWhereUniqueWithoutProductVariantInput[]\n    createMany?: shopping_seller_inventoryCreateManyProductVariantInputEnvelope\n    set?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    disconnect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    delete?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    update?: shopping_seller_inventoryUpdateWithWhereUniqueWithoutProductVariantInput | shopping_seller_inventoryUpdateWithWhereUniqueWithoutProductVariantInput[]\n    updateMany?: shopping_seller_inventoryUpdateManyWithWhereWithoutProductVariantInput | shopping_seller_inventoryUpdateManyWithWhereWithoutProductVariantInput[]\n    deleteMany?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_categoriesCreateNestedOneWithoutRecursiveInput = {\n    create?: XOR<shopping_categoriesCreateWithoutRecursiveInput, shopping_categoriesUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutRecursiveInput\n    connect?: shopping_categoriesWhereUniqueInput\n  }\n\n  export type shopping_productsCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput> | shopping_productsCreateWithoutCategoryInput[] | shopping_productsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutCategoryInput | shopping_productsCreateOrConnectWithoutCategoryInput[]\n    createMany?: shopping_productsCreateManyCategoryInputEnvelope\n    connect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n  }\n\n  export type shopping_categoriesCreateNestedManyWithoutParentInput = {\n    create?: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput> | shopping_categoriesCreateWithoutParentInput[] | shopping_categoriesUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutParentInput | shopping_categoriesCreateOrConnectWithoutParentInput[]\n    createMany?: shopping_categoriesCreateManyParentInputEnvelope\n    connect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n  }\n\n  export type shopping_productsUncheckedCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput> | shopping_productsCreateWithoutCategoryInput[] | shopping_productsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutCategoryInput | shopping_productsCreateOrConnectWithoutCategoryInput[]\n    createMany?: shopping_productsCreateManyCategoryInputEnvelope\n    connect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n  }\n\n  export type shopping_categoriesUncheckedCreateNestedManyWithoutParentInput = {\n    create?: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput> | shopping_categoriesCreateWithoutParentInput[] | shopping_categoriesUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutParentInput | shopping_categoriesCreateOrConnectWithoutParentInput[]\n    createMany?: shopping_categoriesCreateManyParentInputEnvelope\n    connect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n  }\n\n  export type shopping_categoriesUpdateOneWithoutRecursiveNestedInput = {\n    create?: XOR<shopping_categoriesCreateWithoutRecursiveInput, shopping_categoriesUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutRecursiveInput\n    upsert?: shopping_categoriesUpsertWithoutRecursiveInput\n    disconnect?: shopping_categoriesWhereInput | boolean\n    delete?: shopping_categoriesWhereInput | boolean\n    connect?: shopping_categoriesWhereUniqueInput\n    update?: XOR<XOR<shopping_categoriesUpdateToOneWithWhereWithoutRecursiveInput, shopping_categoriesUpdateWithoutRecursiveInput>, shopping_categoriesUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type shopping_productsUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput> | shopping_productsCreateWithoutCategoryInput[] | shopping_productsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutCategoryInput | shopping_productsCreateOrConnectWithoutCategoryInput[]\n    upsert?: shopping_productsUpsertWithWhereUniqueWithoutCategoryInput | shopping_productsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: shopping_productsCreateManyCategoryInputEnvelope\n    set?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    disconnect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    delete?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    connect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    update?: shopping_productsUpdateWithWhereUniqueWithoutCategoryInput | shopping_productsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: shopping_productsUpdateManyWithWhereWithoutCategoryInput | shopping_productsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: shopping_productsScalarWhereInput | shopping_productsScalarWhereInput[]\n  }\n\n  export type shopping_categoriesUpdateManyWithoutParentNestedInput = {\n    create?: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput> | shopping_categoriesCreateWithoutParentInput[] | shopping_categoriesUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutParentInput | shopping_categoriesCreateOrConnectWithoutParentInput[]\n    upsert?: shopping_categoriesUpsertWithWhereUniqueWithoutParentInput | shopping_categoriesUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: shopping_categoriesCreateManyParentInputEnvelope\n    set?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    disconnect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    delete?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    connect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    update?: shopping_categoriesUpdateWithWhereUniqueWithoutParentInput | shopping_categoriesUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: shopping_categoriesUpdateManyWithWhereWithoutParentInput | shopping_categoriesUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: shopping_categoriesScalarWhereInput | shopping_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_productsUncheckedUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput> | shopping_productsCreateWithoutCategoryInput[] | shopping_productsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutCategoryInput | shopping_productsCreateOrConnectWithoutCategoryInput[]\n    upsert?: shopping_productsUpsertWithWhereUniqueWithoutCategoryInput | shopping_productsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: shopping_productsCreateManyCategoryInputEnvelope\n    set?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    disconnect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    delete?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    connect?: shopping_productsWhereUniqueInput | shopping_productsWhereUniqueInput[]\n    update?: shopping_productsUpdateWithWhereUniqueWithoutCategoryInput | shopping_productsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: shopping_productsUpdateManyWithWhereWithoutCategoryInput | shopping_productsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: shopping_productsScalarWhereInput | shopping_productsScalarWhereInput[]\n  }\n\n  export type shopping_categoriesUncheckedUpdateManyWithoutParentNestedInput = {\n    create?: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput> | shopping_categoriesCreateWithoutParentInput[] | shopping_categoriesUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: shopping_categoriesCreateOrConnectWithoutParentInput | shopping_categoriesCreateOrConnectWithoutParentInput[]\n    upsert?: shopping_categoriesUpsertWithWhereUniqueWithoutParentInput | shopping_categoriesUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: shopping_categoriesCreateManyParentInputEnvelope\n    set?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    disconnect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    delete?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    connect?: shopping_categoriesWhereUniqueInput | shopping_categoriesWhereUniqueInput[]\n    update?: shopping_categoriesUpdateWithWhereUniqueWithoutParentInput | shopping_categoriesUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: shopping_categoriesUpdateManyWithWhereWithoutParentInput | shopping_categoriesUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: shopping_categoriesScalarWhereInput | shopping_categoriesScalarWhereInput[]\n  }\n\n  export type shopping_product_variantsCreateNestedOneWithoutShopping_inventoryInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_inventoryInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_inventoryInput\n    connect?: shopping_product_variantsWhereUniqueInput\n  }\n\n  export type shopping_productsCreateNestedOneWithoutShopping_inventoryInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_inventoryInput, shopping_productsUncheckedCreateWithoutShopping_inventoryInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_inventoryInput\n    connect?: shopping_productsWhereUniqueInput\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type NullableIntFieldUpdateOperationsInput = {\n    set?: number | null\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type shopping_product_variantsUpdateOneRequiredWithoutShopping_inventoryNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_inventoryInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_inventoryInput\n    upsert?: shopping_product_variantsUpsertWithoutShopping_inventoryInput\n    connect?: shopping_product_variantsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_variantsUpdateToOneWithWhereWithoutShopping_inventoryInput, shopping_product_variantsUpdateWithoutShopping_inventoryInput>, shopping_product_variantsUncheckedUpdateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_productsUpdateOneRequiredWithoutShopping_inventoryNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_inventoryInput, shopping_productsUncheckedCreateWithoutShopping_inventoryInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_inventoryInput\n    upsert?: shopping_productsUpsertWithoutShopping_inventoryInput\n    connect?: shopping_productsWhereUniqueInput\n    update?: XOR<XOR<shopping_productsUpdateToOneWithWhereWithoutShopping_inventoryInput, shopping_productsUpdateWithoutShopping_inventoryInput>, shopping_productsUncheckedUpdateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_productsCreateNestedOneWithoutShopping_product_reviewsInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_product_reviewsInput, shopping_productsUncheckedCreateWithoutShopping_product_reviewsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_product_reviewsInput\n    connect?: shopping_productsWhereUniqueInput\n  }\n\n  export type shopping_customersCreateNestedOneWithoutShopping_product_reviewsInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_product_reviewsInput, shopping_customersUncheckedCreateWithoutShopping_product_reviewsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_product_reviewsInput\n    connect?: shopping_customersWhereUniqueInput\n  }\n\n  export type shopping_review_moderationCreateNestedManyWithoutReviewInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput> | shopping_review_moderationCreateWithoutReviewInput[] | shopping_review_moderationUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutReviewInput | shopping_review_moderationCreateOrConnectWithoutReviewInput[]\n    createMany?: shopping_review_moderationCreateManyReviewInputEnvelope\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n  }\n\n  export type shopping_review_ratingsCreateNestedManyWithoutReviewInput = {\n    create?: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput> | shopping_review_ratingsCreateWithoutReviewInput[] | shopping_review_ratingsUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_ratingsCreateOrConnectWithoutReviewInput | shopping_review_ratingsCreateOrConnectWithoutReviewInput[]\n    createMany?: shopping_review_ratingsCreateManyReviewInputEnvelope\n    connect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n  }\n\n  export type shopping_review_moderationUncheckedCreateNestedManyWithoutReviewInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput> | shopping_review_moderationCreateWithoutReviewInput[] | shopping_review_moderationUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutReviewInput | shopping_review_moderationCreateOrConnectWithoutReviewInput[]\n    createMany?: shopping_review_moderationCreateManyReviewInputEnvelope\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n  }\n\n  export type shopping_review_ratingsUncheckedCreateNestedManyWithoutReviewInput = {\n    create?: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput> | shopping_review_ratingsCreateWithoutReviewInput[] | shopping_review_ratingsUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_ratingsCreateOrConnectWithoutReviewInput | shopping_review_ratingsCreateOrConnectWithoutReviewInput[]\n    createMany?: shopping_review_ratingsCreateManyReviewInputEnvelope\n    connect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n  }\n\n  export type shopping_productsUpdateOneRequiredWithoutShopping_product_reviewsNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_product_reviewsInput, shopping_productsUncheckedCreateWithoutShopping_product_reviewsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_product_reviewsInput\n    upsert?: shopping_productsUpsertWithoutShopping_product_reviewsInput\n    connect?: shopping_productsWhereUniqueInput\n    update?: XOR<XOR<shopping_productsUpdateToOneWithWhereWithoutShopping_product_reviewsInput, shopping_productsUpdateWithoutShopping_product_reviewsInput>, shopping_productsUncheckedUpdateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_customersUpdateOneRequiredWithoutShopping_product_reviewsNestedInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_product_reviewsInput, shopping_customersUncheckedCreateWithoutShopping_product_reviewsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_product_reviewsInput\n    upsert?: shopping_customersUpsertWithoutShopping_product_reviewsInput\n    connect?: shopping_customersWhereUniqueInput\n    update?: XOR<XOR<shopping_customersUpdateToOneWithWhereWithoutShopping_product_reviewsInput, shopping_customersUpdateWithoutShopping_product_reviewsInput>, shopping_customersUncheckedUpdateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_review_moderationUpdateManyWithoutReviewNestedInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput> | shopping_review_moderationCreateWithoutReviewInput[] | shopping_review_moderationUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutReviewInput | shopping_review_moderationCreateOrConnectWithoutReviewInput[]\n    upsert?: shopping_review_moderationUpsertWithWhereUniqueWithoutReviewInput | shopping_review_moderationUpsertWithWhereUniqueWithoutReviewInput[]\n    createMany?: shopping_review_moderationCreateManyReviewInputEnvelope\n    set?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    disconnect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    delete?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    update?: shopping_review_moderationUpdateWithWhereUniqueWithoutReviewInput | shopping_review_moderationUpdateWithWhereUniqueWithoutReviewInput[]\n    updateMany?: shopping_review_moderationUpdateManyWithWhereWithoutReviewInput | shopping_review_moderationUpdateManyWithWhereWithoutReviewInput[]\n    deleteMany?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n  }\n\n  export type shopping_review_ratingsUpdateManyWithoutReviewNestedInput = {\n    create?: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput> | shopping_review_ratingsCreateWithoutReviewInput[] | shopping_review_ratingsUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_ratingsCreateOrConnectWithoutReviewInput | shopping_review_ratingsCreateOrConnectWithoutReviewInput[]\n    upsert?: shopping_review_ratingsUpsertWithWhereUniqueWithoutReviewInput | shopping_review_ratingsUpsertWithWhereUniqueWithoutReviewInput[]\n    createMany?: shopping_review_ratingsCreateManyReviewInputEnvelope\n    set?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    disconnect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    delete?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    connect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    update?: shopping_review_ratingsUpdateWithWhereUniqueWithoutReviewInput | shopping_review_ratingsUpdateWithWhereUniqueWithoutReviewInput[]\n    updateMany?: shopping_review_ratingsUpdateManyWithWhereWithoutReviewInput | shopping_review_ratingsUpdateManyWithWhereWithoutReviewInput[]\n    deleteMany?: shopping_review_ratingsScalarWhereInput | shopping_review_ratingsScalarWhereInput[]\n  }\n\n  export type shopping_review_moderationUncheckedUpdateManyWithoutReviewNestedInput = {\n    create?: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput> | shopping_review_moderationCreateWithoutReviewInput[] | shopping_review_moderationUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_moderationCreateOrConnectWithoutReviewInput | shopping_review_moderationCreateOrConnectWithoutReviewInput[]\n    upsert?: shopping_review_moderationUpsertWithWhereUniqueWithoutReviewInput | shopping_review_moderationUpsertWithWhereUniqueWithoutReviewInput[]\n    createMany?: shopping_review_moderationCreateManyReviewInputEnvelope\n    set?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    disconnect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    delete?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    connect?: shopping_review_moderationWhereUniqueInput | shopping_review_moderationWhereUniqueInput[]\n    update?: shopping_review_moderationUpdateWithWhereUniqueWithoutReviewInput | shopping_review_moderationUpdateWithWhereUniqueWithoutReviewInput[]\n    updateMany?: shopping_review_moderationUpdateManyWithWhereWithoutReviewInput | shopping_review_moderationUpdateManyWithWhereWithoutReviewInput[]\n    deleteMany?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n  }\n\n  export type shopping_review_ratingsUncheckedUpdateManyWithoutReviewNestedInput = {\n    create?: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput> | shopping_review_ratingsCreateWithoutReviewInput[] | shopping_review_ratingsUncheckedCreateWithoutReviewInput[]\n    connectOrCreate?: shopping_review_ratingsCreateOrConnectWithoutReviewInput | shopping_review_ratingsCreateOrConnectWithoutReviewInput[]\n    upsert?: shopping_review_ratingsUpsertWithWhereUniqueWithoutReviewInput | shopping_review_ratingsUpsertWithWhereUniqueWithoutReviewInput[]\n    createMany?: shopping_review_ratingsCreateManyReviewInputEnvelope\n    set?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    disconnect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    delete?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    connect?: shopping_review_ratingsWhereUniqueInput | shopping_review_ratingsWhereUniqueInput[]\n    update?: shopping_review_ratingsUpdateWithWhereUniqueWithoutReviewInput | shopping_review_ratingsUpdateWithWhereUniqueWithoutReviewInput[]\n    updateMany?: shopping_review_ratingsUpdateManyWithWhereWithoutReviewInput | shopping_review_ratingsUpdateManyWithWhereWithoutReviewInput[]\n    deleteMany?: shopping_review_ratingsScalarWhereInput | shopping_review_ratingsScalarWhereInput[]\n  }\n\n  export type shopping_customersCreateNestedOneWithoutShopping_ordersInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_ordersInput, shopping_customersUncheckedCreateWithoutShopping_ordersInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_ordersInput\n    connect?: shopping_customersWhereUniqueInput\n  }\n\n  export type shopping_order_itemsCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_order_statusCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput> | shopping_order_statusCreateWithoutOrderInput[] | shopping_order_statusUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_statusCreateOrConnectWithoutOrderInput | shopping_order_statusCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_statusCreateManyOrderInputEnvelope\n    connect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n  }\n\n  export type shopping_order_historyCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput> | shopping_order_historyCreateWithoutOrderInput[] | shopping_order_historyUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_historyCreateOrConnectWithoutOrderInput | shopping_order_historyCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_historyCreateManyOrderInputEnvelope\n    connect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n  }\n\n  export type shopping_seller_ordersCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput> | shopping_seller_ordersCreateWithoutOrderInput[] | shopping_seller_ordersUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutOrderInput | shopping_seller_ordersCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_seller_ordersCreateManyOrderInputEnvelope\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_paymentsCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput> | shopping_paymentsCreateWithoutOrderInput[] | shopping_paymentsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutOrderInput | shopping_paymentsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_paymentsCreateManyOrderInputEnvelope\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput> | shopping_shipping_trackingCreateWithoutOrderInput[] | shopping_shipping_trackingUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutOrderInput | shopping_shipping_trackingCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_shipping_trackingCreateManyOrderInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput> | shopping_order_statusCreateWithoutOrderInput[] | shopping_order_statusUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_statusCreateOrConnectWithoutOrderInput | shopping_order_statusCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_statusCreateManyOrderInputEnvelope\n    connect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n  }\n\n  export type shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput> | shopping_order_historyCreateWithoutOrderInput[] | shopping_order_historyUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_historyCreateOrConnectWithoutOrderInput | shopping_order_historyCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_order_historyCreateManyOrderInputEnvelope\n    connect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n  }\n\n  export type shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput> | shopping_seller_ordersCreateWithoutOrderInput[] | shopping_seller_ordersUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutOrderInput | shopping_seller_ordersCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_seller_ordersCreateManyOrderInputEnvelope\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n  }\n\n  export type shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput> | shopping_paymentsCreateWithoutOrderInput[] | shopping_paymentsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutOrderInput | shopping_paymentsCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_paymentsCreateManyOrderInputEnvelope\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput> | shopping_shipping_trackingCreateWithoutOrderInput[] | shopping_shipping_trackingUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutOrderInput | shopping_shipping_trackingCreateOrConnectWithoutOrderInput[]\n    createMany?: shopping_shipping_trackingCreateManyOrderInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_ordersInput, shopping_customersUncheckedCreateWithoutShopping_ordersInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_ordersInput\n    upsert?: shopping_customersUpsertWithoutShopping_ordersInput\n    connect?: shopping_customersWhereUniqueInput\n    update?: XOR<XOR<shopping_customersUpdateToOneWithWhereWithoutShopping_ordersInput, shopping_customersUpdateWithoutShopping_ordersInput>, shopping_customersUncheckedUpdateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_order_itemsUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutOrderInput | shopping_order_itemsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_order_statusUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput> | shopping_order_statusCreateWithoutOrderInput[] | shopping_order_statusUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_statusCreateOrConnectWithoutOrderInput | shopping_order_statusCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_statusUpsertWithWhereUniqueWithoutOrderInput | shopping_order_statusUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_statusCreateManyOrderInputEnvelope\n    set?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    disconnect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    delete?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    connect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    update?: shopping_order_statusUpdateWithWhereUniqueWithoutOrderInput | shopping_order_statusUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_statusUpdateManyWithWhereWithoutOrderInput | shopping_order_statusUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_statusScalarWhereInput | shopping_order_statusScalarWhereInput[]\n  }\n\n  export type shopping_order_historyUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput> | shopping_order_historyCreateWithoutOrderInput[] | shopping_order_historyUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_historyCreateOrConnectWithoutOrderInput | shopping_order_historyCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_historyUpsertWithWhereUniqueWithoutOrderInput | shopping_order_historyUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_historyCreateManyOrderInputEnvelope\n    set?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    disconnect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    delete?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    connect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    update?: shopping_order_historyUpdateWithWhereUniqueWithoutOrderInput | shopping_order_historyUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_historyUpdateManyWithWhereWithoutOrderInput | shopping_order_historyUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_historyScalarWhereInput | shopping_order_historyScalarWhereInput[]\n  }\n\n  export type shopping_seller_ordersUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput> | shopping_seller_ordersCreateWithoutOrderInput[] | shopping_seller_ordersUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutOrderInput | shopping_seller_ordersCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_seller_ordersUpsertWithWhereUniqueWithoutOrderInput | shopping_seller_ordersUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_seller_ordersCreateManyOrderInputEnvelope\n    set?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    disconnect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    delete?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    update?: shopping_seller_ordersUpdateWithWhereUniqueWithoutOrderInput | shopping_seller_ordersUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_seller_ordersUpdateManyWithWhereWithoutOrderInput | shopping_seller_ordersUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n  }\n\n  export type shopping_paymentsUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput> | shopping_paymentsCreateWithoutOrderInput[] | shopping_paymentsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutOrderInput | shopping_paymentsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_paymentsUpsertWithWhereUniqueWithoutOrderInput | shopping_paymentsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_paymentsCreateManyOrderInputEnvelope\n    set?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    disconnect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    delete?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    update?: shopping_paymentsUpdateWithWhereUniqueWithoutOrderInput | shopping_paymentsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_paymentsUpdateManyWithWhereWithoutOrderInput | shopping_paymentsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput> | shopping_shipping_trackingCreateWithoutOrderInput[] | shopping_shipping_trackingUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutOrderInput | shopping_shipping_trackingCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutOrderInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_shipping_trackingCreateManyOrderInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutOrderInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutOrderInput | shopping_shipping_trackingUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput> | shopping_order_itemsCreateWithoutOrderInput[] | shopping_order_itemsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_itemsCreateOrConnectWithoutOrderInput | shopping_order_itemsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_itemsCreateManyOrderInputEnvelope\n    set?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    disconnect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    delete?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    connect?: shopping_order_itemsWhereUniqueInput | shopping_order_itemsWhereUniqueInput[]\n    update?: shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput | shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_itemsUpdateManyWithWhereWithoutOrderInput | shopping_order_itemsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n  }\n\n  export type shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput> | shopping_order_statusCreateWithoutOrderInput[] | shopping_order_statusUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_statusCreateOrConnectWithoutOrderInput | shopping_order_statusCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_statusUpsertWithWhereUniqueWithoutOrderInput | shopping_order_statusUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_statusCreateManyOrderInputEnvelope\n    set?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    disconnect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    delete?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    connect?: shopping_order_statusWhereUniqueInput | shopping_order_statusWhereUniqueInput[]\n    update?: shopping_order_statusUpdateWithWhereUniqueWithoutOrderInput | shopping_order_statusUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_statusUpdateManyWithWhereWithoutOrderInput | shopping_order_statusUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_statusScalarWhereInput | shopping_order_statusScalarWhereInput[]\n  }\n\n  export type shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput> | shopping_order_historyCreateWithoutOrderInput[] | shopping_order_historyUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_order_historyCreateOrConnectWithoutOrderInput | shopping_order_historyCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_order_historyUpsertWithWhereUniqueWithoutOrderInput | shopping_order_historyUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_order_historyCreateManyOrderInputEnvelope\n    set?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    disconnect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    delete?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    connect?: shopping_order_historyWhereUniqueInput | shopping_order_historyWhereUniqueInput[]\n    update?: shopping_order_historyUpdateWithWhereUniqueWithoutOrderInput | shopping_order_historyUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_order_historyUpdateManyWithWhereWithoutOrderInput | shopping_order_historyUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_order_historyScalarWhereInput | shopping_order_historyScalarWhereInput[]\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput> | shopping_seller_ordersCreateWithoutOrderInput[] | shopping_seller_ordersUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_seller_ordersCreateOrConnectWithoutOrderInput | shopping_seller_ordersCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_seller_ordersUpsertWithWhereUniqueWithoutOrderInput | shopping_seller_ordersUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_seller_ordersCreateManyOrderInputEnvelope\n    set?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    disconnect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    delete?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    connect?: shopping_seller_ordersWhereUniqueInput | shopping_seller_ordersWhereUniqueInput[]\n    update?: shopping_seller_ordersUpdateWithWhereUniqueWithoutOrderInput | shopping_seller_ordersUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_seller_ordersUpdateManyWithWhereWithoutOrderInput | shopping_seller_ordersUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n  }\n\n  export type shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput> | shopping_paymentsCreateWithoutOrderInput[] | shopping_paymentsUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutOrderInput | shopping_paymentsCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_paymentsUpsertWithWhereUniqueWithoutOrderInput | shopping_paymentsUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_paymentsCreateManyOrderInputEnvelope\n    set?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    disconnect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    delete?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    connect?: shopping_paymentsWhereUniqueInput | shopping_paymentsWhereUniqueInput[]\n    update?: shopping_paymentsUpdateWithWhereUniqueWithoutOrderInput | shopping_paymentsUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_paymentsUpdateManyWithWhereWithoutOrderInput | shopping_paymentsUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput> | shopping_shipping_trackingCreateWithoutOrderInput[] | shopping_shipping_trackingUncheckedCreateWithoutOrderInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutOrderInput | shopping_shipping_trackingCreateOrConnectWithoutOrderInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutOrderInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutOrderInput[]\n    createMany?: shopping_shipping_trackingCreateManyOrderInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutOrderInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutOrderInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutOrderInput | shopping_shipping_trackingUpdateManyWithWhereWithoutOrderInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_order_itemsInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_product_variantsCreateNestedOneWithoutShopping_order_itemsInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_order_itemsInput\n    connect?: shopping_product_variantsWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_order_itemsNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput\n    upsert?: shopping_ordersUpsertWithoutShopping_order_itemsInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_order_itemsInput, shopping_ordersUpdateWithoutShopping_order_itemsInput>, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_product_variantsUpdateOneRequiredWithoutShopping_order_itemsNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_order_itemsInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_order_itemsInput\n    upsert?: shopping_product_variantsUpsertWithoutShopping_order_itemsInput\n    connect?: shopping_product_variantsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_variantsUpdateToOneWithWhereWithoutShopping_order_itemsInput, shopping_product_variantsUpdateWithoutShopping_order_itemsInput>, shopping_product_variantsUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_order_statusInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_statusInput, shopping_ordersUncheckedCreateWithoutShopping_order_statusInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_statusInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_order_statusNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_statusInput, shopping_ordersUncheckedCreateWithoutShopping_order_statusInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_statusInput\n    upsert?: shopping_ordersUpsertWithoutShopping_order_statusInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_order_statusInput, shopping_ordersUpdateWithoutShopping_order_statusInput>, shopping_ordersUncheckedUpdateWithoutShopping_order_statusInput>\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_order_historyInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_historyInput, shopping_ordersUncheckedCreateWithoutShopping_order_historyInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_historyInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_order_historyNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_order_historyInput, shopping_ordersUncheckedCreateWithoutShopping_order_historyInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_order_historyInput\n    upsert?: shopping_ordersUpsertWithoutShopping_order_historyInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_order_historyInput, shopping_ordersUpdateWithoutShopping_order_historyInput>, shopping_ordersUncheckedUpdateWithoutShopping_order_historyInput>\n  }\n\n  export type shopping_customersCreateNestedOneWithoutShopping_shopping_cartsInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedCreateWithoutShopping_shopping_cartsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_shopping_cartsInput\n    connect?: shopping_customersWhereUniqueInput\n  }\n\n  export type shopping_cart_itemsCreateNestedManyWithoutCartInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n  }\n\n  export type shopping_customersUpdateOneRequiredWithoutShopping_shopping_cartsNestedInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedCreateWithoutShopping_shopping_cartsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_shopping_cartsInput\n    upsert?: shopping_customersUpsertWithoutShopping_shopping_cartsInput\n    connect?: shopping_customersWhereUniqueInput\n    update?: XOR<XOR<shopping_customersUpdateToOneWithWhereWithoutShopping_shopping_cartsInput, shopping_customersUpdateWithoutShopping_shopping_cartsInput>, shopping_customersUncheckedUpdateWithoutShopping_shopping_cartsInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithoutCartNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutCartInput | shopping_cart_itemsUpdateManyWithWhereWithoutCartInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput = {\n    create?: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput> | shopping_cart_itemsCreateWithoutCartInput[] | shopping_cart_itemsUncheckedCreateWithoutCartInput[]\n    connectOrCreate?: shopping_cart_itemsCreateOrConnectWithoutCartInput | shopping_cart_itemsCreateOrConnectWithoutCartInput[]\n    upsert?: shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput[]\n    createMany?: shopping_cart_itemsCreateManyCartInputEnvelope\n    set?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    disconnect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    delete?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    connect?: shopping_cart_itemsWhereUniqueInput | shopping_cart_itemsWhereUniqueInput[]\n    update?: shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput | shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput[]\n    updateMany?: shopping_cart_itemsUpdateManyWithWhereWithoutCartInput | shopping_cart_itemsUpdateManyWithWhereWithoutCartInput[]\n    deleteMany?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n  }\n\n  export type shopping_shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput\n    connect?: shopping_shopping_cartsWhereUniqueInput\n  }\n\n  export type shopping_product_variantsCreateNestedOneWithoutShopping_cart_itemsInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_cart_itemsInput\n    connect?: shopping_product_variantsWhereUniqueInput\n  }\n\n  export type shopping_shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput = {\n    create?: XOR<shopping_shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput\n    upsert?: shopping_shopping_cartsUpsertWithoutShopping_cart_itemsInput\n    connect?: shopping_shopping_cartsWhereUniqueInput\n    update?: XOR<XOR<shopping_shopping_cartsUpdateToOneWithWhereWithoutShopping_cart_itemsInput, shopping_shopping_cartsUpdateWithoutShopping_cart_itemsInput>, shopping_shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_product_variantsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_cart_itemsInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_cart_itemsInput\n    upsert?: shopping_product_variantsUpsertWithoutShopping_cart_itemsInput\n    connect?: shopping_product_variantsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_variantsUpdateToOneWithWhereWithoutShopping_cart_itemsInput, shopping_product_variantsUpdateWithoutShopping_cart_itemsInput>, shopping_product_variantsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_product_reviewsCreateNestedOneWithoutShopping_review_moderationInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_moderationInput>\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutShopping_review_moderationInput\n    connect?: shopping_product_reviewsWhereUniqueInput\n  }\n\n  export type shopping_administratorsCreateNestedOneWithoutShopping_review_moderationInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedCreateWithoutShopping_review_moderationInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_review_moderationInput\n    connect?: shopping_administratorsWhereUniqueInput\n  }\n\n  export type shopping_product_reviewsUpdateOneRequiredWithoutShopping_review_moderationNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_moderationInput>\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutShopping_review_moderationInput\n    upsert?: shopping_product_reviewsUpsertWithoutShopping_review_moderationInput\n    connect?: shopping_product_reviewsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_reviewsUpdateToOneWithWhereWithoutShopping_review_moderationInput, shopping_product_reviewsUpdateWithoutShopping_review_moderationInput>, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_administratorsUpdateOneRequiredWithoutShopping_review_moderationNestedInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedCreateWithoutShopping_review_moderationInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_review_moderationInput\n    upsert?: shopping_administratorsUpsertWithoutShopping_review_moderationInput\n    connect?: shopping_administratorsWhereUniqueInput\n    update?: XOR<XOR<shopping_administratorsUpdateToOneWithWhereWithoutShopping_review_moderationInput, shopping_administratorsUpdateWithoutShopping_review_moderationInput>, shopping_administratorsUncheckedUpdateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_product_reviewsCreateNestedOneWithoutShopping_review_ratingsInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_ratingsInput>\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutShopping_review_ratingsInput\n    connect?: shopping_product_reviewsWhereUniqueInput\n  }\n\n  export type shopping_product_reviewsUpdateOneRequiredWithoutShopping_review_ratingsNestedInput = {\n    create?: XOR<shopping_product_reviewsCreateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_ratingsInput>\n    connectOrCreate?: shopping_product_reviewsCreateOrConnectWithoutShopping_review_ratingsInput\n    upsert?: shopping_product_reviewsUpsertWithoutShopping_review_ratingsInput\n    connect?: shopping_product_reviewsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_reviewsUpdateToOneWithWhereWithoutShopping_review_ratingsInput, shopping_product_reviewsUpdateWithoutShopping_review_ratingsInput>, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_ratingsInput>\n  }\n\n  export type shopping_sellersCreateNestedOneWithoutShopping_seller_productsInput = {\n    create?: XOR<shopping_sellersCreateWithoutShopping_seller_productsInput, shopping_sellersUncheckedCreateWithoutShopping_seller_productsInput>\n    connectOrCreate?: shopping_sellersCreateOrConnectWithoutShopping_seller_productsInput\n    connect?: shopping_sellersWhereUniqueInput\n  }\n\n  export type shopping_productsCreateNestedOneWithoutShopping_seller_productsInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_seller_productsInput, shopping_productsUncheckedCreateWithoutShopping_seller_productsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_seller_productsInput\n    connect?: shopping_productsWhereUniqueInput\n  }\n\n  export type shopping_seller_inventoryCreateNestedManyWithoutSellerProductInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput> | shopping_seller_inventoryCreateWithoutSellerProductInput[] | shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput | shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput[]\n    createMany?: shopping_seller_inventoryCreateManySellerProductInputEnvelope\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n  }\n\n  export type shopping_seller_inventoryUncheckedCreateNestedManyWithoutSellerProductInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput> | shopping_seller_inventoryCreateWithoutSellerProductInput[] | shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput | shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput[]\n    createMany?: shopping_seller_inventoryCreateManySellerProductInputEnvelope\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n  }\n\n  export type shopping_sellersUpdateOneRequiredWithoutShopping_seller_productsNestedInput = {\n    create?: XOR<shopping_sellersCreateWithoutShopping_seller_productsInput, shopping_sellersUncheckedCreateWithoutShopping_seller_productsInput>\n    connectOrCreate?: shopping_sellersCreateOrConnectWithoutShopping_seller_productsInput\n    upsert?: shopping_sellersUpsertWithoutShopping_seller_productsInput\n    connect?: shopping_sellersWhereUniqueInput\n    update?: XOR<XOR<shopping_sellersUpdateToOneWithWhereWithoutShopping_seller_productsInput, shopping_sellersUpdateWithoutShopping_seller_productsInput>, shopping_sellersUncheckedUpdateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_productsUpdateOneRequiredWithoutShopping_seller_productsNestedInput = {\n    create?: XOR<shopping_productsCreateWithoutShopping_seller_productsInput, shopping_productsUncheckedCreateWithoutShopping_seller_productsInput>\n    connectOrCreate?: shopping_productsCreateOrConnectWithoutShopping_seller_productsInput\n    upsert?: shopping_productsUpsertWithoutShopping_seller_productsInput\n    connect?: shopping_productsWhereUniqueInput\n    update?: XOR<XOR<shopping_productsUpdateToOneWithWhereWithoutShopping_seller_productsInput, shopping_productsUpdateWithoutShopping_seller_productsInput>, shopping_productsUncheckedUpdateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_seller_inventoryUpdateManyWithoutSellerProductNestedInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput> | shopping_seller_inventoryCreateWithoutSellerProductInput[] | shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput | shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput[]\n    upsert?: shopping_seller_inventoryUpsertWithWhereUniqueWithoutSellerProductInput | shopping_seller_inventoryUpsertWithWhereUniqueWithoutSellerProductInput[]\n    createMany?: shopping_seller_inventoryCreateManySellerProductInputEnvelope\n    set?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    disconnect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    delete?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    update?: shopping_seller_inventoryUpdateWithWhereUniqueWithoutSellerProductInput | shopping_seller_inventoryUpdateWithWhereUniqueWithoutSellerProductInput[]\n    updateMany?: shopping_seller_inventoryUpdateManyWithWhereWithoutSellerProductInput | shopping_seller_inventoryUpdateManyWithWhereWithoutSellerProductInput[]\n    deleteMany?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductNestedInput = {\n    create?: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput> | shopping_seller_inventoryCreateWithoutSellerProductInput[] | shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput[]\n    connectOrCreate?: shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput | shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput[]\n    upsert?: shopping_seller_inventoryUpsertWithWhereUniqueWithoutSellerProductInput | shopping_seller_inventoryUpsertWithWhereUniqueWithoutSellerProductInput[]\n    createMany?: shopping_seller_inventoryCreateManySellerProductInputEnvelope\n    set?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    disconnect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    delete?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    connect?: shopping_seller_inventoryWhereUniqueInput | shopping_seller_inventoryWhereUniqueInput[]\n    update?: shopping_seller_inventoryUpdateWithWhereUniqueWithoutSellerProductInput | shopping_seller_inventoryUpdateWithWhereUniqueWithoutSellerProductInput[]\n    updateMany?: shopping_seller_inventoryUpdateManyWithWhereWithoutSellerProductInput | shopping_seller_inventoryUpdateManyWithWhereWithoutSellerProductInput[]\n    deleteMany?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n  }\n\n  export type shopping_seller_productsCreateNestedOneWithoutShopping_seller_inventoryInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutShopping_seller_inventoryInput\n    connect?: shopping_seller_productsWhereUniqueInput\n  }\n\n  export type shopping_product_variantsCreateNestedOneWithoutShopping_seller_inventoryInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_seller_inventoryInput\n    connect?: shopping_product_variantsWhereUniqueInput\n  }\n\n  export type shopping_seller_productsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput = {\n    create?: XOR<shopping_seller_productsCreateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    connectOrCreate?: shopping_seller_productsCreateOrConnectWithoutShopping_seller_inventoryInput\n    upsert?: shopping_seller_productsUpsertWithoutShopping_seller_inventoryInput\n    connect?: shopping_seller_productsWhereUniqueInput\n    update?: XOR<XOR<shopping_seller_productsUpdateToOneWithWhereWithoutShopping_seller_inventoryInput, shopping_seller_productsUpdateWithoutShopping_seller_inventoryInput>, shopping_seller_productsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_product_variantsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput = {\n    create?: XOR<shopping_product_variantsCreateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    connectOrCreate?: shopping_product_variantsCreateOrConnectWithoutShopping_seller_inventoryInput\n    upsert?: shopping_product_variantsUpsertWithoutShopping_seller_inventoryInput\n    connect?: shopping_product_variantsWhereUniqueInput\n    update?: XOR<XOR<shopping_product_variantsUpdateToOneWithWhereWithoutShopping_seller_inventoryInput, shopping_product_variantsUpdateWithoutShopping_seller_inventoryInput>, shopping_product_variantsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_sellersCreateNestedOneWithoutShopping_seller_ordersInput = {\n    create?: XOR<shopping_sellersCreateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedCreateWithoutShopping_seller_ordersInput>\n    connectOrCreate?: shopping_sellersCreateOrConnectWithoutShopping_seller_ordersInput\n    connect?: shopping_sellersWhereUniqueInput\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_seller_ordersInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedCreateWithoutShopping_seller_ordersInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_seller_ordersInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_sellersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput = {\n    create?: XOR<shopping_sellersCreateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedCreateWithoutShopping_seller_ordersInput>\n    connectOrCreate?: shopping_sellersCreateOrConnectWithoutShopping_seller_ordersInput\n    upsert?: shopping_sellersUpsertWithoutShopping_seller_ordersInput\n    connect?: shopping_sellersWhereUniqueInput\n    update?: XOR<XOR<shopping_sellersUpdateToOneWithWhereWithoutShopping_seller_ordersInput, shopping_sellersUpdateWithoutShopping_seller_ordersInput>, shopping_sellersUncheckedUpdateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedCreateWithoutShopping_seller_ordersInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_seller_ordersInput\n    upsert?: shopping_ordersUpsertWithoutShopping_seller_ordersInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_seller_ordersInput, shopping_ordersUpdateWithoutShopping_seller_ordersInput>, shopping_ordersUncheckedUpdateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_administratorsCreateNestedOneWithoutShopping_admin_actionsInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_actionsInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_admin_actionsInput\n    connect?: shopping_administratorsWhereUniqueInput\n  }\n\n  export type shopping_administratorsUpdateOneRequiredWithoutShopping_admin_actionsNestedInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_actionsInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_admin_actionsInput\n    upsert?: shopping_administratorsUpsertWithoutShopping_admin_actionsInput\n    connect?: shopping_administratorsWhereUniqueInput\n    update?: XOR<XOR<shopping_administratorsUpdateToOneWithWhereWithoutShopping_admin_actionsInput, shopping_administratorsUpdateWithoutShopping_admin_actionsInput>, shopping_administratorsUncheckedUpdateWithoutShopping_admin_actionsInput>\n  }\n\n  export type shopping_administratorsCreateNestedOneWithoutShopping_admin_logsInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_logsInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_admin_logsInput\n    connect?: shopping_administratorsWhereUniqueInput\n  }\n\n  export type shopping_administratorsUpdateOneWithoutShopping_admin_logsNestedInput = {\n    create?: XOR<shopping_administratorsCreateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_logsInput>\n    connectOrCreate?: shopping_administratorsCreateOrConnectWithoutShopping_admin_logsInput\n    upsert?: shopping_administratorsUpsertWithoutShopping_admin_logsInput\n    disconnect?: shopping_administratorsWhereInput | boolean\n    delete?: shopping_administratorsWhereInput | boolean\n    connect?: shopping_administratorsWhereUniqueInput\n    update?: XOR<XOR<shopping_administratorsUpdateToOneWithWhereWithoutShopping_admin_logsInput, shopping_administratorsUpdateWithoutShopping_admin_logsInput>, shopping_administratorsUncheckedUpdateWithoutShopping_admin_logsInput>\n  }\n\n  export type shopping_customersCreateNestedOneWithoutShopping_paymentsInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_paymentsInput, shopping_customersUncheckedCreateWithoutShopping_paymentsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_paymentsInput\n    connect?: shopping_customersWhereUniqueInput\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_paymentsInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_paymentsInput, shopping_ordersUncheckedCreateWithoutShopping_paymentsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_paymentsInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_payment_transactionsCreateNestedManyWithoutPaymentInput = {\n    create?: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput> | shopping_payment_transactionsCreateWithoutPaymentInput[] | shopping_payment_transactionsUncheckedCreateWithoutPaymentInput[]\n    connectOrCreate?: shopping_payment_transactionsCreateOrConnectWithoutPaymentInput | shopping_payment_transactionsCreateOrConnectWithoutPaymentInput[]\n    createMany?: shopping_payment_transactionsCreateManyPaymentInputEnvelope\n    connect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_payment_transactionsUncheckedCreateNestedManyWithoutPaymentInput = {\n    create?: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput> | shopping_payment_transactionsCreateWithoutPaymentInput[] | shopping_payment_transactionsUncheckedCreateWithoutPaymentInput[]\n    connectOrCreate?: shopping_payment_transactionsCreateOrConnectWithoutPaymentInput | shopping_payment_transactionsCreateOrConnectWithoutPaymentInput[]\n    createMany?: shopping_payment_transactionsCreateManyPaymentInputEnvelope\n    connect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n  }\n\n  export type shopping_customersUpdateOneRequiredWithoutShopping_paymentsNestedInput = {\n    create?: XOR<shopping_customersCreateWithoutShopping_paymentsInput, shopping_customersUncheckedCreateWithoutShopping_paymentsInput>\n    connectOrCreate?: shopping_customersCreateOrConnectWithoutShopping_paymentsInput\n    upsert?: shopping_customersUpsertWithoutShopping_paymentsInput\n    connect?: shopping_customersWhereUniqueInput\n    update?: XOR<XOR<shopping_customersUpdateToOneWithWhereWithoutShopping_paymentsInput, shopping_customersUpdateWithoutShopping_paymentsInput>, shopping_customersUncheckedUpdateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_paymentsNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_paymentsInput, shopping_ordersUncheckedCreateWithoutShopping_paymentsInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_paymentsInput\n    upsert?: shopping_ordersUpsertWithoutShopping_paymentsInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_paymentsInput, shopping_ordersUpdateWithoutShopping_paymentsInput>, shopping_ordersUncheckedUpdateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_payment_transactionsUpdateManyWithoutPaymentNestedInput = {\n    create?: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput> | shopping_payment_transactionsCreateWithoutPaymentInput[] | shopping_payment_transactionsUncheckedCreateWithoutPaymentInput[]\n    connectOrCreate?: shopping_payment_transactionsCreateOrConnectWithoutPaymentInput | shopping_payment_transactionsCreateOrConnectWithoutPaymentInput[]\n    upsert?: shopping_payment_transactionsUpsertWithWhereUniqueWithoutPaymentInput | shopping_payment_transactionsUpsertWithWhereUniqueWithoutPaymentInput[]\n    createMany?: shopping_payment_transactionsCreateManyPaymentInputEnvelope\n    set?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    disconnect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    delete?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    connect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    update?: shopping_payment_transactionsUpdateWithWhereUniqueWithoutPaymentInput | shopping_payment_transactionsUpdateWithWhereUniqueWithoutPaymentInput[]\n    updateMany?: shopping_payment_transactionsUpdateManyWithWhereWithoutPaymentInput | shopping_payment_transactionsUpdateManyWithWhereWithoutPaymentInput[]\n    deleteMany?: shopping_payment_transactionsScalarWhereInput | shopping_payment_transactionsScalarWhereInput[]\n  }\n\n  export type shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentNestedInput = {\n    create?: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput> | shopping_payment_transactionsCreateWithoutPaymentInput[] | shopping_payment_transactionsUncheckedCreateWithoutPaymentInput[]\n    connectOrCreate?: shopping_payment_transactionsCreateOrConnectWithoutPaymentInput | shopping_payment_transactionsCreateOrConnectWithoutPaymentInput[]\n    upsert?: shopping_payment_transactionsUpsertWithWhereUniqueWithoutPaymentInput | shopping_payment_transactionsUpsertWithWhereUniqueWithoutPaymentInput[]\n    createMany?: shopping_payment_transactionsCreateManyPaymentInputEnvelope\n    set?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    disconnect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    delete?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    connect?: shopping_payment_transactionsWhereUniqueInput | shopping_payment_transactionsWhereUniqueInput[]\n    update?: shopping_payment_transactionsUpdateWithWhereUniqueWithoutPaymentInput | shopping_payment_transactionsUpdateWithWhereUniqueWithoutPaymentInput[]\n    updateMany?: shopping_payment_transactionsUpdateManyWithWhereWithoutPaymentInput | shopping_payment_transactionsUpdateManyWithWhereWithoutPaymentInput[]\n    deleteMany?: shopping_payment_transactionsScalarWhereInput | shopping_payment_transactionsScalarWhereInput[]\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type shopping_paymentsCreateNestedOneWithoutShopping_payment_transactionsInput = {\n    create?: XOR<shopping_paymentsCreateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedCreateWithoutShopping_payment_transactionsInput>\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutShopping_payment_transactionsInput\n    connect?: shopping_paymentsWhereUniqueInput\n  }\n\n  export type shopping_paymentsUpdateOneRequiredWithoutShopping_payment_transactionsNestedInput = {\n    create?: XOR<shopping_paymentsCreateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedCreateWithoutShopping_payment_transactionsInput>\n    connectOrCreate?: shopping_paymentsCreateOrConnectWithoutShopping_payment_transactionsInput\n    upsert?: shopping_paymentsUpsertWithoutShopping_payment_transactionsInput\n    connect?: shopping_paymentsWhereUniqueInput\n    update?: XOR<XOR<shopping_paymentsUpdateToOneWithWhereWithoutShopping_payment_transactionsInput, shopping_paymentsUpdateWithoutShopping_payment_transactionsInput>, shopping_paymentsUncheckedUpdateWithoutShopping_payment_transactionsInput>\n  }\n\n  export type shopping_shipping_trackingCreateNestedManyWithoutMethodInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput> | shopping_shipping_trackingCreateWithoutMethodInput[] | shopping_shipping_trackingUncheckedCreateWithoutMethodInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutMethodInput | shopping_shipping_trackingCreateOrConnectWithoutMethodInput[]\n    createMany?: shopping_shipping_trackingCreateManyMethodInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateNestedManyWithoutMethodInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput> | shopping_shipping_trackingCreateWithoutMethodInput[] | shopping_shipping_trackingUncheckedCreateWithoutMethodInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutMethodInput | shopping_shipping_trackingCreateOrConnectWithoutMethodInput[]\n    createMany?: shopping_shipping_trackingCreateManyMethodInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithoutMethodNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput> | shopping_shipping_trackingCreateWithoutMethodInput[] | shopping_shipping_trackingUncheckedCreateWithoutMethodInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutMethodInput | shopping_shipping_trackingCreateOrConnectWithoutMethodInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutMethodInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutMethodInput[]\n    createMany?: shopping_shipping_trackingCreateManyMethodInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutMethodInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutMethodInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutMethodInput | shopping_shipping_trackingUpdateManyWithWhereWithoutMethodInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutMethodNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput> | shopping_shipping_trackingCreateWithoutMethodInput[] | shopping_shipping_trackingUncheckedCreateWithoutMethodInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutMethodInput | shopping_shipping_trackingCreateOrConnectWithoutMethodInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutMethodInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutMethodInput[]\n    createMany?: shopping_shipping_trackingCreateManyMethodInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutMethodInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutMethodInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutMethodInput | shopping_shipping_trackingUpdateManyWithWhereWithoutMethodInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_shipping_trackingCreateNestedManyWithoutCarrierInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput> | shopping_shipping_trackingCreateWithoutCarrierInput[] | shopping_shipping_trackingUncheckedCreateWithoutCarrierInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutCarrierInput | shopping_shipping_trackingCreateOrConnectWithoutCarrierInput[]\n    createMany?: shopping_shipping_trackingCreateManyCarrierInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateNestedManyWithoutCarrierInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput> | shopping_shipping_trackingCreateWithoutCarrierInput[] | shopping_shipping_trackingUncheckedCreateWithoutCarrierInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutCarrierInput | shopping_shipping_trackingCreateOrConnectWithoutCarrierInput[]\n    createMany?: shopping_shipping_trackingCreateManyCarrierInputEnvelope\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithoutCarrierNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput> | shopping_shipping_trackingCreateWithoutCarrierInput[] | shopping_shipping_trackingUncheckedCreateWithoutCarrierInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutCarrierInput | shopping_shipping_trackingCreateOrConnectWithoutCarrierInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutCarrierInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutCarrierInput[]\n    createMany?: shopping_shipping_trackingCreateManyCarrierInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutCarrierInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutCarrierInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutCarrierInput | shopping_shipping_trackingUpdateManyWithWhereWithoutCarrierInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutCarrierNestedInput = {\n    create?: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput> | shopping_shipping_trackingCreateWithoutCarrierInput[] | shopping_shipping_trackingUncheckedCreateWithoutCarrierInput[]\n    connectOrCreate?: shopping_shipping_trackingCreateOrConnectWithoutCarrierInput | shopping_shipping_trackingCreateOrConnectWithoutCarrierInput[]\n    upsert?: shopping_shipping_trackingUpsertWithWhereUniqueWithoutCarrierInput | shopping_shipping_trackingUpsertWithWhereUniqueWithoutCarrierInput[]\n    createMany?: shopping_shipping_trackingCreateManyCarrierInputEnvelope\n    set?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    disconnect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    delete?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    connect?: shopping_shipping_trackingWhereUniqueInput | shopping_shipping_trackingWhereUniqueInput[]\n    update?: shopping_shipping_trackingUpdateWithWhereUniqueWithoutCarrierInput | shopping_shipping_trackingUpdateWithWhereUniqueWithoutCarrierInput[]\n    updateMany?: shopping_shipping_trackingUpdateManyWithWhereWithoutCarrierInput | shopping_shipping_trackingUpdateManyWithWhereWithoutCarrierInput[]\n    deleteMany?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n  }\n\n  export type shopping_ordersCreateNestedOneWithoutShopping_shipping_trackingInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_shipping_trackingInput\n    connect?: shopping_ordersWhereUniqueInput\n  }\n\n  export type shopping_shipping_carriersCreateNestedOneWithoutShopping_shipping_trackingInput = {\n    create?: XOR<shopping_shipping_carriersCreateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_shipping_carriersCreateOrConnectWithoutShopping_shipping_trackingInput\n    connect?: shopping_shipping_carriersWhereUniqueInput\n  }\n\n  export type shopping_shipping_methodsCreateNestedOneWithoutShopping_shipping_trackingInput = {\n    create?: XOR<shopping_shipping_methodsCreateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_shipping_methodsCreateOrConnectWithoutShopping_shipping_trackingInput\n    connect?: shopping_shipping_methodsWhereUniqueInput\n  }\n\n  export type shopping_ordersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput = {\n    create?: XOR<shopping_ordersCreateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_ordersCreateOrConnectWithoutShopping_shipping_trackingInput\n    upsert?: shopping_ordersUpsertWithoutShopping_shipping_trackingInput\n    connect?: shopping_ordersWhereUniqueInput\n    update?: XOR<XOR<shopping_ordersUpdateToOneWithWhereWithoutShopping_shipping_trackingInput, shopping_ordersUpdateWithoutShopping_shipping_trackingInput>, shopping_ordersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_carriersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput = {\n    create?: XOR<shopping_shipping_carriersCreateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_shipping_carriersCreateOrConnectWithoutShopping_shipping_trackingInput\n    upsert?: shopping_shipping_carriersUpsertWithoutShopping_shipping_trackingInput\n    connect?: shopping_shipping_carriersWhereUniqueInput\n    update?: XOR<XOR<shopping_shipping_carriersUpdateToOneWithWhereWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUpdateWithoutShopping_shipping_trackingInput>, shopping_shipping_carriersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_methodsUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput = {\n    create?: XOR<shopping_shipping_methodsCreateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedCreateWithoutShopping_shipping_trackingInput>\n    connectOrCreate?: shopping_shipping_methodsCreateOrConnectWithoutShopping_shipping_trackingInput\n    upsert?: shopping_shipping_methodsUpsertWithoutShopping_shipping_trackingInput\n    connect?: shopping_shipping_methodsWhereUniqueInput\n    update?: XOR<XOR<shopping_shipping_methodsUpdateToOneWithWhereWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUpdateWithoutShopping_shipping_trackingInput>, shopping_shipping_methodsUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type NestedFloatNullableFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedFloatNullableFilter<$PrismaModel>\n    _min?: NestedFloatNullableFilter<$PrismaModel>\n    _max?: NestedFloatNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type shopping_sectionsCreateWithoutChannelInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutChannelInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedCreateNestedManyWithoutSectionInput\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsCreateManyChannelInputEnvelope = {\n    data: shopping_sectionsCreateManyChannelInput | shopping_sectionsCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_channel_categoriesCreateWithoutChannelInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    section: shopping_sectionsCreateNestedOneWithoutShopping_channel_categoriesInput\n  }\n\n  export type shopping_channel_categoriesUncheckedCreateWithoutChannelInput = {\n    id: string\n    shopping_section_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateOrConnectWithoutChannelInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    create: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_channel_categoriesCreateManyChannelInputEnvelope = {\n    data: shopping_channel_categoriesCreateManyChannelInput | shopping_channel_categoriesCreateManyChannelInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_sectionsUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    update: XOR<shopping_sectionsUpdateWithoutChannelInput, shopping_sectionsUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_sectionsCreateWithoutChannelInput, shopping_sectionsUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_sectionsWhereUniqueInput\n    data: XOR<shopping_sectionsUpdateWithoutChannelInput, shopping_sectionsUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_sectionsUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_sectionsScalarWhereInput\n    data: XOR<shopping_sectionsUpdateManyMutationInput, shopping_sectionsUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_sectionsScalarWhereInput = {\n    AND?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n    OR?: shopping_sectionsScalarWhereInput[]\n    NOT?: shopping_sectionsScalarWhereInput | shopping_sectionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_sections\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_sections\"> | string\n    name?: StringFilter<\"shopping_sections\"> | string\n    description?: StringNullableFilter<\"shopping_sections\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_sections\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_sections\"> | Date | string | null\n  }\n\n  export type shopping_channel_categoriesUpsertWithWhereUniqueWithoutChannelInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    update: XOR<shopping_channel_categoriesUpdateWithoutChannelInput, shopping_channel_categoriesUncheckedUpdateWithoutChannelInput>\n    create: XOR<shopping_channel_categoriesCreateWithoutChannelInput, shopping_channel_categoriesUncheckedCreateWithoutChannelInput>\n  }\n\n  export type shopping_channel_categoriesUpdateWithWhereUniqueWithoutChannelInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    data: XOR<shopping_channel_categoriesUpdateWithoutChannelInput, shopping_channel_categoriesUncheckedUpdateWithoutChannelInput>\n  }\n\n  export type shopping_channel_categoriesUpdateManyWithWhereWithoutChannelInput = {\n    where: shopping_channel_categoriesScalarWhereInput\n    data: XOR<shopping_channel_categoriesUpdateManyMutationInput, shopping_channel_categoriesUncheckedUpdateManyWithoutChannelInput>\n  }\n\n  export type shopping_channel_categoriesScalarWhereInput = {\n    AND?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n    OR?: shopping_channel_categoriesScalarWhereInput[]\n    NOT?: shopping_channel_categoriesScalarWhereInput | shopping_channel_categoriesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_channel_categories\"> | string\n    shopping_channel_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    shopping_section_id?: UuidFilter<\"shopping_channel_categories\"> | string\n    name?: StringFilter<\"shopping_channel_categories\"> | string\n    description?: StringNullableFilter<\"shopping_channel_categories\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_channel_categories\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_channel_categories\"> | Date | string | null\n  }\n\n  export type shopping_channelsCreateWithoutShopping_sectionsInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_sectionsInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_sectionsInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_channel_categoriesCreateWithoutSectionInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_channel_categoriesInput\n  }\n\n  export type shopping_channel_categoriesUncheckedCreateWithoutSectionInput = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateOrConnectWithoutSectionInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    create: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_channel_categoriesCreateManySectionInputEnvelope = {\n    data: shopping_channel_categoriesCreateManySectionInput | shopping_channel_categoriesCreateManySectionInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_sectionsInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_sectionsInput, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_sectionsInput, shopping_channelsUncheckedCreateWithoutShopping_sectionsInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_sectionsInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_sectionsInput, shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_sectionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_sectionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channel_categoriesUpsertWithWhereUniqueWithoutSectionInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    update: XOR<shopping_channel_categoriesUpdateWithoutSectionInput, shopping_channel_categoriesUncheckedUpdateWithoutSectionInput>\n    create: XOR<shopping_channel_categoriesCreateWithoutSectionInput, shopping_channel_categoriesUncheckedCreateWithoutSectionInput>\n  }\n\n  export type shopping_channel_categoriesUpdateWithWhereUniqueWithoutSectionInput = {\n    where: shopping_channel_categoriesWhereUniqueInput\n    data: XOR<shopping_channel_categoriesUpdateWithoutSectionInput, shopping_channel_categoriesUncheckedUpdateWithoutSectionInput>\n  }\n\n  export type shopping_channel_categoriesUpdateManyWithWhereWithoutSectionInput = {\n    where: shopping_channel_categoriesScalarWhereInput\n    data: XOR<shopping_channel_categoriesUpdateManyMutationInput, shopping_channel_categoriesUncheckedUpdateManyWithoutSectionInput>\n  }\n\n  export type shopping_channelsCreateWithoutShopping_channel_categoriesInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsUncheckedCreateWithoutShopping_channel_categoriesInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedCreateNestedManyWithoutChannelInput\n  }\n\n  export type shopping_channelsCreateOrConnectWithoutShopping_channel_categoriesInput = {\n    where: shopping_channelsWhereUniqueInput\n    create: XOR<shopping_channelsCreateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedCreateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_sectionsCreateWithoutShopping_channel_categoriesInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    channel: shopping_channelsCreateNestedOneWithoutShopping_sectionsInput\n  }\n\n  export type shopping_sectionsUncheckedCreateWithoutShopping_channel_categoriesInput = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sectionsCreateOrConnectWithoutShopping_channel_categoriesInput = {\n    where: shopping_sectionsWhereUniqueInput\n    create: XOR<shopping_sectionsCreateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedCreateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_channelsUpsertWithoutShopping_channel_categoriesInput = {\n    update: XOR<shopping_channelsUpdateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n    create: XOR<shopping_channelsCreateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    where?: shopping_channelsWhereInput\n  }\n\n  export type shopping_channelsUpdateToOneWithWhereWithoutShopping_channel_categoriesInput = {\n    where?: shopping_channelsWhereInput\n    data: XOR<shopping_channelsUpdateWithoutShopping_channel_categoriesInput, shopping_channelsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_channelsUpdateWithoutShopping_channel_categoriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_channelsUncheckedUpdateWithoutShopping_channel_categoriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_sections?: shopping_sectionsUncheckedUpdateManyWithoutChannelNestedInput\n  }\n\n  export type shopping_sectionsUpsertWithoutShopping_channel_categoriesInput = {\n    update: XOR<shopping_sectionsUpdateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n    create: XOR<shopping_sectionsCreateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedCreateWithoutShopping_channel_categoriesInput>\n    where?: shopping_sectionsWhereInput\n  }\n\n  export type shopping_sectionsUpdateToOneWithWhereWithoutShopping_channel_categoriesInput = {\n    where?: shopping_sectionsWhereInput\n    data: XOR<shopping_sectionsUpdateWithoutShopping_channel_categoriesInput, shopping_sectionsUncheckedUpdateWithoutShopping_channel_categoriesInput>\n  }\n\n  export type shopping_sectionsUpdateWithoutShopping_channel_categoriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_sectionsNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutShopping_channel_categoriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_product_reviewsCreateWithoutCustomerInput = {\n    id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_reviewsInput\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUncheckedCreateWithoutCustomerInput = {\n    id: string\n    shopping_product_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsCreateOrConnectWithoutCustomerInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    create: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_product_reviewsCreateManyCustomerInputEnvelope = {\n    data: shopping_product_reviewsCreateManyCustomerInput | shopping_product_reviewsCreateManyCustomerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_ordersCreateWithoutCustomerInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutCustomerInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutCustomerInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_ordersCreateManyCustomerInputEnvelope = {\n    data: shopping_ordersCreateManyCustomerInput | shopping_ordersCreateManyCustomerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_shopping_cartsCreateWithoutCustomerInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_shopping_cartsUncheckedCreateWithoutCustomerInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutCartInput\n  }\n\n  export type shopping_shopping_cartsCreateOrConnectWithoutCustomerInput = {\n    where: shopping_shopping_cartsWhereUniqueInput\n    create: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_shopping_cartsCreateManyCustomerInputEnvelope = {\n    data: shopping_shopping_cartsCreateManyCustomerInput | shopping_shopping_cartsCreateManyCustomerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_paymentsCreateWithoutCustomerInput = {\n    id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    order: shopping_ordersCreateNestedOneWithoutShopping_paymentsInput\n    shopping_payment_transactions?: shopping_payment_transactionsCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsUncheckedCreateWithoutCustomerInput = {\n    id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsCreateOrConnectWithoutCustomerInput = {\n    where: shopping_paymentsWhereUniqueInput\n    create: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_paymentsCreateManyCustomerInputEnvelope = {\n    data: shopping_paymentsCreateManyCustomerInput | shopping_paymentsCreateManyCustomerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_product_reviewsUpsertWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    update: XOR<shopping_product_reviewsUpdateWithoutCustomerInput, shopping_product_reviewsUncheckedUpdateWithoutCustomerInput>\n    create: XOR<shopping_product_reviewsCreateWithoutCustomerInput, shopping_product_reviewsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_product_reviewsUpdateWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    data: XOR<shopping_product_reviewsUpdateWithoutCustomerInput, shopping_product_reviewsUncheckedUpdateWithoutCustomerInput>\n  }\n\n  export type shopping_product_reviewsUpdateManyWithWhereWithoutCustomerInput = {\n    where: shopping_product_reviewsScalarWhereInput\n    data: XOR<shopping_product_reviewsUpdateManyMutationInput, shopping_product_reviewsUncheckedUpdateManyWithoutCustomerInput>\n  }\n\n  export type shopping_product_reviewsScalarWhereInput = {\n    AND?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n    OR?: shopping_product_reviewsScalarWhereInput[]\n    NOT?: shopping_product_reviewsScalarWhereInput | shopping_product_reviewsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_product_reviews\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_product_reviews\"> | string\n    rating?: IntFilter<\"shopping_product_reviews\"> | number\n    title?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n    content?: StringFilter<\"shopping_product_reviews\"> | string\n    created_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_reviews\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_reviews\"> | string | null\n  }\n\n  export type shopping_ordersUpsertWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_ordersWhereUniqueInput\n    update: XOR<shopping_ordersUpdateWithoutCustomerInput, shopping_ordersUncheckedUpdateWithoutCustomerInput>\n    create: XOR<shopping_ordersCreateWithoutCustomerInput, shopping_ordersUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_ordersUpdateWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_ordersWhereUniqueInput\n    data: XOR<shopping_ordersUpdateWithoutCustomerInput, shopping_ordersUncheckedUpdateWithoutCustomerInput>\n  }\n\n  export type shopping_ordersUpdateManyWithWhereWithoutCustomerInput = {\n    where: shopping_ordersScalarWhereInput\n    data: XOR<shopping_ordersUpdateManyMutationInput, shopping_ordersUncheckedUpdateManyWithoutCustomerInput>\n  }\n\n  export type shopping_ordersScalarWhereInput = {\n    AND?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n    OR?: shopping_ordersScalarWhereInput[]\n    NOT?: shopping_ordersScalarWhereInput | shopping_ordersScalarWhereInput[]\n    id?: UuidFilter<\"shopping_orders\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_orders\"> | string\n    order_code?: StringFilter<\"shopping_orders\"> | string\n    total_amount?: FloatFilter<\"shopping_orders\"> | number\n    currency?: StringFilter<\"shopping_orders\"> | string\n    status?: StringFilter<\"shopping_orders\"> | string\n    payment_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_method?: StringFilter<\"shopping_orders\"> | string\n    shipping_address?: StringFilter<\"shopping_orders\"> | string\n    billing_address?: StringFilter<\"shopping_orders\"> | string\n    created_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_orders\"> | Date | string | null\n  }\n\n  export type shopping_shopping_cartsUpsertWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_shopping_cartsWhereUniqueInput\n    update: XOR<shopping_shopping_cartsUpdateWithoutCustomerInput, shopping_shopping_cartsUncheckedUpdateWithoutCustomerInput>\n    create: XOR<shopping_shopping_cartsCreateWithoutCustomerInput, shopping_shopping_cartsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_shopping_cartsUpdateWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_shopping_cartsWhereUniqueInput\n    data: XOR<shopping_shopping_cartsUpdateWithoutCustomerInput, shopping_shopping_cartsUncheckedUpdateWithoutCustomerInput>\n  }\n\n  export type shopping_shopping_cartsUpdateManyWithWhereWithoutCustomerInput = {\n    where: shopping_shopping_cartsScalarWhereInput\n    data: XOR<shopping_shopping_cartsUpdateManyMutationInput, shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerInput>\n  }\n\n  export type shopping_shopping_cartsScalarWhereInput = {\n    AND?: shopping_shopping_cartsScalarWhereInput | shopping_shopping_cartsScalarWhereInput[]\n    OR?: shopping_shopping_cartsScalarWhereInput[]\n    NOT?: shopping_shopping_cartsScalarWhereInput | shopping_shopping_cartsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_shopping_carts\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_shopping_carts\"> | string\n    created_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shopping_carts\"> | Date | string\n  }\n\n  export type shopping_paymentsUpsertWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_paymentsWhereUniqueInput\n    update: XOR<shopping_paymentsUpdateWithoutCustomerInput, shopping_paymentsUncheckedUpdateWithoutCustomerInput>\n    create: XOR<shopping_paymentsCreateWithoutCustomerInput, shopping_paymentsUncheckedCreateWithoutCustomerInput>\n  }\n\n  export type shopping_paymentsUpdateWithWhereUniqueWithoutCustomerInput = {\n    where: shopping_paymentsWhereUniqueInput\n    data: XOR<shopping_paymentsUpdateWithoutCustomerInput, shopping_paymentsUncheckedUpdateWithoutCustomerInput>\n  }\n\n  export type shopping_paymentsUpdateManyWithWhereWithoutCustomerInput = {\n    where: shopping_paymentsScalarWhereInput\n    data: XOR<shopping_paymentsUpdateManyMutationInput, shopping_paymentsUncheckedUpdateManyWithoutCustomerInput>\n  }\n\n  export type shopping_paymentsScalarWhereInput = {\n    AND?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n    OR?: shopping_paymentsScalarWhereInput[]\n    NOT?: shopping_paymentsScalarWhereInput | shopping_paymentsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_payments\"> | string\n    shopping_customer_id?: UuidFilter<\"shopping_payments\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_payments\"> | string\n    payment_method_id?: UuidFilter<\"shopping_payments\"> | string\n    amount?: FloatFilter<\"shopping_payments\"> | number\n    currency?: StringFilter<\"shopping_payments\"> | string\n    status?: StringFilter<\"shopping_payments\"> | string\n    transaction_id?: StringNullableFilter<\"shopping_payments\"> | string | null\n    payment_date?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payments\"> | Date | string | null\n  }\n\n  export type shopping_seller_productsCreateWithoutSellerInput = {\n    id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_seller_productsInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsUncheckedCreateWithoutSellerInput = {\n    id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsCreateOrConnectWithoutSellerInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    create: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput>\n  }\n\n  export type shopping_seller_productsCreateManySellerInputEnvelope = {\n    data: shopping_seller_productsCreateManySellerInput | shopping_seller_productsCreateManySellerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_seller_ordersCreateWithoutSellerInput = {\n    id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    order: shopping_ordersCreateNestedOneWithoutShopping_seller_ordersInput\n  }\n\n  export type shopping_seller_ordersUncheckedCreateWithoutSellerInput = {\n    id: string\n    shopping_order_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_ordersCreateOrConnectWithoutSellerInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    create: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput>\n  }\n\n  export type shopping_seller_ordersCreateManySellerInputEnvelope = {\n    data: shopping_seller_ordersCreateManySellerInput | shopping_seller_ordersCreateManySellerInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_seller_productsUpsertWithWhereUniqueWithoutSellerInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    update: XOR<shopping_seller_productsUpdateWithoutSellerInput, shopping_seller_productsUncheckedUpdateWithoutSellerInput>\n    create: XOR<shopping_seller_productsCreateWithoutSellerInput, shopping_seller_productsUncheckedCreateWithoutSellerInput>\n  }\n\n  export type shopping_seller_productsUpdateWithWhereUniqueWithoutSellerInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    data: XOR<shopping_seller_productsUpdateWithoutSellerInput, shopping_seller_productsUncheckedUpdateWithoutSellerInput>\n  }\n\n  export type shopping_seller_productsUpdateManyWithWhereWithoutSellerInput = {\n    where: shopping_seller_productsScalarWhereInput\n    data: XOR<shopping_seller_productsUpdateManyMutationInput, shopping_seller_productsUncheckedUpdateManyWithoutSellerInput>\n  }\n\n  export type shopping_seller_productsScalarWhereInput = {\n    AND?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n    OR?: shopping_seller_productsScalarWhereInput[]\n    NOT?: shopping_seller_productsScalarWhereInput | shopping_seller_productsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_seller_products\"> | string\n    shopping_seller_id?: UuidFilter<\"shopping_seller_products\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_seller_products\"> | string\n    seller_product_code?: StringFilter<\"shopping_seller_products\"> | string\n    price?: FloatFilter<\"shopping_seller_products\"> | number\n    quantity_available?: IntFilter<\"shopping_seller_products\"> | number\n    status?: StringFilter<\"shopping_seller_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_products\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_products\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_products\"> | Date | string | null\n  }\n\n  export type shopping_seller_ordersUpsertWithWhereUniqueWithoutSellerInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    update: XOR<shopping_seller_ordersUpdateWithoutSellerInput, shopping_seller_ordersUncheckedUpdateWithoutSellerInput>\n    create: XOR<shopping_seller_ordersCreateWithoutSellerInput, shopping_seller_ordersUncheckedCreateWithoutSellerInput>\n  }\n\n  export type shopping_seller_ordersUpdateWithWhereUniqueWithoutSellerInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    data: XOR<shopping_seller_ordersUpdateWithoutSellerInput, shopping_seller_ordersUncheckedUpdateWithoutSellerInput>\n  }\n\n  export type shopping_seller_ordersUpdateManyWithWhereWithoutSellerInput = {\n    where: shopping_seller_ordersScalarWhereInput\n    data: XOR<shopping_seller_ordersUpdateManyMutationInput, shopping_seller_ordersUncheckedUpdateManyWithoutSellerInput>\n  }\n\n  export type shopping_seller_ordersScalarWhereInput = {\n    AND?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n    OR?: shopping_seller_ordersScalarWhereInput[]\n    NOT?: shopping_seller_ordersScalarWhereInput | shopping_seller_ordersScalarWhereInput[]\n    id?: UuidFilter<\"shopping_seller_orders\"> | string\n    shopping_seller_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_seller_orders\"> | string\n    seller_order_code?: StringFilter<\"shopping_seller_orders\"> | string\n    fulfillment_status?: StringFilter<\"shopping_seller_orders\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_orders\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_orders\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_orders\"> | Date | string | null\n  }\n\n  export type shopping_review_moderationCreateWithoutAdministratorInput = {\n    id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n    review: shopping_product_reviewsCreateNestedOneWithoutShopping_review_moderationInput\n  }\n\n  export type shopping_review_moderationUncheckedCreateWithoutAdministratorInput = {\n    id: string\n    shopping_product_review_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationCreateOrConnectWithoutAdministratorInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    create: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_review_moderationCreateManyAdministratorInputEnvelope = {\n    data: shopping_review_moderationCreateManyAdministratorInput | shopping_review_moderationCreateManyAdministratorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_admin_actionsCreateWithoutAdministratorInput = {\n    id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_actionsUncheckedCreateWithoutAdministratorInput = {\n    id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_actionsCreateOrConnectWithoutAdministratorInput = {\n    where: shopping_admin_actionsWhereUniqueInput\n    create: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_actionsCreateManyAdministratorInputEnvelope = {\n    data: shopping_admin_actionsCreateManyAdministratorInput | shopping_admin_actionsCreateManyAdministratorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_admin_logsCreateWithoutAdministratorInput = {\n    id: string\n    log_type: string\n    message: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_logsUncheckedCreateWithoutAdministratorInput = {\n    id: string\n    log_type: string\n    message: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_logsCreateOrConnectWithoutAdministratorInput = {\n    where: shopping_admin_logsWhereUniqueInput\n    create: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_logsCreateManyAdministratorInputEnvelope = {\n    data: shopping_admin_logsCreateManyAdministratorInput | shopping_admin_logsCreateManyAdministratorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_review_moderationUpsertWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    update: XOR<shopping_review_moderationUpdateWithoutAdministratorInput, shopping_review_moderationUncheckedUpdateWithoutAdministratorInput>\n    create: XOR<shopping_review_moderationCreateWithoutAdministratorInput, shopping_review_moderationUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_review_moderationUpdateWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    data: XOR<shopping_review_moderationUpdateWithoutAdministratorInput, shopping_review_moderationUncheckedUpdateWithoutAdministratorInput>\n  }\n\n  export type shopping_review_moderationUpdateManyWithWhereWithoutAdministratorInput = {\n    where: shopping_review_moderationScalarWhereInput\n    data: XOR<shopping_review_moderationUpdateManyMutationInput, shopping_review_moderationUncheckedUpdateManyWithoutAdministratorInput>\n  }\n\n  export type shopping_review_moderationScalarWhereInput = {\n    AND?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n    OR?: shopping_review_moderationScalarWhereInput[]\n    NOT?: shopping_review_moderationScalarWhereInput | shopping_review_moderationScalarWhereInput[]\n    id?: UuidFilter<\"shopping_review_moderation\"> | string\n    shopping_product_review_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    shopping_administrator_id?: UuidFilter<\"shopping_review_moderation\"> | string\n    action_type?: StringFilter<\"shopping_review_moderation\"> | string\n    reason?: StringNullableFilter<\"shopping_review_moderation\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_review_moderation\"> | Date | string\n  }\n\n  export type shopping_admin_actionsUpsertWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_admin_actionsWhereUniqueInput\n    update: XOR<shopping_admin_actionsUpdateWithoutAdministratorInput, shopping_admin_actionsUncheckedUpdateWithoutAdministratorInput>\n    create: XOR<shopping_admin_actionsCreateWithoutAdministratorInput, shopping_admin_actionsUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_actionsUpdateWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_admin_actionsWhereUniqueInput\n    data: XOR<shopping_admin_actionsUpdateWithoutAdministratorInput, shopping_admin_actionsUncheckedUpdateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_actionsUpdateManyWithWhereWithoutAdministratorInput = {\n    where: shopping_admin_actionsScalarWhereInput\n    data: XOR<shopping_admin_actionsUpdateManyMutationInput, shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_actionsScalarWhereInput = {\n    AND?: shopping_admin_actionsScalarWhereInput | shopping_admin_actionsScalarWhereInput[]\n    OR?: shopping_admin_actionsScalarWhereInput[]\n    NOT?: shopping_admin_actionsScalarWhereInput | shopping_admin_actionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_admin_actions\"> | string\n    shopping_administrator_id?: UuidFilter<\"shopping_admin_actions\"> | string\n    action_type?: StringFilter<\"shopping_admin_actions\"> | string\n    description?: StringFilter<\"shopping_admin_actions\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_actions\"> | Date | string\n  }\n\n  export type shopping_admin_logsUpsertWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_admin_logsWhereUniqueInput\n    update: XOR<shopping_admin_logsUpdateWithoutAdministratorInput, shopping_admin_logsUncheckedUpdateWithoutAdministratorInput>\n    create: XOR<shopping_admin_logsCreateWithoutAdministratorInput, shopping_admin_logsUncheckedCreateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_logsUpdateWithWhereUniqueWithoutAdministratorInput = {\n    where: shopping_admin_logsWhereUniqueInput\n    data: XOR<shopping_admin_logsUpdateWithoutAdministratorInput, shopping_admin_logsUncheckedUpdateWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_logsUpdateManyWithWhereWithoutAdministratorInput = {\n    where: shopping_admin_logsScalarWhereInput\n    data: XOR<shopping_admin_logsUpdateManyMutationInput, shopping_admin_logsUncheckedUpdateManyWithoutAdministratorInput>\n  }\n\n  export type shopping_admin_logsScalarWhereInput = {\n    AND?: shopping_admin_logsScalarWhereInput | shopping_admin_logsScalarWhereInput[]\n    OR?: shopping_admin_logsScalarWhereInput[]\n    NOT?: shopping_admin_logsScalarWhereInput | shopping_admin_logsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_admin_logs\"> | string\n    shopping_administrator_id?: UuidNullableFilter<\"shopping_admin_logs\"> | string | null\n    log_type?: StringFilter<\"shopping_admin_logs\"> | string\n    message?: StringFilter<\"shopping_admin_logs\"> | string\n    created_at?: DateTimeFilter<\"shopping_admin_logs\"> | Date | string\n  }\n\n  export type shopping_categoriesCreateWithoutShopping_productsInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    parent?: shopping_categoriesCreateNestedOneWithoutRecursiveInput\n    recursive?: shopping_categoriesCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesUncheckedCreateWithoutShopping_productsInput = {\n    id: string\n    parent_id?: string | null\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    recursive?: shopping_categoriesUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesCreateOrConnectWithoutShopping_productsInput = {\n    where: shopping_categoriesWhereUniqueInput\n    create: XOR<shopping_categoriesCreateWithoutShopping_productsInput, shopping_categoriesUncheckedCreateWithoutShopping_productsInput>\n  }\n\n  export type shopping_product_variantsCreateWithoutProductInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateWithoutProductInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsCreateOrConnectWithoutProductInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    create: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_product_variantsCreateManyProductInputEnvelope = {\n    data: shopping_product_variantsCreateManyProductInput | shopping_product_variantsCreateManyProductInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_inventoryCreateWithoutProductInput = {\n    id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    variant: shopping_product_variantsCreateNestedOneWithoutShopping_inventoryInput\n  }\n\n  export type shopping_inventoryUncheckedCreateWithoutProductInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_inventoryCreateOrConnectWithoutProductInput = {\n    where: shopping_inventoryWhereUniqueInput\n    create: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_inventoryCreateManyProductInputEnvelope = {\n    data: shopping_inventoryCreateManyProductInput | shopping_inventoryCreateManyProductInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_product_reviewsCreateWithoutProductInput = {\n    id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_product_reviewsInput\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUncheckedCreateWithoutProductInput = {\n    id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutReviewInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsCreateOrConnectWithoutProductInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    create: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_product_reviewsCreateManyProductInputEnvelope = {\n    data: shopping_product_reviewsCreateManyProductInput | shopping_product_reviewsCreateManyProductInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_seller_productsCreateWithoutProductInput = {\n    id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    seller: shopping_sellersCreateNestedOneWithoutShopping_seller_productsInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsUncheckedCreateWithoutProductInput = {\n    id: string\n    shopping_seller_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutSellerProductInput\n  }\n\n  export type shopping_seller_productsCreateOrConnectWithoutProductInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    create: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_seller_productsCreateManyProductInputEnvelope = {\n    data: shopping_seller_productsCreateManyProductInput | shopping_seller_productsCreateManyProductInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_categoriesUpsertWithoutShopping_productsInput = {\n    update: XOR<shopping_categoriesUpdateWithoutShopping_productsInput, shopping_categoriesUncheckedUpdateWithoutShopping_productsInput>\n    create: XOR<shopping_categoriesCreateWithoutShopping_productsInput, shopping_categoriesUncheckedCreateWithoutShopping_productsInput>\n    where?: shopping_categoriesWhereInput\n  }\n\n  export type shopping_categoriesUpdateToOneWithWhereWithoutShopping_productsInput = {\n    where?: shopping_categoriesWhereInput\n    data: XOR<shopping_categoriesUpdateWithoutShopping_productsInput, shopping_categoriesUncheckedUpdateWithoutShopping_productsInput>\n  }\n\n  export type shopping_categoriesUpdateWithoutShopping_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    parent?: shopping_categoriesUpdateOneWithoutRecursiveNestedInput\n    recursive?: shopping_categoriesUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_categoriesUncheckedUpdateWithoutShopping_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    recursive?: shopping_categoriesUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_product_variantsUpsertWithWhereUniqueWithoutProductInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    update: XOR<shopping_product_variantsUpdateWithoutProductInput, shopping_product_variantsUncheckedUpdateWithoutProductInput>\n    create: XOR<shopping_product_variantsCreateWithoutProductInput, shopping_product_variantsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_product_variantsUpdateWithWhereUniqueWithoutProductInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    data: XOR<shopping_product_variantsUpdateWithoutProductInput, shopping_product_variantsUncheckedUpdateWithoutProductInput>\n  }\n\n  export type shopping_product_variantsUpdateManyWithWhereWithoutProductInput = {\n    where: shopping_product_variantsScalarWhereInput\n    data: XOR<shopping_product_variantsUpdateManyMutationInput, shopping_product_variantsUncheckedUpdateManyWithoutProductInput>\n  }\n\n  export type shopping_product_variantsScalarWhereInput = {\n    AND?: shopping_product_variantsScalarWhereInput | shopping_product_variantsScalarWhereInput[]\n    OR?: shopping_product_variantsScalarWhereInput[]\n    NOT?: shopping_product_variantsScalarWhereInput | shopping_product_variantsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_product_variants\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_product_variants\"> | string\n    sku?: StringFilter<\"shopping_product_variants\"> | string\n    option_name?: StringFilter<\"shopping_product_variants\"> | string\n    option_value?: StringFilter<\"shopping_product_variants\"> | string\n    price_adjustment?: FloatNullableFilter<\"shopping_product_variants\"> | number | null\n    created_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_product_variants\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_product_variants\"> | string | null\n  }\n\n  export type shopping_inventoryUpsertWithWhereUniqueWithoutProductInput = {\n    where: shopping_inventoryWhereUniqueInput\n    update: XOR<shopping_inventoryUpdateWithoutProductInput, shopping_inventoryUncheckedUpdateWithoutProductInput>\n    create: XOR<shopping_inventoryCreateWithoutProductInput, shopping_inventoryUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_inventoryUpdateWithWhereUniqueWithoutProductInput = {\n    where: shopping_inventoryWhereUniqueInput\n    data: XOR<shopping_inventoryUpdateWithoutProductInput, shopping_inventoryUncheckedUpdateWithoutProductInput>\n  }\n\n  export type shopping_inventoryUpdateManyWithWhereWithoutProductInput = {\n    where: shopping_inventoryScalarWhereInput\n    data: XOR<shopping_inventoryUpdateManyMutationInput, shopping_inventoryUncheckedUpdateManyWithoutProductInput>\n  }\n\n  export type shopping_inventoryScalarWhereInput = {\n    AND?: shopping_inventoryScalarWhereInput | shopping_inventoryScalarWhereInput[]\n    OR?: shopping_inventoryScalarWhereInput[]\n    NOT?: shopping_inventoryScalarWhereInput | shopping_inventoryScalarWhereInput[]\n    id?: UuidFilter<\"shopping_inventory\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_inventory\"> | string\n    shopping_product_id?: UuidFilter<\"shopping_inventory\"> | string\n    quantity?: IntFilter<\"shopping_inventory\"> | number\n    reserved_quantity?: IntFilter<\"shopping_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_inventory\"> | number | null\n    last_stock_update?: DateTimeNullableFilter<\"shopping_inventory\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_inventory\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_inventory\"> | string | null\n  }\n\n  export type shopping_product_reviewsUpsertWithWhereUniqueWithoutProductInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    update: XOR<shopping_product_reviewsUpdateWithoutProductInput, shopping_product_reviewsUncheckedUpdateWithoutProductInput>\n    create: XOR<shopping_product_reviewsCreateWithoutProductInput, shopping_product_reviewsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_product_reviewsUpdateWithWhereUniqueWithoutProductInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    data: XOR<shopping_product_reviewsUpdateWithoutProductInput, shopping_product_reviewsUncheckedUpdateWithoutProductInput>\n  }\n\n  export type shopping_product_reviewsUpdateManyWithWhereWithoutProductInput = {\n    where: shopping_product_reviewsScalarWhereInput\n    data: XOR<shopping_product_reviewsUpdateManyMutationInput, shopping_product_reviewsUncheckedUpdateManyWithoutProductInput>\n  }\n\n  export type shopping_seller_productsUpsertWithWhereUniqueWithoutProductInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    update: XOR<shopping_seller_productsUpdateWithoutProductInput, shopping_seller_productsUncheckedUpdateWithoutProductInput>\n    create: XOR<shopping_seller_productsCreateWithoutProductInput, shopping_seller_productsUncheckedCreateWithoutProductInput>\n  }\n\n  export type shopping_seller_productsUpdateWithWhereUniqueWithoutProductInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    data: XOR<shopping_seller_productsUpdateWithoutProductInput, shopping_seller_productsUncheckedUpdateWithoutProductInput>\n  }\n\n  export type shopping_seller_productsUpdateManyWithWhereWithoutProductInput = {\n    where: shopping_seller_productsScalarWhereInput\n    data: XOR<shopping_seller_productsUpdateManyMutationInput, shopping_seller_productsUncheckedUpdateManyWithoutProductInput>\n  }\n\n  export type shopping_productsCreateWithoutShopping_product_variantsInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    category?: shopping_categoriesCreateNestedOneWithoutShopping_productsInput\n    shopping_inventory?: shopping_inventoryCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateWithoutShopping_product_variantsInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsCreateOrConnectWithoutShopping_product_variantsInput = {\n    where: shopping_productsWhereUniqueInput\n    create: XOR<shopping_productsCreateWithoutShopping_product_variantsInput, shopping_productsUncheckedCreateWithoutShopping_product_variantsInput>\n  }\n\n  export type shopping_inventoryCreateWithoutVariantInput = {\n    id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_inventoryInput\n  }\n\n  export type shopping_inventoryUncheckedCreateWithoutVariantInput = {\n    id: string\n    shopping_product_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_inventoryCreateOrConnectWithoutVariantInput = {\n    where: shopping_inventoryWhereUniqueInput\n    create: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n  }\n\n  export type shopping_order_itemsCreateWithoutProductVariantInput = {\n    id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_order_itemsInput\n  }\n\n  export type shopping_order_itemsUncheckedCreateWithoutProductVariantInput = {\n    id: string\n    shopping_order_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsCreateOrConnectWithoutProductVariantInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    create: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_order_itemsCreateManyProductVariantInputEnvelope = {\n    data: shopping_order_itemsCreateManyProductVariantInput | shopping_order_itemsCreateManyProductVariantInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_cart_itemsCreateWithoutProductVariantInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    cart: shopping_shopping_cartsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateWithoutProductVariantInput = {\n    id: string\n    shopping_shopping_cart_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsCreateOrConnectWithoutProductVariantInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    create: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_cart_itemsCreateManyProductVariantInputEnvelope = {\n    data: shopping_cart_itemsCreateManyProductVariantInput | shopping_cart_itemsCreateManyProductVariantInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_seller_inventoryCreateWithoutProductVariantInput = {\n    id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    sellerProduct: shopping_seller_productsCreateNestedOneWithoutShopping_seller_inventoryInput\n  }\n\n  export type shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput = {\n    id: string\n    shopping_seller_product_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_inventoryCreateOrConnectWithoutProductVariantInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    create: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_seller_inventoryCreateManyProductVariantInputEnvelope = {\n    data: shopping_seller_inventoryCreateManyProductVariantInput | shopping_seller_inventoryCreateManyProductVariantInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_productsUpsertWithoutShopping_product_variantsInput = {\n    update: XOR<shopping_productsUpdateWithoutShopping_product_variantsInput, shopping_productsUncheckedUpdateWithoutShopping_product_variantsInput>\n    create: XOR<shopping_productsCreateWithoutShopping_product_variantsInput, shopping_productsUncheckedCreateWithoutShopping_product_variantsInput>\n    where?: shopping_productsWhereInput\n  }\n\n  export type shopping_productsUpdateToOneWithWhereWithoutShopping_product_variantsInput = {\n    where?: shopping_productsWhereInput\n    data: XOR<shopping_productsUpdateWithoutShopping_product_variantsInput, shopping_productsUncheckedUpdateWithoutShopping_product_variantsInput>\n  }\n\n  export type shopping_productsUpdateWithoutShopping_product_variantsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    category?: shopping_categoriesUpdateOneWithoutShopping_productsNestedInput\n    shopping_inventory?: shopping_inventoryUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateWithoutShopping_product_variantsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_inventoryUpsertWithoutVariantInput = {\n    update: XOR<shopping_inventoryUpdateWithoutVariantInput, shopping_inventoryUncheckedUpdateWithoutVariantInput>\n    create: XOR<shopping_inventoryCreateWithoutVariantInput, shopping_inventoryUncheckedCreateWithoutVariantInput>\n    where?: shopping_inventoryWhereInput\n  }\n\n  export type shopping_inventoryUpdateToOneWithWhereWithoutVariantInput = {\n    where?: shopping_inventoryWhereInput\n    data: XOR<shopping_inventoryUpdateWithoutVariantInput, shopping_inventoryUncheckedUpdateWithoutVariantInput>\n  }\n\n  export type shopping_inventoryUpdateWithoutVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_inventoryNestedInput\n  }\n\n  export type shopping_inventoryUncheckedUpdateWithoutVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_itemsUpsertWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    update: XOR<shopping_order_itemsUpdateWithoutProductVariantInput, shopping_order_itemsUncheckedUpdateWithoutProductVariantInput>\n    create: XOR<shopping_order_itemsCreateWithoutProductVariantInput, shopping_order_itemsUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_order_itemsUpdateWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    data: XOR<shopping_order_itemsUpdateWithoutProductVariantInput, shopping_order_itemsUncheckedUpdateWithoutProductVariantInput>\n  }\n\n  export type shopping_order_itemsUpdateManyWithWhereWithoutProductVariantInput = {\n    where: shopping_order_itemsScalarWhereInput\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyWithoutProductVariantInput>\n  }\n\n  export type shopping_order_itemsScalarWhereInput = {\n    AND?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n    OR?: shopping_order_itemsScalarWhereInput[]\n    NOT?: shopping_order_itemsScalarWhereInput | shopping_order_itemsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_order_items\"> | string\n    quantity?: IntFilter<\"shopping_order_items\"> | number\n    unit_price?: FloatFilter<\"shopping_order_items\"> | number\n    total_price?: FloatFilter<\"shopping_order_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_order_items\"> | Date | string\n  }\n\n  export type shopping_cart_itemsUpsertWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    update: XOR<shopping_cart_itemsUpdateWithoutProductVariantInput, shopping_cart_itemsUncheckedUpdateWithoutProductVariantInput>\n    create: XOR<shopping_cart_itemsCreateWithoutProductVariantInput, shopping_cart_itemsUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_cart_itemsUpdateWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    data: XOR<shopping_cart_itemsUpdateWithoutProductVariantInput, shopping_cart_itemsUncheckedUpdateWithoutProductVariantInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithWhereWithoutProductVariantInput = {\n    where: shopping_cart_itemsScalarWhereInput\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantInput>\n  }\n\n  export type shopping_cart_itemsScalarWhereInput = {\n    AND?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n    OR?: shopping_cart_itemsScalarWhereInput[]\n    NOT?: shopping_cart_itemsScalarWhereInput | shopping_cart_itemsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_shopping_cart_id?: UuidFilter<\"shopping_cart_items\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_cart_items\"> | string\n    quantity?: IntFilter<\"shopping_cart_items\"> | number\n    price?: FloatFilter<\"shopping_cart_items\"> | number\n    created_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_cart_items\"> | Date | string\n  }\n\n  export type shopping_seller_inventoryUpsertWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    update: XOR<shopping_seller_inventoryUpdateWithoutProductVariantInput, shopping_seller_inventoryUncheckedUpdateWithoutProductVariantInput>\n    create: XOR<shopping_seller_inventoryCreateWithoutProductVariantInput, shopping_seller_inventoryUncheckedCreateWithoutProductVariantInput>\n  }\n\n  export type shopping_seller_inventoryUpdateWithWhereUniqueWithoutProductVariantInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    data: XOR<shopping_seller_inventoryUpdateWithoutProductVariantInput, shopping_seller_inventoryUncheckedUpdateWithoutProductVariantInput>\n  }\n\n  export type shopping_seller_inventoryUpdateManyWithWhereWithoutProductVariantInput = {\n    where: shopping_seller_inventoryScalarWhereInput\n    data: XOR<shopping_seller_inventoryUpdateManyMutationInput, shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantInput>\n  }\n\n  export type shopping_seller_inventoryScalarWhereInput = {\n    AND?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n    OR?: shopping_seller_inventoryScalarWhereInput[]\n    NOT?: shopping_seller_inventoryScalarWhereInput | shopping_seller_inventoryScalarWhereInput[]\n    id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    shopping_seller_product_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    shopping_product_variant_id?: UuidFilter<\"shopping_seller_inventory\"> | string\n    stock_quantity?: IntFilter<\"shopping_seller_inventory\"> | number\n    low_stock_threshold?: IntNullableFilter<\"shopping_seller_inventory\"> | number | null\n    status?: StringFilter<\"shopping_seller_inventory\"> | string\n    business_status?: StringNullableFilter<\"shopping_seller_inventory\"> | string | null\n    created_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_seller_inventory\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_seller_inventory\"> | Date | string | null\n  }\n\n  export type shopping_categoriesCreateWithoutRecursiveInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    parent?: shopping_categoriesCreateNestedOneWithoutRecursiveInput\n    shopping_products?: shopping_productsCreateNestedManyWithoutCategoryInput\n  }\n\n  export type shopping_categoriesUncheckedCreateWithoutRecursiveInput = {\n    id: string\n    parent_id?: string | null\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_products?: shopping_productsUncheckedCreateNestedManyWithoutCategoryInput\n  }\n\n  export type shopping_categoriesCreateOrConnectWithoutRecursiveInput = {\n    where: shopping_categoriesWhereUniqueInput\n    create: XOR<shopping_categoriesCreateWithoutRecursiveInput, shopping_categoriesUncheckedCreateWithoutRecursiveInput>\n  }\n\n  export type shopping_productsCreateWithoutCategoryInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateWithoutCategoryInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsCreateOrConnectWithoutCategoryInput = {\n    where: shopping_productsWhereUniqueInput\n    create: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type shopping_productsCreateManyCategoryInputEnvelope = {\n    data: shopping_productsCreateManyCategoryInput | shopping_productsCreateManyCategoryInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_categoriesCreateWithoutParentInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_products?: shopping_productsCreateNestedManyWithoutCategoryInput\n    recursive?: shopping_categoriesCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesUncheckedCreateWithoutParentInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_products?: shopping_productsUncheckedCreateNestedManyWithoutCategoryInput\n    recursive?: shopping_categoriesUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type shopping_categoriesCreateOrConnectWithoutParentInput = {\n    where: shopping_categoriesWhereUniqueInput\n    create: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput>\n  }\n\n  export type shopping_categoriesCreateManyParentInputEnvelope = {\n    data: shopping_categoriesCreateManyParentInput | shopping_categoriesCreateManyParentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_categoriesUpsertWithoutRecursiveInput = {\n    update: XOR<shopping_categoriesUpdateWithoutRecursiveInput, shopping_categoriesUncheckedUpdateWithoutRecursiveInput>\n    create: XOR<shopping_categoriesCreateWithoutRecursiveInput, shopping_categoriesUncheckedCreateWithoutRecursiveInput>\n    where?: shopping_categoriesWhereInput\n  }\n\n  export type shopping_categoriesUpdateToOneWithWhereWithoutRecursiveInput = {\n    where?: shopping_categoriesWhereInput\n    data: XOR<shopping_categoriesUpdateWithoutRecursiveInput, shopping_categoriesUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type shopping_categoriesUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    parent?: shopping_categoriesUpdateOneWithoutRecursiveNestedInput\n    shopping_products?: shopping_productsUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type shopping_categoriesUncheckedUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_products?: shopping_productsUncheckedUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type shopping_productsUpsertWithWhereUniqueWithoutCategoryInput = {\n    where: shopping_productsWhereUniqueInput\n    update: XOR<shopping_productsUpdateWithoutCategoryInput, shopping_productsUncheckedUpdateWithoutCategoryInput>\n    create: XOR<shopping_productsCreateWithoutCategoryInput, shopping_productsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type shopping_productsUpdateWithWhereUniqueWithoutCategoryInput = {\n    where: shopping_productsWhereUniqueInput\n    data: XOR<shopping_productsUpdateWithoutCategoryInput, shopping_productsUncheckedUpdateWithoutCategoryInput>\n  }\n\n  export type shopping_productsUpdateManyWithWhereWithoutCategoryInput = {\n    where: shopping_productsScalarWhereInput\n    data: XOR<shopping_productsUpdateManyMutationInput, shopping_productsUncheckedUpdateManyWithoutCategoryInput>\n  }\n\n  export type shopping_productsScalarWhereInput = {\n    AND?: shopping_productsScalarWhereInput | shopping_productsScalarWhereInput[]\n    OR?: shopping_productsScalarWhereInput[]\n    NOT?: shopping_productsScalarWhereInput | shopping_productsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_products\"> | string\n    shopping_category_id?: UuidNullableFilter<\"shopping_products\"> | string | null\n    name?: StringFilter<\"shopping_products\"> | string\n    description?: StringNullableFilter<\"shopping_products\"> | string | null\n    price?: FloatFilter<\"shopping_products\"> | number\n    sku?: StringFilter<\"shopping_products\"> | string\n    created_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_products\"> | Date | string\n    password_hash?: StringFilter<\"shopping_products\"> | string\n    business_status?: StringNullableFilter<\"shopping_products\"> | string | null\n  }\n\n  export type shopping_categoriesUpsertWithWhereUniqueWithoutParentInput = {\n    where: shopping_categoriesWhereUniqueInput\n    update: XOR<shopping_categoriesUpdateWithoutParentInput, shopping_categoriesUncheckedUpdateWithoutParentInput>\n    create: XOR<shopping_categoriesCreateWithoutParentInput, shopping_categoriesUncheckedCreateWithoutParentInput>\n  }\n\n  export type shopping_categoriesUpdateWithWhereUniqueWithoutParentInput = {\n    where: shopping_categoriesWhereUniqueInput\n    data: XOR<shopping_categoriesUpdateWithoutParentInput, shopping_categoriesUncheckedUpdateWithoutParentInput>\n  }\n\n  export type shopping_categoriesUpdateManyWithWhereWithoutParentInput = {\n    where: shopping_categoriesScalarWhereInput\n    data: XOR<shopping_categoriesUpdateManyMutationInput, shopping_categoriesUncheckedUpdateManyWithoutParentInput>\n  }\n\n  export type shopping_categoriesScalarWhereInput = {\n    AND?: shopping_categoriesScalarWhereInput | shopping_categoriesScalarWhereInput[]\n    OR?: shopping_categoriesScalarWhereInput[]\n    NOT?: shopping_categoriesScalarWhereInput | shopping_categoriesScalarWhereInput[]\n    id?: UuidFilter<\"shopping_categories\"> | string\n    parent_id?: UuidNullableFilter<\"shopping_categories\"> | string | null\n    name?: StringFilter<\"shopping_categories\"> | string\n    description?: StringNullableFilter<\"shopping_categories\"> | string | null\n    code?: StringFilter<\"shopping_categories\"> | string\n    created_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_categories\"> | Date | string\n    business_status?: StringNullableFilter<\"shopping_categories\"> | string | null\n  }\n\n  export type shopping_product_variantsCreateWithoutShopping_inventoryInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_variantsInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateWithoutShopping_inventoryInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsCreateOrConnectWithoutShopping_inventoryInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    create: XOR<shopping_product_variantsCreateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_productsCreateWithoutShopping_inventoryInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    category?: shopping_categoriesCreateNestedOneWithoutShopping_productsInput\n    shopping_product_variants?: shopping_product_variantsCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateWithoutShopping_inventoryInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsCreateOrConnectWithoutShopping_inventoryInput = {\n    where: shopping_productsWhereUniqueInput\n    create: XOR<shopping_productsCreateWithoutShopping_inventoryInput, shopping_productsUncheckedCreateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_product_variantsUpsertWithoutShopping_inventoryInput = {\n    update: XOR<shopping_product_variantsUpdateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedUpdateWithoutShopping_inventoryInput>\n    create: XOR<shopping_product_variantsCreateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_inventoryInput>\n    where?: shopping_product_variantsWhereInput\n  }\n\n  export type shopping_product_variantsUpdateToOneWithWhereWithoutShopping_inventoryInput = {\n    where?: shopping_product_variantsWhereInput\n    data: XOR<shopping_product_variantsUpdateWithoutShopping_inventoryInput, shopping_product_variantsUncheckedUpdateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_product_variantsUpdateWithoutShopping_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateWithoutShopping_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_productsUpsertWithoutShopping_inventoryInput = {\n    update: XOR<shopping_productsUpdateWithoutShopping_inventoryInput, shopping_productsUncheckedUpdateWithoutShopping_inventoryInput>\n    create: XOR<shopping_productsCreateWithoutShopping_inventoryInput, shopping_productsUncheckedCreateWithoutShopping_inventoryInput>\n    where?: shopping_productsWhereInput\n  }\n\n  export type shopping_productsUpdateToOneWithWhereWithoutShopping_inventoryInput = {\n    where?: shopping_productsWhereInput\n    data: XOR<shopping_productsUpdateWithoutShopping_inventoryInput, shopping_productsUncheckedUpdateWithoutShopping_inventoryInput>\n  }\n\n  export type shopping_productsUpdateWithoutShopping_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    category?: shopping_categoriesUpdateOneWithoutShopping_productsNestedInput\n    shopping_product_variants?: shopping_product_variantsUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateWithoutShopping_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsCreateWithoutShopping_product_reviewsInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    category?: shopping_categoriesCreateNestedOneWithoutShopping_productsInput\n    shopping_product_variants?: shopping_product_variantsCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateWithoutShopping_product_reviewsInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedManyWithoutProductInput\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsCreateOrConnectWithoutShopping_product_reviewsInput = {\n    where: shopping_productsWhereUniqueInput\n    create: XOR<shopping_productsCreateWithoutShopping_product_reviewsInput, shopping_productsUncheckedCreateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_customersCreateWithoutShopping_product_reviewsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUncheckedCreateWithoutShopping_product_reviewsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersCreateOrConnectWithoutShopping_product_reviewsInput = {\n    where: shopping_customersWhereUniqueInput\n    create: XOR<shopping_customersCreateWithoutShopping_product_reviewsInput, shopping_customersUncheckedCreateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_review_moderationCreateWithoutReviewInput = {\n    id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n    administrator: shopping_administratorsCreateNestedOneWithoutShopping_review_moderationInput\n  }\n\n  export type shopping_review_moderationUncheckedCreateWithoutReviewInput = {\n    id: string\n    shopping_administrator_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationCreateOrConnectWithoutReviewInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    create: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput>\n  }\n\n  export type shopping_review_moderationCreateManyReviewInputEnvelope = {\n    data: shopping_review_moderationCreateManyReviewInput | shopping_review_moderationCreateManyReviewInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_review_ratingsCreateWithoutReviewInput = {\n    id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n  }\n\n  export type shopping_review_ratingsUncheckedCreateWithoutReviewInput = {\n    id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n  }\n\n  export type shopping_review_ratingsCreateOrConnectWithoutReviewInput = {\n    where: shopping_review_ratingsWhereUniqueInput\n    create: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput>\n  }\n\n  export type shopping_review_ratingsCreateManyReviewInputEnvelope = {\n    data: shopping_review_ratingsCreateManyReviewInput | shopping_review_ratingsCreateManyReviewInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_productsUpsertWithoutShopping_product_reviewsInput = {\n    update: XOR<shopping_productsUpdateWithoutShopping_product_reviewsInput, shopping_productsUncheckedUpdateWithoutShopping_product_reviewsInput>\n    create: XOR<shopping_productsCreateWithoutShopping_product_reviewsInput, shopping_productsUncheckedCreateWithoutShopping_product_reviewsInput>\n    where?: shopping_productsWhereInput\n  }\n\n  export type shopping_productsUpdateToOneWithWhereWithoutShopping_product_reviewsInput = {\n    where?: shopping_productsWhereInput\n    data: XOR<shopping_productsUpdateWithoutShopping_product_reviewsInput, shopping_productsUncheckedUpdateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_productsUpdateWithoutShopping_product_reviewsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    category?: shopping_categoriesUpdateOneWithoutShopping_productsNestedInput\n    shopping_product_variants?: shopping_product_variantsUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateWithoutShopping_product_reviewsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_customersUpsertWithoutShopping_product_reviewsInput = {\n    update: XOR<shopping_customersUpdateWithoutShopping_product_reviewsInput, shopping_customersUncheckedUpdateWithoutShopping_product_reviewsInput>\n    create: XOR<shopping_customersCreateWithoutShopping_product_reviewsInput, shopping_customersUncheckedCreateWithoutShopping_product_reviewsInput>\n    where?: shopping_customersWhereInput\n  }\n\n  export type shopping_customersUpdateToOneWithWhereWithoutShopping_product_reviewsInput = {\n    where?: shopping_customersWhereInput\n    data: XOR<shopping_customersUpdateWithoutShopping_product_reviewsInput, shopping_customersUncheckedUpdateWithoutShopping_product_reviewsInput>\n  }\n\n  export type shopping_customersUpdateWithoutShopping_product_reviewsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_orders?: shopping_ordersUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersUncheckedUpdateWithoutShopping_product_reviewsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_review_moderationUpsertWithWhereUniqueWithoutReviewInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    update: XOR<shopping_review_moderationUpdateWithoutReviewInput, shopping_review_moderationUncheckedUpdateWithoutReviewInput>\n    create: XOR<shopping_review_moderationCreateWithoutReviewInput, shopping_review_moderationUncheckedCreateWithoutReviewInput>\n  }\n\n  export type shopping_review_moderationUpdateWithWhereUniqueWithoutReviewInput = {\n    where: shopping_review_moderationWhereUniqueInput\n    data: XOR<shopping_review_moderationUpdateWithoutReviewInput, shopping_review_moderationUncheckedUpdateWithoutReviewInput>\n  }\n\n  export type shopping_review_moderationUpdateManyWithWhereWithoutReviewInput = {\n    where: shopping_review_moderationScalarWhereInput\n    data: XOR<shopping_review_moderationUpdateManyMutationInput, shopping_review_moderationUncheckedUpdateManyWithoutReviewInput>\n  }\n\n  export type shopping_review_ratingsUpsertWithWhereUniqueWithoutReviewInput = {\n    where: shopping_review_ratingsWhereUniqueInput\n    update: XOR<shopping_review_ratingsUpdateWithoutReviewInput, shopping_review_ratingsUncheckedUpdateWithoutReviewInput>\n    create: XOR<shopping_review_ratingsCreateWithoutReviewInput, shopping_review_ratingsUncheckedCreateWithoutReviewInput>\n  }\n\n  export type shopping_review_ratingsUpdateWithWhereUniqueWithoutReviewInput = {\n    where: shopping_review_ratingsWhereUniqueInput\n    data: XOR<shopping_review_ratingsUpdateWithoutReviewInput, shopping_review_ratingsUncheckedUpdateWithoutReviewInput>\n  }\n\n  export type shopping_review_ratingsUpdateManyWithWhereWithoutReviewInput = {\n    where: shopping_review_ratingsScalarWhereInput\n    data: XOR<shopping_review_ratingsUpdateManyMutationInput, shopping_review_ratingsUncheckedUpdateManyWithoutReviewInput>\n  }\n\n  export type shopping_review_ratingsScalarWhereInput = {\n    AND?: shopping_review_ratingsScalarWhereInput | shopping_review_ratingsScalarWhereInput[]\n    OR?: shopping_review_ratingsScalarWhereInput[]\n    NOT?: shopping_review_ratingsScalarWhereInput | shopping_review_ratingsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_review_ratings\"> | string\n    shopping_product_review_id?: UuidFilter<\"shopping_review_ratings\"> | string\n    quality_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    value_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    service_rating?: IntFilter<\"shopping_review_ratings\"> | number\n    created_at?: DateTimeFilter<\"shopping_review_ratings\"> | Date | string\n  }\n\n  export type shopping_customersCreateWithoutShopping_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUncheckedCreateWithoutShopping_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersCreateOrConnectWithoutShopping_ordersInput = {\n    where: shopping_customersWhereUniqueInput\n    create: XOR<shopping_customersCreateWithoutShopping_ordersInput, shopping_customersUncheckedCreateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_order_itemsCreateWithoutOrderInput = {\n    id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_order_itemsInput\n  }\n\n  export type shopping_order_itemsUncheckedCreateWithoutOrderInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsCreateOrConnectWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    create: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsCreateManyOrderInputEnvelope = {\n    data: shopping_order_itemsCreateManyOrderInput | shopping_order_itemsCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_order_statusCreateWithoutOrderInput = {\n    id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n  }\n\n  export type shopping_order_statusUncheckedCreateWithoutOrderInput = {\n    id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n  }\n\n  export type shopping_order_statusCreateOrConnectWithoutOrderInput = {\n    where: shopping_order_statusWhereUniqueInput\n    create: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_statusCreateManyOrderInputEnvelope = {\n    data: shopping_order_statusCreateManyOrderInput | shopping_order_statusCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_order_historyCreateWithoutOrderInput = {\n    id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n  }\n\n  export type shopping_order_historyUncheckedCreateWithoutOrderInput = {\n    id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n  }\n\n  export type shopping_order_historyCreateOrConnectWithoutOrderInput = {\n    where: shopping_order_historyWhereUniqueInput\n    create: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_historyCreateManyOrderInputEnvelope = {\n    data: shopping_order_historyCreateManyOrderInput | shopping_order_historyCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_seller_ordersCreateWithoutOrderInput = {\n    id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    seller: shopping_sellersCreateNestedOneWithoutShopping_seller_ordersInput\n  }\n\n  export type shopping_seller_ordersUncheckedCreateWithoutOrderInput = {\n    id: string\n    shopping_seller_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_ordersCreateOrConnectWithoutOrderInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    create: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_seller_ordersCreateManyOrderInputEnvelope = {\n    data: shopping_seller_ordersCreateManyOrderInput | shopping_seller_ordersCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_paymentsCreateWithoutOrderInput = {\n    id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_paymentsInput\n    shopping_payment_transactions?: shopping_payment_transactionsCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsUncheckedCreateWithoutOrderInput = {\n    id: string\n    shopping_customer_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedCreateNestedManyWithoutPaymentInput\n  }\n\n  export type shopping_paymentsCreateOrConnectWithoutOrderInput = {\n    where: shopping_paymentsWhereUniqueInput\n    create: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_paymentsCreateManyOrderInputEnvelope = {\n    data: shopping_paymentsCreateManyOrderInput | shopping_paymentsCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_shipping_trackingCreateWithoutOrderInput = {\n    id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    carrier: shopping_shipping_carriersCreateNestedOneWithoutShopping_shipping_trackingInput\n    method: shopping_shipping_methodsCreateNestedOneWithoutShopping_shipping_trackingInput\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateWithoutOrderInput = {\n    id: string\n    shopping_shipping_carrier_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingCreateOrConnectWithoutOrderInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    create: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_shipping_trackingCreateManyOrderInputEnvelope = {\n    data: shopping_shipping_trackingCreateManyOrderInput | shopping_shipping_trackingCreateManyOrderInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_customersUpsertWithoutShopping_ordersInput = {\n    update: XOR<shopping_customersUpdateWithoutShopping_ordersInput, shopping_customersUncheckedUpdateWithoutShopping_ordersInput>\n    create: XOR<shopping_customersCreateWithoutShopping_ordersInput, shopping_customersUncheckedCreateWithoutShopping_ordersInput>\n    where?: shopping_customersWhereInput\n  }\n\n  export type shopping_customersUpdateToOneWithWhereWithoutShopping_ordersInput = {\n    where?: shopping_customersWhereInput\n    data: XOR<shopping_customersUpdateWithoutShopping_ordersInput, shopping_customersUncheckedUpdateWithoutShopping_ordersInput>\n  }\n\n  export type shopping_customersUpdateWithoutShopping_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersUncheckedUpdateWithoutShopping_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_order_itemsUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    update: XOR<shopping_order_itemsUpdateWithoutOrderInput, shopping_order_itemsUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_order_itemsCreateWithoutOrderInput, shopping_order_itemsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_itemsWhereUniqueInput\n    data: XOR<shopping_order_itemsUpdateWithoutOrderInput, shopping_order_itemsUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_order_itemsUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_order_itemsScalarWhereInput\n    data: XOR<shopping_order_itemsUpdateManyMutationInput, shopping_order_itemsUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_order_statusUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_statusWhereUniqueInput\n    update: XOR<shopping_order_statusUpdateWithoutOrderInput, shopping_order_statusUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_order_statusCreateWithoutOrderInput, shopping_order_statusUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_statusUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_statusWhereUniqueInput\n    data: XOR<shopping_order_statusUpdateWithoutOrderInput, shopping_order_statusUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_order_statusUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_order_statusScalarWhereInput\n    data: XOR<shopping_order_statusUpdateManyMutationInput, shopping_order_statusUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_order_statusScalarWhereInput = {\n    AND?: shopping_order_statusScalarWhereInput | shopping_order_statusScalarWhereInput[]\n    OR?: shopping_order_statusScalarWhereInput[]\n    NOT?: shopping_order_statusScalarWhereInput | shopping_order_statusScalarWhereInput[]\n    id?: UuidFilter<\"shopping_order_status\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_status\"> | string\n    status?: StringFilter<\"shopping_order_status\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_status\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_status\"> | string | null\n    notes?: StringNullableFilter<\"shopping_order_status\"> | string | null\n  }\n\n  export type shopping_order_historyUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_historyWhereUniqueInput\n    update: XOR<shopping_order_historyUpdateWithoutOrderInput, shopping_order_historyUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_order_historyCreateWithoutOrderInput, shopping_order_historyUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_order_historyUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_order_historyWhereUniqueInput\n    data: XOR<shopping_order_historyUpdateWithoutOrderInput, shopping_order_historyUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_order_historyUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_order_historyScalarWhereInput\n    data: XOR<shopping_order_historyUpdateManyMutationInput, shopping_order_historyUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_order_historyScalarWhereInput = {\n    AND?: shopping_order_historyScalarWhereInput | shopping_order_historyScalarWhereInput[]\n    OR?: shopping_order_historyScalarWhereInput[]\n    NOT?: shopping_order_historyScalarWhereInput | shopping_order_historyScalarWhereInput[]\n    id?: UuidFilter<\"shopping_order_history\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_order_history\"> | string\n    action?: StringFilter<\"shopping_order_history\"> | string\n    changed_at?: DateTimeFilter<\"shopping_order_history\"> | Date | string\n    changed_by?: StringNullableFilter<\"shopping_order_history\"> | string | null\n    details?: StringNullableFilter<\"shopping_order_history\"> | string | null\n  }\n\n  export type shopping_seller_ordersUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    update: XOR<shopping_seller_ordersUpdateWithoutOrderInput, shopping_seller_ordersUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_seller_ordersCreateWithoutOrderInput, shopping_seller_ordersUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_seller_ordersUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_seller_ordersWhereUniqueInput\n    data: XOR<shopping_seller_ordersUpdateWithoutOrderInput, shopping_seller_ordersUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_seller_ordersUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_seller_ordersScalarWhereInput\n    data: XOR<shopping_seller_ordersUpdateManyMutationInput, shopping_seller_ordersUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_paymentsUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_paymentsWhereUniqueInput\n    update: XOR<shopping_paymentsUpdateWithoutOrderInput, shopping_paymentsUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_paymentsCreateWithoutOrderInput, shopping_paymentsUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_paymentsUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_paymentsWhereUniqueInput\n    data: XOR<shopping_paymentsUpdateWithoutOrderInput, shopping_paymentsUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_paymentsUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_paymentsScalarWhereInput\n    data: XOR<shopping_paymentsUpdateManyMutationInput, shopping_paymentsUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_shipping_trackingUpsertWithWhereUniqueWithoutOrderInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    update: XOR<shopping_shipping_trackingUpdateWithoutOrderInput, shopping_shipping_trackingUncheckedUpdateWithoutOrderInput>\n    create: XOR<shopping_shipping_trackingCreateWithoutOrderInput, shopping_shipping_trackingUncheckedCreateWithoutOrderInput>\n  }\n\n  export type shopping_shipping_trackingUpdateWithWhereUniqueWithoutOrderInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    data: XOR<shopping_shipping_trackingUpdateWithoutOrderInput, shopping_shipping_trackingUncheckedUpdateWithoutOrderInput>\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithWhereWithoutOrderInput = {\n    where: shopping_shipping_trackingScalarWhereInput\n    data: XOR<shopping_shipping_trackingUpdateManyMutationInput, shopping_shipping_trackingUncheckedUpdateManyWithoutOrderInput>\n  }\n\n  export type shopping_shipping_trackingScalarWhereInput = {\n    AND?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n    OR?: shopping_shipping_trackingScalarWhereInput[]\n    NOT?: shopping_shipping_trackingScalarWhereInput | shopping_shipping_trackingScalarWhereInput[]\n    id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_order_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_carrier_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    shopping_shipping_method_id?: UuidFilter<\"shopping_shipping_tracking\"> | string\n    tracking_number?: StringFilter<\"shopping_shipping_tracking\"> | string\n    status?: StringFilter<\"shopping_shipping_tracking\"> | string\n    estimated_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    actual_delivery_date?: DateTimeNullableFilter<\"shopping_shipping_tracking\"> | Date | string | null\n    created_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_shipping_tracking\"> | Date | string\n  }\n\n  export type shopping_ordersCreateWithoutShopping_order_itemsInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_order_itemsInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_product_variantsCreateWithoutShopping_order_itemsInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_variantsInput\n    shopping_inventory?: shopping_inventoryCreateNestedOneWithoutVariantInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateWithoutShopping_order_itemsInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsCreateOrConnectWithoutShopping_order_itemsInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    create: XOR<shopping_product_variantsCreateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_order_itemsInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_order_itemsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_order_itemsInput, shopping_ordersUncheckedCreateWithoutShopping_order_itemsInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_order_itemsInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_order_itemsInput, shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_product_variantsUpsertWithoutShopping_order_itemsInput = {\n    update: XOR<shopping_product_variantsUpdateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedUpdateWithoutShopping_order_itemsInput>\n    create: XOR<shopping_product_variantsCreateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_order_itemsInput>\n    where?: shopping_product_variantsWhereInput\n  }\n\n  export type shopping_product_variantsUpdateToOneWithWhereWithoutShopping_order_itemsInput = {\n    where?: shopping_product_variantsWhereInput\n    data: XOR<shopping_product_variantsUpdateWithoutShopping_order_itemsInput, shopping_product_variantsUncheckedUpdateWithoutShopping_order_itemsInput>\n  }\n\n  export type shopping_product_variantsUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput\n    shopping_inventory?: shopping_inventoryUpdateOneWithoutVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateWithoutShopping_order_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_ordersCreateWithoutShopping_order_statusInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_order_statusInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_order_statusInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_order_statusInput, shopping_ordersUncheckedCreateWithoutShopping_order_statusInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_order_statusInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_order_statusInput, shopping_ordersUncheckedUpdateWithoutShopping_order_statusInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_order_statusInput, shopping_ordersUncheckedCreateWithoutShopping_order_statusInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_order_statusInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_order_statusInput, shopping_ordersUncheckedUpdateWithoutShopping_order_statusInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_order_statusInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_order_statusInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersCreateWithoutShopping_order_historyInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_order_historyInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_order_historyInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_order_historyInput, shopping_ordersUncheckedCreateWithoutShopping_order_historyInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_order_historyInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_order_historyInput, shopping_ordersUncheckedUpdateWithoutShopping_order_historyInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_order_historyInput, shopping_ordersUncheckedCreateWithoutShopping_order_historyInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_order_historyInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_order_historyInput, shopping_ordersUncheckedUpdateWithoutShopping_order_historyInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_order_historyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_order_historyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_customersCreateWithoutShopping_shopping_cartsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUncheckedCreateWithoutShopping_shopping_cartsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersCreateOrConnectWithoutShopping_shopping_cartsInput = {\n    where: shopping_customersWhereUniqueInput\n    create: XOR<shopping_customersCreateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedCreateWithoutShopping_shopping_cartsInput>\n  }\n\n  export type shopping_cart_itemsCreateWithoutCartInput = {\n    id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_cart_itemsInput\n  }\n\n  export type shopping_cart_itemsUncheckedCreateWithoutCartInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsCreateOrConnectWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    create: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsCreateManyCartInputEnvelope = {\n    data: shopping_cart_itemsCreateManyCartInput | shopping_cart_itemsCreateManyCartInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_customersUpsertWithoutShopping_shopping_cartsInput = {\n    update: XOR<shopping_customersUpdateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedUpdateWithoutShopping_shopping_cartsInput>\n    create: XOR<shopping_customersCreateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedCreateWithoutShopping_shopping_cartsInput>\n    where?: shopping_customersWhereInput\n  }\n\n  export type shopping_customersUpdateToOneWithWhereWithoutShopping_shopping_cartsInput = {\n    where?: shopping_customersWhereInput\n    data: XOR<shopping_customersUpdateWithoutShopping_shopping_cartsInput, shopping_customersUncheckedUpdateWithoutShopping_shopping_cartsInput>\n  }\n\n  export type shopping_customersUpdateWithoutShopping_shopping_cartsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersUncheckedUpdateWithoutShopping_shopping_cartsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_cart_itemsUpsertWithWhereUniqueWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    update: XOR<shopping_cart_itemsUpdateWithoutCartInput, shopping_cart_itemsUncheckedUpdateWithoutCartInput>\n    create: XOR<shopping_cart_itemsCreateWithoutCartInput, shopping_cart_itemsUncheckedCreateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsUpdateWithWhereUniqueWithoutCartInput = {\n    where: shopping_cart_itemsWhereUniqueInput\n    data: XOR<shopping_cart_itemsUpdateWithoutCartInput, shopping_cart_itemsUncheckedUpdateWithoutCartInput>\n  }\n\n  export type shopping_cart_itemsUpdateManyWithWhereWithoutCartInput = {\n    where: shopping_cart_itemsScalarWhereInput\n    data: XOR<shopping_cart_itemsUpdateManyMutationInput, shopping_cart_itemsUncheckedUpdateManyWithoutCartInput>\n  }\n\n  export type shopping_shopping_cartsCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    customer: shopping_customersCreateNestedOneWithoutShopping_shopping_cartsInput\n  }\n\n  export type shopping_shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    shopping_customer_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shopping_cartsCreateOrConnectWithoutShopping_cart_itemsInput = {\n    where: shopping_shopping_cartsWhereUniqueInput\n    create: XOR<shopping_shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_product_variantsCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_variantsInput\n    shopping_inventory?: shopping_inventoryCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateWithoutShopping_cart_itemsInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsCreateOrConnectWithoutShopping_cart_itemsInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    create: XOR<shopping_product_variantsCreateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_shopping_cartsUpsertWithoutShopping_cart_itemsInput = {\n    update: XOR<shopping_shopping_cartsUpdateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n    create: XOR<shopping_shopping_cartsCreateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedCreateWithoutShopping_cart_itemsInput>\n    where?: shopping_shopping_cartsWhereInput\n  }\n\n  export type shopping_shopping_cartsUpdateToOneWithWhereWithoutShopping_cart_itemsInput = {\n    where?: shopping_shopping_cartsWhereInput\n    data: XOR<shopping_shopping_cartsUpdateWithoutShopping_cart_itemsInput, shopping_shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_shopping_cartsUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_shopping_cartsNestedInput\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_product_variantsUpsertWithoutShopping_cart_itemsInput = {\n    update: XOR<shopping_product_variantsUpdateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedUpdateWithoutShopping_cart_itemsInput>\n    create: XOR<shopping_product_variantsCreateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedCreateWithoutShopping_cart_itemsInput>\n    where?: shopping_product_variantsWhereInput\n  }\n\n  export type shopping_product_variantsUpdateToOneWithWhereWithoutShopping_cart_itemsInput = {\n    where?: shopping_product_variantsWhereInput\n    data: XOR<shopping_product_variantsUpdateWithoutShopping_cart_itemsInput, shopping_product_variantsUncheckedUpdateWithoutShopping_cart_itemsInput>\n  }\n\n  export type shopping_product_variantsUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput\n    shopping_inventory?: shopping_inventoryUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateWithoutShopping_cart_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_reviewsCreateWithoutShopping_review_moderationInput = {\n    id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_reviewsInput\n    customer: shopping_customersCreateNestedOneWithoutShopping_product_reviewsInput\n    shopping_review_ratings?: shopping_review_ratingsCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUncheckedCreateWithoutShopping_review_moderationInput = {\n    id: string\n    shopping_product_id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_review_ratings?: shopping_review_ratingsUncheckedCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsCreateOrConnectWithoutShopping_review_moderationInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    create: XOR<shopping_product_reviewsCreateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_administratorsCreateWithoutShopping_review_moderationInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_admin_actions?: shopping_admin_actionsCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsUncheckedCreateWithoutShopping_review_moderationInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_admin_actions?: shopping_admin_actionsUncheckedCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsCreateOrConnectWithoutShopping_review_moderationInput = {\n    where: shopping_administratorsWhereUniqueInput\n    create: XOR<shopping_administratorsCreateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedCreateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_product_reviewsUpsertWithoutShopping_review_moderationInput = {\n    update: XOR<shopping_product_reviewsUpdateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_moderationInput>\n    create: XOR<shopping_product_reviewsCreateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_moderationInput>\n    where?: shopping_product_reviewsWhereInput\n  }\n\n  export type shopping_product_reviewsUpdateToOneWithWhereWithoutShopping_review_moderationInput = {\n    where?: shopping_product_reviewsWhereInput\n    data: XOR<shopping_product_reviewsUpdateWithoutShopping_review_moderationInput, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_product_reviewsUpdateWithoutShopping_review_moderationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateWithoutShopping_review_moderationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_review_ratings?: shopping_review_ratingsUncheckedUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_administratorsUpsertWithoutShopping_review_moderationInput = {\n    update: XOR<shopping_administratorsUpdateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedUpdateWithoutShopping_review_moderationInput>\n    create: XOR<shopping_administratorsCreateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedCreateWithoutShopping_review_moderationInput>\n    where?: shopping_administratorsWhereInput\n  }\n\n  export type shopping_administratorsUpdateToOneWithWhereWithoutShopping_review_moderationInput = {\n    where?: shopping_administratorsWhereInput\n    data: XOR<shopping_administratorsUpdateWithoutShopping_review_moderationInput, shopping_administratorsUncheckedUpdateWithoutShopping_review_moderationInput>\n  }\n\n  export type shopping_administratorsUpdateWithoutShopping_review_moderationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_admin_actions?: shopping_admin_actionsUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsUncheckedUpdateWithoutShopping_review_moderationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_admin_actions?: shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_product_reviewsCreateWithoutShopping_review_ratingsInput = {\n    id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_reviewsInput\n    customer: shopping_customersCreateNestedOneWithoutShopping_product_reviewsInput\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsUncheckedCreateWithoutShopping_review_ratingsInput = {\n    id: string\n    shopping_product_id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutReviewInput\n  }\n\n  export type shopping_product_reviewsCreateOrConnectWithoutShopping_review_ratingsInput = {\n    where: shopping_product_reviewsWhereUniqueInput\n    create: XOR<shopping_product_reviewsCreateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_ratingsInput>\n  }\n\n  export type shopping_product_reviewsUpsertWithoutShopping_review_ratingsInput = {\n    update: XOR<shopping_product_reviewsUpdateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_ratingsInput>\n    create: XOR<shopping_product_reviewsCreateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedCreateWithoutShopping_review_ratingsInput>\n    where?: shopping_product_reviewsWhereInput\n  }\n\n  export type shopping_product_reviewsUpdateToOneWithWhereWithoutShopping_review_ratingsInput = {\n    where?: shopping_product_reviewsWhereInput\n    data: XOR<shopping_product_reviewsUpdateWithoutShopping_review_ratingsInput, shopping_product_reviewsUncheckedUpdateWithoutShopping_review_ratingsInput>\n  }\n\n  export type shopping_product_reviewsUpdateWithoutShopping_review_ratingsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateWithoutShopping_review_ratingsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_sellersCreateWithoutShopping_seller_productsInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersUncheckedCreateWithoutShopping_seller_productsInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersCreateOrConnectWithoutShopping_seller_productsInput = {\n    where: shopping_sellersWhereUniqueInput\n    create: XOR<shopping_sellersCreateWithoutShopping_seller_productsInput, shopping_sellersUncheckedCreateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_productsCreateWithoutShopping_seller_productsInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    category?: shopping_categoriesCreateNestedOneWithoutShopping_productsInput\n    shopping_product_variants?: shopping_product_variantsCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsUncheckedCreateWithoutShopping_seller_productsInput = {\n    id: string\n    shopping_category_id?: string | null\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedCreateNestedManyWithoutProductInput\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedManyWithoutProductInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutProductInput\n  }\n\n  export type shopping_productsCreateOrConnectWithoutShopping_seller_productsInput = {\n    where: shopping_productsWhereUniqueInput\n    create: XOR<shopping_productsCreateWithoutShopping_seller_productsInput, shopping_productsUncheckedCreateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_seller_inventoryCreateWithoutSellerProductInput = {\n    id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    productVariant: shopping_product_variantsCreateNestedOneWithoutShopping_seller_inventoryInput\n  }\n\n  export type shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput = {\n    id: string\n    shopping_product_variant_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_inventoryCreateOrConnectWithoutSellerProductInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    create: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput>\n  }\n\n  export type shopping_seller_inventoryCreateManySellerProductInputEnvelope = {\n    data: shopping_seller_inventoryCreateManySellerProductInput | shopping_seller_inventoryCreateManySellerProductInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_sellersUpsertWithoutShopping_seller_productsInput = {\n    update: XOR<shopping_sellersUpdateWithoutShopping_seller_productsInput, shopping_sellersUncheckedUpdateWithoutShopping_seller_productsInput>\n    create: XOR<shopping_sellersCreateWithoutShopping_seller_productsInput, shopping_sellersUncheckedCreateWithoutShopping_seller_productsInput>\n    where?: shopping_sellersWhereInput\n  }\n\n  export type shopping_sellersUpdateToOneWithWhereWithoutShopping_seller_productsInput = {\n    where?: shopping_sellersWhereInput\n    data: XOR<shopping_sellersUpdateWithoutShopping_seller_productsInput, shopping_sellersUncheckedUpdateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_sellersUpdateWithoutShopping_seller_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_sellersUncheckedUpdateWithoutShopping_seller_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_productsUpsertWithoutShopping_seller_productsInput = {\n    update: XOR<shopping_productsUpdateWithoutShopping_seller_productsInput, shopping_productsUncheckedUpdateWithoutShopping_seller_productsInput>\n    create: XOR<shopping_productsCreateWithoutShopping_seller_productsInput, shopping_productsUncheckedCreateWithoutShopping_seller_productsInput>\n    where?: shopping_productsWhereInput\n  }\n\n  export type shopping_productsUpdateToOneWithWhereWithoutShopping_seller_productsInput = {\n    where?: shopping_productsWhereInput\n    data: XOR<shopping_productsUpdateWithoutShopping_seller_productsInput, shopping_productsUncheckedUpdateWithoutShopping_seller_productsInput>\n  }\n\n  export type shopping_productsUpdateWithoutShopping_seller_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    category?: shopping_categoriesUpdateOneWithoutShopping_productsNestedInput\n    shopping_product_variants?: shopping_product_variantsUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateWithoutShopping_seller_productsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_category_id?: NullableStringFieldUpdateOperationsInput | string | null\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_seller_inventoryUpsertWithWhereUniqueWithoutSellerProductInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    update: XOR<shopping_seller_inventoryUpdateWithoutSellerProductInput, shopping_seller_inventoryUncheckedUpdateWithoutSellerProductInput>\n    create: XOR<shopping_seller_inventoryCreateWithoutSellerProductInput, shopping_seller_inventoryUncheckedCreateWithoutSellerProductInput>\n  }\n\n  export type shopping_seller_inventoryUpdateWithWhereUniqueWithoutSellerProductInput = {\n    where: shopping_seller_inventoryWhereUniqueInput\n    data: XOR<shopping_seller_inventoryUpdateWithoutSellerProductInput, shopping_seller_inventoryUncheckedUpdateWithoutSellerProductInput>\n  }\n\n  export type shopping_seller_inventoryUpdateManyWithWhereWithoutSellerProductInput = {\n    where: shopping_seller_inventoryScalarWhereInput\n    data: XOR<shopping_seller_inventoryUpdateManyMutationInput, shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductInput>\n  }\n\n  export type shopping_seller_productsCreateWithoutShopping_seller_inventoryInput = {\n    id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    seller: shopping_sellersCreateNestedOneWithoutShopping_seller_productsInput\n    product: shopping_productsCreateNestedOneWithoutShopping_seller_productsInput\n  }\n\n  export type shopping_seller_productsUncheckedCreateWithoutShopping_seller_inventoryInput = {\n    id: string\n    shopping_seller_id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_productsCreateOrConnectWithoutShopping_seller_inventoryInput = {\n    where: shopping_seller_productsWhereUniqueInput\n    create: XOR<shopping_seller_productsCreateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedCreateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_product_variantsCreateWithoutShopping_seller_inventoryInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    product: shopping_productsCreateNestedOneWithoutShopping_product_variantsInput\n    shopping_inventory?: shopping_inventoryCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsUncheckedCreateWithoutShopping_seller_inventoryInput = {\n    id: string\n    shopping_product_id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n    shopping_inventory?: shopping_inventoryUncheckedCreateNestedOneWithoutVariantInput\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedCreateNestedManyWithoutProductVariantInput\n  }\n\n  export type shopping_product_variantsCreateOrConnectWithoutShopping_seller_inventoryInput = {\n    where: shopping_product_variantsWhereUniqueInput\n    create: XOR<shopping_product_variantsCreateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_seller_productsUpsertWithoutShopping_seller_inventoryInput = {\n    update: XOR<shopping_seller_productsUpdateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n    create: XOR<shopping_seller_productsCreateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    where?: shopping_seller_productsWhereInput\n  }\n\n  export type shopping_seller_productsUpdateToOneWithWhereWithoutShopping_seller_inventoryInput = {\n    where?: shopping_seller_productsWhereInput\n    data: XOR<shopping_seller_productsUpdateWithoutShopping_seller_inventoryInput, shopping_seller_productsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_seller_productsUpdateWithoutShopping_seller_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    seller?: shopping_sellersUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateWithoutShopping_seller_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_product_variantsUpsertWithoutShopping_seller_inventoryInput = {\n    update: XOR<shopping_product_variantsUpdateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n    create: XOR<shopping_product_variantsCreateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedCreateWithoutShopping_seller_inventoryInput>\n    where?: shopping_product_variantsWhereInput\n  }\n\n  export type shopping_product_variantsUpdateToOneWithWhereWithoutShopping_seller_inventoryInput = {\n    where?: shopping_product_variantsWhereInput\n    data: XOR<shopping_product_variantsUpdateWithoutShopping_seller_inventoryInput, shopping_product_variantsUncheckedUpdateWithoutShopping_seller_inventoryInput>\n  }\n\n  export type shopping_product_variantsUpdateWithoutShopping_seller_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_variantsNestedInput\n    shopping_inventory?: shopping_inventoryUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateWithoutShopping_seller_inventoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_sellersCreateWithoutShopping_seller_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_products?: shopping_seller_productsCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersUncheckedCreateWithoutShopping_seller_ordersInput = {\n    id: string\n    email: string\n    password_hash: string\n    business_name: string\n    contact_name: string\n    phone?: string | null\n    address?: string | null\n    tax_id?: string | null\n    shopping_seller_products?: shopping_seller_productsUncheckedCreateNestedManyWithoutSellerInput\n  }\n\n  export type shopping_sellersCreateOrConnectWithoutShopping_seller_ordersInput = {\n    where: shopping_sellersWhereUniqueInput\n    create: XOR<shopping_sellersCreateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedCreateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_ordersCreateWithoutShopping_seller_ordersInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_seller_ordersInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_seller_ordersInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedCreateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_sellersUpsertWithoutShopping_seller_ordersInput = {\n    update: XOR<shopping_sellersUpdateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedUpdateWithoutShopping_seller_ordersInput>\n    create: XOR<shopping_sellersCreateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedCreateWithoutShopping_seller_ordersInput>\n    where?: shopping_sellersWhereInput\n  }\n\n  export type shopping_sellersUpdateToOneWithWhereWithoutShopping_seller_ordersInput = {\n    where?: shopping_sellersWhereInput\n    data: XOR<shopping_sellersUpdateWithoutShopping_seller_ordersInput, shopping_sellersUncheckedUpdateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_sellersUpdateWithoutShopping_seller_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_sellersUncheckedUpdateWithoutShopping_seller_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_name?: StringFieldUpdateOperationsInput | string\n    contact_name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    tax_id?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutSellerNestedInput\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_seller_ordersInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedUpdateWithoutShopping_seller_ordersInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedCreateWithoutShopping_seller_ordersInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_seller_ordersInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_seller_ordersInput, shopping_ordersUncheckedUpdateWithoutShopping_seller_ordersInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_seller_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_seller_ordersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_administratorsCreateWithoutShopping_admin_actionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsUncheckedCreateWithoutShopping_admin_actionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutAdministratorInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsCreateOrConnectWithoutShopping_admin_actionsInput = {\n    where: shopping_administratorsWhereUniqueInput\n    create: XOR<shopping_administratorsCreateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_actionsInput>\n  }\n\n  export type shopping_administratorsUpsertWithoutShopping_admin_actionsInput = {\n    update: XOR<shopping_administratorsUpdateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedUpdateWithoutShopping_admin_actionsInput>\n    create: XOR<shopping_administratorsCreateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_actionsInput>\n    where?: shopping_administratorsWhereInput\n  }\n\n  export type shopping_administratorsUpdateToOneWithWhereWithoutShopping_admin_actionsInput = {\n    where?: shopping_administratorsWhereInput\n    data: XOR<shopping_administratorsUpdateWithoutShopping_admin_actionsInput, shopping_administratorsUncheckedUpdateWithoutShopping_admin_actionsInput>\n  }\n\n  export type shopping_administratorsUpdateWithoutShopping_admin_actionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsUncheckedUpdateWithoutShopping_admin_actionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_logs?: shopping_admin_logsUncheckedUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsCreateWithoutShopping_admin_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationCreateNestedManyWithoutAdministratorInput\n    shopping_admin_actions?: shopping_admin_actionsCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsUncheckedCreateWithoutShopping_admin_logsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    role: string\n    shopping_review_moderation?: shopping_review_moderationUncheckedCreateNestedManyWithoutAdministratorInput\n    shopping_admin_actions?: shopping_admin_actionsUncheckedCreateNestedManyWithoutAdministratorInput\n  }\n\n  export type shopping_administratorsCreateOrConnectWithoutShopping_admin_logsInput = {\n    where: shopping_administratorsWhereUniqueInput\n    create: XOR<shopping_administratorsCreateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_logsInput>\n  }\n\n  export type shopping_administratorsUpsertWithoutShopping_admin_logsInput = {\n    update: XOR<shopping_administratorsUpdateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedUpdateWithoutShopping_admin_logsInput>\n    create: XOR<shopping_administratorsCreateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedCreateWithoutShopping_admin_logsInput>\n    where?: shopping_administratorsWhereInput\n  }\n\n  export type shopping_administratorsUpdateToOneWithWhereWithoutShopping_admin_logsInput = {\n    where?: shopping_administratorsWhereInput\n    data: XOR<shopping_administratorsUpdateWithoutShopping_admin_logsInput, shopping_administratorsUncheckedUpdateWithoutShopping_admin_logsInput>\n  }\n\n  export type shopping_administratorsUpdateWithoutShopping_admin_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_actions?: shopping_admin_actionsUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_administratorsUncheckedUpdateWithoutShopping_admin_logsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    role?: StringFieldUpdateOperationsInput | string\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutAdministratorNestedInput\n    shopping_admin_actions?: shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorNestedInput\n  }\n\n  export type shopping_customersCreateWithoutShopping_paymentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersUncheckedCreateWithoutShopping_paymentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    name: string\n    phone?: string | null\n    address?: string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_orders?: shopping_ordersUncheckedCreateNestedManyWithoutCustomerInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedCreateNestedManyWithoutCustomerInput\n  }\n\n  export type shopping_customersCreateOrConnectWithoutShopping_paymentsInput = {\n    where: shopping_customersWhereUniqueInput\n    create: XOR<shopping_customersCreateWithoutShopping_paymentsInput, shopping_customersUncheckedCreateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_ordersCreateWithoutShopping_paymentsInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_paymentsInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_paymentsInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_paymentsInput, shopping_ordersUncheckedCreateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_payment_transactionsCreateWithoutPaymentInput = {\n    id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_transactionsUncheckedCreateWithoutPaymentInput = {\n    id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_transactionsCreateOrConnectWithoutPaymentInput = {\n    where: shopping_payment_transactionsWhereUniqueInput\n    create: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput>\n  }\n\n  export type shopping_payment_transactionsCreateManyPaymentInputEnvelope = {\n    data: shopping_payment_transactionsCreateManyPaymentInput | shopping_payment_transactionsCreateManyPaymentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_customersUpsertWithoutShopping_paymentsInput = {\n    update: XOR<shopping_customersUpdateWithoutShopping_paymentsInput, shopping_customersUncheckedUpdateWithoutShopping_paymentsInput>\n    create: XOR<shopping_customersCreateWithoutShopping_paymentsInput, shopping_customersUncheckedCreateWithoutShopping_paymentsInput>\n    where?: shopping_customersWhereInput\n  }\n\n  export type shopping_customersUpdateToOneWithWhereWithoutShopping_paymentsInput = {\n    where?: shopping_customersWhereInput\n    data: XOR<shopping_customersUpdateWithoutShopping_paymentsInput, shopping_customersUncheckedUpdateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_customersUpdateWithoutShopping_paymentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_customersUncheckedUpdateWithoutShopping_paymentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    phone?: NullableStringFieldUpdateOperationsInput | string | null\n    address?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_orders?: shopping_ordersUncheckedUpdateManyWithoutCustomerNestedInput\n    shopping_shopping_carts?: shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerNestedInput\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_paymentsInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_paymentsInput, shopping_ordersUncheckedUpdateWithoutShopping_paymentsInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_paymentsInput, shopping_ordersUncheckedCreateWithoutShopping_paymentsInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_paymentsInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_paymentsInput, shopping_ordersUncheckedUpdateWithoutShopping_paymentsInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_paymentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_paymentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_payment_transactionsUpsertWithWhereUniqueWithoutPaymentInput = {\n    where: shopping_payment_transactionsWhereUniqueInput\n    update: XOR<shopping_payment_transactionsUpdateWithoutPaymentInput, shopping_payment_transactionsUncheckedUpdateWithoutPaymentInput>\n    create: XOR<shopping_payment_transactionsCreateWithoutPaymentInput, shopping_payment_transactionsUncheckedCreateWithoutPaymentInput>\n  }\n\n  export type shopping_payment_transactionsUpdateWithWhereUniqueWithoutPaymentInput = {\n    where: shopping_payment_transactionsWhereUniqueInput\n    data: XOR<shopping_payment_transactionsUpdateWithoutPaymentInput, shopping_payment_transactionsUncheckedUpdateWithoutPaymentInput>\n  }\n\n  export type shopping_payment_transactionsUpdateManyWithWhereWithoutPaymentInput = {\n    where: shopping_payment_transactionsScalarWhereInput\n    data: XOR<shopping_payment_transactionsUpdateManyMutationInput, shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentInput>\n  }\n\n  export type shopping_payment_transactionsScalarWhereInput = {\n    AND?: shopping_payment_transactionsScalarWhereInput | shopping_payment_transactionsScalarWhereInput[]\n    OR?: shopping_payment_transactionsScalarWhereInput[]\n    NOT?: shopping_payment_transactionsScalarWhereInput | shopping_payment_transactionsScalarWhereInput[]\n    id?: UuidFilter<\"shopping_payment_transactions\"> | string\n    shopping_payment_id?: UuidFilter<\"shopping_payment_transactions\"> | string\n    transaction_type?: StringFilter<\"shopping_payment_transactions\"> | string\n    amount?: FloatFilter<\"shopping_payment_transactions\"> | number\n    currency?: StringFilter<\"shopping_payment_transactions\"> | string\n    status?: StringFilter<\"shopping_payment_transactions\"> | string\n    gateway_response?: StringNullableFilter<\"shopping_payment_transactions\"> | string | null\n    transaction_date?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    created_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    updated_at?: DateTimeFilter<\"shopping_payment_transactions\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"shopping_payment_transactions\"> | Date | string | null\n  }\n\n  export type shopping_paymentsCreateWithoutShopping_payment_transactionsInput = {\n    id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_paymentsInput\n    order: shopping_ordersCreateNestedOneWithoutShopping_paymentsInput\n  }\n\n  export type shopping_paymentsUncheckedCreateWithoutShopping_payment_transactionsInput = {\n    id: string\n    shopping_customer_id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_paymentsCreateOrConnectWithoutShopping_payment_transactionsInput = {\n    where: shopping_paymentsWhereUniqueInput\n    create: XOR<shopping_paymentsCreateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedCreateWithoutShopping_payment_transactionsInput>\n  }\n\n  export type shopping_paymentsUpsertWithoutShopping_payment_transactionsInput = {\n    update: XOR<shopping_paymentsUpdateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedUpdateWithoutShopping_payment_transactionsInput>\n    create: XOR<shopping_paymentsCreateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedCreateWithoutShopping_payment_transactionsInput>\n    where?: shopping_paymentsWhereInput\n  }\n\n  export type shopping_paymentsUpdateToOneWithWhereWithoutShopping_payment_transactionsInput = {\n    where?: shopping_paymentsWhereInput\n    data: XOR<shopping_paymentsUpdateWithoutShopping_payment_transactionsInput, shopping_paymentsUncheckedUpdateWithoutShopping_payment_transactionsInput>\n  }\n\n  export type shopping_paymentsUpdateWithoutShopping_payment_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateWithoutShopping_payment_transactionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_shipping_trackingCreateWithoutMethodInput = {\n    id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_shipping_trackingInput\n    carrier: shopping_shipping_carriersCreateNestedOneWithoutShopping_shipping_trackingInput\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateWithoutMethodInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_carrier_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingCreateOrConnectWithoutMethodInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    create: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput>\n  }\n\n  export type shopping_shipping_trackingCreateManyMethodInputEnvelope = {\n    data: shopping_shipping_trackingCreateManyMethodInput | shopping_shipping_trackingCreateManyMethodInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_shipping_trackingUpsertWithWhereUniqueWithoutMethodInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    update: XOR<shopping_shipping_trackingUpdateWithoutMethodInput, shopping_shipping_trackingUncheckedUpdateWithoutMethodInput>\n    create: XOR<shopping_shipping_trackingCreateWithoutMethodInput, shopping_shipping_trackingUncheckedCreateWithoutMethodInput>\n  }\n\n  export type shopping_shipping_trackingUpdateWithWhereUniqueWithoutMethodInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    data: XOR<shopping_shipping_trackingUpdateWithoutMethodInput, shopping_shipping_trackingUncheckedUpdateWithoutMethodInput>\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithWhereWithoutMethodInput = {\n    where: shopping_shipping_trackingScalarWhereInput\n    data: XOR<shopping_shipping_trackingUpdateManyMutationInput, shopping_shipping_trackingUncheckedUpdateManyWithoutMethodInput>\n  }\n\n  export type shopping_shipping_trackingCreateWithoutCarrierInput = {\n    id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    order: shopping_ordersCreateNestedOneWithoutShopping_shipping_trackingInput\n    method: shopping_shipping_methodsCreateNestedOneWithoutShopping_shipping_trackingInput\n  }\n\n  export type shopping_shipping_trackingUncheckedCreateWithoutCarrierInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingCreateOrConnectWithoutCarrierInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    create: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput>\n  }\n\n  export type shopping_shipping_trackingCreateManyCarrierInputEnvelope = {\n    data: shopping_shipping_trackingCreateManyCarrierInput | shopping_shipping_trackingCreateManyCarrierInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type shopping_shipping_trackingUpsertWithWhereUniqueWithoutCarrierInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    update: XOR<shopping_shipping_trackingUpdateWithoutCarrierInput, shopping_shipping_trackingUncheckedUpdateWithoutCarrierInput>\n    create: XOR<shopping_shipping_trackingCreateWithoutCarrierInput, shopping_shipping_trackingUncheckedCreateWithoutCarrierInput>\n  }\n\n  export type shopping_shipping_trackingUpdateWithWhereUniqueWithoutCarrierInput = {\n    where: shopping_shipping_trackingWhereUniqueInput\n    data: XOR<shopping_shipping_trackingUpdateWithoutCarrierInput, shopping_shipping_trackingUncheckedUpdateWithoutCarrierInput>\n  }\n\n  export type shopping_shipping_trackingUpdateManyWithWhereWithoutCarrierInput = {\n    where: shopping_shipping_trackingScalarWhereInput\n    data: XOR<shopping_shipping_trackingUpdateManyMutationInput, shopping_shipping_trackingUncheckedUpdateManyWithoutCarrierInput>\n  }\n\n  export type shopping_ordersCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    customer: shopping_customersCreateNestedOneWithoutShopping_ordersInput\n    shopping_order_items?: shopping_order_itemsCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersUncheckedCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    shopping_customer_id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_status?: shopping_order_statusUncheckedCreateNestedManyWithoutOrderInput\n    shopping_order_history?: shopping_order_historyUncheckedCreateNestedManyWithoutOrderInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedCreateNestedManyWithoutOrderInput\n    shopping_payments?: shopping_paymentsUncheckedCreateNestedManyWithoutOrderInput\n  }\n\n  export type shopping_ordersCreateOrConnectWithoutShopping_shipping_trackingInput = {\n    where: shopping_ordersWhereUniqueInput\n    create: XOR<shopping_ordersCreateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedCreateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_carriersCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    name: string\n    description?: string | null\n    tracking_url_template?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_carriersUncheckedCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    name: string\n    description?: string | null\n    tracking_url_template?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_carriersCreateOrConnectWithoutShopping_shipping_trackingInput = {\n    where: shopping_shipping_carriersWhereUniqueInput\n    create: XOR<shopping_shipping_carriersCreateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedCreateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_methodsCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    name: string\n    description?: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_methodsUncheckedCreateWithoutShopping_shipping_trackingInput = {\n    id: string\n    name: string\n    description?: string | null\n    cost: number\n    estimated_delivery_days: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_methodsCreateOrConnectWithoutShopping_shipping_trackingInput = {\n    where: shopping_shipping_methodsWhereUniqueInput\n    create: XOR<shopping_shipping_methodsCreateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedCreateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_ordersUpsertWithoutShopping_shipping_trackingInput = {\n    update: XOR<shopping_ordersUpdateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n    create: XOR<shopping_ordersCreateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    where?: shopping_ordersWhereInput\n  }\n\n  export type shopping_ordersUpdateToOneWithWhereWithoutShopping_shipping_trackingInput = {\n    where?: shopping_ordersWhereInput\n    data: XOR<shopping_ordersUpdateWithoutShopping_shipping_trackingInput, shopping_ordersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_ordersUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_ordersNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_shipping_carriersUpsertWithoutShopping_shipping_trackingInput = {\n    update: XOR<shopping_shipping_carriersUpdateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n    create: XOR<shopping_shipping_carriersCreateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedCreateWithoutShopping_shipping_trackingInput>\n    where?: shopping_shipping_carriersWhereInput\n  }\n\n  export type shopping_shipping_carriersUpdateToOneWithWhereWithoutShopping_shipping_trackingInput = {\n    where?: shopping_shipping_carriersWhereInput\n    data: XOR<shopping_shipping_carriersUpdateWithoutShopping_shipping_trackingInput, shopping_shipping_carriersUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_carriersUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_carriersUncheckedUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    tracking_url_template?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_methodsUpsertWithoutShopping_shipping_trackingInput = {\n    update: XOR<shopping_shipping_methodsUpdateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedUpdateWithoutShopping_shipping_trackingInput>\n    create: XOR<shopping_shipping_methodsCreateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedCreateWithoutShopping_shipping_trackingInput>\n    where?: shopping_shipping_methodsWhereInput\n  }\n\n  export type shopping_shipping_methodsUpdateToOneWithWhereWithoutShopping_shipping_trackingInput = {\n    where?: shopping_shipping_methodsWhereInput\n    data: XOR<shopping_shipping_methodsUpdateWithoutShopping_shipping_trackingInput, shopping_shipping_methodsUncheckedUpdateWithoutShopping_shipping_trackingInput>\n  }\n\n  export type shopping_shipping_methodsUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_methodsUncheckedUpdateWithoutShopping_shipping_trackingInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    cost?: FloatFieldUpdateOperationsInput | number\n    estimated_delivery_days?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_sectionsCreateManyChannelInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateManyChannelInput = {\n    id: string\n    shopping_section_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_sectionsUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_channel_categories?: shopping_channel_categoriesUncheckedUpdateManyWithoutSectionNestedInput\n  }\n\n  export type shopping_sectionsUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    section?: shopping_sectionsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateManyWithoutChannelInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_section_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesCreateManySectionInput = {\n    id: string\n    shopping_channel_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_channel_categoriesUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    channel?: shopping_channelsUpdateOneRequiredWithoutShopping_channel_categoriesNestedInput\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_channel_categoriesUncheckedUpdateManyWithoutSectionInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_channel_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_product_reviewsCreateManyCustomerInput = {\n    id: string\n    shopping_product_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_ordersCreateManyCustomerInput = {\n    id: string\n    order_code: string\n    total_amount: number\n    currency: string\n    status: string\n    payment_method: string\n    shipping_method: string\n    shipping_address: string\n    billing_address: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_shopping_cartsCreateManyCustomerInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_paymentsCreateManyCustomerInput = {\n    id: string\n    shopping_order_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_product_reviewsUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateManyWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_ordersUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_status?: shopping_order_statusUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_order_history?: shopping_order_historyUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_seller_orders?: shopping_seller_ordersUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_payments?: shopping_paymentsUncheckedUpdateManyWithoutOrderNestedInput\n    shopping_shipping_tracking?: shopping_shipping_trackingUncheckedUpdateManyWithoutOrderNestedInput\n  }\n\n  export type shopping_ordersUncheckedUpdateManyWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    order_code?: StringFieldUpdateOperationsInput | string\n    total_amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    payment_method?: StringFieldUpdateOperationsInput | string\n    shipping_method?: StringFieldUpdateOperationsInput | string\n    shipping_address?: StringFieldUpdateOperationsInput | string\n    billing_address?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_shopping_cartsUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutCartNestedInput\n  }\n\n  export type shopping_shopping_cartsUncheckedUpdateManyWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_paymentsUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n    shopping_payment_transactions?: shopping_payment_transactionsUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateManyWithoutCustomerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_productsCreateManySellerInput = {\n    id: string\n    shopping_product_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_ordersCreateManySellerInput = {\n    id: string\n    shopping_order_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_productsUpdateWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    product?: shopping_productsUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateManyWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersUpdateWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateManyWithoutSellerInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_review_moderationCreateManyAdministratorInput = {\n    id: string\n    shopping_product_review_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_admin_actionsCreateManyAdministratorInput = {\n    id: string\n    action_type: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type shopping_admin_logsCreateManyAdministratorInput = {\n    id: string\n    log_type: string\n    message: string\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    review?: shopping_product_reviewsUpdateOneRequiredWithoutShopping_review_moderationNestedInput\n  }\n\n  export type shopping_review_moderationUncheckedUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_moderationUncheckedUpdateManyWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_review_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_actionsUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_actionsUncheckedUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_actionsUncheckedUpdateManyWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsUncheckedUpdateWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_admin_logsUncheckedUpdateManyWithoutAdministratorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    log_type?: StringFieldUpdateOperationsInput | string\n    message?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_product_variantsCreateManyProductInput = {\n    id: string\n    sku: string\n    option_name: string\n    option_value: string\n    price_adjustment?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_inventoryCreateManyProductInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    reserved_quantity: number\n    low_stock_threshold?: number | null\n    last_stock_update?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_product_reviewsCreateManyProductInput = {\n    id: string\n    shopping_customer_id: string\n    rating: number\n    title?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_seller_productsCreateManyProductInput = {\n    id: string\n    shopping_seller_id: string\n    seller_product_code: string\n    price: number\n    quantity_available: number\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_product_variantsUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_inventory?: shopping_inventoryUncheckedUpdateOneWithoutVariantNestedInput\n    shopping_order_items?: shopping_order_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_cart_items?: shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantNestedInput\n  }\n\n  export type shopping_product_variantsUncheckedUpdateManyWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sku?: StringFieldUpdateOperationsInput | string\n    option_name?: StringFieldUpdateOperationsInput | string\n    option_value?: StringFieldUpdateOperationsInput | string\n    price_adjustment?: NullableFloatFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_inventoryUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    variant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_inventoryNestedInput\n  }\n\n  export type shopping_inventoryUncheckedUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_inventoryUncheckedUpdateManyWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    reserved_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    last_stock_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_product_reviewsUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_product_reviewsNestedInput\n    shopping_review_moderation?: shopping_review_moderationUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_review_moderation?: shopping_review_moderationUncheckedUpdateManyWithoutReviewNestedInput\n    shopping_review_ratings?: shopping_review_ratingsUncheckedUpdateManyWithoutReviewNestedInput\n  }\n\n  export type shopping_product_reviewsUncheckedUpdateManyWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    rating?: IntFieldUpdateOperationsInput | number\n    title?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_seller_productsUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    seller?: shopping_sellersUpdateOneRequiredWithoutShopping_seller_productsNestedInput\n    shopping_seller_inventory?: shopping_seller_inventoryUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_seller_inventory?: shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductNestedInput\n  }\n\n  export type shopping_seller_productsUncheckedUpdateManyWithoutProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    seller_product_code?: StringFieldUpdateOperationsInput | string\n    price?: FloatFieldUpdateOperationsInput | number\n    quantity_available?: IntFieldUpdateOperationsInput | number\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_order_itemsCreateManyProductVariantInput = {\n    id: string\n    shopping_order_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsCreateManyProductVariantInput = {\n    id: string\n    shopping_shopping_cart_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_seller_inventoryCreateManyProductVariantInput = {\n    id: string\n    shopping_seller_product_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_order_itemsUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_order_itemsNestedInput\n  }\n\n  export type shopping_order_itemsUncheckedUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    cart?: shopping_shopping_cartsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shopping_cart_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_seller_inventoryUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    sellerProduct?: shopping_seller_productsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_product_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateManyWithoutProductVariantInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_product_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_productsCreateManyCategoryInput = {\n    id: string\n    name: string\n    description?: string | null\n    price: number\n    sku: string\n    created_at: Date | string\n    updated_at: Date | string\n    password_hash: string\n    business_status?: string | null\n  }\n\n  export type shopping_categoriesCreateManyParentInput = {\n    id: string\n    name: string\n    description?: string | null\n    code: string\n    created_at: Date | string\n    updated_at: Date | string\n    business_status?: string | null\n  }\n\n  export type shopping_productsUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_product_variants?: shopping_product_variantsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_inventory?: shopping_inventoryUncheckedUpdateManyWithoutProductNestedInput\n    shopping_product_reviews?: shopping_product_reviewsUncheckedUpdateManyWithoutProductNestedInput\n    shopping_seller_products?: shopping_seller_productsUncheckedUpdateManyWithoutProductNestedInput\n  }\n\n  export type shopping_productsUncheckedUpdateManyWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    price?: FloatFieldUpdateOperationsInput | number\n    sku?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_categoriesUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_products?: shopping_productsUpdateManyWithoutCategoryNestedInput\n    recursive?: shopping_categoriesUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_categoriesUncheckedUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    shopping_products?: shopping_productsUncheckedUpdateManyWithoutCategoryNestedInput\n    recursive?: shopping_categoriesUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type shopping_categoriesUncheckedUpdateManyWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    code?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_review_moderationCreateManyReviewInput = {\n    id: string\n    shopping_administrator_id: string\n    action_type: string\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type shopping_review_ratingsCreateManyReviewInput = {\n    id: string\n    quality_rating: number\n    value_rating: number\n    service_rating: number\n    created_at: Date | string\n  }\n\n  export type shopping_review_moderationUpdateWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    administrator?: shopping_administratorsUpdateOneRequiredWithoutShopping_review_moderationNestedInput\n  }\n\n  export type shopping_review_moderationUncheckedUpdateWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_moderationUncheckedUpdateManyWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_administrator_id?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsUpdateWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsUncheckedUpdateWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_review_ratingsUncheckedUpdateManyWithoutReviewInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quality_rating?: IntFieldUpdateOperationsInput | number\n    value_rating?: IntFieldUpdateOperationsInput | number\n    service_rating?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsCreateManyOrderInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    unit_price: number\n    total_price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_statusCreateManyOrderInput = {\n    id: string\n    status: string\n    changed_at: Date | string\n    changed_by?: string | null\n    notes?: string | null\n  }\n\n  export type shopping_order_historyCreateManyOrderInput = {\n    id: string\n    action: string\n    changed_at: Date | string\n    changed_by?: string | null\n    details?: string | null\n  }\n\n  export type shopping_seller_ordersCreateManyOrderInput = {\n    id: string\n    shopping_seller_id: string\n    seller_order_code: string\n    fulfillment_status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_paymentsCreateManyOrderInput = {\n    id: string\n    shopping_customer_id: string\n    payment_method_id: string\n    amount: number\n    currency: string\n    status: string\n    transaction_id?: string | null\n    payment_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_shipping_trackingCreateManyOrderInput = {\n    id: string\n    shopping_shipping_carrier_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_order_itemsUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_order_itemsNestedInput\n  }\n\n  export type shopping_order_itemsUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_itemsUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    unit_price?: FloatFieldUpdateOperationsInput | number\n    total_price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_order_statusUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_statusUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_statusUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    notes?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_order_historyUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    action?: StringFieldUpdateOperationsInput | string\n    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    changed_by?: NullableStringFieldUpdateOperationsInput | string | null\n    details?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type shopping_seller_ordersUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    seller?: shopping_sellersUpdateOneRequiredWithoutShopping_seller_ordersNestedInput\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_ordersUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_seller_id?: StringFieldUpdateOperationsInput | string\n    seller_order_code?: StringFieldUpdateOperationsInput | string\n    fulfillment_status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_paymentsUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    customer?: shopping_customersUpdateOneRequiredWithoutShopping_paymentsNestedInput\n    shopping_payment_transactions?: shopping_payment_transactionsUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    shopping_payment_transactions?: shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentNestedInput\n  }\n\n  export type shopping_paymentsUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_customer_id?: StringFieldUpdateOperationsInput | string\n    payment_method_id?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null\n    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_shipping_trackingUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    carrier?: shopping_shipping_carriersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n    method?: shopping_shipping_methodsUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutOrderInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsCreateManyCartInput = {\n    id: string\n    shopping_product_variant_id: string\n    quantity: number\n    price: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_cart_itemsUpdateWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_cart_itemsNestedInput\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_cart_itemsUncheckedUpdateManyWithoutCartInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    quantity?: IntFieldUpdateOperationsInput | number\n    price?: FloatFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_seller_inventoryCreateManySellerProductInput = {\n    id: string\n    shopping_product_variant_id: string\n    stock_quantity: number\n    low_stock_threshold?: number | null\n    status: string\n    business_status?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_seller_inventoryUpdateWithoutSellerProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    productVariant?: shopping_product_variantsUpdateOneRequiredWithoutShopping_seller_inventoryNestedInput\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateWithoutSellerProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_seller_inventoryUncheckedUpdateManyWithoutSellerProductInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_product_variant_id?: StringFieldUpdateOperationsInput | string\n    stock_quantity?: IntFieldUpdateOperationsInput | number\n    low_stock_threshold?: NullableIntFieldUpdateOperationsInput | number | null\n    status?: StringFieldUpdateOperationsInput | string\n    business_status?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsCreateManyPaymentInput = {\n    id: string\n    transaction_type: string\n    amount: number\n    currency: string\n    status: string\n    gateway_response?: string | null\n    transaction_date: Date | string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type shopping_payment_transactionsUpdateWithoutPaymentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsUncheckedUpdateWithoutPaymentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_payment_transactionsUncheckedUpdateManyWithoutPaymentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    transaction_type?: StringFieldUpdateOperationsInput | string\n    amount?: FloatFieldUpdateOperationsInput | number\n    currency?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    gateway_response?: NullableStringFieldUpdateOperationsInput | string | null\n    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type shopping_shipping_trackingCreateManyMethodInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_carrier_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingUpdateWithoutMethodInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n    carrier?: shopping_shipping_carriersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateWithoutMethodInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutMethodInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_carrier_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingCreateManyCarrierInput = {\n    id: string\n    shopping_order_id: string\n    shopping_shipping_method_id: string\n    tracking_number: string\n    status: string\n    estimated_delivery_date?: Date | string | null\n    actual_delivery_date?: Date | string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type shopping_shipping_trackingUpdateWithoutCarrierInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    order?: shopping_ordersUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n    method?: shopping_shipping_methodsUpdateOneRequiredWithoutShopping_shipping_trackingNestedInput\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateWithoutCarrierInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type shopping_shipping_trackingUncheckedUpdateManyWithoutCarrierInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    shopping_order_id?: StringFieldUpdateOperationsInput | string\n    shopping_shipping_method_id?: StringFieldUpdateOperationsInput | string\n    tracking_number?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    actual_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Systematic](#systematic)\n- [Actors](#actors)\n- [Sales](#sales)\n- [Orders](#orders)\n- [Carts](#carts)\n- [Reviews](#reviews)\n- [Sellers](#sellers)\n- [Admin](#admin)\n- [Payments](#payments)\n- [Shipping](#shipping)\n\n## Systematic\n\n```mermaid\nerDiagram\n\"shopping_channels\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" {\n  String id PK\n  String shopping_channel_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_channel_categories\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" }o--|| \"shopping_channels\" : channel\n\"shopping_channel_categories\" }o--|| \"shopping_channels\" : channel\n\"shopping_channel_categories\" }o--|| \"shopping_sections\" : section\n```\n\n### `shopping_channels`\n\nRepresents the channels through which products are sold in the shopping\nmall platform. Each channel can have multiple sections and categories,\nforming the foundation of the platform's organizational structure.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `name`: The name of the shopping channel.\n- `description`: A detailed description of the shopping channel.\n- `created_at`: The timestamp when the channel was created.\n- `updated_at`: The timestamp when the channel was last updated.\n- `deleted_at`: The timestamp when the channel was soft deleted, if applicable.\n\n### `shopping_sections`\n\nRepresents the sections within shopping channels. Each section belongs to\na specific channel and can contain multiple categories.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`: The channel to which this section belongs. [shopping_channels.id](#shopping_channels).\n- `name`: The name of the shopping section.\n- `description`: A detailed description of the shopping section.\n- `created_at`: The timestamp when the section was created.\n- `updated_at`: The timestamp when the section was last updated.\n- `deleted_at`: The timestamp when the section was soft deleted, if applicable.\n\n### `shopping_channel_categories`\n\nRepresents the categories within shopping channel sections. Each category\nbelongs to a specific section and channel, forming the hierarchical\nstructure of the platform's product organization.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_channel_id`: The channel to which this category belongs. [shopping_channels.id](#shopping_channels).\n- `shopping_section_id`: The section to which this category belongs. [shopping_sections.id](#shopping_sections).\n- `name`: The name of the shopping category.\n- `description`: A detailed description of the shopping category.\n- `created_at`: The timestamp when the category was created.\n- `updated_at`: The timestamp when the category was last updated.\n- `deleted_at`: The timestamp when the category was soft deleted, if applicable.\n\n## Actors\n\n```mermaid\nerDiagram\n\"shopping_customers\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String address \"nullable\"\n}\n\"shopping_sellers\" {\n  String id PK\n  String email UK\n  String password_hash\n  String business_name\n  String contact_name\n  String phone \"nullable\"\n  String address \"nullable\"\n  String tax_id UK \"nullable\"\n}\n\"shopping_administrators\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String role\n}\n```\n\n### `shopping_customers`\n\nCustomer information, but not a person but a **connection** basis. This\nis the main entity for customer identity management. Contains\nauthentication credentials and basic profile information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Customer's email address. Used for login and communication.\n- `password_hash`: Securely hashed password for authentication.\n- `name`: Customer's full name.\n- `phone`: Customer's phone number.\n- `address`: Customer's primary address.\n\n### `shopping_sellers`\n\nSeller information for marketplace vendors. Contains authentication\ncredentials and business profile information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Seller's email address. Used for login and communication.\n- `password_hash`: Securely hashed password for authentication.\n- `business_name`: Seller's business name.\n- `contact_name`: Primary contact person's name.\n- `phone`: Seller's phone number.\n- `address`: Seller's business address.\n- `tax_id`: Seller's tax identification number.\n\n### `shopping_administrators`\n\nAdministrator information for platform management. Contains\nauthentication credentials and admin profile information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Admin's email address. Used for login and communication.\n- `password_hash`: Securely hashed password for authentication.\n- `name`: Admin's full name.\n- `phone`: Admin's phone number.\n- `role`: Admin's role or permission level.\n\n## Sales\n\n```mermaid\nerDiagram\n\"shopping_products\" {\n  String id PK\n  String shopping_category_id FK \"nullable\"\n  String name\n  String description \"nullable\"\n  Float price\n  String sku UK\n  DateTime created_at\n  DateTime updated_at\n  String password_hash\n  String business_status \"nullable\"\n}\n\"shopping_product_variants\" {\n  String id PK\n  String shopping_product_id FK\n  String sku UK\n  String option_name\n  String option_value\n  Float price_adjustment \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_categories\" {\n  String id PK\n  String parent_id FK \"nullable\"\n  String name\n  String description \"nullable\"\n  String code UK\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_inventory\" {\n  String id PK\n  String shopping_product_variant_id FK,UK\n  String shopping_product_id FK\n  Int quantity\n  Int reserved_quantity\n  Int low_stock_threshold \"nullable\"\n  DateTime last_stock_update \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_product_reviews\" {\n  String id PK\n  String shopping_product_id FK\n  String shopping_customer_id FK\n  Int rating\n  String title \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_products\" }o--o| \"shopping_categories\" : category\n\"shopping_product_variants\" }o--|| \"shopping_products\" : product\n\"shopping_categories\" }o--o| \"shopping_categories\" : parent\n\"shopping_inventory\" |o--|| \"shopping_product_variants\" : variant\n\"shopping_inventory\" }o--|| \"shopping_products\" : product\n\"shopping_product_reviews\" }o--|| \"shopping_products\" : product\n```\n\n### `shopping_products`\n\nCore product information for the e-commerce platform. Contains all\nessential details about products including name, description, pricing,\nand categorization. Serves as the primary entity for product management\nand is referenced by variants, inventory, and reviews.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_category_id`: Category this product belongs to. [shopping_categories.id](#shopping_categories).\n- `name`: Name of the product.\n- `description`: Detailed description of the product.\n- `price`: Base price of the product.\n- `sku`: Stock Keeping Unit - unique identifier for the product.\n- `created_at`: Timestamp when the product was created.\n- `updated_at`: Timestamp when the product was last updated.\n- `password_hash`: Securely hashed password for authentication.\n- `business_status`: Business-specific status for workflow management.\n\n### `shopping_product_variants`\n\nProduct variants representing different options (colors, sizes,\nmaterials) for products. Each variant has its own SKU and inventory\ntracking. References the main product and contains variant-specific\ndetails.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_product_id`: Main product this variant belongs to. [shopping_products.id](#shopping_products).\n- `sku`: Stock Keeping Unit - unique identifier for this variant.\n- `option_name`: Name of the variant option (e.g., Color, Size).\n- `option_value`: Value of the variant option (e.g., Red, Large).\n- `price_adjustment`: Price adjustment for this variant from base price.\n- `created_at`: Timestamp when the variant was created.\n- `updated_at`: Timestamp when the variant was last updated.\n- `business_status`: Business-specific status for workflow management.\n\n### `shopping_categories`\n\nProduct categorization hierarchy for organizing products. Categories can\nhave parent-child relationships to create a hierarchical structure.\nProducts are assigned to categories for better organization and\nfiltering.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `parent_id`: Parent category if this is a subcategory. [shopping_categories.id](#shopping_categories).\n- `name`: Name of the category.\n- `description`: Description of the category.\n- `code`: Unique code for the category.\n- `created_at`: Timestamp when the category was created.\n- `updated_at`: Timestamp when the category was last updated.\n- `business_status`: Business-specific status for workflow management.\n\n### `shopping_inventory`\n\nInventory tracking for product variants. Monitors stock levels,\nreservations, and availability status for each product variant. Critical\nfor order fulfillment and stock management.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_product_variant_id`\n  > Product variant this inventory tracks. {@link\n  > shopping_product_variants.id}.\n- `shopping_product_id`: Product this inventory belongs to. [shopping_products.id](#shopping_products).\n- `quantity`: Current available quantity.\n- `reserved_quantity`: Quantity reserved for pending orders.\n- `low_stock_threshold`: Threshold for low stock alerts.\n- `last_stock_update`: Timestamp of last stock update.\n- `created_at`: Timestamp when the inventory record was created.\n- `updated_at`: Timestamp when the inventory record was last updated.\n- `business_status`: Business-specific status for workflow management.\n\n### `shopping_product_reviews`\n\nCustomer reviews for products. Contains rating, text, and metadata about\ncustomer feedback on products. Critical for building trust and providing\nsocial proof.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_product_id`: Product this review is for. [shopping_products.id](#shopping_products).\n- `shopping_customer_id`: Customer who left the review. [shopping_customers.id](#shopping_customers).\n- `rating`: Rating score (1-5).\n- `title`: Title of the review.\n- `content`: Main content of the review.\n- `created_at`: Timestamp when the review was created.\n- `updated_at`: Timestamp when the review was last updated.\n- `business_status`: Business-specific status for workflow management.\n\n## Orders\n\n```mermaid\nerDiagram\n\"shopping_orders\" {\n  String id PK\n  String shopping_customer_id FK\n  String order_code UK\n  Float total_amount\n  String currency\n  String status\n  String payment_method\n  String shipping_method\n  String shipping_address\n  String billing_address\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_order_items\" {\n  String id PK\n  String shopping_order_id FK\n  String shopping_product_variant_id FK\n  Int quantity\n  Float unit_price\n  Float total_price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_order_status\" {\n  String id PK\n  String shopping_order_id FK\n  String status\n  DateTime changed_at\n  String changed_by \"nullable\"\n  String notes \"nullable\"\n}\n\"shopping_order_history\" {\n  String id PK\n  String shopping_order_id FK\n  String action\n  DateTime changed_at\n  String changed_by \"nullable\"\n  String details \"nullable\"\n}\n\"shopping_order_items\" }o--|| \"shopping_orders\" : order\n\"shopping_order_status\" }o--|| \"shopping_orders\" : order\n\"shopping_order_history\" }o--|| \"shopping_orders\" : order\n```\n\n### `shopping_orders`\n\nMain order table containing all order information. Represents customer\norders with status tracking and payment information. This is the primary\nentity for order management.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_customer_id`: Customer who placed the order. [shopping_customers.id](#shopping_customers).\n- `order_code`: Unique order code for business identification.\n- `total_amount`: Total order amount including all items and taxes.\n- `currency`: Currency used for the order (e.g., USD, KRW).\n- `status`\n  > Current order status (e.g., pending, processing, shipped, delivered,\n  > cancelled).\n- `payment_method`: Payment method used for the order.\n- `shipping_method`: Selected shipping method for the order.\n- `shipping_address`: Shipping address for the order.\n- `billing_address`: Billing address for the order.\n- `created_at`: Timestamp when the order was created.\n- `updated_at`: Timestamp when the order was last updated.\n- `deleted_at`: Timestamp when the order was soft deleted (if applicable).\n\n### `shopping_order_items`\n\nOrder line items representing individual products in an order. Each item\nreferences a product variant and tracks quantity and price.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: Order this item belongs to. [shopping_orders.id](#shopping_orders).\n- `shopping_product_variant_id`: Product variant being ordered. [shopping_product_variants.id](#shopping_product_variants).\n- `quantity`: Number of units ordered.\n- `unit_price`: Price per unit at time of order.\n- `total_price`: Total price for this line item (quantity × unit_price).\n- `created_at`: Timestamp when the order item was created.\n- `updated_at`: Timestamp when the order item was last updated.\n\n### `shopping_order_status`\n\nOrder status tracking table. Records all status changes for an order with\ntimestamps.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: Order this status belongs to. [shopping_orders.id](#shopping_orders).\n- `status`: Order status at this point in time.\n- `changed_at`: Timestamp when this status was set.\n- `changed_by`: User or system that changed the status.\n- `notes`: Additional notes about the status change.\n\n### `shopping_order_history`\n\nHistorical record of all order changes. Captures snapshots of order\nstates for audit trails and change tracking.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: Order this history record belongs to. [shopping_orders.id](#shopping_orders).\n- `action`: Action performed on the order (e.g., created, updated, cancelled).\n- `changed_at`: Timestamp when this action occurred.\n- `changed_by`: User or system that performed the action.\n- `details`: JSON object containing order state at time of action.\n\n## Carts\n\n```mermaid\nerDiagram\n\"shopping_shopping_carts\" {\n  String id PK\n  String shopping_customer_id FK,UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" {\n  String id PK\n  String shopping_shopping_cart_id FK\n  String shopping_product_variant_id FK\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" }o--|| \"shopping_shopping_carts\" : cart\n```\n\n### `shopping_shopping_carts`\n\nRepresents a customer's shopping cart containing items they intend to\npurchase. Each cart belongs to a specific customer and can contain\nmultiple cart items. This is a primary business entity that users manage\nindependently through their shopping experience.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_customer_id`: Customer who owns this shopping cart. [shopping_customers.id](#shopping_customers).\n- `created_at`: Timestamp when the shopping cart was created.\n- `updated_at`: Timestamp when the shopping cart was last updated.\n\n### `shopping_cart_items`\n\nRepresents individual items in a shopping cart. Each item references a\nspecific product variant and belongs to a specific shopping cart. This is\na subsidiary entity managed through the parent shopping cart.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_shopping_cart_id`: Shopping cart that contains this item. [shopping_shopping_carts.id](#shopping_shopping_carts).\n- `shopping_product_variant_id`\n  > Product variant referenced by this cart item. {@link\n  > shopping_product_variants.id}.\n- `quantity`: Quantity of this product variant in the cart.\n- `price`: Price of the product variant at the time it was added to the cart.\n- `created_at`: Timestamp when the cart item was added.\n- `updated_at`: Timestamp when the cart item was last updated.\n\n## Reviews\n\n```mermaid\nerDiagram\n\"shopping_review_moderation\" {\n  String id PK\n  String shopping_product_review_id FK\n  String shopping_administrator_id FK\n  String action_type\n  String reason \"nullable\"\n  DateTime created_at\n}\n\"shopping_review_ratings\" {\n  String id PK\n  String shopping_product_review_id FK,UK\n  Int quality_rating\n  Int value_rating\n  Int service_rating\n  DateTime created_at\n}\n```\n\n### `shopping_review_moderation`\n\nTracks moderation actions taken on product reviews. This table records\neach moderation event, including the administrator who performed the\naction, the type of action, reason, and timestamp. It supports the review\napproval workflow and audit trail.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_product_review_id`: The review being moderated. [shopping_product_reviews.id](#shopping_product_reviews).\n- `shopping_administrator_id`\n  > The administrator who performed the moderation action. {@link\n  > shopping_administrators.id}.\n- `action_type`: Type of moderation action (approve, reject, flag).\n- `reason`: Reason for the moderation action.\n- `created_at`: When the moderation action was performed.\n\n### `shopping_review_ratings`\n\nStores detailed rating breakdowns for product reviews. This table\ncaptures individual rating dimensions (quality, value, etc.) that\ncontribute to the overall rating. It allows for granular analysis of\nreview ratings across different aspects.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_product_review_id`: The review this rating belongs to. [shopping_product_reviews.id](#shopping_product_reviews).\n- `quality_rating`: Rating for product quality (1-5).\n- `value_rating`: Rating for product value (1-5).\n- `service_rating`: Rating for service experience (1-5).\n- `created_at`: When the rating was created.\n\n## Sellers\n\n```mermaid\nerDiagram\n\"shopping_seller_products\" {\n  String id PK\n  String shopping_seller_id FK\n  String shopping_product_id FK\n  String seller_product_code\n  Float price\n  Int quantity_available\n  String status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_inventory\" {\n  String id PK\n  String shopping_seller_product_id FK\n  String shopping_product_variant_id FK\n  Int stock_quantity\n  Int low_stock_threshold \"nullable\"\n  String status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_orders\" {\n  String id PK\n  String shopping_seller_id FK\n  String shopping_order_id FK\n  String seller_order_code\n  String fulfillment_status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_inventory\" }o--|| \"shopping_seller_products\" : sellerProduct\n```\n\n### `shopping_seller_products`\n\nProducts managed by sellers, including product details and\nseller-specific information. This table represents the products that\nsellers offer on the platform, with a relationship to the main products\ntable.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_seller_id`\n  > Reference to the seller who owns this product. {@link\n  > shopping_sellers.id}.\n- `shopping_product_id`\n  > Reference to the main product in the catalog. {@link\n  > shopping_products.id}.\n- `seller_product_code`: Seller-specific product code for internal management.\n- `price`: Seller's price for the product.\n- `quantity_available`: Current available quantity for this product.\n- `status`: Status of the product (e.g., active, draft, archived).\n- `business_status`: Business-specific status for workflow management.\n- `created_at`: Timestamp when the seller product was created.\n- `updated_at`: Timestamp when the seller product was last updated.\n- `deleted_at`: Timestamp when the seller product was soft deleted, if applicable.\n\n### `shopping_seller_inventory`\n\nInventory tracking for seller products, including stock levels and\nmanagement details. This table represents the inventory information that\nsellers manage for their products.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_seller_product_id`: Reference to the seller product. [shopping_seller_products.id](#shopping_seller_products).\n- `shopping_product_variant_id`\n  > Reference to the specific product variant. {@link\n  > shopping_product_variants.id}.\n- `stock_quantity`: Current stock quantity for this inventory item.\n- `low_stock_threshold`: Threshold for low stock alerts.\n- `status`: Status of the inventory item (e.g., in_stock, low_stock, out_of_stock).\n- `business_status`: Business-specific status for workflow management.\n- `created_at`: Timestamp when the inventory record was created.\n- `updated_at`: Timestamp when the inventory record was last updated.\n- `deleted_at`: Timestamp when the inventory record was soft deleted, if applicable.\n\n### `shopping_seller_orders`\n\nOrders managed by sellers, including order details and seller-specific\ninformation. This table represents the orders that sellers need to\nfulfill and manage.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_seller_id`: Reference to the seller who owns this order. [shopping_sellers.id](#shopping_sellers).\n- `shopping_order_id`: Reference to the main order. [shopping_orders.id](#shopping_orders).\n- `seller_order_code`: Seller-specific order code for internal management.\n- `fulfillment_status`\n  > Current fulfillment status of the order (e.g., pending, processing,\n  > shipped, delivered).\n- `business_status`: Business-specific status for workflow management.\n- `created_at`: Timestamp when the seller order was created.\n- `updated_at`: Timestamp when the seller order was last updated.\n- `deleted_at`: Timestamp when the seller order was soft deleted, if applicable.\n\n## Admin\n\n```mermaid\nerDiagram\n\"shopping_admin_actions\" {\n  String id PK\n  String shopping_administrator_id FK\n  String action_type\n  String description\n  DateTime created_at\n}\n\"shopping_admin_logs\" {\n  String id PK\n  String shopping_administrator_id FK \"nullable\"\n  String log_type\n  String message\n  DateTime created_at\n}\n```\n\n### `shopping_admin_actions`\n\nRecords of actions performed by administrators. Tracks all administrative\nactivities for audit and accountability purposes. Each action is linked\nto a specific administrator.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_administrator_id`\n  > Administrator who performed the action. {@link\n  > shopping_administrators.id}.\n- `action_type`\n  > Type of action performed (e.g., 'user_management', 'product_approval',\n  > 'order_update').\n- `description`: Detailed description of the action performed.\n- `created_at`: Timestamp when the action was performed.\n\n### `shopping_admin_logs`\n\nSystem logs recording important events and changes. Tracks system-level\nevents that may be initiated by administrators or system processes.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_administrator_id`\n  > Administrator associated with the log entry (if applicable). {@link\n  > shopping_administrators.id}.\n- `log_type`: Type of log entry (e.g., 'system_event', 'security_event', 'data_change').\n- `message`: Detailed log message describing the event.\n- `created_at`: Timestamp when the log entry was created.\n\n## Payments\n\n```mermaid\nerDiagram\n\"shopping_payments\" {\n  String id PK\n  String shopping_customer_id FK\n  String shopping_order_id FK\n  String payment_method_id\n  Float amount\n  String currency\n  String status\n  String transaction_id UK \"nullable\"\n  DateTime payment_date\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_methods\" {\n  String id PK\n  String method_name UK\n  String method_type\n  String provider \"nullable\"\n  Boolean is_active\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_transactions\" {\n  String id PK\n  String shopping_payment_id FK\n  String transaction_type\n  Float amount\n  String currency\n  String status\n  String gateway_response \"nullable\"\n  DateTime transaction_date\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_transactions\" }o--|| \"shopping_payments\" : payment\n```\n\n### `shopping_payments`\n\nPayment records for all transactions in the shopping mall platform. This\ntable stores information about each payment made by customers, including\npayment method, amount, status, and related order information. It serves\nas the central record for all financial transactions in the system.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_customer_id`: Customer who made the payment. [shopping_customers.id](#shopping_customers).\n- `shopping_order_id`: Order associated with this payment. [shopping_orders.id](#shopping_orders).\n- `payment_method_id`\n  > Payment method used for this transaction. {@link\n  > shopping_payment_methods.id}.\n- `amount`: Total amount paid in this transaction.\n- `currency`: Currency used for the payment (e.g., USD, EUR).\n- `status`\n  > Current status of the payment (e.g., pending, completed, failed,\n  > refunded).\n- `transaction_id`: External transaction ID from payment gateway.\n- `payment_date`: Date and time when the payment was processed.\n- `created_at`: Record creation timestamp.\n- `updated_at`: Record last update timestamp.\n- `deleted_at`: Soft delete timestamp.\n\n### `shopping_payment_methods`\n\nAvailable payment methods in the shopping mall platform. This table\ndefines all supported payment methods that customers can use to make\npurchases, including credit cards, digital wallets, bank transfers, etc.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `method_name`: Name of the payment method (e.g., Credit Card, PayPal, Apple Pay).\n- `method_type`: Type of payment method (e.g., card, digital_wallet, bank_transfer).\n- `provider`: Payment provider name (e.g., Stripe, PayPal, Visa).\n- `is_active`: Whether this payment method is currently active and available.\n- `created_at`: Record creation timestamp.\n- `updated_at`: Record last update timestamp.\n- `deleted_at`: Soft delete timestamp.\n\n### `shopping_payment_transactions`\n\nDetailed records of individual payment transactions. This table captures\nall the detailed information about each payment transaction, including\nauthorization, capture, refund, and chargeback information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_payment_id`: Payment record this transaction belongs to. [shopping_payments.id](#shopping_payments).\n- `transaction_type`: Type of transaction (e.g., authorization, capture, refund, chargeback).\n- `amount`: Amount involved in this transaction.\n- `currency`: Currency used for this transaction.\n- `status`: Current status of this transaction.\n- `gateway_response`: Raw response from payment gateway.\n- `transaction_date`: Date and time when this transaction occurred.\n- `created_at`: Record creation timestamp.\n- `updated_at`: Record last update timestamp.\n- `deleted_at`: Soft delete timestamp.\n\n## Shipping\n\n```mermaid\nerDiagram\n\"shopping_shipping_methods\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  Float cost\n  Int estimated_delivery_days\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_carriers\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  String tracking_url_template \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_tracking\" {\n  String id PK\n  String shopping_order_id FK\n  String shopping_shipping_carrier_id FK\n  String shopping_shipping_method_id FK\n  String tracking_number UK\n  String status\n  DateTime estimated_delivery_date \"nullable\"\n  DateTime actual_delivery_date \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_tracking\" }o--|| \"shopping_shipping_carriers\" : carrier\n\"shopping_shipping_tracking\" }o--|| \"shopping_shipping_methods\" : method\n```\n\n### `shopping_shipping_methods`\n\nShipping methods available for order fulfillment. Contains information\nabout different shipping options, their costs, and delivery time\nestimates.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `name`: Name of the shipping method (e.g., Standard, Express, Overnight).\n- `description`: Detailed description of the shipping method.\n- `cost`: Base cost of the shipping method.\n- `estimated_delivery_days`: Estimated number of days for delivery.\n- `created_at`: Timestamp when the shipping method was created.\n- `updated_at`: Timestamp when the shipping method was last updated.\n\n### `shopping_shipping_carriers`\n\nShipping carriers that handle order deliveries. Contains information\nabout different shipping companies and their services.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `name`: Name of the shipping carrier (e.g., UPS, FedEx, DHL).\n- `description`: Detailed description of the shipping carrier.\n- `tracking_url_template`: URL template for tracking shipments with this carrier.\n- `created_at`: Timestamp when the shipping carrier was created.\n- `updated_at`: Timestamp when the shipping carrier was last updated.\n\n### `shopping_shipping_tracking`\n\nTracking information for shipped orders. Contains details about shipment\nstatus, tracking numbers, and carrier information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `shopping_order_id`: The order being tracked. [shopping_orders.id](#shopping_orders).\n- `shopping_shipping_carrier_id`: The carrier handling the shipment. [shopping_shipping_carriers.id](#shopping_shipping_carriers).\n- `shopping_shipping_method_id`\n  > The shipping method used for this shipment. {@link\n  > shopping_shipping_methods.id}.\n- `tracking_number`: Tracking number provided by the carrier.\n- `status`: Current status of the shipment (e.g., Processing, Shipped, Delivered).\n- `estimated_delivery_date`: Estimated delivery date for the shipment.\n- `actual_delivery_date`: Actual delivery date when the shipment was delivered.\n- `created_at`: Timestamp when the tracking information was created.\n- `updated_at`: Timestamp when the tracking information was last updated.\n","diagrams":{"Systematic":"```mermaid\nerDiagram\n\"shopping_channels\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" {\n  String id PK\n  String shopping_channel_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_channel_categories\" {\n  String id PK\n  String shopping_channel_id FK\n  String shopping_section_id FK\n  String name\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_sections\" }o--|| \"shopping_channels\" : channel\n\"shopping_channel_categories\" }o--|| \"shopping_channels\" : channel\n\"shopping_channel_categories\" }o--|| \"shopping_sections\" : section\n```","Actors":"```mermaid\nerDiagram\n\"shopping_customers\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String address \"nullable\"\n}\n\"shopping_sellers\" {\n  String id PK\n  String email UK\n  String password_hash\n  String business_name\n  String contact_name\n  String phone \"nullable\"\n  String address \"nullable\"\n  String tax_id UK \"nullable\"\n}\n\"shopping_administrators\" {\n  String id PK\n  String email UK\n  String password_hash\n  String name\n  String phone \"nullable\"\n  String role\n}\n```","Sales":"```mermaid\nerDiagram\n\"shopping_products\" {\n  String id PK\n  String shopping_category_id FK \"nullable\"\n  String name\n  String description \"nullable\"\n  Float price\n  String sku UK\n  DateTime created_at\n  DateTime updated_at\n  String password_hash\n  String business_status \"nullable\"\n}\n\"shopping_product_variants\" {\n  String id PK\n  String shopping_product_id FK\n  String sku UK\n  String option_name\n  String option_value\n  Float price_adjustment \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_categories\" {\n  String id PK\n  String parent_id FK \"nullable\"\n  String name\n  String description \"nullable\"\n  String code UK\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_inventory\" {\n  String id PK\n  String shopping_product_variant_id FK,UK\n  String shopping_product_id FK\n  Int quantity\n  Int reserved_quantity\n  Int low_stock_threshold \"nullable\"\n  DateTime last_stock_update \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_product_reviews\" {\n  String id PK\n  String shopping_product_id FK\n  String shopping_customer_id FK\n  Int rating\n  String title \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  String business_status \"nullable\"\n}\n\"shopping_products\" }o--o| \"shopping_categories\" : category\n\"shopping_product_variants\" }o--|| \"shopping_products\" : product\n\"shopping_categories\" }o--o| \"shopping_categories\" : parent\n\"shopping_inventory\" |o--|| \"shopping_product_variants\" : variant\n\"shopping_inventory\" }o--|| \"shopping_products\" : product\n\"shopping_product_reviews\" }o--|| \"shopping_products\" : product\n```","Orders":"```mermaid\nerDiagram\n\"shopping_orders\" {\n  String id PK\n  String shopping_customer_id FK\n  String order_code UK\n  Float total_amount\n  String currency\n  String status\n  String payment_method\n  String shipping_method\n  String shipping_address\n  String billing_address\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_order_items\" {\n  String id PK\n  String shopping_order_id FK\n  String shopping_product_variant_id FK\n  Int quantity\n  Float unit_price\n  Float total_price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_order_status\" {\n  String id PK\n  String shopping_order_id FK\n  String status\n  DateTime changed_at\n  String changed_by \"nullable\"\n  String notes \"nullable\"\n}\n\"shopping_order_history\" {\n  String id PK\n  String shopping_order_id FK\n  String action\n  DateTime changed_at\n  String changed_by \"nullable\"\n  String details \"nullable\"\n}\n\"shopping_order_items\" }o--|| \"shopping_orders\" : order\n\"shopping_order_status\" }o--|| \"shopping_orders\" : order\n\"shopping_order_history\" }o--|| \"shopping_orders\" : order\n```","Carts":"```mermaid\nerDiagram\n\"shopping_shopping_carts\" {\n  String id PK\n  String shopping_customer_id FK,UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" {\n  String id PK\n  String shopping_shopping_cart_id FK\n  String shopping_product_variant_id FK\n  Int quantity\n  Float price\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_cart_items\" }o--|| \"shopping_shopping_carts\" : cart\n```","Reviews":"```mermaid\nerDiagram\n\"shopping_review_moderation\" {\n  String id PK\n  String shopping_product_review_id FK\n  String shopping_administrator_id FK\n  String action_type\n  String reason \"nullable\"\n  DateTime created_at\n}\n\"shopping_review_ratings\" {\n  String id PK\n  String shopping_product_review_id FK,UK\n  Int quality_rating\n  Int value_rating\n  Int service_rating\n  DateTime created_at\n}\n```","Sellers":"```mermaid\nerDiagram\n\"shopping_seller_products\" {\n  String id PK\n  String shopping_seller_id FK\n  String shopping_product_id FK\n  String seller_product_code\n  Float price\n  Int quantity_available\n  String status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_inventory\" {\n  String id PK\n  String shopping_seller_product_id FK\n  String shopping_product_variant_id FK\n  Int stock_quantity\n  Int low_stock_threshold \"nullable\"\n  String status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_orders\" {\n  String id PK\n  String shopping_seller_id FK\n  String shopping_order_id FK\n  String seller_order_code\n  String fulfillment_status\n  String business_status \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_seller_inventory\" }o--|| \"shopping_seller_products\" : sellerProduct\n```","Admin":"```mermaid\nerDiagram\n\"shopping_admin_actions\" {\n  String id PK\n  String shopping_administrator_id FK\n  String action_type\n  String description\n  DateTime created_at\n}\n\"shopping_admin_logs\" {\n  String id PK\n  String shopping_administrator_id FK \"nullable\"\n  String log_type\n  String message\n  DateTime created_at\n}\n```","Payments":"```mermaid\nerDiagram\n\"shopping_payments\" {\n  String id PK\n  String shopping_customer_id FK\n  String shopping_order_id FK\n  String payment_method_id\n  Float amount\n  String currency\n  String status\n  String transaction_id UK \"nullable\"\n  DateTime payment_date\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_methods\" {\n  String id PK\n  String method_name UK\n  String method_type\n  String provider \"nullable\"\n  Boolean is_active\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_transactions\" {\n  String id PK\n  String shopping_payment_id FK\n  String transaction_type\n  Float amount\n  String currency\n  String status\n  String gateway_response \"nullable\"\n  DateTime transaction_date\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"shopping_payment_transactions\" }o--|| \"shopping_payments\" : payment\n```","Shipping":"```mermaid\nerDiagram\n\"shopping_shipping_methods\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  Float cost\n  Int estimated_delivery_days\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_carriers\" {\n  String id PK\n  String name UK\n  String description \"nullable\"\n  String tracking_url_template \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_tracking\" {\n  String id PK\n  String shopping_order_id FK\n  String shopping_shipping_carrier_id FK\n  String shopping_shipping_method_id FK\n  String tracking_number UK\n  String status\n  DateTime estimated_delivery_date \"nullable\"\n  DateTime actual_delivery_date \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"shopping_shipping_tracking\" }o--|| \"shopping_shipping_carriers\" : carrier\n\"shopping_shipping_tracking\" }o--|| \"shopping_shipping_methods\" : method\n```"}},"created_at":"2025-10-14T15:32:41.559Z","completed_at":"2025-10-14T15:41:28.136Z","step":0}]