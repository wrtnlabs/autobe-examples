[{"id":"0199e33c-225e-7589-b84e-c687a2ba43d1","type":"userMessage","contents":[{"type":"text","text":"I want to create a Reddit-like community platform.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit.\r\n\r\nHere are the key features I want:\r\n- User registration and login\r\n- Create communities (subreddits)\r\n- Post text, links, or images in communities\r\n- Upvote/downvote posts and comments\r\n- Comment on posts with nested replies\r\n- User karma system\r\n- Sort posts by hot, new, top, controversial\r\n- Subscribe to communities\r\n- User profiles showing their posts and comments\r\n- Report inappropriate content"}],"created_at":"2025-10-14T14:59:53.054Z"},{"id":"0199e33c-2664-771a-8e46-532c8f4cb7f9","type":"assistantMessage","text":"I'll help you create a Reddit-like community platform. Let me start by analyzing your requirements and then we'll proceed step by step.\n\nFirst, let me call the analyze agent to create a structured requirements specification based on what you've told me.","created_at":"2025-10-14T14:59:54.084Z","completed_at":"2025-10-14T14:59:56.005Z"},{"type":"analyze","id":"0199e34b-d9be-77cc-a4de-fa63cb3317cc","instruction":"Create a requirements analysis for a Reddit-like community platform with these key features:\n- User registration and login\n- Create communities (subreddits)\n- Post text, links, or images in communities\n- Upvote/downvote posts and comments\n- Comment on posts with nested replies\n- User karma system\n- Sort posts by hot, new, top, controversial\n- Subscribe to communities\n- User profiles showing their posts and comments\n- Report inappropriate content\n\nThe user has delegated the planning to me, so I should proceed with a comprehensive analysis that covers all typical features of a Reddit-like platform, while focusing on the core features mentioned above.","prefix":"redditClone","roles":[{"name":"guest","description":"Unauthenticated users who can view public content and register/login","kind":"guest"},{"name":"member","description":"Authenticated users who can create posts, comment, vote, and manage their profile","kind":"member"},{"name":"moderator","description":"Users who can manage content in specific communities, including removing posts and comments","kind":"member"},{"name":"admin","description":"System administrators with full access to manage all users, communities, and system settings","kind":"admin"}],"files":[{"reason":"To provide an overview of the entire Reddit-like community platform project","filename":"00-toc.md","documentType":"service-overview","outline":["Project Overview","Key Features","User Roles","Document Structure","Developer Note"],"audience":"general","keyQuestions":["What is the purpose of this platform?","What are the main features?","Who are the target users?","What documents are included in this analysis?"],"detailLevel":"moderate detail","relatedDocuments":[],"constraints":["Must include all key features mentioned by user","Must define user roles and authentication system","Must provide clear navigation to all documents"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n\nThe enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To define the core business requirements and functional specifications","filename":"01-functional-requirements.md","documentType":"requirement","outline":["User Authentication","Community Management","Content Creation","Voting System","User Profiles","Content Moderation","Sorting and Filtering"],"audience":"development team","keyQuestions":["What are the specific functional requirements?","What business rules must be implemented?","What are the user roles and permissions?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md"],"constraints":["Must include all key features from user requirements","Must use EARS format for requirements","Must define business rules clearly"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n\nThe enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To describe the user roles and authentication system","filename":"02-user-roles.md","documentType":"requirement","outline":["User Roles Overview","Authentication System","Role Permissions","JWT Implementation"],"audience":"development team","keyQuestions":["What are the different user roles?","How does authentication work?","What permissions does each role have?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-functional-requirements.md"],"constraints":["Must define all user roles","Must specify authentication flow","Must include JWT token structure"],"content":"# Reddit-like Community Platform: User Roles and Authentication System\n\n## User Roles Overview\n\nThe Reddit-like community platform requires a robust user role system to manage access control and permissions. The platform will support the following user roles:\n\n### Guest\n- **Description**: Unauthenticated users who can view public content and register/login\n- **Permissions**: View public posts, view public communities, register for an account, login\n- **Restrictions**: Cannot create content, cannot vote, cannot comment\n\n### Member\n- **Description**: Authenticated users who can create posts, comment, vote, and manage their profile\n- **Permissions**: Create posts, comment on posts, upvote/downvote content, create and join communities, subscribe to communities, manage profile\n- **Restrictions**: Cannot moderate content, cannot manage other users\n\n### Moderator\n- **Description**: Users who can manage content in specific communities, including removing posts and comments\n- **Permissions**: All member permissions plus: remove posts, remove comments, manage community settings, approve/remove content\n- **Restrictions**: Limited to specific communities they moderate\n\n### Admin\n- **Description**: System administrators with full access to manage all users, communities, and system settings\n- **Permissions**: All permissions plus: manage all users, manage all communities, configure system settings, view all content\n- **Restrictions**: None\n\n## Authentication System\n\nThe authentication system will follow industry best practices with the following components:\n\n### Registration\n- **EARS**: WHEN a user submits registration information, THE system SHALL validate the email format\n- **EARS**: WHEN a user submits registration information, THE system SHALL check for password strength\n- **EARS**: WHEN registration is successful, THE system SHALL send verification email\n\n### Login\n- **EARS**: WHEN a user submits login credentials, THE system SHALL validate email and password\n- **EARS**: WHEN login is successful, THE system SHALL generate JWT with 15-minute expiration\n- **EARS**: WHEN login fails, THE system SHALL return an appropriate error message\n\n### Password Management\n- **EARS**: WHEN a user requests password reset, THE system SHALL send a reset email\n- **EARS**: WHEN a user submits password change, THE system SHALL validate the new password strength\n\n### Email Verification\n- **EARS**: WHEN a user clicks verification link, THE system SHALL activate the account\n- **EARS**: WHEN email verification fails, THE system SHALL show an error message\n\n## Role Permissions\n\n### Permission Matrix\n\n| Action | Guest | Member | Moderator | Admin |\n|--------|-------|--------|-----------|-------|\n| View public posts | ✅ | ✅ | ✅ | ✅ |\n| Create post | ❌ | ✅ | ✅ | ✅ |\n| Comment on post | ❌ | ✅ | ✅ | ✅ |\n| Vote | ❌ | ✅ | ✅ | ✅ |\n| Create community | ❌ | ✅ | ✅ | ✅ |\n| Moderate content | ❌ | ❌ | ✅ | ✅ |\n| Manage users | ❌ | ❌ | ❌ | ✅ |\n| Manage all communities | ❌ | ❌ | ❌ | ✅ |\n\n### Role-Based Access Control\n- **EARS**: THE system SHALL enforce role-based access control for all operations\n- **EARS**: WHEN a user attempts an action, THE system SHALL check role permissions\n- **EARS**: WHEN a user lacks permission, THE system SHALL return a 403 Forbidden error\n\n## JWT Implementation\n\n### Token Structure\n- **EARS**: THE JWT token SHALL contain userId, role, and expiration\n- **EARS**: THE JWT token SHALL be signed with a secure secret\n- **EARS**: THE JWT token SHALL have an expiration time of 1 hour\n\n### Token Lifecycle\n- **EARS**: WHEN a user logs in, THE system SHALL generate a new JWT token\n- **EARS**: WHEN a token expires, THE system SHALL require re-authentication\n- **EARS**: WHEN a user logs out, THE system SHALL invalidate the token\n\n### Security Considerations\n- **EARS**: THE system SHALL use HTTPS for all authentication requests\n- **EARS**: THE system SHALL store tokens securely (httpOnly cookies)\n- **EARS**: THE system SHALL implement token refresh mechanism\n\n## User Session Management\n\n### Session Persistence\n- **EARS**: THE system SHALL maintain user sessions across page reloads\n- **EARS**: THE system SHALL allow session persistence for 30 days\n\n### Session Expiration\n- **EARS**: THE system SHALL expire sessions after 30 days of inactivity\n- **EARS**: THE system SHALL allow users to manually end sessions\n\n### Multi-Device Support\n- **EARS**: THE system SHALL support concurrent sessions on multiple devices\n- **EARS**: THE system SHALL allow users to view and manage active sessions\n\n## Authentication Flow Diagram\n\n```mermaid\ngraph LR\n    A[\"Guest Access\"] --> B[\"View Public Content\"]\n    A --> C[\"Register\"]\n    C --> D[\"Email Verification\"]\n    D --> E[\"Member Access\"]\n    E --> F[\"Create Content\"]\n    E --> G[\"Vote/Comment\"]\n    E --> H[\"Manage Profile\"]\n    H --> I[\"Become Moderator\"]\n    I --> J[\"Moderate Content\"]\n    J --> K[\"Admin Access\"]\n    K --> L[\"Manage All Users\"]\n    K --> M[\"Manage All Communities\"]\n```\n\n## Permission Flow Diagram\n\n```mermaid\ngraph TD\n    A[\"User Action Request\"] --> B[\"Check Authentication\"]\n    B -->|\"Authenticated\"| C[\"Check Role\"]\n    B -->|\"Not Authenticated\"| D[\"Return 401 Unauthorized\"]\n    C --> E[\"Check Permissions\"]\n    E -->|\"Has Permission\"| F[\"Allow Action\"]\n    E -->|\"No Permission\"| G[\"Return 403 Forbidden\"]\n```\n\n## Business Rules\n\n### Content Moderation\n\n```ears\nWHEN content is reported, THE system SHALL notify moderators\nWHEN content is removed, THE system SHALL hide from public view\nWHEN user is banned, THE system SHALL restrict community access\n```\n\n### Karma System\n\n```ears\nWHEN post is upvoted, THE system SHALL increment author karma\nWHEN post is downvoted, THE system SHALL decrement author karma\nWHEN comment is upvoted, THE system SHALL increment author karma\n```\n\n### Community Management\n\n```ears\nWHEN community is created, THE system SHALL assign creator as moderator\nWHEN user subscribes, THE system SHALL add to feed\nWHEN user unsubscribes, THE system SHALL remove from feed\n```\n\n## Error Handling\n\n### Common Error Scenarios\n- Invalid authentication credentials\n- Duplicate content submission\n- Rate limit exceeded\n- Insufficient permissions\n- Content not found\n\n### Error Recovery\n\n```ears\nWHEN authentication fails, THE system SHALL provide password reset option\nWHEN duplicate content is detected, THE system SHALL suggest editing\nWHEN rate limit is exceeded, THE system SHALL show cooldown timer\n```\n\n## Performance Requirements\n\n### Response Times\n\n```ears\nTHE system SHALL load content feeds within 2 seconds\nTHE system SHALL handle 10,000 concurrent users\nTHE system SHALL process votes instantly\n```\n\n### User Experience\n\n```ears\nTHE system SHALL provide real-time vote updates\nTHE system SHALL show instant comment posting\nTHE system SHALL update karma immediately\n```\n\n## Security Requirements\n\n```ears\nTHE system SHALL encrypt all user passwords\nTHE system SHALL implement CSRF protection\nTHE system SHALL use secure cookies for token storage\nTHE system SHALL implement account lockout after 5 failed attempts\n```\n\n## Related Documents\n\n- [Project Overview](./00-toc.md)\n- [Functional Requirements](./01-functional-requirements.md)\n- [API Structure](./06-api-structure.md)\n- [Database Schema](./07-database-schema.md)\n\n## Developer Note\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To map out user journeys and scenarios","filename":"03-user-journeys.md","documentType":"user-story","outline":["New User Registration","Creating a Community","Posting Content","Voting and Commenting","User Profile Management","Content Moderation"],"audience":"product managers","keyQuestions":["What are the main user flows?","How do users interact with the platform?","What are the key scenarios to consider?"],"detailLevel":"moderate detail","relatedDocuments":["00-toc.md","01-functional-requirements.md"],"constraints":["Must cover all key user interactions","Must include edge cases","Must show complete user flows"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n- Includes Mermaid diagrams with proper syntax (double quotes mandatory)\n\nThe enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To define the business model and value proposition","filename":"04-business-model.md","documentType":"business-model","outline":["Platform Purpose","Value Proposition","Revenue Model","User Engagement","Growth Strategy"],"audience":"business stakeholders","keyQuestions":["Why does this platform exist?","What value does it provide?","How will it generate revenue?","What are the growth strategies?"],"detailLevel":"moderate detail","relatedDocuments":["00-toc.md"],"constraints":["Must define clear business value","Must include revenue strategy","Must address user engagement"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n- Includes Mermaid diagrams with proper syntax (double quotes mandatory)\n\nThe enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To specify the data flow and business rules","filename":"05-data-flow.md","documentType":"requirement","outline":["Data Entities","Content Lifecycle","Voting System","User Karma","Community Management"],"audience":"development team","keyQuestions":["What data entities exist?","How does content flow through the system?","What are the business rules for voting and karma?","How are communities managed?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-functional-requirements.md"],"constraints":["Must define all data entities","Must specify content lifecycle","Must include business rules for all features"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n- The enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To define the API structure and endpoints","filename":"06-api-structure.md","documentType":"requirement","outline":["Authentication Endpoints","Community Endpoints","Content Endpoints","Voting Endpoints","User Profile Endpoints","Moderation Endpoints"],"audience":"development team","keyQuestions":["What are the main API endpoints?","How are they secured?","What data do they return?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-functional-requirements.md"],"constraints":["Must define all API endpoints","Must specify security requirements","Must include request/response formats"],"content":"Step 3 (CoT: Content Phase) - Complete Document Content\n\nThe actual markdown document content that incorporates review feedback.\n\nThis field contains a COMPLETE MARKDOWN DOCUMENT that has already \nincorporated the review criteria and plan requirements.\n\nDO: Treat this as the final, production-ready document.\nDO NOT: Treat this as raw input to be reviewed.\n\nThis content represents:\n- A fully-formed markdown document (.md file)\n- The result of applying review criteria to the original plan\n- A production-ready document for immediate deployment\n- Complete business requirements ready for developers\n\nThe enhancer should treat this as the actual document content:\n\n- Length and completeness (minimum 2,000 characters, more for technical\n  docs)\n- All sections from the plan are fully written\n- No vague or abstract statements\n- Proper use of EARS format for requirements\n- Correct Mermaid diagram syntax (double quotes mandatory)\n- Appropriate level of detail for backend implementation\n- Proper document linking (descriptive text, not raw filenames)\n- Includes Mermaid diagrams with proper syntax (double quotes mandatory)\n\nThe enhancer outputs the document itself:\n\n- If content is provided, it represents the actual document\n- The enhancer outputs the enhanced version AS the document itself\n- No meta-commentary or review feedback should be in the output\n- The output becomes the saved .md file directly\n\nExample of what this field contains:\n\"# Service Overview\\n## Vision\\nThe service provides...\" (actual document)\nNOT: \"This document should cover service overview...\" (review comment)"},{"reason":"To define the database schema and relationships","filename":"07-database-schema.md","documentType":"requirement","outline":["User Tables","Community Tables","Content Tables","Voting Tables","Relationships"],"audience":"development team","keyQuestions":["What tables are needed?","What are the relationships between entities?","What indexes are required?"],"detailLevel":"detailed specification","relatedDocuments":["00-toc.md","01-functional-requirements.md"],"constraints":["Must define all tables","Must specify relationships","Must include indexing strategy"],"content":"# Database Schema Requirements for Reddit-like Community Platform\n\n## 1. User Tables\n\n### 1.1 Users Table\n- **user_id**: UUID (Primary Key)\n- **username**: VARCHAR(50) UNIQUE NOT NULL\n- **email**: VARCHAR(255) UNIQUE NOT NULL\n- **password_hash**: VARCHAR(255) NOT NULL\n- **karma**: INTEGER DEFAULT 0\n- **created_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **updated_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n- **is_active**: BOOLEAN DEFAULT TRUE\n- **role**: ENUM('guest', 'member', 'moderator', 'admin') DEFAULT 'member'\n\n### 1.2 User Profiles Table\n- **user_id**: UUID (Foreign Key to Users)\n- **bio**: TEXT\n- **avatar_url**: VARCHAR(255)\n- **website**: VARCHAR(255)\n- **location**: VARCHAR(100)\n\n## 2. Community Tables\n\n### 2.1 Communities Table\n- **community_id**: UUID (Primary Key)\n- **name**: VARCHAR(100) UNIQUE NOT NULL\n- **description**: TEXT\n- **created_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **updated_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n- **creator_id**: UUID (Foreign Key to Users)\n- **is_nsfw**: BOOLEAN DEFAULT FALSE\n- **member_count**: INTEGER DEFAULT 0\n\n### 2.2 Community Subscriptions Table\n- **user_id**: UUID (Foreign Key to Users)\n- **community_id**: UUID (Foreign Key to Communities)\n- **subscribed_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **is_muted**: BOOLEAN DEFAULT FALSE\n- **PRIMARY KEY (user_id, community_id)**\n\n## 3. Content Tables\n\n### 3.1 Posts Table\n- **post_id**: UUID (Primary Key)\n- **author_id**: UUID (Foreign Key to Users)\n- **community_id**: UUID (Foreign Key to Communities)\n- **title**: VARCHAR(300) NOT NULL\n- **content**: TEXT\n- **content_type**: ENUM('text', 'link', 'image') DEFAULT 'text'\n- **created_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **updated_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n- **is_locked**: BOOLEAN DEFAULT FALSE\n- **is_nsfw**: BOOLEAN DEFAULT FALSE\n- **upvote_count**: INTEGER DEFAULT 0\n- **downvote_count**: INTEGER DEFAULT 0\n- **comment_count**: INTEGER DEFAULT 0\n\n### 3.2 Comments Table\n- **comment_id**: UUID (Primary Key)\n- **post_id**: UUID (Foreign Key to Posts)\n- **author_id**: UUID (Foreign Key to Users)\n- **parent_comment_id**: UUID (NULL for top-level comments, self-referencing)\n- **content**: TEXT NOT NULL\n- **created_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **updated_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n- **upvote_count**: INTEGER DEFAULT 0\n- **downvote_count**: INTEGER DEFAULT 0\n\n## 4. Voting Tables\n\n### 4.1 Post Votes Table\n- **user_id**: UUID (Foreign Key to Users)\n- **post_id**: UUID (Foreign Key to Posts)\n- **vote_type**: ENUM('upvote', 'downvote') NOT NULL\n- **voted_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **PRIMARY KEY (user_id, post_id)**\n\n### 4.2 Comment Votes Table\n- **user_id**: UUID (Foreign Key to Users)\n- **comment_id**: UUID (Foreign Key to Comments)\n- **vote_type**: ENUM('upvote', 'downvote') NOT NULL\n- **voted_at**: TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n- **PRIMARY KEY (user_id, comment_id)**\n\n## 5. Relationships\n\n```mermaid\ngraph LR\n    A[\"Users\"] -->|\"1:N\"| B[\"Posts\"]\n    A -->|\"1:N\"| C[\"Comments\"]\n    A -->|\"1:N\"| D[\"Post Votes\"]\n    A -->|\"1:N\"| E[\"Comment Votes\"]\n    A -->|\"N:M\"| F[\"Communities\"]\n    B -->|\"1:N\"| C\n    F -->|\"1:N\"| B\n```\n\n## 6. Indexing Strategy\n\n### 6.1 Performance Indexes\n- **Users**: INDEX on (username), INDEX on (email)\n- **Communities**: INDEX on (name)\n- **Posts**: INDEX on (community_id, created_at), INDEX on (author_id, created_at)\n- **Comments**: INDEX on (post_id, created_at), INDEX on (parent_comment_id)\n- **Votes**: INDEX on (user_id, post_id), INDEX on (user_id, comment_id)\n\n### 6.2 Full-Text Search Indexes\n- **Posts**: FULLTEXT INDEX on (title, content)\n- **Comments**: FULLTEXT INDEX on (content)\n\n## 7. Business Rules\n\n### 7.1 Data Integrity\n- **THE system SHALL prevent duplicate usernames and emails**\n- **THE system SHALL ensure community names are unique**\n- **THE system SHALL maintain referential integrity between all tables**\n\n### 7.2 Voting Constraints\n- **WHEN a user votes on a post, THE system SHALL prevent duplicate votes**\n- **WHEN a user votes on a comment, THE system SHALL prevent duplicate votes**\n- **WHEN a user changes their vote, THE system SHALL update the existing vote record**\n\n### 7.3 Content Moderation\n- **WHEN content is reported, THE system SHALL track the report status**\n- **WHEN content is removed, THE system SHALL maintain a record of the action**\n\n## 8. Future Considerations\n\n### 8.1 Scalability\n- **THE system SHALL support horizontal scaling through sharding**\n- **THE system SHALL implement read replicas for high traffic scenarios**\n\n### 8.2 Analytics\n- **THE system SHALL track user engagement metrics**\n- **THE system SHALL maintain historical data for trend analysis**\n\n## 9. Developer Note\n\n> *Developer Note: This document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the user interface requirements","filename":"08-ui-requirements.md","documentType":"requirement","outline":["Layout Requirements","Navigation","Responsive Design","Accessibility"],"audience":"design team","keyQuestions":["What are the main UI components?","How should navigation work?","What are the responsive design requirements?"],"detailLevel":"moderate detail","relatedDocuments":["00-toc.md"],"constraints":["Must define main UI components","Must specify navigation requirements","Must include responsive design considerations"],"content":"# Reddit-like Community Platform Requirements Analysis\n\n## Project Overview\n\nThis document provides a comprehensive requirements analysis for building a Reddit-like community platform. The platform will allow users to create communities, post content, vote on posts, comment with nested replies, and manage user profiles with a karma system.\n\n## Key Features\n\nThe platform will include the following core features:\n\n1. **User Registration and Login** - Secure authentication system\n2. **Community Management** - Create and manage subreddit-like communities\n3. **Content Creation** - Post text, links, and images\n4. **Voting System** - Upvote/downvote posts and comments\n5. **Commenting System** - Nested comment replies\n6. **User Karma System** - Reputation tracking\n7. **Content Sorting** - Hot, new, top, controversial filters\n8. **User Profiles** - Show user activity and contributions\n9. **Content Moderation** - Reporting and management tools\n\n## User Roles and Authentication\n\nThe platform will support the following user roles:\n\n### Guest (Unauthenticated)\n- View public content\n- Register for an account\n- Login to existing account\n\n### Member (Authenticated)\n- Create and manage posts\n- Comment on posts\n- Vote on content\n- Manage profile\n- Create and subscribe to communities\n\n### Moderator\n- Manage content in specific communities\n- Remove inappropriate posts/comments\n- Manage community settings\n\n### Admin\n- Full system access\n- Manage all users and communities\n- System configuration\n\n## Functional Requirements\n\n### User Registration and Login\n\n**EARS Format Requirements:**\n- WHEN a user submits registration, THE system SHALL validate email uniqueness\n- WHEN a user logs in, THE system SHALL verify credentials and create session\n- THE system SHALL support password reset functionality\n\n**Business Rules:**\n- Email must be unique across the platform\n- Passwords must meet complexity requirements\n- Sessions expire after 30 days of inactivity\n\n### Community Management\n\n**EARS Format Requirements:**\n- WHEN a member creates a community, THE system SHALL validate unique name\n- WHEN a user subscribes to a community, THE system SHALL add to subscription list\n- THE system SHALL display community-specific content to subscribers\n\n**Business Rules:**\n- Community names must be unique\n- Users can subscribe to unlimited communities\n- Community creators become default moderators\n\n### Content Creation and Management\n\n**EARS Format Requirements:**\n- WHEN a member creates a post, THE system SHALL validate content type\n- WHEN a post is created, THE system SHALL assign unique identifier\n- THE system SHALL support text, link, and image post types\n\n**Business Rules:**\n- Posts can contain text (max 40,000 characters)\n- Links must be validated URLs\n- Images must meet size and format requirements\n\n### Voting System\n\n**EARS Format Requirements:**\n- WHEN a member upvotes content, THE system SHALL increment vote count\n- WHEN a member downvotes content, THE system SHALL decrement vote count\n- THE system SHALL prevent duplicate votes from same user\n\n**Business Rules:**\n- Users can change their vote (upvote → downvote or vice versa)\n- Vote counts update in real-time\n- Vote history is tracked for each user\n\n### Commenting System\n\n**EARS Format Requirements:**\n- WHEN a member comments on a post, THE system SHALL create nested reply\n- WHEN a comment is replied to, THE system SHALL create thread structure\n- THE system SHALL support unlimited nesting depth\n\n**Business Rules:**\n- Comments can be edited within 5 minutes\n- Deleted comments show as [deleted]\n- Comment length maximum: 10,000 characters\n\n### User Karma System\n\n**EARS Format Requirements:**\n- WHEN content receives upvotes, THE system SHALL increment author karma\n- WHEN content receives downvotes, THE system SHALL decrement author karma\n- THE system SHALL display karma on user profiles\n\n**Business Rules:**\n- Karma is calculated as net upvotes minus downvotes\n- Karma affects posting limits and privileges\n- Negative karma may trigger moderation\n\n### Content Sorting and Filtering\n\n**EARS Format Requirements:**\n- THE system SHALL support sorting by hot, new, top, controversial\n- WHEN a user selects a sort option, THE system SHALL reorder content\n- THE system SHALL provide time-based filters (hour, day, week, month, year, all-time)\n\n**Business Rules:**\n- \"Hot\" algorithm: (upvotes - downvotes) / (time since post)^gravity\n- \"Top\" shows highest vote content for selected time period\n- \"Controversial\" shows content with balanced up/down votes\n\n### User Profiles\n\n**EARS Format Requirements:**\n- THE system SHALL display user posts and comments on profile\n- THE system SHALL show user karma and activity statistics\n- WHEN a user edits profile, THE system SHALL validate changes\n\n**Business Rules:**\n- Profiles show last 100 posts and comments\n- Users can set profile visibility preferences\n- Profile edits require re-authentication\n\n### Content Moderation\n\n**EARS Format Requirements:**\n- WHEN content is reported, THE system SHALL flag for moderator review\n- WHEN a moderator removes content, THE system SHALL hide from public view\n- THE system SHALL track moderation actions for audit\n\n**Business Rules:**\n- Reported content requires 3 reports before auto-hiding\n- Moderators can reinstate removed content\n- Users can appeal moderation decisions\n\n## Non-Functional Requirements\n\n### Performance\n- Page loads under 2 seconds\n- API responses under 500ms\n- Support 10,000 concurrent users\n\n### Security\n- HTTPS encryption for all traffic\n- Password hashing with bcrypt\n- Rate limiting on API endpoints\n\n### Scalability\n- Horizontal scaling capability\n- Database sharding for large datasets\n- CDN for static content delivery\n\n## User Scenarios and Use Cases\n\n### New User Registration\n```mermaid\ngraph LR\nA[\"User visits platform\"] --> B[\"Clicks Register\"]\nB --> C[\"Enters email/password\"]\nC --> D[\"Submits form\"]\nD --> E[\"System validates\"]\nE --> F[\"Account created\"]\nF --> G[\"Welcome email sent\"]\n```\n\n### Creating a Community\n```mermaid\ngraph LR\nA[\"User clicks 'Create Community'\"] --> B[\"Enters name/description\"]\nB --> C[\"Submits form\"]\nC --> D[\"System validates uniqueness\"]\nD --> E[\"Community created\"]\nE --> F[\"User becomes moderator\"]\n```\n\n### Posting Content\n```mermaid\ngraph LR\nA[\"User selects community\"] --> B[\"Clicks 'Create Post'\"]\nB --> C[\"Enters title/content\"]\nC --> D[\"Submits post\"]\nD --> E[\"System validates\"]\nE --> F[\"Post published\"]\n```\n\n## Business Model and Value Proposition\n\n### Why This Platform Exists\n- Fill the gap for niche community discussions\n- Provide better moderation tools than existing platforms\n- Offer enhanced user engagement features\n\n### Revenue Strategy\n- Targeted advertising based on community topics\n- Premium memberships for advanced features\n- Sponsored communities and posts\n\n### Growth Plan\n- SEO optimization for community content\n- Integration with social media platforms\n- Influencer partnerships for community growth\n\n### Success Metrics\n- Monthly Active Users (MAU)\n- Daily Active Users (DAU)\n- Average Time Spent per User\n- Community Growth Rate\n- Advertising Click-Through Rate (CTR)\n\n## Technical Considerations\n\n### Architecture\n- Microservices for core functionality\n- API-first design for frontend flexibility\n- Event-driven architecture for real-time features\n\n### Database Design\n- Relational database for structured data\n- NoSQL for content and activity streams\n- Caching layer for high-performance access\n\n### Infrastructure\n- Cloud-based hosting (AWS/Azure/GCP)\n- Containerization with Docker\n- Orchestration with Kubernetes\n\n## Conclusion and Next Steps\n\nThis requirements analysis provides a comprehensive foundation for building the Reddit-like community platform. The next steps include:\n\n1. Detailed technical specification\n2. Database schema design\n3. API endpoint definition\n4. UI/UX design planning\n5. Development roadmap creation\n\n## Developer Note\n\nThis document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team."},{"reason":"To define the testing strategy and requirements","filename":"09-testing-strategy.md","documentType":"requirement","outline":["Testing Approach","Test Cases","Automation Strategy","Performance Testing"],"audience":"QA team","keyQuestions":["What testing approaches will be used?","What are the key test cases?","How will automation be implemented?"],"detailLevel":"moderate detail","relatedDocuments":["00-toc.md"],"constraints":["Must define testing approach","Must specify key test cases","Must include automation strategy"],"content":"# Reddit-like Community Platform Testing Strategy\n\n## 1. Introduction\n\n### 1.1 Purpose\nThis document defines the testing strategy and requirements for the Reddit-like community platform. It outlines the approach to ensure the platform meets all functional and non-functional requirements.\n\n### 1.2 Scope\nThis document covers all testing aspects for the Reddit-like community platform, including:\n- Testing approach\n- Test cases\n- Automation strategy\n- Performance testing\n\n### 1.3 Target Audience\n- Quality Assurance (QA) team\n- Developers\n- Project managers\n\n## 2. Testing Approach\n\n### 2.1 Testing Types\nThe platform will undergo the following types of testing:\n- Unit testing\n- Integration testing\n- System testing\n- User acceptance testing (UAT)\n- Performance testing\n- Security testing\n\n### 2.2 Testing Levels\n- Component testing\n- Integration testing\n- System testing\n- Acceptance testing\n\n### 2.3 Testing Methods\n- Manual testing\n- Automated testing\n- Exploratory testing\n\n## 3. Test Cases\n\n### 3.1 User Authentication\n\n**Test Case 1: User Registration**\n- **Description**: Verify that a new user can register successfully\n- **Preconditions**: User is not logged in\n- **Steps**:\n  1. Navigate to registration page\n  2. Enter valid email, username, and password\n  3. Submit registration form\n- **Expected Result**: User account is created and verification email is sent\n\n**Test Case 2: User Login**\n- **Description**: Verify that a registered user can log in successfully\n- **Preconditions**: User has a registered account\n- **Steps**:\n  1. Navigate to login page\n  2. Enter valid credentials\n  3. Submit login form\n- **Expected Result**: User is authenticated and redirected to homepage\n\n### 3.2 Community Management\n\n**Test Case 3: Community Creation**\n- **Description**: Verify that a user can create a new community\n- **Preconditions**: User is logged in\n- **Steps**:\n  1. Navigate to community creation page\n  2. Enter valid community name and description\n  3. Submit form\n- **Expected Result**: Community is created and user is assigned as moderator\n\n**Test Case 4: Community Subscription**\n- **Description**: Verify that a user can subscribe to a community\n- **Preconditions**: User is logged in, community exists\n- **Steps**:\n  1. Navigate to community page\n  2. Click subscribe button\n- **Expected Result**: User is subscribed to the community\n\n### 3.3 Content Creation\n\n**Test Case 5: Post Creation**\n- **Description**: Verify that a user can create a post\n- **Preconditions**: User is logged in, community exists\n- **Steps**:\n  1. Navigate to community page\n  2. Click \"Create Post\" button\n  3. Enter post title and content\n  4. Submit post\n- **Expected Result**: Post is created and visible in community\n\n**Test Case 6: Comment Creation**\n- **Description**: Verify that a user can comment on a post\n- **Preconditions**: User is logged in, post exists\n- **Steps**:\n  1. Navigate to post page\n  2. Enter comment text\n  3. Submit comment\n- **Expected Result**: Comment is created and visible on post\n\n### 3.4 Voting System\n\n**Test Case 7: Upvote Post**\n- **Description**: Verify that a user can upvote a post\n- **Preconditions**: User is logged in, post exists\n- **Steps**:\n  1. Navigate to post page\n  2. Click upvote button\n- **Expected Result**: Post vote count is incremented\n\n**Test Case 8: Downvote Comment**\n- **Description**: Verify that a user can downvote a comment\n- **Preconditions**: User is logged in, comment exists\n- **Steps**:\n  1. Navigate to comment\n  2. Click downvote button\n- **Expected Result**: Comment vote count is decremented\n\n### 3.5 User Profiles\n\n**Test Case 9: View User Profile**\n- **Description**: Verify that a user can view their profile\n- **Preconditions**: User is logged in\n- **Steps**:\n  1. Click on profile link\n- **Expected Result**: User profile is displayed with posts and comments\n\n**Test Case 10: Edit User Profile**\n- **Description**: Verify that a user can edit their profile\n- **Preconditions**: User is logged in\n- **Steps**:\n  1. Navigate to profile page\n  2. Click edit button\n  3. Update profile information\n  4. Submit changes\n- **Expected Result**: Profile is updated with new information\n\n## 4. Automation Strategy\n\n### 4.1 Test Automation Tools\n- Selenium for browser automation\n- JUnit for unit testing\n- Postman for API testing\n\n### 4.2 Automation Framework\n- Page Object Model for UI tests\n- Data-driven testing for multiple scenarios\n- Continuous Integration (CI) for automated test execution\n\n### 4.3 Test Coverage\n- 80% unit test coverage\n- 60% integration test coverage\n- 40% end-to-end test coverage\n\n## 5. Performance Testing\n\n### 5.1 Load Testing\n- Simulate 10,000 concurrent users\n- Measure response times under load\n- Identify performance bottlenecks\n\n### 5.2 Stress Testing\n- Test system behavior under extreme load\n- Identify breaking points\n- Verify graceful degradation\n\n### 5.3 Performance Metrics\n- Page load time < 2 seconds\n- API response time < 500ms\n- Database query time < 100ms\n\n## 6. Security Testing\n\n### 6.1 Vulnerability Testing\n- SQL injection testing\n- Cross-Site Scripting (XSS) testing\n- Cross-Site Request Forgery (CSRF) testing\n\n### 6.2 Penetration Testing\n- Simulate real-world attacks\n- Identify security weaknesses\n- Verify security controls\n\n### 6.3 Compliance Testing\n- Verify GDPR compliance\n- Verify CCPA compliance\n- Verify PCI DSS compliance\n\n## 7. Test Environment\n\n### 7.1 Test Environment Setup\n- Development environment\n- Staging environment\n- Production environment\n\n### 7.2 Test Data Management\n- Test data generation\n- Test data anonymization\n- Test data cleanup\n\n### 7.3 Test Environment Configuration\n- Environment-specific configurations\n- Environment-specific variables\n- Environment-specific settings\n\n## 8. Test Reporting\n\n### 8.1 Test Results Reporting\n- Test execution reports\n- Test coverage reports\n- Test defect reports\n\n### 8.2 Test Metrics\n- Test pass rate\n- Test failure rate\n- Test execution time\n\n### 8.3 Test Documentation\n- Test plan\n- Test cases\n- Test scripts\n\n## 9. Conclusion\n\nThis document outlines the testing strategy and requirements for the Reddit-like community platform. It provides a comprehensive guide for the QA team to ensure the platform meets all functional and non-functional requirements.\n\n## 10. References\n\n- [Functional Requirements Document](./01-functional-requirements.md)\n- [Data Flow Document](./05-data-flow.md)\n- [API Structure Document](./06-api-structure.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"},{"reason":"To define the deployment and infrastructure requirements","filename":"10-deployment.md","documentType":"requirement","outline":["Hosting Requirements","Scaling Strategy","Monitoring","Backup Strategy"],"audience":"operations team","keyQuestions":["What are the hosting requirements?","How will the system scale?","What monitoring is needed?"],"detailLevel":"moderate detail","relatedDocuments":["00-toc.md"],"constraints":["Must define hosting requirements","Must specify scaling strategy","Must include monitoring needs"],"content":"# Reddit-like Community Platform Deployment Requirements\n\n## 1. Introduction\n\n### Document Purpose\nThis document defines the deployment and infrastructure requirements for the Reddit-like community platform. It outlines the hosting, scaling, monitoring, backup, security, and performance optimization strategies needed to ensure the platform operates reliably and efficiently.\n\n### Scope\nThis document covers all aspects of deployment and infrastructure for the Reddit-like community platform, including:\n- Hosting requirements\n- Scaling strategy\n- Monitoring and alerting\n- Backup and disaster recovery\n- Security requirements\n- Performance optimization\n- Deployment process\n- Maintenance and support\n\n### Target Audience\n- Operations team\n- DevOps engineers\n- System administrators\n- IT managers\n\n## 2. Hosting Requirements\n\n### Server Infrastructure\nThe platform requires a robust server infrastructure to handle user traffic, content storage, and application processing. The infrastructure should support:\n- Web servers for serving the application\n- Application servers for processing business logic\n- Database servers for storing user data, content, and metadata\n- File storage for images and other media\n\n### Cloud vs On-Premises\n**Recommendation**: Cloud hosting is preferred for its scalability, flexibility, and cost-effectiveness.\n\n**Cloud Providers**:\n- Amazon Web Services (AWS)\n- Microsoft Azure\n- Google Cloud Platform (GCP)\n\n### High Availability\nThe platform must maintain high availability to ensure continuous service:\n- Minimum uptime: 99.9%\n- Redundant servers and databases\n- Failover mechanisms\n- Load balancing\n\n## 3. Scaling Strategy\n\n### Horizontal Scaling\nAdd more servers to handle increased load:\n- Web server scaling\n- Application server scaling\n- Database read replicas\n\n### Vertical Scaling\nUpgrade existing servers with more resources:\n- CPU upgrades\n- Memory upgrades\n- Storage upgrades\n\n### Load Balancing\nDistribute traffic evenly across servers:\n- Layer 4 load balancing (TCP/UDP)\n- Layer 7 load balancing (HTTP/HTTPS)\n- Health checks and automatic failover\n\n### Auto-scaling\nAutomatically adjust resources based on demand:\n- CPU utilization thresholds\n- Memory utilization thresholds\n- Request rate thresholds\n\n## 4. Monitoring\n\n### System Monitoring\nMonitor server health and performance:\n- CPU usage\n- Memory usage\n- Disk I/O\n- Network traffic\n\n### Application Monitoring\nMonitor application performance and errors:\n- Response times\n- Error rates\n- Throughput\n- User activity\n\n### Alerting\nSet up alerts for critical issues:\n- Server downtime\n- High error rates\n- Resource exhaustion\n- Security incidents\n\n### Logging\nImplement comprehensive logging:\n- Application logs\n- Server logs\n- Access logs\n- Error logs\n\n## 5. Backup Strategy\n\n### Data Backup\nRegularly back up all critical data:\n- User data\n- Content data\n- System configuration\n\n### Disaster Recovery\nImplement a disaster recovery plan:\n- Regular backup testing\n- Off-site backup storage\n- Recovery time objective (RTO)\n- Recovery point objective (RPO)\n\n### Backup Frequency\n- Daily incremental backups\n- Weekly full backups\n- Monthly archive backups\n\n## 6. Security Requirements\n\n### Network Security\nProtect the network infrastructure:\n- Firewalls\n- Intrusion detection/prevention systems\n- Virtual private networks (VPNs)\n- Network segmentation\n\n### Data Encryption\nEncrypt data at rest and in transit:\n- HTTPS for all communications\n- Database encryption\n- File storage encryption\n\n### Access Control\nImplement strict access control:\n- Role-based access control (RBAC)\n- Multi-factor authentication (MFA)\n- Principle of least privilege\n\n### Compliance\nEnsure compliance with relevant regulations:\n- General Data Protection Regulation (GDPR)\n- California Consumer Privacy Act (CCPA)\n- Payment Card Industry Data Security Standard (PCI DSS)\n\n## 7. Performance Optimization\n\n### Caching\nImplement caching to reduce load and improve response times:\n- Content caching\n- Database query caching\n- API response caching\n\n### Content Delivery Network (CDN)\nUse a CDN to deliver content efficiently:\n- Static content delivery\n- Dynamic content acceleration\n- Global content distribution\n\n### Database Optimization\nOptimize database performance:\n- Indexing\n- Query optimization\n- Database partitioning\n\n## 8. Deployment Process\n\n### Continuous Integration/Continuous Deployment (CI/CD)\nImplement CI/CD for efficient deployment:\n- Automated testing\n- Automated deployment\n- Rollback capabilities\n\n### Rollback Strategy\nImplement a rollback strategy for failed deployments:\n- Version control\n- Backup and restore\n- Feature toggles\n\n### Environment Management\nManage different environments:\n- Development\n- Staging\n- Production\n\n## 9. Maintenance and Support\n\n### Regular Maintenance\nPerform regular maintenance to ensure system health:\n- Software updates\n- Security patches\n- Database maintenance\n\n### Incident Response\nImplement an incident response plan:\n- Incident detection\n- Incident response\n- Incident resolution\n\n### Support Channels\nProvide support channels for users and administrators:\n- Email support\n- Live chat support\n- Knowledge base\n\n## 10. Conclusion\n\nThis document outlines the deployment and infrastructure requirements for the Reddit-like community platform. It provides a comprehensive guide for the operations team to ensure the platform operates reliably and efficiently.\n\n## 11. References\n\n- [Functional Requirements Document](./01-functional-requirements.md)\n- [Data Flow Document](./05-data-flow.md)\n- [API Structure Document](./06-api-structure.md)\n\n> *Developer Note: This document defines **business requirements only**. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team.*"}],"created_at":"2025-10-14T14:59:56.027Z","completed_at":"2025-10-14T15:17:03.036Z","step":0},{"id":"0199e34b-da2c-777a-a540-8f0068643829","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-10-14T15:17:03.148Z"},{"id":"0199e34b-fdec-719c-8e22-8dc6c28ab474","type":"assistantMessage","text":"Now that we have the requirements analysis complete, I'll proceed to design the database schema for your Reddit-like community platform.","created_at":"2025-10-14T15:17:12.300Z","completed_at":"2025-10-14T15:17:14.875Z"},{"type":"prisma","id":"0199e34e-d227-74cc-b330-9af1d2312afb","instruction":"Design a comprehensive database schema for a Reddit-like community platform based on the requirements analysis. The schema should include:\n\n1. User authentication and profile management\n2. Community (subreddit) creation and management\n3. Post types (text, link, image) with content handling\n4. Voting system for posts and comments\n5. Nested comment structure\n6. User karma tracking\n7. Post sorting mechanisms\n8. Community subscription system\n9. Content reporting functionality\n\nFocus on creating efficient relationships between entities, proper indexing for performance, and data integrity constraints. Ensure the schema supports all the core features while allowing for future scalability.","schemas":{"schema-01-systematic.prisma":"/// System configuration settings for the Reddit-like community platform.\n/// Stores platform-wide settings, feature flags, and system parameters that\n/// control platform behavior.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_configurations {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Configuration key identifier.\n  key String\n  \n  /// Configuration value.\n  value String\n  \n  /// Description of the configuration setting.\n  description String?\n  \n  /// Timestamp when the configuration was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the configuration was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([key])\n  @@index([created_at])\n  @@index([updated_at])\n}","schema-02-actors.prisma":"/// Guest users who can view public content and register/login. This table\n/// stores temporary session information for unauthenticated users.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Email address for registration (optional for guests).\n  email String?\n  \n  /// Password hash for login (optional for guests).\n  password_hash String?\n  \n  /// Timestamp when the guest session was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the guest session was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Authenticated members who can create content, vote, and manage their\n/// profile. This table stores all regular user accounts.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_member {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Unique email address for authentication.\n  email String\n  \n  /// Secure password hash for login.\n  password_hash String\n  \n  /// Unique username for display.\n  username String\n  \n  /// User's karma score based on votes.\n  karma Int @db.Integer\n  \n  /// Timestamp when the account was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the account was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  reddit_clone_moderator reddit_clone_moderator[]\n  reddit_clone_admin reddit_clone_admin[]\n  reddit_clone_communities reddit_clone_communities[]\n  reddit_clone_community_subscriptions reddit_clone_community_subscriptions[]\n  reddit_clone_posts reddit_clone_posts[]\n  reddit_clone_comments reddit_clone_comments[]\n  reddit_clone_post_votes reddit_clone_post_votes[]\n  reddit_clone_comment_votes reddit_clone_comment_votes[]\n  \n  @@unique([email])\n  @@unique([username])\n  @@index([created_at])\n}\n\n/// Users with moderation privileges in specific communities. This table\n/// stores moderator-specific information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_moderator {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the member account. {@link reddit_clone_member.id}.\n  member_id String @db.Uuid\n  \n  /// Community where the user is a moderator. {@link\n  /// reddit_clone_communities.id}.\n  community_id String @db.Uuid\n  \n  /// Timestamp when moderator privileges were granted.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when moderator privileges were last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member reddit_clone_member @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  \n  @@index([community_id])\n  \n  @@unique([member_id, community_id])\n  @@index([created_at])\n}\n\n/// System administrators with full access to manage all users and\n/// communities. This table stores admin-specific information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Reference to the member account. {@link reddit_clone_member.id}.\n  member_id String @db.Uuid\n  \n  /// Timestamp when admin privileges were granted.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when admin privileges were last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  member reddit_clone_member @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  \n  @@unique([member_id])\n  @@index([created_at])\n}","schema-03-communities.prisma":"/// Core community entity representing subreddit-like communities where users\n/// can post content, subscribe, and interact. This table stores all\n/// community metadata and serves as the central hub for community\n/// operations.\n///\n/// @namespace Communities\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_communities {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The member who created this community. {@link reddit_clone_member.id}.\n  creator_id String @db.Uuid\n  \n  /// Unique name of the community (e.g., 'programming', 'gaming').\n  name String\n  \n  /// Detailed description of the community's purpose and topics.\n  description String?\n  \n  /// Timestamp when the community was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the community was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the community was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  /// Flag indicating if the community contains adult content.\n  is_nsfw Boolean\n  \n  /// Current number of subscribers to this community.\n  member_count Int @db.Integer\n  \n  //----\n  // RELATIONS\n  //----\n  creator reddit_clone_member @relation(fields: [creator_id], references: [id], onDelete: Cascade)\n  \n  reddit_clone_moderator reddit_clone_moderator[]\n  reddit_clone_community_subscriptions reddit_clone_community_subscriptions[]\n  reddit_clone_posts reddit_clone_posts[]\n  \n  @@unique([name])\n  @@index([creator_id])\n  @@index([created_at])\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Junction table representing the many-to-many relationship between users\n/// and communities. Tracks which users are subscribed to which communities\n/// and manages subscription metadata.\n///\n/// @namespace Communities\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_community_subscriptions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The user who is subscribed to the community. {@link\n  /// reddit_clone_member.id}.\n  user_id String @db.Uuid\n  \n  /// The community being subscribed to. {@link reddit_clone_communities.id}.\n  community_id String @db.Uuid\n  \n  /// Timestamp when the user subscribed to the community.\n  subscribed_at DateTime @db.Timestamptz\n  \n  /// Flag indicating if the user has muted notifications from this community.\n  is_muted Boolean\n  \n  //----\n  // RELATIONS\n  //----\n  user reddit_clone_member @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  \n  @@unique([user_id, community_id])\n  @@index([user_id, subscribed_at])\n  @@index([community_id, subscribed_at], map: \"reddit_clone_community_subscriptions_community_id_subs_918c51ed\")\n}","schema-04-content.prisma":"/// Represents user-created posts in the Reddit-like community platform.\n/// Posts are the primary content entities that users create, edit, and\n/// manage. Each post belongs to a community and has an author. Posts can be\n/// text, links, or images and support voting functionality.\n///\n/// @namespace Content\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The author who created the post. {@link reddit_clone_member.id}.\n  author_id String @db.Uuid\n  \n  /// The community where the post was created. {@link\n  /// reddit_clone_communities.id}.\n  community_id String @db.Uuid\n  \n  /// The title of the post.\n  title String\n  \n  /// The content of the post.\n  content String\n  \n  /// The type of content (text, link, image).\n  content_type String\n  \n  /// When the post was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the post was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Whether the post is locked (no new comments allowed).\n  is_locked Boolean\n  \n  /// Whether the post contains NSFW (Not Safe For Work) content.\n  is_nsfw Boolean\n  \n  /// The number of upvotes the post has received.\n  upvote_count Int @db.Integer\n  \n  /// The number of downvotes the post has received.\n  downvote_count Int @db.Integer\n  \n  /// The number of comments on the post.\n  comment_count Int @db.Integer\n  \n  //----\n  // RELATIONS\n  //----\n  author reddit_clone_member @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  \n  reddit_clone_comments reddit_clone_comments[]\n  reddit_clone_post_votes reddit_clone_post_votes[]\n  \n  @@index([created_at])\n  @@index([author_id, created_at])\n  @@index([community_id, created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents user comments on posts in the Reddit-like community platform.\n/// Comments are primary content entities that users create, edit, and\n/// manage. Each comment belongs to a post and has an author. Comments\n/// support nested replies and voting functionality.\n///\n/// @namespace Content\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// The post this comment belongs to. {@link reddit_clone_posts.id}.\n  post_id String @db.Uuid\n  \n  /// The author who created the comment. {@link reddit_clone_member.id}.\n  author_id String @db.Uuid\n  \n  /// The parent comment ID for nested replies (null for top-level comments).\n  /// {@link reddit_clone_comments.id}.\n  parent_comment_id String? @db.Uuid\n  \n  /// The content of the comment.\n  content String\n  \n  /// When the comment was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// When the comment was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// The number of upvotes the comment has received.\n  upvote_count Int @db.Integer\n  \n  /// The number of downvotes the comment has received.\n  downvote_count Int @db.Integer\n  \n  //----\n  // RELATIONS\n  //----\n  post reddit_clone_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author reddit_clone_member @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent reddit_clone_comments? @relation(\"recursive\", fields: [parent_comment_id], references: [id], onDelete: Cascade)\n  \n  recursive reddit_clone_comments[] @relation(\"recursive\")\n  reddit_clone_comment_votes reddit_clone_comment_votes[]\n  \n  @@index([author_id])\n  \n  @@index([post_id, created_at])\n  @@index([parent_comment_id])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","schema-05-voting.prisma":"/// Tracks user votes on posts in the Reddit-like community platform. This\n/// table records each user's vote (upvote or downvote) on specific posts,\n/// ensuring data integrity through composite primary keys and enforcing that\n/// users can only vote once per post. The table supports the core voting\n/// functionality and enables features like vote counting, user vote history,\n/// and content ranking.\n///\n/// @namespace Voting\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_post_votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// User who cast the vote. {@link reddit_clone_member.id}.\n  user_id String @db.Uuid\n  \n  /// Post that received the vote. {@link reddit_clone_posts.id}.\n  post_id String @db.Uuid\n  \n  /// Type of vote (upvote or downvote).\n  vote_type String\n  \n  /// Timestamp when the vote was cast.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user reddit_clone_member @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post reddit_clone_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  \n  @@unique([user_id, post_id])\n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n}\n\n/// Tracks user votes on comments in the Reddit-like community platform. This\n/// table records each user's vote (upvote or downvote) on specific comments,\n/// ensuring data integrity through composite primary keys and enforcing that\n/// users can only vote once per comment. The table supports nested comment\n/// voting and enables features like comment ranking, user vote history, and\n/// reputation systems.\n///\n/// @namespace Voting\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_comment_votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// User who cast the vote. {@link reddit_clone_member.id}.\n  user_id String @db.Uuid\n  \n  /// Comment that received the vote. {@link reddit_clone_comments.id}.\n  comment_id String @db.Uuid\n  \n  /// Type of vote (upvote or downvote).\n  vote_type String\n  \n  /// Timestamp when the vote was cast.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user reddit_clone_member @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  comment reddit_clone_comments @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  \n  @@unique([user_id, comment_id])\n  @@index([comment_id, created_at])\n  @@index([user_id, created_at])\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-systematic.prisma","namespace":"Systematic","models":[{"name":"reddit_clone_configurations","description":"System configuration settings for the Reddit-like community platform. Stores platform-wide settings, feature flags, and system parameters that control platform behavior.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"key","type":"string","description":"Configuration key identifier.","nullable":false},{"name":"value","type":"string","description":"Configuration value.","nullable":false},{"name":"description","type":"string","description":"Description of the configuration setting.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the configuration was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the configuration was last updated.","nullable":false}],"uniqueIndexes":[{"fieldNames":["key"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["updated_at"]}],"ginIndexes":[]}]},{"filename":"schema-02-actors.prisma","namespace":"Actors","models":[{"name":"reddit_clone_guest","description":"Guest users who can view public content and register/login. This table stores temporary session information for unauthenticated users.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":true,"description":"Email address for registration (optional for guests)."},{"name":"password_hash","type":"string","nullable":true,"description":"Password hash for login (optional for guests)."},{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when the guest session was created."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when the guest session was last updated."}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"reddit_clone_member","description":"Authenticated members who can create content, vote, and manage their profile. This table stores all regular user accounts.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":false,"description":"Unique email address for authentication."},{"name":"password_hash","type":"string","nullable":false,"description":"Secure password hash for login."},{"name":"username","type":"string","nullable":false,"description":"Unique username for display."},{"name":"karma","type":"int","nullable":false,"description":"User's karma score based on votes."},{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when the account was created."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when the account was last updated."}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true},{"fieldNames":["username"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"reddit_clone_moderator","description":"Users with moderation privileges in specific communities. This table stores moderator-specific information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"member_id","type":"uuid","relation":{"name":"member","targetModel":"reddit_clone_member"},"unique":false,"nullable":false,"description":"Reference to the member account. {@link reddit_clone_member.id}."},{"name":"community_id","type":"uuid","relation":{"name":"community","targetModel":"reddit_clone_communities"},"unique":false,"nullable":false,"description":"Community where the user is a moderator. {@link reddit_clone_communities.id}."}],"plainFields":[{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when moderator privileges were granted."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when moderator privileges were last updated."}],"uniqueIndexes":[{"fieldNames":["member_id","community_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"reddit_clone_admin","description":"System administrators with full access to manage all users and communities. This table stores admin-specific information.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"member_id","type":"uuid","relation":{"name":"member","targetModel":"reddit_clone_member"},"unique":false,"nullable":false,"description":"Reference to the member account. {@link reddit_clone_member.id}."}],"plainFields":[{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when admin privileges were granted."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when admin privileges were last updated."}],"uniqueIndexes":[{"fieldNames":["member_id"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-03-communities.prisma","namespace":"Communities","models":[{"name":"reddit_clone_communities","description":"Core community entity representing subreddit-like communities where users can post content, subscribe, and interact. This table stores all community metadata and serves as the central hub for community operations.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"creator_id","type":"uuid","description":"The member who created this community. {@link reddit_clone_member.id}.","relation":{"name":"creator","targetModel":"reddit_clone_member"},"unique":false,"nullable":false}],"plainFields":[{"name":"name","type":"string","description":"Unique name of the community (e.g., 'programming', 'gaming').","nullable":false},{"name":"description","type":"string","description":"Detailed description of the community's purpose and topics.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when the community was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp when the community was last updated.","nullable":false},{"name":"deleted_at","type":"datetime","description":"Timestamp when the community was soft deleted, if applicable.","nullable":true},{"name":"is_nsfw","type":"boolean","description":"Flag indicating if the community contains adult content.","nullable":false},{"name":"member_count","type":"int","description":"Current number of subscribers to this community.","nullable":false}],"uniqueIndexes":[{"fieldNames":["name"],"unique":true}],"plainIndexes":[{"fieldNames":["creator_id"]},{"fieldNames":["created_at"]}],"ginIndexes":[{"fieldName":"description"}]},{"name":"reddit_clone_community_subscriptions","description":"Junction table representing the many-to-many relationship between users and communities. Tracks which users are subscribed to which communities and manages subscription metadata.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"user_id","type":"uuid","description":"The user who is subscribed to the community. {@link reddit_clone_member.id}.","relation":{"name":"user","targetModel":"reddit_clone_member"},"unique":false,"nullable":false},{"name":"community_id","type":"uuid","description":"The community being subscribed to. {@link reddit_clone_communities.id}.","relation":{"name":"community","targetModel":"reddit_clone_communities"},"unique":false,"nullable":false}],"plainFields":[{"name":"subscribed_at","type":"datetime","description":"Timestamp when the user subscribed to the community.","nullable":false},{"name":"is_muted","type":"boolean","description":"Flag indicating if the user has muted notifications from this community.","nullable":false}],"uniqueIndexes":[{"fieldNames":["user_id","community_id"],"unique":true}],"plainIndexes":[{"fieldNames":["user_id","subscribed_at"]},{"fieldNames":["community_id","subscribed_at"]}],"ginIndexes":[]}]},{"filename":"schema-04-content.prisma","namespace":"Content","models":[{"name":"reddit_clone_posts","description":"Represents user-created posts in the Reddit-like community platform. Posts are the primary content entities that users create, edit, and manage. Each post belongs to a community and has an author. Posts can be text, links, or images and support voting functionality.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"author_id","type":"uuid","description":"The author who created the post. {@link reddit_clone_member.id}.","relation":{"name":"author","targetModel":"reddit_clone_member"},"unique":false,"nullable":false},{"name":"community_id","type":"uuid","description":"The community where the post was created. {@link reddit_clone_communities.id}.","relation":{"name":"community","targetModel":"reddit_clone_communities"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","description":"The title of the post.","nullable":false},{"name":"content","type":"string","description":"The content of the post.","nullable":false},{"name":"content_type","type":"string","description":"The type of content (text, link, image).","nullable":false},{"name":"created_at","type":"datetime","description":"When the post was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the post was last updated.","nullable":false},{"name":"is_locked","type":"boolean","description":"Whether the post is locked (no new comments allowed).","nullable":false},{"name":"is_nsfw","type":"boolean","description":"Whether the post contains NSFW (Not Safe For Work) content.","nullable":false},{"name":"upvote_count","type":"int","description":"The number of upvotes the post has received.","nullable":false},{"name":"downvote_count","type":"int","description":"The number of downvotes the post has received.","nullable":false},{"name":"comment_count","type":"int","description":"The number of comments on the post.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["created_at"]},{"fieldNames":["author_id","created_at"]},{"fieldNames":["community_id","created_at"]}],"ginIndexes":[{"fieldName":"title"},{"fieldName":"content"}]},{"name":"reddit_clone_comments","description":"Represents user comments on posts in the Reddit-like community platform. Comments are primary content entities that users create, edit, and manage. Each comment belongs to a post and has an author. Comments support nested replies and voting functionality.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"post_id","type":"uuid","description":"The post this comment belongs to. {@link reddit_clone_posts.id}.","relation":{"name":"post","targetModel":"reddit_clone_posts"},"unique":false,"nullable":false},{"name":"author_id","type":"uuid","description":"The author who created the comment. {@link reddit_clone_member.id}.","relation":{"name":"author","targetModel":"reddit_clone_member"},"unique":false,"nullable":false},{"name":"parent_comment_id","type":"uuid","description":"The parent comment ID for nested replies (null for top-level comments). {@link reddit_clone_comments.id}.","relation":{"name":"parent","targetModel":"reddit_clone_comments","mappingName":"recursive"},"unique":false,"nullable":true}],"plainFields":[{"name":"content","type":"string","description":"The content of the comment.","nullable":false},{"name":"created_at","type":"datetime","description":"When the comment was created.","nullable":false},{"name":"updated_at","type":"datetime","description":"When the comment was last updated.","nullable":false},{"name":"upvote_count","type":"int","description":"The number of upvotes the comment has received.","nullable":false},{"name":"downvote_count","type":"int","description":"The number of downvotes the comment has received.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["post_id","created_at"]},{"fieldNames":["parent_comment_id"]}],"ginIndexes":[{"fieldName":"content"}]}]},{"filename":"schema-05-voting.prisma","namespace":"Voting","models":[{"name":"reddit_clone_post_votes","description":"Tracks user votes on posts in the Reddit-like community platform. This table records each user's vote (upvote or downvote) on specific posts, ensuring data integrity through composite primary keys and enforcing that users can only vote once per post. The table supports the core voting functionality and enables features like vote counting, user vote history, and content ranking.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"user_id","type":"uuid","description":"User who cast the vote. {@link reddit_clone_member.id}.","relation":{"name":"user","targetModel":"reddit_clone_member"},"unique":false,"nullable":false},{"name":"post_id","type":"uuid","description":"Post that received the vote. {@link reddit_clone_posts.id}.","relation":{"name":"post","targetModel":"reddit_clone_posts"},"unique":false,"nullable":false}],"plainFields":[{"name":"vote_type","type":"string","description":"Type of vote (upvote or downvote).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the vote was cast.","nullable":false}],"uniqueIndexes":[{"fieldNames":["user_id","post_id"],"unique":true}],"plainIndexes":[{"fieldNames":["post_id","created_at"]},{"fieldNames":["user_id","created_at"]}],"ginIndexes":[]},{"name":"reddit_clone_comment_votes","description":"Tracks user votes on comments in the Reddit-like community platform. This table records each user's vote (upvote or downvote) on specific comments, ensuring data integrity through composite primary keys and enforcing that users can only vote once per comment. The table supports nested comment voting and enables features like comment ranking, user vote history, and reputation systems.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"user_id","type":"uuid","description":"User who cast the vote. {@link reddit_clone_member.id}.","relation":{"name":"user","targetModel":"reddit_clone_member"},"unique":false,"nullable":false},{"name":"comment_id","type":"uuid","description":"Comment that received the vote. {@link reddit_clone_comments.id}.","relation":{"name":"comment","targetModel":"reddit_clone_comments"},"unique":false,"nullable":false}],"plainFields":[{"name":"vote_type","type":"string","description":"Type of vote (upvote or downvote).","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the vote was cast.","nullable":false}],"uniqueIndexes":[{"fieldNames":["user_id","comment_id"],"unique":true}],"plainIndexes":[{"fieldNames":["comment_id","created_at"]},{"fieldNames":["user_id","created_at"]}],"ginIndexes":[]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-systematic.prisma":"/// System configuration settings for the Reddit-like community platform.\n/// Stores platform-wide settings, feature flags, and system parameters that\n/// control platform behavior.\n///\n/// @namespace Systematic\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_configurations {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Configuration key identifier.\n  key String\n\n  /// Configuration value.\n  value String\n\n  /// Description of the configuration setting.\n  description String?\n\n  /// Timestamp when the configuration was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the configuration was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([key])\n  @@index([created_at])\n  @@index([updated_at])\n}\n","schema-02-actors.prisma":"/// Guest users who can view public content and register/login. This table\n/// stores temporary session information for unauthenticated users.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Email address for registration (optional for guests).\n  email String?\n\n  /// Password hash for login (optional for guests).\n  password_hash String?\n\n  /// Timestamp when the guest session was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the guest session was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Authenticated members who can create content, vote, and manage their\n/// profile. This table stores all regular user accounts.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_member {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Unique email address for authentication.\n  email String\n\n  /// Secure password hash for login.\n  password_hash String\n\n  /// Unique username for display.\n  username String\n\n  /// User's karma score based on votes.\n  karma Int @db.Integer\n\n  /// Timestamp when the account was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the account was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  reddit_clone_moderator               reddit_clone_moderator[]\n  reddit_clone_admin                   reddit_clone_admin[]\n  reddit_clone_communities             reddit_clone_communities[]\n  reddit_clone_community_subscriptions reddit_clone_community_subscriptions[]\n  reddit_clone_posts                   reddit_clone_posts[]\n  reddit_clone_comments                reddit_clone_comments[]\n  reddit_clone_post_votes              reddit_clone_post_votes[]\n  reddit_clone_comment_votes           reddit_clone_comment_votes[]\n\n  @@unique([email])\n  @@unique([username])\n  @@index([created_at])\n}\n\n/// Users with moderation privileges in specific communities. This table\n/// stores moderator-specific information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_moderator {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the member account. {@link reddit_clone_member.id}.\n  member_id String @db.Uuid\n\n  /// Community where the user is a moderator. {@link\n  /// reddit_clone_communities.id}.\n  community_id String @db.Uuid\n\n  /// Timestamp when moderator privileges were granted.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when moderator privileges were last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member    reddit_clone_member      @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n\n  @@unique([member_id, community_id])\n  @@index([community_id])\n  @@index([created_at])\n}\n\n/// System administrators with full access to manage all users and\n/// communities. This table stores admin-specific information.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Reference to the member account. {@link reddit_clone_member.id}.\n  member_id String @db.Uuid\n\n  /// Timestamp when admin privileges were granted.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when admin privileges were last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  member reddit_clone_member @relation(fields: [member_id], references: [id], onDelete: Cascade)\n\n  @@unique([member_id])\n  @@index([created_at])\n}\n","schema-03-communities.prisma":"/// Core community entity representing subreddit-like communities where users\n/// can post content, subscribe, and interact. This table stores all\n/// community metadata and serves as the central hub for community\n/// operations.\n///\n/// @namespace Communities\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_communities {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The member who created this community. {@link reddit_clone_member.id}.\n  creator_id String @db.Uuid\n\n  /// Unique name of the community (e.g., 'programming', 'gaming').\n  name String\n\n  /// Detailed description of the community's purpose and topics.\n  description String?\n\n  /// Timestamp when the community was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the community was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the community was soft deleted, if applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  /// Flag indicating if the community contains adult content.\n  is_nsfw Boolean\n\n  /// Current number of subscribers to this community.\n  member_count Int @db.Integer\n\n  //----\n  // RELATIONS\n  //----\n  creator reddit_clone_member @relation(fields: [creator_id], references: [id], onDelete: Cascade)\n\n  reddit_clone_moderator               reddit_clone_moderator[]\n  reddit_clone_community_subscriptions reddit_clone_community_subscriptions[]\n  reddit_clone_posts                   reddit_clone_posts[]\n\n  @@unique([name])\n  @@index([creator_id])\n  @@index([created_at])\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Junction table representing the many-to-many relationship between users\n/// and communities. Tracks which users are subscribed to which communities\n/// and manages subscription metadata.\n///\n/// @namespace Communities\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_community_subscriptions {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The user who is subscribed to the community. {@link\n  /// reddit_clone_member.id}.\n  user_id String @db.Uuid\n\n  /// The community being subscribed to. {@link reddit_clone_communities.id}.\n  community_id String @db.Uuid\n\n  /// Timestamp when the user subscribed to the community.\n  subscribed_at DateTime @db.Timestamptz\n\n  /// Flag indicating if the user has muted notifications from this community.\n  is_muted Boolean\n\n  //----\n  // RELATIONS\n  //----\n  user      reddit_clone_member      @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n\n  @@unique([user_id, community_id])\n  @@index([user_id, subscribed_at])\n  @@index([community_id, subscribed_at], map: \"reddit_clone_community_subscriptions_community_id_subs_918c51ed\")\n}\n","schema-04-content.prisma":"/// Represents user-created posts in the Reddit-like community platform.\n/// Posts are the primary content entities that users create, edit, and\n/// manage. Each post belongs to a community and has an author. Posts can be\n/// text, links, or images and support voting functionality.\n///\n/// @namespace Content\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The author who created the post. {@link reddit_clone_member.id}.\n  author_id String @db.Uuid\n\n  /// The community where the post was created. {@link\n  /// reddit_clone_communities.id}.\n  community_id String @db.Uuid\n\n  /// The title of the post.\n  title String\n\n  /// The content of the post.\n  content String\n\n  /// The type of content (text, link, image).\n  content_type String\n\n  /// When the post was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the post was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Whether the post is locked (no new comments allowed).\n  is_locked Boolean\n\n  /// Whether the post contains NSFW (Not Safe For Work) content.\n  is_nsfw Boolean\n\n  /// The number of upvotes the post has received.\n  upvote_count Int @db.Integer\n\n  /// The number of downvotes the post has received.\n  downvote_count Int @db.Integer\n\n  /// The number of comments on the post.\n  comment_count Int @db.Integer\n\n  //----\n  // RELATIONS\n  //----\n  author    reddit_clone_member      @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  community reddit_clone_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n\n  reddit_clone_comments   reddit_clone_comments[]\n  reddit_clone_post_votes reddit_clone_post_votes[]\n\n  @@index([created_at])\n  @@index([author_id, created_at])\n  @@index([community_id, created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Represents user comments on posts in the Reddit-like community platform.\n/// Comments are primary content entities that users create, edit, and\n/// manage. Each comment belongs to a post and has an author. Comments\n/// support nested replies and voting functionality.\n///\n/// @namespace Content\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// The post this comment belongs to. {@link reddit_clone_posts.id}.\n  post_id String @db.Uuid\n\n  /// The author who created the comment. {@link reddit_clone_member.id}.\n  author_id String @db.Uuid\n\n  /// The parent comment ID for nested replies (null for top-level comments).\n  /// {@link reddit_clone_comments.id}.\n  parent_comment_id String? @db.Uuid\n\n  /// The content of the comment.\n  content String\n\n  /// When the comment was created.\n  created_at DateTime @db.Timestamptz\n\n  /// When the comment was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// The number of upvotes the comment has received.\n  upvote_count Int @db.Integer\n\n  /// The number of downvotes the comment has received.\n  downvote_count Int @db.Integer\n\n  //----\n  // RELATIONS\n  //----\n  post   reddit_clone_posts     @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author reddit_clone_member    @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent reddit_clone_comments? @relation(\"recursive\", fields: [parent_comment_id], references: [id], onDelete: Cascade)\n\n  recursive                  reddit_clone_comments[]      @relation(\"recursive\")\n  reddit_clone_comment_votes reddit_clone_comment_votes[]\n\n  @@index([author_id])\n  @@index([post_id, created_at])\n  @@index([parent_comment_id])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","schema-05-voting.prisma":"/// Tracks user votes on posts in the Reddit-like community platform. This\n/// table records each user's vote (upvote or downvote) on specific posts,\n/// ensuring data integrity through composite primary keys and enforcing that\n/// users can only vote once per post. The table supports the core voting\n/// functionality and enables features like vote counting, user vote history,\n/// and content ranking.\n///\n/// @namespace Voting\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_post_votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// User who cast the vote. {@link reddit_clone_member.id}.\n  user_id String @db.Uuid\n\n  /// Post that received the vote. {@link reddit_clone_posts.id}.\n  post_id String @db.Uuid\n\n  /// Type of vote (upvote or downvote).\n  vote_type String\n\n  /// Timestamp when the vote was cast.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user reddit_clone_member @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post reddit_clone_posts  @relation(fields: [post_id], references: [id], onDelete: Cascade)\n\n  @@unique([user_id, post_id])\n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n}\n\n/// Tracks user votes on comments in the Reddit-like community platform. This\n/// table records each user's vote (upvote or downvote) on specific comments,\n/// ensuring data integrity through composite primary keys and enforcing that\n/// users can only vote once per comment. The table supports nested comment\n/// voting and enables features like comment ranking, user vote history, and\n/// reputation systems.\n///\n/// @namespace Voting\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel reddit_clone_comment_votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// User who cast the vote. {@link reddit_clone_member.id}.\n  user_id String @db.Uuid\n\n  /// Comment that received the vote. {@link reddit_clone_comments.id}.\n  comment_id String @db.Uuid\n\n  /// Type of vote (upvote or downvote).\n  vote_type String\n\n  /// Timestamp when the vote was cast.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user    reddit_clone_member   @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  comment reddit_clone_comments @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n\n  @@unique([user_id, comment_id])\n  @@index([comment_id, created_at])\n  @@index([user_id, created_at])\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model reddit_clone_configurations\n * System configuration settings for the Reddit-like community platform.\n * Stores platform-wide settings, feature flags, and system parameters that\n * control platform behavior.\n * \n * @namespace Systematic\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_configurations = $Result.DefaultSelection<Prisma.$reddit_clone_configurationsPayload>\n/**\n * Model reddit_clone_guest\n * Guest users who can view public content and register/login. This table\n * stores temporary session information for unauthenticated users.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_guest = $Result.DefaultSelection<Prisma.$reddit_clone_guestPayload>\n/**\n * Model reddit_clone_member\n * Authenticated members who can create content, vote, and manage their\n * profile. This table stores all regular user accounts.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_member = $Result.DefaultSelection<Prisma.$reddit_clone_memberPayload>\n/**\n * Model reddit_clone_moderator\n * Users with moderation privileges in specific communities. This table\n * stores moderator-specific information.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_moderator = $Result.DefaultSelection<Prisma.$reddit_clone_moderatorPayload>\n/**\n * Model reddit_clone_admin\n * System administrators with full access to manage all users and\n * communities. This table stores admin-specific information.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_admin = $Result.DefaultSelection<Prisma.$reddit_clone_adminPayload>\n/**\n * Model reddit_clone_communities\n * Core community entity representing subreddit-like communities where users\n * can post content, subscribe, and interact. This table stores all\n * community metadata and serves as the central hub for community\n * operations.\n * \n * @namespace Communities\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_communities = $Result.DefaultSelection<Prisma.$reddit_clone_communitiesPayload>\n/**\n * Model reddit_clone_community_subscriptions\n * Junction table representing the many-to-many relationship between users\n * and communities. Tracks which users are subscribed to which communities\n * and manages subscription metadata.\n * \n * @namespace Communities\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_community_subscriptions = $Result.DefaultSelection<Prisma.$reddit_clone_community_subscriptionsPayload>\n/**\n * Model reddit_clone_posts\n * Represents user-created posts in the Reddit-like community platform.\n * Posts are the primary content entities that users create, edit, and\n * manage. Each post belongs to a community and has an author. Posts can be\n * text, links, or images and support voting functionality.\n * \n * @namespace Content\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_posts = $Result.DefaultSelection<Prisma.$reddit_clone_postsPayload>\n/**\n * Model reddit_clone_comments\n * Represents user comments on posts in the Reddit-like community platform.\n * Comments are primary content entities that users create, edit, and\n * manage. Each comment belongs to a post and has an author. Comments\n * support nested replies and voting functionality.\n * \n * @namespace Content\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_comments = $Result.DefaultSelection<Prisma.$reddit_clone_commentsPayload>\n/**\n * Model reddit_clone_post_votes\n * Tracks user votes on posts in the Reddit-like community platform. This\n * table records each user's vote (upvote or downvote) on specific posts,\n * ensuring data integrity through composite primary keys and enforcing that\n * users can only vote once per post. The table supports the core voting\n * functionality and enables features like vote counting, user vote history,\n * and content ranking.\n * \n * @namespace Voting\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_post_votes = $Result.DefaultSelection<Prisma.$reddit_clone_post_votesPayload>\n/**\n * Model reddit_clone_comment_votes\n * Tracks user votes on comments in the Reddit-like community platform. This\n * table records each user's vote (upvote or downvote) on specific comments,\n * ensuring data integrity through composite primary keys and enforcing that\n * users can only vote once per comment. The table supports nested comment\n * voting and enables features like comment ranking, user vote history, and\n * reputation systems.\n * \n * @namespace Voting\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type reddit_clone_comment_votes = $Result.DefaultSelection<Prisma.$reddit_clone_comment_votesPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Reddit_clone_configurations\n * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Reddit_clone_configurations\n   * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.reddit_clone_configurations`: Exposes CRUD operations for the **reddit_clone_configurations** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_configurations\n    * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findMany()\n    * ```\n    */\n  get reddit_clone_configurations(): Prisma.reddit_clone_configurationsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_guest`: Exposes CRUD operations for the **reddit_clone_guest** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_guests\n    * const reddit_clone_guests = await prisma.reddit_clone_guest.findMany()\n    * ```\n    */\n  get reddit_clone_guest(): Prisma.reddit_clone_guestDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_member`: Exposes CRUD operations for the **reddit_clone_member** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_members\n    * const reddit_clone_members = await prisma.reddit_clone_member.findMany()\n    * ```\n    */\n  get reddit_clone_member(): Prisma.reddit_clone_memberDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_moderator`: Exposes CRUD operations for the **reddit_clone_moderator** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_moderators\n    * const reddit_clone_moderators = await prisma.reddit_clone_moderator.findMany()\n    * ```\n    */\n  get reddit_clone_moderator(): Prisma.reddit_clone_moderatorDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_admin`: Exposes CRUD operations for the **reddit_clone_admin** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_admins\n    * const reddit_clone_admins = await prisma.reddit_clone_admin.findMany()\n    * ```\n    */\n  get reddit_clone_admin(): Prisma.reddit_clone_adminDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_communities`: Exposes CRUD operations for the **reddit_clone_communities** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_communities\n    * const reddit_clone_communities = await prisma.reddit_clone_communities.findMany()\n    * ```\n    */\n  get reddit_clone_communities(): Prisma.reddit_clone_communitiesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_community_subscriptions`: Exposes CRUD operations for the **reddit_clone_community_subscriptions** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_community_subscriptions\n    * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findMany()\n    * ```\n    */\n  get reddit_clone_community_subscriptions(): Prisma.reddit_clone_community_subscriptionsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_posts`: Exposes CRUD operations for the **reddit_clone_posts** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_posts\n    * const reddit_clone_posts = await prisma.reddit_clone_posts.findMany()\n    * ```\n    */\n  get reddit_clone_posts(): Prisma.reddit_clone_postsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_comments`: Exposes CRUD operations for the **reddit_clone_comments** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_comments\n    * const reddit_clone_comments = await prisma.reddit_clone_comments.findMany()\n    * ```\n    */\n  get reddit_clone_comments(): Prisma.reddit_clone_commentsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_post_votes`: Exposes CRUD operations for the **reddit_clone_post_votes** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_post_votes\n    * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findMany()\n    * ```\n    */\n  get reddit_clone_post_votes(): Prisma.reddit_clone_post_votesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.reddit_clone_comment_votes`: Exposes CRUD operations for the **reddit_clone_comment_votes** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Reddit_clone_comment_votes\n    * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findMany()\n    * ```\n    */\n  get reddit_clone_comment_votes(): Prisma.reddit_clone_comment_votesDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    reddit_clone_configurations: 'reddit_clone_configurations',\n    reddit_clone_guest: 'reddit_clone_guest',\n    reddit_clone_member: 'reddit_clone_member',\n    reddit_clone_moderator: 'reddit_clone_moderator',\n    reddit_clone_admin: 'reddit_clone_admin',\n    reddit_clone_communities: 'reddit_clone_communities',\n    reddit_clone_community_subscriptions: 'reddit_clone_community_subscriptions',\n    reddit_clone_posts: 'reddit_clone_posts',\n    reddit_clone_comments: 'reddit_clone_comments',\n    reddit_clone_post_votes: 'reddit_clone_post_votes',\n    reddit_clone_comment_votes: 'reddit_clone_comment_votes'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"reddit_clone_configurations\" | \"reddit_clone_guest\" | \"reddit_clone_member\" | \"reddit_clone_moderator\" | \"reddit_clone_admin\" | \"reddit_clone_communities\" | \"reddit_clone_community_subscriptions\" | \"reddit_clone_posts\" | \"reddit_clone_comments\" | \"reddit_clone_post_votes\" | \"reddit_clone_comment_votes\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      reddit_clone_configurations: {\n        payload: Prisma.$reddit_clone_configurationsPayload<ExtArgs>\n        fields: Prisma.reddit_clone_configurationsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_configurationsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_configurationsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_configurationsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_configurationsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_configurationsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_configurationsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_configurationsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_configurationsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_configurationsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_configurationsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_configurationsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_configurationsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_configurationsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_configurationsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_configurationsPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_configurationsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_configurations>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_configurationsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_configurationsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_configurationsCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_configurationsCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_guest: {\n        payload: Prisma.$reddit_clone_guestPayload<ExtArgs>\n        fields: Prisma.reddit_clone_guestFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_guestFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_guestFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_guestFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_guestFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_guestFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_guestCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_guestCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_guestCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_guestDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_guestUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_guestDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_guestUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_guestUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_guestUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_guestPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_guestAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_guest>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_guestGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_guestGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_guestCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_guestCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_member: {\n        payload: Prisma.$reddit_clone_memberPayload<ExtArgs>\n        fields: Prisma.reddit_clone_memberFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_memberFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_memberFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_memberFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_memberFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_memberFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_memberCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_memberCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_memberCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_memberDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_memberUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_memberDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_memberUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_memberUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_memberUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_memberPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_memberAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_member>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_memberGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_memberGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_memberCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_memberCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_moderator: {\n        payload: Prisma.$reddit_clone_moderatorPayload<ExtArgs>\n        fields: Prisma.reddit_clone_moderatorFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_moderatorFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_moderatorFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_moderatorFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_moderatorFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_moderatorFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_moderatorCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_moderatorCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_moderatorCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_moderatorDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_moderatorUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_moderatorDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_moderatorUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_moderatorUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_moderatorUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_moderatorPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_moderatorAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_moderator>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_moderatorGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_moderatorGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_moderatorCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_moderatorCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_admin: {\n        payload: Prisma.$reddit_clone_adminPayload<ExtArgs>\n        fields: Prisma.reddit_clone_adminFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_adminFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_adminFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_adminFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_adminFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_adminFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_adminCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_adminCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_adminCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_adminDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_adminUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_adminDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_adminUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_adminUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_adminUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_adminPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_adminAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_admin>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_adminGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_adminGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_adminCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_adminCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_communities: {\n        payload: Prisma.$reddit_clone_communitiesPayload<ExtArgs>\n        fields: Prisma.reddit_clone_communitiesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_communitiesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_communitiesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_communitiesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_communitiesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_communitiesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_communitiesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_communitiesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_communitiesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_communitiesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_communitiesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_communitiesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_communitiesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_communitiesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_communitiesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_communitiesPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_communitiesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_communities>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_communitiesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_communitiesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_communitiesCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_communitiesCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_community_subscriptions: {\n        payload: Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>\n        fields: Prisma.reddit_clone_community_subscriptionsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_community_subscriptionsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_community_subscriptionsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_community_subscriptionsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_community_subscriptionsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_community_subscriptionsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_community_subscriptionsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_community_subscriptionsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_community_subscriptionsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_community_subscriptionsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_community_subscriptionsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_community_subscriptionsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_community_subscriptionsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_community_subscriptionsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_community_subscriptionsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_community_subscriptionsPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_community_subscriptionsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_community_subscriptions>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_community_subscriptionsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_community_subscriptionsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_community_subscriptionsCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_community_subscriptionsCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_posts: {\n        payload: Prisma.$reddit_clone_postsPayload<ExtArgs>\n        fields: Prisma.reddit_clone_postsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_postsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_postsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_postsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_postsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_postsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_postsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_postsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_postsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_postsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_postsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_postsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_postsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_postsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_postsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_postsPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_postsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_posts>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_postsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_postsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_postsCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_postsCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_comments: {\n        payload: Prisma.$reddit_clone_commentsPayload<ExtArgs>\n        fields: Prisma.reddit_clone_commentsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_commentsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_commentsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_commentsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_commentsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_commentsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_commentsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_commentsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_commentsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_commentsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_commentsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_commentsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_commentsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_commentsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_commentsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_commentsPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_commentsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_comments>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_commentsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_commentsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_commentsCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_commentsCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_post_votes: {\n        payload: Prisma.$reddit_clone_post_votesPayload<ExtArgs>\n        fields: Prisma.reddit_clone_post_votesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_post_votesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_post_votesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_post_votesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_post_votesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_post_votesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_post_votesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_post_votesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_post_votesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_post_votesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_post_votesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_post_votesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_post_votesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_post_votesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_post_votesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_post_votesPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_post_votesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_post_votes>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_post_votesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_post_votesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_post_votesCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_post_votesCountAggregateOutputType> | number\n          }\n        }\n      }\n      reddit_clone_comment_votes: {\n        payload: Prisma.$reddit_clone_comment_votesPayload<ExtArgs>\n        fields: Prisma.reddit_clone_comment_votesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.reddit_clone_comment_votesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.reddit_clone_comment_votesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          findFirst: {\n            args: Prisma.reddit_clone_comment_votesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.reddit_clone_comment_votesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          findMany: {\n            args: Prisma.reddit_clone_comment_votesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>[]\n          }\n          create: {\n            args: Prisma.reddit_clone_comment_votesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          createMany: {\n            args: Prisma.reddit_clone_comment_votesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.reddit_clone_comment_votesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>[]\n          }\n          delete: {\n            args: Prisma.reddit_clone_comment_votesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          update: {\n            args: Prisma.reddit_clone_comment_votesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          deleteMany: {\n            args: Prisma.reddit_clone_comment_votesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.reddit_clone_comment_votesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.reddit_clone_comment_votesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>[]\n          }\n          upsert: {\n            args: Prisma.reddit_clone_comment_votesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$reddit_clone_comment_votesPayload>\n          }\n          aggregate: {\n            args: Prisma.Reddit_clone_comment_votesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateReddit_clone_comment_votes>\n          }\n          groupBy: {\n            args: Prisma.reddit_clone_comment_votesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_comment_votesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.reddit_clone_comment_votesCountArgs<ExtArgs>\n            result: $Utils.Optional<Reddit_clone_comment_votesCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    reddit_clone_configurations?: reddit_clone_configurationsOmit\n    reddit_clone_guest?: reddit_clone_guestOmit\n    reddit_clone_member?: reddit_clone_memberOmit\n    reddit_clone_moderator?: reddit_clone_moderatorOmit\n    reddit_clone_admin?: reddit_clone_adminOmit\n    reddit_clone_communities?: reddit_clone_communitiesOmit\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsOmit\n    reddit_clone_posts?: reddit_clone_postsOmit\n    reddit_clone_comments?: reddit_clone_commentsOmit\n    reddit_clone_post_votes?: reddit_clone_post_votesOmit\n    reddit_clone_comment_votes?: reddit_clone_comment_votesOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Reddit_clone_memberCountOutputType\n   */\n\n  export type Reddit_clone_memberCountOutputType = {\n    reddit_clone_moderator: number\n    reddit_clone_admin: number\n    reddit_clone_communities: number\n    reddit_clone_community_subscriptions: number\n    reddit_clone_posts: number\n    reddit_clone_comments: number\n    reddit_clone_post_votes: number\n    reddit_clone_comment_votes: number\n  }\n\n  export type Reddit_clone_memberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    reddit_clone_moderator?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_moderatorArgs\n    reddit_clone_admin?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_adminArgs\n    reddit_clone_communities?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_communitiesArgs\n    reddit_clone_community_subscriptions?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_community_subscriptionsArgs\n    reddit_clone_posts?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_postsArgs\n    reddit_clone_comments?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_commentsArgs\n    reddit_clone_post_votes?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_post_votesArgs\n    reddit_clone_comment_votes?: boolean | Reddit_clone_memberCountOutputTypeCountReddit_clone_comment_votesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Reddit_clone_memberCountOutputType\n     */\n    select?: Reddit_clone_memberCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_moderatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_moderatorWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_adminWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_communitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_communitiesWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_community_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_community_subscriptionsWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_postsWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_post_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_post_votesWhereInput\n  }\n\n  /**\n   * Reddit_clone_memberCountOutputType without action\n   */\n  export type Reddit_clone_memberCountOutputTypeCountReddit_clone_comment_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_comment_votesWhereInput\n  }\n\n\n  /**\n   * Count Type Reddit_clone_communitiesCountOutputType\n   */\n\n  export type Reddit_clone_communitiesCountOutputType = {\n    reddit_clone_moderator: number\n    reddit_clone_community_subscriptions: number\n    reddit_clone_posts: number\n  }\n\n  export type Reddit_clone_communitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    reddit_clone_moderator?: boolean | Reddit_clone_communitiesCountOutputTypeCountReddit_clone_moderatorArgs\n    reddit_clone_community_subscriptions?: boolean | Reddit_clone_communitiesCountOutputTypeCountReddit_clone_community_subscriptionsArgs\n    reddit_clone_posts?: boolean | Reddit_clone_communitiesCountOutputTypeCountReddit_clone_postsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Reddit_clone_communitiesCountOutputType without action\n   */\n  export type Reddit_clone_communitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Reddit_clone_communitiesCountOutputType\n     */\n    select?: Reddit_clone_communitiesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Reddit_clone_communitiesCountOutputType without action\n   */\n  export type Reddit_clone_communitiesCountOutputTypeCountReddit_clone_moderatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_moderatorWhereInput\n  }\n\n  /**\n   * Reddit_clone_communitiesCountOutputType without action\n   */\n  export type Reddit_clone_communitiesCountOutputTypeCountReddit_clone_community_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_community_subscriptionsWhereInput\n  }\n\n  /**\n   * Reddit_clone_communitiesCountOutputType without action\n   */\n  export type Reddit_clone_communitiesCountOutputTypeCountReddit_clone_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_postsWhereInput\n  }\n\n\n  /**\n   * Count Type Reddit_clone_postsCountOutputType\n   */\n\n  export type Reddit_clone_postsCountOutputType = {\n    reddit_clone_comments: number\n    reddit_clone_post_votes: number\n  }\n\n  export type Reddit_clone_postsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    reddit_clone_comments?: boolean | Reddit_clone_postsCountOutputTypeCountReddit_clone_commentsArgs\n    reddit_clone_post_votes?: boolean | Reddit_clone_postsCountOutputTypeCountReddit_clone_post_votesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Reddit_clone_postsCountOutputType without action\n   */\n  export type Reddit_clone_postsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Reddit_clone_postsCountOutputType\n     */\n    select?: Reddit_clone_postsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Reddit_clone_postsCountOutputType without action\n   */\n  export type Reddit_clone_postsCountOutputTypeCountReddit_clone_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  /**\n   * Reddit_clone_postsCountOutputType without action\n   */\n  export type Reddit_clone_postsCountOutputTypeCountReddit_clone_post_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_post_votesWhereInput\n  }\n\n\n  /**\n   * Count Type Reddit_clone_commentsCountOutputType\n   */\n\n  export type Reddit_clone_commentsCountOutputType = {\n    recursive: number\n    reddit_clone_comment_votes: number\n  }\n\n  export type Reddit_clone_commentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    recursive?: boolean | Reddit_clone_commentsCountOutputTypeCountRecursiveArgs\n    reddit_clone_comment_votes?: boolean | Reddit_clone_commentsCountOutputTypeCountReddit_clone_comment_votesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Reddit_clone_commentsCountOutputType without action\n   */\n  export type Reddit_clone_commentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Reddit_clone_commentsCountOutputType\n     */\n    select?: Reddit_clone_commentsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Reddit_clone_commentsCountOutputType without action\n   */\n  export type Reddit_clone_commentsCountOutputTypeCountRecursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  /**\n   * Reddit_clone_commentsCountOutputType without action\n   */\n  export type Reddit_clone_commentsCountOutputTypeCountReddit_clone_comment_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_comment_votesWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model reddit_clone_configurations\n   */\n\n  export type AggregateReddit_clone_configurations = {\n    _count: Reddit_clone_configurationsCountAggregateOutputType | null\n    _min: Reddit_clone_configurationsMinAggregateOutputType | null\n    _max: Reddit_clone_configurationsMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_configurationsMinAggregateOutputType = {\n    id: string | null\n    key: string | null\n    value: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_configurationsMaxAggregateOutputType = {\n    id: string | null\n    key: string | null\n    value: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_configurationsCountAggregateOutputType = {\n    id: number\n    key: number\n    value: number\n    description: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_configurationsMinAggregateInputType = {\n    id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_configurationsMaxAggregateInputType = {\n    id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_configurationsCountAggregateInputType = {\n    id?: true\n    key?: true\n    value?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_configurationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_configurations to aggregate.\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_configurations to fetch.\n     */\n    orderBy?: reddit_clone_configurationsOrderByWithRelationInput | reddit_clone_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_configurations\n    **/\n    _count?: true | Reddit_clone_configurationsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_configurationsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_configurationsMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_configurationsAggregateType<T extends Reddit_clone_configurationsAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_configurations]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_configurations[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_configurations[P]>\n  }\n\n\n\n\n  export type reddit_clone_configurationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_configurationsWhereInput\n    orderBy?: reddit_clone_configurationsOrderByWithAggregationInput | reddit_clone_configurationsOrderByWithAggregationInput[]\n    by: Reddit_clone_configurationsScalarFieldEnum[] | Reddit_clone_configurationsScalarFieldEnum\n    having?: reddit_clone_configurationsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_configurationsCountAggregateInputType | true\n    _min?: Reddit_clone_configurationsMinAggregateInputType\n    _max?: Reddit_clone_configurationsMaxAggregateInputType\n  }\n\n  export type Reddit_clone_configurationsGroupByOutputType = {\n    id: string\n    key: string\n    value: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    _count: Reddit_clone_configurationsCountAggregateOutputType | null\n    _min: Reddit_clone_configurationsMinAggregateOutputType | null\n    _max: Reddit_clone_configurationsMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_configurationsGroupByPayload<T extends reddit_clone_configurationsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_configurationsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_configurationsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_configurationsGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_configurationsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_configurationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_configurations\"]>\n\n  export type reddit_clone_configurationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_configurations\"]>\n\n  export type reddit_clone_configurationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_configurations\"]>\n\n  export type reddit_clone_configurationsSelectScalar = {\n    id?: boolean\n    key?: boolean\n    value?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type reddit_clone_configurationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"key\" | \"value\" | \"description\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"reddit_clone_configurations\"]>\n\n  export type $reddit_clone_configurationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_configurations\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Configuration key identifier.\n       */\n      key: string\n      /**\n       * Configuration value.\n       */\n      value: string\n      /**\n       * Description of the configuration setting.\n       */\n      description: string | null\n      /**\n       * Timestamp when the configuration was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the configuration was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_configurations\"]>\n    composites: {}\n  }\n\n  type reddit_clone_configurationsGetPayload<S extends boolean | null | undefined | reddit_clone_configurationsDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_configurationsPayload, S>\n\n  type reddit_clone_configurationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_configurationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_configurationsCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_configurationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_configurations'], meta: { name: 'reddit_clone_configurations' } }\n    /**\n     * Find zero or one Reddit_clone_configurations that matches the filter.\n     * @param {reddit_clone_configurationsFindUniqueArgs} args - Arguments to find a Reddit_clone_configurations\n     * @example\n     * // Get one Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_configurationsFindUniqueArgs>(args: SelectSubset<T, reddit_clone_configurationsFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_configurations that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_configurationsFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_configurations\n     * @example\n     * // Get one Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_configurationsFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_configurationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_configurations that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsFindFirstArgs} args - Arguments to find a Reddit_clone_configurations\n     * @example\n     * // Get one Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_configurationsFindFirstArgs>(args?: SelectSubset<T, reddit_clone_configurationsFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_configurations that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_configurations\n     * @example\n     * // Get one Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_configurationsFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_configurationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_configurations that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findMany()\n     * \n     * // Get first 10 Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_configurationsWithIdOnly = await prisma.reddit_clone_configurations.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_configurationsFindManyArgs>(args?: SelectSubset<T, reddit_clone_configurationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsCreateArgs} args - Arguments to create a Reddit_clone_configurations.\n     * @example\n     * // Create one Reddit_clone_configurations\n     * const Reddit_clone_configurations = await prisma.reddit_clone_configurations.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_configurations\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_configurationsCreateArgs>(args: SelectSubset<T, reddit_clone_configurationsCreateArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsCreateManyArgs} args - Arguments to create many Reddit_clone_configurations.\n     * @example\n     * // Create many Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_configurationsCreateManyArgs>(args?: SelectSubset<T, reddit_clone_configurationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_configurations and returns the data saved in the database.\n     * @param {reddit_clone_configurationsCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_configurations.\n     * @example\n     * // Create many Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_configurations and only return the `id`\n     * const reddit_clone_configurationsWithIdOnly = await prisma.reddit_clone_configurations.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_configurationsCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_configurationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsDeleteArgs} args - Arguments to delete one Reddit_clone_configurations.\n     * @example\n     * // Delete one Reddit_clone_configurations\n     * const Reddit_clone_configurations = await prisma.reddit_clone_configurations.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_configurations\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_configurationsDeleteArgs>(args: SelectSubset<T, reddit_clone_configurationsDeleteArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsUpdateArgs} args - Arguments to update one Reddit_clone_configurations.\n     * @example\n     * // Update one Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_configurationsUpdateArgs>(args: SelectSubset<T, reddit_clone_configurationsUpdateArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsDeleteManyArgs} args - Arguments to filter Reddit_clone_configurations to delete.\n     * @example\n     * // Delete a few Reddit_clone_configurations\n     * const { count } = await prisma.reddit_clone_configurations.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_configurationsDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_configurationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_configurationsUpdateManyArgs>(args: SelectSubset<T, reddit_clone_configurationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_configurations and returns the data updated in the database.\n     * @param {reddit_clone_configurationsUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_configurations.\n     * @example\n     * // Update many Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_configurations and only return the `id`\n     * const reddit_clone_configurationsWithIdOnly = await prisma.reddit_clone_configurations.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_configurationsUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_configurationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_configurations.\n     * @param {reddit_clone_configurationsUpsertArgs} args - Arguments to update or create a Reddit_clone_configurations.\n     * @example\n     * // Update or create a Reddit_clone_configurations\n     * const reddit_clone_configurations = await prisma.reddit_clone_configurations.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_configurations\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_configurations we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_configurationsUpsertArgs>(args: SelectSubset<T, reddit_clone_configurationsUpsertArgs<ExtArgs>>): Prisma__reddit_clone_configurationsClient<$Result.GetResult<Prisma.$reddit_clone_configurationsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsCountArgs} args - Arguments to filter Reddit_clone_configurations to count.\n     * @example\n     * // Count the number of Reddit_clone_configurations\n     * const count = await prisma.reddit_clone_configurations.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_configurations we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_configurationsCountArgs>(\n      args?: Subset<T, reddit_clone_configurationsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_configurationsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_configurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_configurationsAggregateArgs>(args: Subset<T, Reddit_clone_configurationsAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_configurationsAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_configurations.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_configurationsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_configurationsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_configurationsGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_configurationsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_configurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_configurationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_configurations model\n   */\n  readonly fields: reddit_clone_configurationsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_configurations.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_configurationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_configurations model\n   */\n  interface reddit_clone_configurationsFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_configurations\", 'String'>\n    readonly key: FieldRef<\"reddit_clone_configurations\", 'String'>\n    readonly value: FieldRef<\"reddit_clone_configurations\", 'String'>\n    readonly description: FieldRef<\"reddit_clone_configurations\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_configurations\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_configurations\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_configurations findUnique\n   */\n  export type reddit_clone_configurationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_configurations to fetch.\n     */\n    where: reddit_clone_configurationsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_configurations findUniqueOrThrow\n   */\n  export type reddit_clone_configurationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_configurations to fetch.\n     */\n    where: reddit_clone_configurationsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_configurations findFirst\n   */\n  export type reddit_clone_configurationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_configurations to fetch.\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_configurations to fetch.\n     */\n    orderBy?: reddit_clone_configurationsOrderByWithRelationInput | reddit_clone_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_configurations.\n     */\n    cursor?: reddit_clone_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_configurations.\n     */\n    distinct?: Reddit_clone_configurationsScalarFieldEnum | Reddit_clone_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_configurations findFirstOrThrow\n   */\n  export type reddit_clone_configurationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_configurations to fetch.\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_configurations to fetch.\n     */\n    orderBy?: reddit_clone_configurationsOrderByWithRelationInput | reddit_clone_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_configurations.\n     */\n    cursor?: reddit_clone_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_configurations.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_configurations.\n     */\n    distinct?: Reddit_clone_configurationsScalarFieldEnum | Reddit_clone_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_configurations findMany\n   */\n  export type reddit_clone_configurationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_configurations to fetch.\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_configurations to fetch.\n     */\n    orderBy?: reddit_clone_configurationsOrderByWithRelationInput | reddit_clone_configurationsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_configurations.\n     */\n    cursor?: reddit_clone_configurationsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_configurations from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_configurations.\n     */\n    skip?: number\n    distinct?: Reddit_clone_configurationsScalarFieldEnum | Reddit_clone_configurationsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_configurations create\n   */\n  export type reddit_clone_configurationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_configurations.\n     */\n    data: XOR<reddit_clone_configurationsCreateInput, reddit_clone_configurationsUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_configurations createMany\n   */\n  export type reddit_clone_configurationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_configurations.\n     */\n    data: reddit_clone_configurationsCreateManyInput | reddit_clone_configurationsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_configurations createManyAndReturn\n   */\n  export type reddit_clone_configurationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_configurations.\n     */\n    data: reddit_clone_configurationsCreateManyInput | reddit_clone_configurationsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_configurations update\n   */\n  export type reddit_clone_configurationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_configurations.\n     */\n    data: XOR<reddit_clone_configurationsUpdateInput, reddit_clone_configurationsUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_configurations to update.\n     */\n    where: reddit_clone_configurationsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_configurations updateMany\n   */\n  export type reddit_clone_configurationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_configurations.\n     */\n    data: XOR<reddit_clone_configurationsUpdateManyMutationInput, reddit_clone_configurationsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_configurations to update\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * Limit how many reddit_clone_configurations to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_configurations updateManyAndReturn\n   */\n  export type reddit_clone_configurationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_configurations.\n     */\n    data: XOR<reddit_clone_configurationsUpdateManyMutationInput, reddit_clone_configurationsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_configurations to update\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * Limit how many reddit_clone_configurations to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_configurations upsert\n   */\n  export type reddit_clone_configurationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_configurations to update in case it exists.\n     */\n    where: reddit_clone_configurationsWhereUniqueInput\n    /**\n     * In case the reddit_clone_configurations found by the `where` argument doesn't exist, create a new reddit_clone_configurations with this data.\n     */\n    create: XOR<reddit_clone_configurationsCreateInput, reddit_clone_configurationsUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_configurations was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_configurationsUpdateInput, reddit_clone_configurationsUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_configurations delete\n   */\n  export type reddit_clone_configurationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_configurations to delete.\n     */\n    where: reddit_clone_configurationsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_configurations deleteMany\n   */\n  export type reddit_clone_configurationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_configurations to delete\n     */\n    where?: reddit_clone_configurationsWhereInput\n    /**\n     * Limit how many reddit_clone_configurations to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_configurations without action\n   */\n  export type reddit_clone_configurationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_configurations\n     */\n    select?: reddit_clone_configurationsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_configurations\n     */\n    omit?: reddit_clone_configurationsOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_guest\n   */\n\n  export type AggregateReddit_clone_guest = {\n    _count: Reddit_clone_guestCountAggregateOutputType | null\n    _min: Reddit_clone_guestMinAggregateOutputType | null\n    _max: Reddit_clone_guestMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_guestMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_guestMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_guestCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_guestMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_guestMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_guestCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_guestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_guest to aggregate.\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_guests to fetch.\n     */\n    orderBy?: reddit_clone_guestOrderByWithRelationInput | reddit_clone_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_guests\n    **/\n    _count?: true | Reddit_clone_guestCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_guestMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_guestMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_guestAggregateType<T extends Reddit_clone_guestAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_guest]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_guest[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_guest[P]>\n  }\n\n\n\n\n  export type reddit_clone_guestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_guestWhereInput\n    orderBy?: reddit_clone_guestOrderByWithAggregationInput | reddit_clone_guestOrderByWithAggregationInput[]\n    by: Reddit_clone_guestScalarFieldEnum[] | Reddit_clone_guestScalarFieldEnum\n    having?: reddit_clone_guestScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_guestCountAggregateInputType | true\n    _min?: Reddit_clone_guestMinAggregateInputType\n    _max?: Reddit_clone_guestMaxAggregateInputType\n  }\n\n  export type Reddit_clone_guestGroupByOutputType = {\n    id: string\n    email: string | null\n    password_hash: string | null\n    created_at: Date\n    updated_at: Date\n    _count: Reddit_clone_guestCountAggregateOutputType | null\n    _min: Reddit_clone_guestMinAggregateOutputType | null\n    _max: Reddit_clone_guestMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_guestGroupByPayload<T extends reddit_clone_guestGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_guestGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_guestGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_guestGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_guestGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_guestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_guest\"]>\n\n  export type reddit_clone_guestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_guest\"]>\n\n  export type reddit_clone_guestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_guest\"]>\n\n  export type reddit_clone_guestSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type reddit_clone_guestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"reddit_clone_guest\"]>\n\n  export type $reddit_clone_guestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_guest\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Email address for registration (optional for guests).\n       */\n      email: string | null\n      /**\n       * Password hash for login (optional for guests).\n       */\n      password_hash: string | null\n      /**\n       * Timestamp when the guest session was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the guest session was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_guest\"]>\n    composites: {}\n  }\n\n  type reddit_clone_guestGetPayload<S extends boolean | null | undefined | reddit_clone_guestDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_guestPayload, S>\n\n  type reddit_clone_guestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_guestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_guestCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_guestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_guest'], meta: { name: 'reddit_clone_guest' } }\n    /**\n     * Find zero or one Reddit_clone_guest that matches the filter.\n     * @param {reddit_clone_guestFindUniqueArgs} args - Arguments to find a Reddit_clone_guest\n     * @example\n     * // Get one Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_guestFindUniqueArgs>(args: SelectSubset<T, reddit_clone_guestFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_guest that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_guestFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_guest\n     * @example\n     * // Get one Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_guestFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_guestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_guest that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestFindFirstArgs} args - Arguments to find a Reddit_clone_guest\n     * @example\n     * // Get one Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_guestFindFirstArgs>(args?: SelectSubset<T, reddit_clone_guestFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_guest that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_guest\n     * @example\n     * // Get one Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_guestFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_guestFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_guests that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_guests\n     * const reddit_clone_guests = await prisma.reddit_clone_guest.findMany()\n     * \n     * // Get first 10 Reddit_clone_guests\n     * const reddit_clone_guests = await prisma.reddit_clone_guest.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_guestWithIdOnly = await prisma.reddit_clone_guest.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_guestFindManyArgs>(args?: SelectSubset<T, reddit_clone_guestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_guest.\n     * @param {reddit_clone_guestCreateArgs} args - Arguments to create a Reddit_clone_guest.\n     * @example\n     * // Create one Reddit_clone_guest\n     * const Reddit_clone_guest = await prisma.reddit_clone_guest.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_guest\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_guestCreateArgs>(args: SelectSubset<T, reddit_clone_guestCreateArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_guests.\n     * @param {reddit_clone_guestCreateManyArgs} args - Arguments to create many Reddit_clone_guests.\n     * @example\n     * // Create many Reddit_clone_guests\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_guestCreateManyArgs>(args?: SelectSubset<T, reddit_clone_guestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_guests and returns the data saved in the database.\n     * @param {reddit_clone_guestCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_guests.\n     * @example\n     * // Create many Reddit_clone_guests\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_guests and only return the `id`\n     * const reddit_clone_guestWithIdOnly = await prisma.reddit_clone_guest.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_guestCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_guestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_guest.\n     * @param {reddit_clone_guestDeleteArgs} args - Arguments to delete one Reddit_clone_guest.\n     * @example\n     * // Delete one Reddit_clone_guest\n     * const Reddit_clone_guest = await prisma.reddit_clone_guest.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_guest\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_guestDeleteArgs>(args: SelectSubset<T, reddit_clone_guestDeleteArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_guest.\n     * @param {reddit_clone_guestUpdateArgs} args - Arguments to update one Reddit_clone_guest.\n     * @example\n     * // Update one Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_guestUpdateArgs>(args: SelectSubset<T, reddit_clone_guestUpdateArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_guests.\n     * @param {reddit_clone_guestDeleteManyArgs} args - Arguments to filter Reddit_clone_guests to delete.\n     * @example\n     * // Delete a few Reddit_clone_guests\n     * const { count } = await prisma.reddit_clone_guest.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_guestDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_guestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_guests\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_guestUpdateManyArgs>(args: SelectSubset<T, reddit_clone_guestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_guests and returns the data updated in the database.\n     * @param {reddit_clone_guestUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_guests.\n     * @example\n     * // Update many Reddit_clone_guests\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_guests and only return the `id`\n     * const reddit_clone_guestWithIdOnly = await prisma.reddit_clone_guest.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_guestUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_guestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_guest.\n     * @param {reddit_clone_guestUpsertArgs} args - Arguments to update or create a Reddit_clone_guest.\n     * @example\n     * // Update or create a Reddit_clone_guest\n     * const reddit_clone_guest = await prisma.reddit_clone_guest.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_guest\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_guest we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_guestUpsertArgs>(args: SelectSubset<T, reddit_clone_guestUpsertArgs<ExtArgs>>): Prisma__reddit_clone_guestClient<$Result.GetResult<Prisma.$reddit_clone_guestPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestCountArgs} args - Arguments to filter Reddit_clone_guests to count.\n     * @example\n     * // Count the number of Reddit_clone_guests\n     * const count = await prisma.reddit_clone_guest.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_guests we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_guestCountArgs>(\n      args?: Subset<T, reddit_clone_guestCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_guestCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_guestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_guestAggregateArgs>(args: Subset<T, Reddit_clone_guestAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_guestAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_guestGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_guestGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_guestGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_guestGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_guestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_guestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_guest model\n   */\n  readonly fields: reddit_clone_guestFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_guest.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_guestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_guest model\n   */\n  interface reddit_clone_guestFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_guest\", 'String'>\n    readonly email: FieldRef<\"reddit_clone_guest\", 'String'>\n    readonly password_hash: FieldRef<\"reddit_clone_guest\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_guest\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_guest\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_guest findUnique\n   */\n  export type reddit_clone_guestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_guest to fetch.\n     */\n    where: reddit_clone_guestWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_guest findUniqueOrThrow\n   */\n  export type reddit_clone_guestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_guest to fetch.\n     */\n    where: reddit_clone_guestWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_guest findFirst\n   */\n  export type reddit_clone_guestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_guest to fetch.\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_guests to fetch.\n     */\n    orderBy?: reddit_clone_guestOrderByWithRelationInput | reddit_clone_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_guests.\n     */\n    cursor?: reddit_clone_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_guests.\n     */\n    distinct?: Reddit_clone_guestScalarFieldEnum | Reddit_clone_guestScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_guest findFirstOrThrow\n   */\n  export type reddit_clone_guestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_guest to fetch.\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_guests to fetch.\n     */\n    orderBy?: reddit_clone_guestOrderByWithRelationInput | reddit_clone_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_guests.\n     */\n    cursor?: reddit_clone_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_guests.\n     */\n    distinct?: Reddit_clone_guestScalarFieldEnum | Reddit_clone_guestScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_guest findMany\n   */\n  export type reddit_clone_guestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_guests to fetch.\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_guests to fetch.\n     */\n    orderBy?: reddit_clone_guestOrderByWithRelationInput | reddit_clone_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_guests.\n     */\n    cursor?: reddit_clone_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_guests.\n     */\n    skip?: number\n    distinct?: Reddit_clone_guestScalarFieldEnum | Reddit_clone_guestScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_guest create\n   */\n  export type reddit_clone_guestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_guest.\n     */\n    data: XOR<reddit_clone_guestCreateInput, reddit_clone_guestUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_guest createMany\n   */\n  export type reddit_clone_guestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_guests.\n     */\n    data: reddit_clone_guestCreateManyInput | reddit_clone_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_guest createManyAndReturn\n   */\n  export type reddit_clone_guestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_guests.\n     */\n    data: reddit_clone_guestCreateManyInput | reddit_clone_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_guest update\n   */\n  export type reddit_clone_guestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_guest.\n     */\n    data: XOR<reddit_clone_guestUpdateInput, reddit_clone_guestUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_guest to update.\n     */\n    where: reddit_clone_guestWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_guest updateMany\n   */\n  export type reddit_clone_guestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_guests.\n     */\n    data: XOR<reddit_clone_guestUpdateManyMutationInput, reddit_clone_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_guests to update\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * Limit how many reddit_clone_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_guest updateManyAndReturn\n   */\n  export type reddit_clone_guestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_guests.\n     */\n    data: XOR<reddit_clone_guestUpdateManyMutationInput, reddit_clone_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_guests to update\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * Limit how many reddit_clone_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_guest upsert\n   */\n  export type reddit_clone_guestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_guest to update in case it exists.\n     */\n    where: reddit_clone_guestWhereUniqueInput\n    /**\n     * In case the reddit_clone_guest found by the `where` argument doesn't exist, create a new reddit_clone_guest with this data.\n     */\n    create: XOR<reddit_clone_guestCreateInput, reddit_clone_guestUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_guest was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_guestUpdateInput, reddit_clone_guestUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_guest delete\n   */\n  export type reddit_clone_guestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_guest to delete.\n     */\n    where: reddit_clone_guestWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_guest deleteMany\n   */\n  export type reddit_clone_guestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_guests to delete\n     */\n    where?: reddit_clone_guestWhereInput\n    /**\n     * Limit how many reddit_clone_guests to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_guest without action\n   */\n  export type reddit_clone_guestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_guest\n     */\n    select?: reddit_clone_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_guest\n     */\n    omit?: reddit_clone_guestOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_member\n   */\n\n  export type AggregateReddit_clone_member = {\n    _count: Reddit_clone_memberCountAggregateOutputType | null\n    _avg: Reddit_clone_memberAvgAggregateOutputType | null\n    _sum: Reddit_clone_memberSumAggregateOutputType | null\n    _min: Reddit_clone_memberMinAggregateOutputType | null\n    _max: Reddit_clone_memberMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_memberAvgAggregateOutputType = {\n    karma: number | null\n  }\n\n  export type Reddit_clone_memberSumAggregateOutputType = {\n    karma: number | null\n  }\n\n  export type Reddit_clone_memberMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    username: string | null\n    karma: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_memberMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    username: string | null\n    karma: number | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_memberCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    username: number\n    karma: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_memberAvgAggregateInputType = {\n    karma?: true\n  }\n\n  export type Reddit_clone_memberSumAggregateInputType = {\n    karma?: true\n  }\n\n  export type Reddit_clone_memberMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    username?: true\n    karma?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_memberMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    username?: true\n    karma?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_memberCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    username?: true\n    karma?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_member to aggregate.\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_members to fetch.\n     */\n    orderBy?: reddit_clone_memberOrderByWithRelationInput | reddit_clone_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_members\n    **/\n    _count?: true | Reddit_clone_memberCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Reddit_clone_memberAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Reddit_clone_memberSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_memberMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_memberMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_memberAggregateType<T extends Reddit_clone_memberAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_member]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_member[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_member[P]>\n  }\n\n\n\n\n  export type reddit_clone_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_memberWhereInput\n    orderBy?: reddit_clone_memberOrderByWithAggregationInput | reddit_clone_memberOrderByWithAggregationInput[]\n    by: Reddit_clone_memberScalarFieldEnum[] | Reddit_clone_memberScalarFieldEnum\n    having?: reddit_clone_memberScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_memberCountAggregateInputType | true\n    _avg?: Reddit_clone_memberAvgAggregateInputType\n    _sum?: Reddit_clone_memberSumAggregateInputType\n    _min?: Reddit_clone_memberMinAggregateInputType\n    _max?: Reddit_clone_memberMaxAggregateInputType\n  }\n\n  export type Reddit_clone_memberGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date\n    updated_at: Date\n    _count: Reddit_clone_memberCountAggregateOutputType | null\n    _avg: Reddit_clone_memberAvgAggregateOutputType | null\n    _sum: Reddit_clone_memberSumAggregateOutputType | null\n    _min: Reddit_clone_memberMinAggregateOutputType | null\n    _max: Reddit_clone_memberMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_memberGroupByPayload<T extends reddit_clone_memberGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_memberGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_memberGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_memberGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_memberGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    username?: boolean\n    karma?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    reddit_clone_moderator?: boolean | reddit_clone_member$reddit_clone_moderatorArgs<ExtArgs>\n    reddit_clone_admin?: boolean | reddit_clone_member$reddit_clone_adminArgs<ExtArgs>\n    reddit_clone_communities?: boolean | reddit_clone_member$reddit_clone_communitiesArgs<ExtArgs>\n    reddit_clone_community_subscriptions?: boolean | reddit_clone_member$reddit_clone_community_subscriptionsArgs<ExtArgs>\n    reddit_clone_posts?: boolean | reddit_clone_member$reddit_clone_postsArgs<ExtArgs>\n    reddit_clone_comments?: boolean | reddit_clone_member$reddit_clone_commentsArgs<ExtArgs>\n    reddit_clone_post_votes?: boolean | reddit_clone_member$reddit_clone_post_votesArgs<ExtArgs>\n    reddit_clone_comment_votes?: boolean | reddit_clone_member$reddit_clone_comment_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_memberCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_member\"]>\n\n  export type reddit_clone_memberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    username?: boolean\n    karma?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_member\"]>\n\n  export type reddit_clone_memberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    username?: boolean\n    karma?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }, ExtArgs[\"result\"][\"reddit_clone_member\"]>\n\n  export type reddit_clone_memberSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    username?: boolean\n    karma?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type reddit_clone_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"username\" | \"karma\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"reddit_clone_member\"]>\n  export type reddit_clone_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    reddit_clone_moderator?: boolean | reddit_clone_member$reddit_clone_moderatorArgs<ExtArgs>\n    reddit_clone_admin?: boolean | reddit_clone_member$reddit_clone_adminArgs<ExtArgs>\n    reddit_clone_communities?: boolean | reddit_clone_member$reddit_clone_communitiesArgs<ExtArgs>\n    reddit_clone_community_subscriptions?: boolean | reddit_clone_member$reddit_clone_community_subscriptionsArgs<ExtArgs>\n    reddit_clone_posts?: boolean | reddit_clone_member$reddit_clone_postsArgs<ExtArgs>\n    reddit_clone_comments?: boolean | reddit_clone_member$reddit_clone_commentsArgs<ExtArgs>\n    reddit_clone_post_votes?: boolean | reddit_clone_member$reddit_clone_post_votesArgs<ExtArgs>\n    reddit_clone_comment_votes?: boolean | reddit_clone_member$reddit_clone_comment_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_memberCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_memberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type reddit_clone_memberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $reddit_clone_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_member\"\n    objects: {\n      reddit_clone_moderator: Prisma.$reddit_clone_moderatorPayload<ExtArgs>[]\n      reddit_clone_admin: Prisma.$reddit_clone_adminPayload<ExtArgs>[]\n      reddit_clone_communities: Prisma.$reddit_clone_communitiesPayload<ExtArgs>[]\n      reddit_clone_community_subscriptions: Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>[]\n      reddit_clone_posts: Prisma.$reddit_clone_postsPayload<ExtArgs>[]\n      reddit_clone_comments: Prisma.$reddit_clone_commentsPayload<ExtArgs>[]\n      reddit_clone_post_votes: Prisma.$reddit_clone_post_votesPayload<ExtArgs>[]\n      reddit_clone_comment_votes: Prisma.$reddit_clone_comment_votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Unique email address for authentication.\n       */\n      email: string\n      /**\n       * Secure password hash for login.\n       */\n      password_hash: string\n      /**\n       * Unique username for display.\n       */\n      username: string\n      /**\n       * User's karma score based on votes.\n       */\n      karma: number\n      /**\n       * Timestamp when the account was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the account was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_member\"]>\n    composites: {}\n  }\n\n  type reddit_clone_memberGetPayload<S extends boolean | null | undefined | reddit_clone_memberDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_memberPayload, S>\n\n  type reddit_clone_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_memberCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_member'], meta: { name: 'reddit_clone_member' } }\n    /**\n     * Find zero or one Reddit_clone_member that matches the filter.\n     * @param {reddit_clone_memberFindUniqueArgs} args - Arguments to find a Reddit_clone_member\n     * @example\n     * // Get one Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_memberFindUniqueArgs>(args: SelectSubset<T, reddit_clone_memberFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_member that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_memberFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_member\n     * @example\n     * // Get one Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_member that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberFindFirstArgs} args - Arguments to find a Reddit_clone_member\n     * @example\n     * // Get one Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_memberFindFirstArgs>(args?: SelectSubset<T, reddit_clone_memberFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_member that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_member\n     * @example\n     * // Get one Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_members that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_members\n     * const reddit_clone_members = await prisma.reddit_clone_member.findMany()\n     * \n     * // Get first 10 Reddit_clone_members\n     * const reddit_clone_members = await prisma.reddit_clone_member.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_memberWithIdOnly = await prisma.reddit_clone_member.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_memberFindManyArgs>(args?: SelectSubset<T, reddit_clone_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_member.\n     * @param {reddit_clone_memberCreateArgs} args - Arguments to create a Reddit_clone_member.\n     * @example\n     * // Create one Reddit_clone_member\n     * const Reddit_clone_member = await prisma.reddit_clone_member.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_member\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_memberCreateArgs>(args: SelectSubset<T, reddit_clone_memberCreateArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_members.\n     * @param {reddit_clone_memberCreateManyArgs} args - Arguments to create many Reddit_clone_members.\n     * @example\n     * // Create many Reddit_clone_members\n     * const reddit_clone_member = await prisma.reddit_clone_member.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_memberCreateManyArgs>(args?: SelectSubset<T, reddit_clone_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_members and returns the data saved in the database.\n     * @param {reddit_clone_memberCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_members.\n     * @example\n     * // Create many Reddit_clone_members\n     * const reddit_clone_member = await prisma.reddit_clone_member.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_members and only return the `id`\n     * const reddit_clone_memberWithIdOnly = await prisma.reddit_clone_member.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_memberCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_memberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_member.\n     * @param {reddit_clone_memberDeleteArgs} args - Arguments to delete one Reddit_clone_member.\n     * @example\n     * // Delete one Reddit_clone_member\n     * const Reddit_clone_member = await prisma.reddit_clone_member.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_member\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_memberDeleteArgs>(args: SelectSubset<T, reddit_clone_memberDeleteArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_member.\n     * @param {reddit_clone_memberUpdateArgs} args - Arguments to update one Reddit_clone_member.\n     * @example\n     * // Update one Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_memberUpdateArgs>(args: SelectSubset<T, reddit_clone_memberUpdateArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_members.\n     * @param {reddit_clone_memberDeleteManyArgs} args - Arguments to filter Reddit_clone_members to delete.\n     * @example\n     * // Delete a few Reddit_clone_members\n     * const { count } = await prisma.reddit_clone_member.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_memberDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_members.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_members\n     * const reddit_clone_member = await prisma.reddit_clone_member.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_memberUpdateManyArgs>(args: SelectSubset<T, reddit_clone_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_members and returns the data updated in the database.\n     * @param {reddit_clone_memberUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_members.\n     * @example\n     * // Update many Reddit_clone_members\n     * const reddit_clone_member = await prisma.reddit_clone_member.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_members and only return the `id`\n     * const reddit_clone_memberWithIdOnly = await prisma.reddit_clone_member.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_memberUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_memberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_member.\n     * @param {reddit_clone_memberUpsertArgs} args - Arguments to update or create a Reddit_clone_member.\n     * @example\n     * // Update or create a Reddit_clone_member\n     * const reddit_clone_member = await prisma.reddit_clone_member.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_member\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_member we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_memberUpsertArgs>(args: SelectSubset<T, reddit_clone_memberUpsertArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_members.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberCountArgs} args - Arguments to filter Reddit_clone_members to count.\n     * @example\n     * // Count the number of Reddit_clone_members\n     * const count = await prisma.reddit_clone_member.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_members we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_memberCountArgs>(\n      args?: Subset<T, reddit_clone_memberCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_memberCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_member.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_memberAggregateArgs>(args: Subset<T, Reddit_clone_memberAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_memberAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_member.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_memberGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_memberGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_memberGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_memberGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_member model\n   */\n  readonly fields: reddit_clone_memberFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_member.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    reddit_clone_moderator<T extends reddit_clone_member$reddit_clone_moderatorArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_moderatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_admin<T extends reddit_clone_member$reddit_clone_adminArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_communities<T extends reddit_clone_member$reddit_clone_communitiesArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_communitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_community_subscriptions<T extends reddit_clone_member$reddit_clone_community_subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_community_subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_posts<T extends reddit_clone_member$reddit_clone_postsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_comments<T extends reddit_clone_member$reddit_clone_commentsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_post_votes<T extends reddit_clone_member$reddit_clone_post_votesArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_post_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_comment_votes<T extends reddit_clone_member$reddit_clone_comment_votesArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_member$reddit_clone_comment_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_member model\n   */\n  interface reddit_clone_memberFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_member\", 'String'>\n    readonly email: FieldRef<\"reddit_clone_member\", 'String'>\n    readonly password_hash: FieldRef<\"reddit_clone_member\", 'String'>\n    readonly username: FieldRef<\"reddit_clone_member\", 'String'>\n    readonly karma: FieldRef<\"reddit_clone_member\", 'Int'>\n    readonly created_at: FieldRef<\"reddit_clone_member\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_member\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_member findUnique\n   */\n  export type reddit_clone_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_member to fetch.\n     */\n    where: reddit_clone_memberWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_member findUniqueOrThrow\n   */\n  export type reddit_clone_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_member to fetch.\n     */\n    where: reddit_clone_memberWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_member findFirst\n   */\n  export type reddit_clone_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_member to fetch.\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_members to fetch.\n     */\n    orderBy?: reddit_clone_memberOrderByWithRelationInput | reddit_clone_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_members.\n     */\n    cursor?: reddit_clone_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_members.\n     */\n    distinct?: Reddit_clone_memberScalarFieldEnum | Reddit_clone_memberScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member findFirstOrThrow\n   */\n  export type reddit_clone_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_member to fetch.\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_members to fetch.\n     */\n    orderBy?: reddit_clone_memberOrderByWithRelationInput | reddit_clone_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_members.\n     */\n    cursor?: reddit_clone_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_members.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_members.\n     */\n    distinct?: Reddit_clone_memberScalarFieldEnum | Reddit_clone_memberScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member findMany\n   */\n  export type reddit_clone_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_members to fetch.\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_members to fetch.\n     */\n    orderBy?: reddit_clone_memberOrderByWithRelationInput | reddit_clone_memberOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_members.\n     */\n    cursor?: reddit_clone_memberWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_members from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_members.\n     */\n    skip?: number\n    distinct?: Reddit_clone_memberScalarFieldEnum | Reddit_clone_memberScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member create\n   */\n  export type reddit_clone_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_member.\n     */\n    data: XOR<reddit_clone_memberCreateInput, reddit_clone_memberUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_member createMany\n   */\n  export type reddit_clone_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_members.\n     */\n    data: reddit_clone_memberCreateManyInput | reddit_clone_memberCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_member createManyAndReturn\n   */\n  export type reddit_clone_memberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_members.\n     */\n    data: reddit_clone_memberCreateManyInput | reddit_clone_memberCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_member update\n   */\n  export type reddit_clone_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_member.\n     */\n    data: XOR<reddit_clone_memberUpdateInput, reddit_clone_memberUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_member to update.\n     */\n    where: reddit_clone_memberWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_member updateMany\n   */\n  export type reddit_clone_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_members.\n     */\n    data: XOR<reddit_clone_memberUpdateManyMutationInput, reddit_clone_memberUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_members to update\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * Limit how many reddit_clone_members to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_member updateManyAndReturn\n   */\n  export type reddit_clone_memberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_members.\n     */\n    data: XOR<reddit_clone_memberUpdateManyMutationInput, reddit_clone_memberUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_members to update\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * Limit how many reddit_clone_members to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_member upsert\n   */\n  export type reddit_clone_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_member to update in case it exists.\n     */\n    where: reddit_clone_memberWhereUniqueInput\n    /**\n     * In case the reddit_clone_member found by the `where` argument doesn't exist, create a new reddit_clone_member with this data.\n     */\n    create: XOR<reddit_clone_memberCreateInput, reddit_clone_memberUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_member was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_memberUpdateInput, reddit_clone_memberUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_member delete\n   */\n  export type reddit_clone_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_member to delete.\n     */\n    where: reddit_clone_memberWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_member deleteMany\n   */\n  export type reddit_clone_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_members to delete\n     */\n    where?: reddit_clone_memberWhereInput\n    /**\n     * Limit how many reddit_clone_members to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_moderator\n   */\n  export type reddit_clone_member$reddit_clone_moderatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    where?: reddit_clone_moderatorWhereInput\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_moderatorScalarFieldEnum | Reddit_clone_moderatorScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_admin\n   */\n  export type reddit_clone_member$reddit_clone_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    where?: reddit_clone_adminWhereInput\n    orderBy?: reddit_clone_adminOrderByWithRelationInput | reddit_clone_adminOrderByWithRelationInput[]\n    cursor?: reddit_clone_adminWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_adminScalarFieldEnum | Reddit_clone_adminScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_communities\n   */\n  export type reddit_clone_member$reddit_clone_communitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    where?: reddit_clone_communitiesWhereInput\n    orderBy?: reddit_clone_communitiesOrderByWithRelationInput | reddit_clone_communitiesOrderByWithRelationInput[]\n    cursor?: reddit_clone_communitiesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_communitiesScalarFieldEnum | Reddit_clone_communitiesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_community_subscriptions\n   */\n  export type reddit_clone_member$reddit_clone_community_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    where?: reddit_clone_community_subscriptionsWhereInput\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_community_subscriptionsScalarFieldEnum | Reddit_clone_community_subscriptionsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_posts\n   */\n  export type reddit_clone_member$reddit_clone_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    where?: reddit_clone_postsWhereInput\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    cursor?: reddit_clone_postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_postsScalarFieldEnum | Reddit_clone_postsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_comments\n   */\n  export type reddit_clone_member$reddit_clone_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    where?: reddit_clone_commentsWhereInput\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_post_votes\n   */\n  export type reddit_clone_member$reddit_clone_post_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    where?: reddit_clone_post_votesWhereInput\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_post_votesScalarFieldEnum | Reddit_clone_post_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member.reddit_clone_comment_votes\n   */\n  export type reddit_clone_member$reddit_clone_comment_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    where?: reddit_clone_comment_votesWhereInput\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_comment_votesScalarFieldEnum | Reddit_clone_comment_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_member without action\n   */\n  export type reddit_clone_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_member\n     */\n    select?: reddit_clone_memberSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_member\n     */\n    omit?: reddit_clone_memberOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_memberInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_moderator\n   */\n\n  export type AggregateReddit_clone_moderator = {\n    _count: Reddit_clone_moderatorCountAggregateOutputType | null\n    _min: Reddit_clone_moderatorMinAggregateOutputType | null\n    _max: Reddit_clone_moderatorMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_moderatorMinAggregateOutputType = {\n    id: string | null\n    member_id: string | null\n    community_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_moderatorMaxAggregateOutputType = {\n    id: string | null\n    member_id: string | null\n    community_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_moderatorCountAggregateOutputType = {\n    id: number\n    member_id: number\n    community_id: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_moderatorMinAggregateInputType = {\n    id?: true\n    member_id?: true\n    community_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_moderatorMaxAggregateInputType = {\n    id?: true\n    member_id?: true\n    community_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_moderatorCountAggregateInputType = {\n    id?: true\n    member_id?: true\n    community_id?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_moderatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_moderator to aggregate.\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_moderators to fetch.\n     */\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_moderators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_moderators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_moderators\n    **/\n    _count?: true | Reddit_clone_moderatorCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_moderatorMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_moderatorMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_moderatorAggregateType<T extends Reddit_clone_moderatorAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_moderator]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_moderator[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_moderator[P]>\n  }\n\n\n\n\n  export type reddit_clone_moderatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_moderatorWhereInput\n    orderBy?: reddit_clone_moderatorOrderByWithAggregationInput | reddit_clone_moderatorOrderByWithAggregationInput[]\n    by: Reddit_clone_moderatorScalarFieldEnum[] | Reddit_clone_moderatorScalarFieldEnum\n    having?: reddit_clone_moderatorScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_moderatorCountAggregateInputType | true\n    _min?: Reddit_clone_moderatorMinAggregateInputType\n    _max?: Reddit_clone_moderatorMaxAggregateInputType\n  }\n\n  export type Reddit_clone_moderatorGroupByOutputType = {\n    id: string\n    member_id: string\n    community_id: string\n    created_at: Date\n    updated_at: Date\n    _count: Reddit_clone_moderatorCountAggregateOutputType | null\n    _min: Reddit_clone_moderatorMinAggregateOutputType | null\n    _max: Reddit_clone_moderatorMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_moderatorGroupByPayload<T extends reddit_clone_moderatorGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_moderatorGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_moderatorGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_moderatorGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_moderatorGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_moderatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    community_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_moderator\"]>\n\n  export type reddit_clone_moderatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    community_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_moderator\"]>\n\n  export type reddit_clone_moderatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    community_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_moderator\"]>\n\n  export type reddit_clone_moderatorSelectScalar = {\n    id?: boolean\n    member_id?: boolean\n    community_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type reddit_clone_moderatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"member_id\" | \"community_id\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"reddit_clone_moderator\"]>\n  export type reddit_clone_moderatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_moderatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_moderatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_moderatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_moderator\"\n    objects: {\n      member: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      community: Prisma.$reddit_clone_communitiesPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the member account. {@link reddit_clone_member.id}.\n       */\n      member_id: string\n      /**\n       * Community where the user is a moderator. {@link\n       * reddit_clone_communities.id}.\n       */\n      community_id: string\n      /**\n       * Timestamp when moderator privileges were granted.\n       */\n      created_at: Date\n      /**\n       * Timestamp when moderator privileges were last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_moderator\"]>\n    composites: {}\n  }\n\n  type reddit_clone_moderatorGetPayload<S extends boolean | null | undefined | reddit_clone_moderatorDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_moderatorPayload, S>\n\n  type reddit_clone_moderatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_moderatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_moderatorCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_moderatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_moderator'], meta: { name: 'reddit_clone_moderator' } }\n    /**\n     * Find zero or one Reddit_clone_moderator that matches the filter.\n     * @param {reddit_clone_moderatorFindUniqueArgs} args - Arguments to find a Reddit_clone_moderator\n     * @example\n     * // Get one Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_moderatorFindUniqueArgs>(args: SelectSubset<T, reddit_clone_moderatorFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_moderator that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_moderatorFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_moderator\n     * @example\n     * // Get one Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_moderatorFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_moderatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_moderator that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorFindFirstArgs} args - Arguments to find a Reddit_clone_moderator\n     * @example\n     * // Get one Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_moderatorFindFirstArgs>(args?: SelectSubset<T, reddit_clone_moderatorFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_moderator that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_moderator\n     * @example\n     * // Get one Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_moderatorFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_moderatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_moderators that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_moderators\n     * const reddit_clone_moderators = await prisma.reddit_clone_moderator.findMany()\n     * \n     * // Get first 10 Reddit_clone_moderators\n     * const reddit_clone_moderators = await prisma.reddit_clone_moderator.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_moderatorWithIdOnly = await prisma.reddit_clone_moderator.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_moderatorFindManyArgs>(args?: SelectSubset<T, reddit_clone_moderatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_moderator.\n     * @param {reddit_clone_moderatorCreateArgs} args - Arguments to create a Reddit_clone_moderator.\n     * @example\n     * // Create one Reddit_clone_moderator\n     * const Reddit_clone_moderator = await prisma.reddit_clone_moderator.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_moderator\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_moderatorCreateArgs>(args: SelectSubset<T, reddit_clone_moderatorCreateArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_moderators.\n     * @param {reddit_clone_moderatorCreateManyArgs} args - Arguments to create many Reddit_clone_moderators.\n     * @example\n     * // Create many Reddit_clone_moderators\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_moderatorCreateManyArgs>(args?: SelectSubset<T, reddit_clone_moderatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_moderators and returns the data saved in the database.\n     * @param {reddit_clone_moderatorCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_moderators.\n     * @example\n     * // Create many Reddit_clone_moderators\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_moderators and only return the `id`\n     * const reddit_clone_moderatorWithIdOnly = await prisma.reddit_clone_moderator.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_moderatorCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_moderatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_moderator.\n     * @param {reddit_clone_moderatorDeleteArgs} args - Arguments to delete one Reddit_clone_moderator.\n     * @example\n     * // Delete one Reddit_clone_moderator\n     * const Reddit_clone_moderator = await prisma.reddit_clone_moderator.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_moderator\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_moderatorDeleteArgs>(args: SelectSubset<T, reddit_clone_moderatorDeleteArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_moderator.\n     * @param {reddit_clone_moderatorUpdateArgs} args - Arguments to update one Reddit_clone_moderator.\n     * @example\n     * // Update one Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_moderatorUpdateArgs>(args: SelectSubset<T, reddit_clone_moderatorUpdateArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_moderators.\n     * @param {reddit_clone_moderatorDeleteManyArgs} args - Arguments to filter Reddit_clone_moderators to delete.\n     * @example\n     * // Delete a few Reddit_clone_moderators\n     * const { count } = await prisma.reddit_clone_moderator.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_moderatorDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_moderatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_moderators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_moderators\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_moderatorUpdateManyArgs>(args: SelectSubset<T, reddit_clone_moderatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_moderators and returns the data updated in the database.\n     * @param {reddit_clone_moderatorUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_moderators.\n     * @example\n     * // Update many Reddit_clone_moderators\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_moderators and only return the `id`\n     * const reddit_clone_moderatorWithIdOnly = await prisma.reddit_clone_moderator.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_moderatorUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_moderatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_moderator.\n     * @param {reddit_clone_moderatorUpsertArgs} args - Arguments to update or create a Reddit_clone_moderator.\n     * @example\n     * // Update or create a Reddit_clone_moderator\n     * const reddit_clone_moderator = await prisma.reddit_clone_moderator.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_moderator\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_moderator we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_moderatorUpsertArgs>(args: SelectSubset<T, reddit_clone_moderatorUpsertArgs<ExtArgs>>): Prisma__reddit_clone_moderatorClient<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_moderators.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorCountArgs} args - Arguments to filter Reddit_clone_moderators to count.\n     * @example\n     * // Count the number of Reddit_clone_moderators\n     * const count = await prisma.reddit_clone_moderator.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_moderators we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_moderatorCountArgs>(\n      args?: Subset<T, reddit_clone_moderatorCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_moderatorCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_moderator.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_moderatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_moderatorAggregateArgs>(args: Subset<T, Reddit_clone_moderatorAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_moderatorAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_moderator.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_moderatorGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_moderatorGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_moderatorGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_moderatorGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_moderatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_moderatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_moderator model\n   */\n  readonly fields: reddit_clone_moderatorFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_moderator.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_moderatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    community<T extends reddit_clone_communitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communitiesDefaultArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_moderator model\n   */\n  interface reddit_clone_moderatorFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_moderator\", 'String'>\n    readonly member_id: FieldRef<\"reddit_clone_moderator\", 'String'>\n    readonly community_id: FieldRef<\"reddit_clone_moderator\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_moderator\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_moderator\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_moderator findUnique\n   */\n  export type reddit_clone_moderatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_moderator to fetch.\n     */\n    where: reddit_clone_moderatorWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_moderator findUniqueOrThrow\n   */\n  export type reddit_clone_moderatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_moderator to fetch.\n     */\n    where: reddit_clone_moderatorWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_moderator findFirst\n   */\n  export type reddit_clone_moderatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_moderator to fetch.\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_moderators to fetch.\n     */\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_moderators.\n     */\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_moderators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_moderators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_moderators.\n     */\n    distinct?: Reddit_clone_moderatorScalarFieldEnum | Reddit_clone_moderatorScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_moderator findFirstOrThrow\n   */\n  export type reddit_clone_moderatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_moderator to fetch.\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_moderators to fetch.\n     */\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_moderators.\n     */\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_moderators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_moderators.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_moderators.\n     */\n    distinct?: Reddit_clone_moderatorScalarFieldEnum | Reddit_clone_moderatorScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_moderator findMany\n   */\n  export type reddit_clone_moderatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_moderators to fetch.\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_moderators to fetch.\n     */\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_moderators.\n     */\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_moderators from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_moderators.\n     */\n    skip?: number\n    distinct?: Reddit_clone_moderatorScalarFieldEnum | Reddit_clone_moderatorScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_moderator create\n   */\n  export type reddit_clone_moderatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_moderator.\n     */\n    data: XOR<reddit_clone_moderatorCreateInput, reddit_clone_moderatorUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_moderator createMany\n   */\n  export type reddit_clone_moderatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_moderators.\n     */\n    data: reddit_clone_moderatorCreateManyInput | reddit_clone_moderatorCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_moderator createManyAndReturn\n   */\n  export type reddit_clone_moderatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_moderators.\n     */\n    data: reddit_clone_moderatorCreateManyInput | reddit_clone_moderatorCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_moderator update\n   */\n  export type reddit_clone_moderatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_moderator.\n     */\n    data: XOR<reddit_clone_moderatorUpdateInput, reddit_clone_moderatorUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_moderator to update.\n     */\n    where: reddit_clone_moderatorWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_moderator updateMany\n   */\n  export type reddit_clone_moderatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_moderators.\n     */\n    data: XOR<reddit_clone_moderatorUpdateManyMutationInput, reddit_clone_moderatorUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_moderators to update\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * Limit how many reddit_clone_moderators to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_moderator updateManyAndReturn\n   */\n  export type reddit_clone_moderatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_moderators.\n     */\n    data: XOR<reddit_clone_moderatorUpdateManyMutationInput, reddit_clone_moderatorUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_moderators to update\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * Limit how many reddit_clone_moderators to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_moderator upsert\n   */\n  export type reddit_clone_moderatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_moderator to update in case it exists.\n     */\n    where: reddit_clone_moderatorWhereUniqueInput\n    /**\n     * In case the reddit_clone_moderator found by the `where` argument doesn't exist, create a new reddit_clone_moderator with this data.\n     */\n    create: XOR<reddit_clone_moderatorCreateInput, reddit_clone_moderatorUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_moderator was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_moderatorUpdateInput, reddit_clone_moderatorUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_moderator delete\n   */\n  export type reddit_clone_moderatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_moderator to delete.\n     */\n    where: reddit_clone_moderatorWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_moderator deleteMany\n   */\n  export type reddit_clone_moderatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_moderators to delete\n     */\n    where?: reddit_clone_moderatorWhereInput\n    /**\n     * Limit how many reddit_clone_moderators to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_moderator without action\n   */\n  export type reddit_clone_moderatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_admin\n   */\n\n  export type AggregateReddit_clone_admin = {\n    _count: Reddit_clone_adminCountAggregateOutputType | null\n    _min: Reddit_clone_adminMinAggregateOutputType | null\n    _max: Reddit_clone_adminMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_adminMinAggregateOutputType = {\n    id: string | null\n    member_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_adminMaxAggregateOutputType = {\n    id: string | null\n    member_id: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Reddit_clone_adminCountAggregateOutputType = {\n    id: number\n    member_id: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_adminMinAggregateInputType = {\n    id?: true\n    member_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_adminMaxAggregateInputType = {\n    id?: true\n    member_id?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Reddit_clone_adminCountAggregateInputType = {\n    id?: true\n    member_id?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_admin to aggregate.\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_admins to fetch.\n     */\n    orderBy?: reddit_clone_adminOrderByWithRelationInput | reddit_clone_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_admins\n    **/\n    _count?: true | Reddit_clone_adminCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_adminMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_adminMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_adminAggregateType<T extends Reddit_clone_adminAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_admin]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_admin[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_admin[P]>\n  }\n\n\n\n\n  export type reddit_clone_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_adminWhereInput\n    orderBy?: reddit_clone_adminOrderByWithAggregationInput | reddit_clone_adminOrderByWithAggregationInput[]\n    by: Reddit_clone_adminScalarFieldEnum[] | Reddit_clone_adminScalarFieldEnum\n    having?: reddit_clone_adminScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_adminCountAggregateInputType | true\n    _min?: Reddit_clone_adminMinAggregateInputType\n    _max?: Reddit_clone_adminMaxAggregateInputType\n  }\n\n  export type Reddit_clone_adminGroupByOutputType = {\n    id: string\n    member_id: string\n    created_at: Date\n    updated_at: Date\n    _count: Reddit_clone_adminCountAggregateOutputType | null\n    _min: Reddit_clone_adminMinAggregateOutputType | null\n    _max: Reddit_clone_adminMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_adminGroupByPayload<T extends reddit_clone_adminGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_adminGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_adminGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_adminGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_adminGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_admin\"]>\n\n  export type reddit_clone_adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_admin\"]>\n\n  export type reddit_clone_adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    member_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_admin\"]>\n\n  export type reddit_clone_adminSelectScalar = {\n    id?: boolean\n    member_id?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type reddit_clone_adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"member_id\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"reddit_clone_admin\"]>\n  export type reddit_clone_adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    member?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_admin\"\n    objects: {\n      member: Prisma.$reddit_clone_memberPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Reference to the member account. {@link reddit_clone_member.id}.\n       */\n      member_id: string\n      /**\n       * Timestamp when admin privileges were granted.\n       */\n      created_at: Date\n      /**\n       * Timestamp when admin privileges were last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_admin\"]>\n    composites: {}\n  }\n\n  type reddit_clone_adminGetPayload<S extends boolean | null | undefined | reddit_clone_adminDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_adminPayload, S>\n\n  type reddit_clone_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_adminCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_admin'], meta: { name: 'reddit_clone_admin' } }\n    /**\n     * Find zero or one Reddit_clone_admin that matches the filter.\n     * @param {reddit_clone_adminFindUniqueArgs} args - Arguments to find a Reddit_clone_admin\n     * @example\n     * // Get one Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_adminFindUniqueArgs>(args: SelectSubset<T, reddit_clone_adminFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_admin that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_adminFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_admin\n     * @example\n     * // Get one Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_admin that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminFindFirstArgs} args - Arguments to find a Reddit_clone_admin\n     * @example\n     * // Get one Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_adminFindFirstArgs>(args?: SelectSubset<T, reddit_clone_adminFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_admin that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_admin\n     * @example\n     * // Get one Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_admins\n     * const reddit_clone_admins = await prisma.reddit_clone_admin.findMany()\n     * \n     * // Get first 10 Reddit_clone_admins\n     * const reddit_clone_admins = await prisma.reddit_clone_admin.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_adminWithIdOnly = await prisma.reddit_clone_admin.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_adminFindManyArgs>(args?: SelectSubset<T, reddit_clone_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_admin.\n     * @param {reddit_clone_adminCreateArgs} args - Arguments to create a Reddit_clone_admin.\n     * @example\n     * // Create one Reddit_clone_admin\n     * const Reddit_clone_admin = await prisma.reddit_clone_admin.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_admin\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_adminCreateArgs>(args: SelectSubset<T, reddit_clone_adminCreateArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_admins.\n     * @param {reddit_clone_adminCreateManyArgs} args - Arguments to create many Reddit_clone_admins.\n     * @example\n     * // Create many Reddit_clone_admins\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_adminCreateManyArgs>(args?: SelectSubset<T, reddit_clone_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_admins and returns the data saved in the database.\n     * @param {reddit_clone_adminCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_admins.\n     * @example\n     * // Create many Reddit_clone_admins\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_admins and only return the `id`\n     * const reddit_clone_adminWithIdOnly = await prisma.reddit_clone_admin.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_adminCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_admin.\n     * @param {reddit_clone_adminDeleteArgs} args - Arguments to delete one Reddit_clone_admin.\n     * @example\n     * // Delete one Reddit_clone_admin\n     * const Reddit_clone_admin = await prisma.reddit_clone_admin.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_admin\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_adminDeleteArgs>(args: SelectSubset<T, reddit_clone_adminDeleteArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_admin.\n     * @param {reddit_clone_adminUpdateArgs} args - Arguments to update one Reddit_clone_admin.\n     * @example\n     * // Update one Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_adminUpdateArgs>(args: SelectSubset<T, reddit_clone_adminUpdateArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_admins.\n     * @param {reddit_clone_adminDeleteManyArgs} args - Arguments to filter Reddit_clone_admins to delete.\n     * @example\n     * // Delete a few Reddit_clone_admins\n     * const { count } = await prisma.reddit_clone_admin.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_adminDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_admins\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_adminUpdateManyArgs>(args: SelectSubset<T, reddit_clone_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_admins and returns the data updated in the database.\n     * @param {reddit_clone_adminUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_admins.\n     * @example\n     * // Update many Reddit_clone_admins\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_admins and only return the `id`\n     * const reddit_clone_adminWithIdOnly = await prisma.reddit_clone_admin.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_adminUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_admin.\n     * @param {reddit_clone_adminUpsertArgs} args - Arguments to update or create a Reddit_clone_admin.\n     * @example\n     * // Update or create a Reddit_clone_admin\n     * const reddit_clone_admin = await prisma.reddit_clone_admin.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_admin\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_admin we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_adminUpsertArgs>(args: SelectSubset<T, reddit_clone_adminUpsertArgs<ExtArgs>>): Prisma__reddit_clone_adminClient<$Result.GetResult<Prisma.$reddit_clone_adminPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminCountArgs} args - Arguments to filter Reddit_clone_admins to count.\n     * @example\n     * // Count the number of Reddit_clone_admins\n     * const count = await prisma.reddit_clone_admin.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_admins we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_adminCountArgs>(\n      args?: Subset<T, reddit_clone_adminCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_adminCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_adminAggregateArgs>(args: Subset<T, Reddit_clone_adminAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_adminAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_adminGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_adminGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_adminGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_adminGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_admin model\n   */\n  readonly fields: reddit_clone_adminFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_admin.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    member<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_admin model\n   */\n  interface reddit_clone_adminFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_admin\", 'String'>\n    readonly member_id: FieldRef<\"reddit_clone_admin\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_admin\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_admin\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_admin findUnique\n   */\n  export type reddit_clone_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_admin to fetch.\n     */\n    where: reddit_clone_adminWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_admin findUniqueOrThrow\n   */\n  export type reddit_clone_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_admin to fetch.\n     */\n    where: reddit_clone_adminWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_admin findFirst\n   */\n  export type reddit_clone_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_admin to fetch.\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_admins to fetch.\n     */\n    orderBy?: reddit_clone_adminOrderByWithRelationInput | reddit_clone_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_admins.\n     */\n    cursor?: reddit_clone_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_admins.\n     */\n    distinct?: Reddit_clone_adminScalarFieldEnum | Reddit_clone_adminScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_admin findFirstOrThrow\n   */\n  export type reddit_clone_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_admin to fetch.\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_admins to fetch.\n     */\n    orderBy?: reddit_clone_adminOrderByWithRelationInput | reddit_clone_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_admins.\n     */\n    cursor?: reddit_clone_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_admins.\n     */\n    distinct?: Reddit_clone_adminScalarFieldEnum | Reddit_clone_adminScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_admin findMany\n   */\n  export type reddit_clone_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_admins to fetch.\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_admins to fetch.\n     */\n    orderBy?: reddit_clone_adminOrderByWithRelationInput | reddit_clone_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_admins.\n     */\n    cursor?: reddit_clone_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_admins.\n     */\n    skip?: number\n    distinct?: Reddit_clone_adminScalarFieldEnum | Reddit_clone_adminScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_admin create\n   */\n  export type reddit_clone_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_admin.\n     */\n    data: XOR<reddit_clone_adminCreateInput, reddit_clone_adminUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_admin createMany\n   */\n  export type reddit_clone_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_admins.\n     */\n    data: reddit_clone_adminCreateManyInput | reddit_clone_adminCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_admin createManyAndReturn\n   */\n  export type reddit_clone_adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_admins.\n     */\n    data: reddit_clone_adminCreateManyInput | reddit_clone_adminCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_admin update\n   */\n  export type reddit_clone_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_admin.\n     */\n    data: XOR<reddit_clone_adminUpdateInput, reddit_clone_adminUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_admin to update.\n     */\n    where: reddit_clone_adminWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_admin updateMany\n   */\n  export type reddit_clone_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_admins.\n     */\n    data: XOR<reddit_clone_adminUpdateManyMutationInput, reddit_clone_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_admins to update\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * Limit how many reddit_clone_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_admin updateManyAndReturn\n   */\n  export type reddit_clone_adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_admins.\n     */\n    data: XOR<reddit_clone_adminUpdateManyMutationInput, reddit_clone_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_admins to update\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * Limit how many reddit_clone_admins to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_admin upsert\n   */\n  export type reddit_clone_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_admin to update in case it exists.\n     */\n    where: reddit_clone_adminWhereUniqueInput\n    /**\n     * In case the reddit_clone_admin found by the `where` argument doesn't exist, create a new reddit_clone_admin with this data.\n     */\n    create: XOR<reddit_clone_adminCreateInput, reddit_clone_adminUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_admin was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_adminUpdateInput, reddit_clone_adminUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_admin delete\n   */\n  export type reddit_clone_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_admin to delete.\n     */\n    where: reddit_clone_adminWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_admin deleteMany\n   */\n  export type reddit_clone_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_admins to delete\n     */\n    where?: reddit_clone_adminWhereInput\n    /**\n     * Limit how many reddit_clone_admins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_admin without action\n   */\n  export type reddit_clone_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_admin\n     */\n    select?: reddit_clone_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_admin\n     */\n    omit?: reddit_clone_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_adminInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_communities\n   */\n\n  export type AggregateReddit_clone_communities = {\n    _count: Reddit_clone_communitiesCountAggregateOutputType | null\n    _avg: Reddit_clone_communitiesAvgAggregateOutputType | null\n    _sum: Reddit_clone_communitiesSumAggregateOutputType | null\n    _min: Reddit_clone_communitiesMinAggregateOutputType | null\n    _max: Reddit_clone_communitiesMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_communitiesAvgAggregateOutputType = {\n    member_count: number | null\n  }\n\n  export type Reddit_clone_communitiesSumAggregateOutputType = {\n    member_count: number | null\n  }\n\n  export type Reddit_clone_communitiesMinAggregateOutputType = {\n    id: string | null\n    creator_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n    is_nsfw: boolean | null\n    member_count: number | null\n  }\n\n  export type Reddit_clone_communitiesMaxAggregateOutputType = {\n    id: string | null\n    creator_id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n    is_nsfw: boolean | null\n    member_count: number | null\n  }\n\n  export type Reddit_clone_communitiesCountAggregateOutputType = {\n    id: number\n    creator_id: number\n    name: number\n    description: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    is_nsfw: number\n    member_count: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_communitiesAvgAggregateInputType = {\n    member_count?: true\n  }\n\n  export type Reddit_clone_communitiesSumAggregateInputType = {\n    member_count?: true\n  }\n\n  export type Reddit_clone_communitiesMinAggregateInputType = {\n    id?: true\n    creator_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    is_nsfw?: true\n    member_count?: true\n  }\n\n  export type Reddit_clone_communitiesMaxAggregateInputType = {\n    id?: true\n    creator_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    is_nsfw?: true\n    member_count?: true\n  }\n\n  export type Reddit_clone_communitiesCountAggregateInputType = {\n    id?: true\n    creator_id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    is_nsfw?: true\n    member_count?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_communitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_communities to aggregate.\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_communities to fetch.\n     */\n    orderBy?: reddit_clone_communitiesOrderByWithRelationInput | reddit_clone_communitiesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_communitiesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_communities from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_communities.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_communities\n    **/\n    _count?: true | Reddit_clone_communitiesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Reddit_clone_communitiesAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Reddit_clone_communitiesSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_communitiesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_communitiesMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_communitiesAggregateType<T extends Reddit_clone_communitiesAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_communities]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_communities[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_communities[P]>\n  }\n\n\n\n\n  export type reddit_clone_communitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_communitiesWhereInput\n    orderBy?: reddit_clone_communitiesOrderByWithAggregationInput | reddit_clone_communitiesOrderByWithAggregationInput[]\n    by: Reddit_clone_communitiesScalarFieldEnum[] | Reddit_clone_communitiesScalarFieldEnum\n    having?: reddit_clone_communitiesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_communitiesCountAggregateInputType | true\n    _avg?: Reddit_clone_communitiesAvgAggregateInputType\n    _sum?: Reddit_clone_communitiesSumAggregateInputType\n    _min?: Reddit_clone_communitiesMinAggregateInputType\n    _max?: Reddit_clone_communitiesMaxAggregateInputType\n  }\n\n  export type Reddit_clone_communitiesGroupByOutputType = {\n    id: string\n    creator_id: string\n    name: string\n    description: string | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    is_nsfw: boolean\n    member_count: number\n    _count: Reddit_clone_communitiesCountAggregateOutputType | null\n    _avg: Reddit_clone_communitiesAvgAggregateOutputType | null\n    _sum: Reddit_clone_communitiesSumAggregateOutputType | null\n    _min: Reddit_clone_communitiesMinAggregateOutputType | null\n    _max: Reddit_clone_communitiesMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_communitiesGroupByPayload<T extends reddit_clone_communitiesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_communitiesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_communitiesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_communitiesGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_communitiesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_communitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    creator_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    is_nsfw?: boolean\n    member_count?: boolean\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    reddit_clone_moderator?: boolean | reddit_clone_communities$reddit_clone_moderatorArgs<ExtArgs>\n    reddit_clone_community_subscriptions?: boolean | reddit_clone_communities$reddit_clone_community_subscriptionsArgs<ExtArgs>\n    reddit_clone_posts?: boolean | reddit_clone_communities$reddit_clone_postsArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_communitiesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_communities\"]>\n\n  export type reddit_clone_communitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    creator_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    is_nsfw?: boolean\n    member_count?: boolean\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_communities\"]>\n\n  export type reddit_clone_communitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    creator_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    is_nsfw?: boolean\n    member_count?: boolean\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_communities\"]>\n\n  export type reddit_clone_communitiesSelectScalar = {\n    id?: boolean\n    creator_id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    is_nsfw?: boolean\n    member_count?: boolean\n  }\n\n  export type reddit_clone_communitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"creator_id\" | \"name\" | \"description\" | \"created_at\" | \"updated_at\" | \"deleted_at\" | \"is_nsfw\" | \"member_count\", ExtArgs[\"result\"][\"reddit_clone_communities\"]>\n  export type reddit_clone_communitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    reddit_clone_moderator?: boolean | reddit_clone_communities$reddit_clone_moderatorArgs<ExtArgs>\n    reddit_clone_community_subscriptions?: boolean | reddit_clone_communities$reddit_clone_community_subscriptionsArgs<ExtArgs>\n    reddit_clone_posts?: boolean | reddit_clone_communities$reddit_clone_postsArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_communitiesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_communitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_communitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    creator?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_communitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_communities\"\n    objects: {\n      creator: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      reddit_clone_moderator: Prisma.$reddit_clone_moderatorPayload<ExtArgs>[]\n      reddit_clone_community_subscriptions: Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>[]\n      reddit_clone_posts: Prisma.$reddit_clone_postsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The member who created this community. {@link reddit_clone_member.id}.\n       */\n      creator_id: string\n      /**\n       * Unique name of the community (e.g., 'programming', 'gaming').\n       */\n      name: string\n      /**\n       * Detailed description of the community's purpose and topics.\n       */\n      description: string | null\n      /**\n       * Timestamp when the community was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the community was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the community was soft deleted, if applicable.\n       */\n      deleted_at: Date | null\n      /**\n       * Flag indicating if the community contains adult content.\n       */\n      is_nsfw: boolean\n      /**\n       * Current number of subscribers to this community.\n       */\n      member_count: number\n    }, ExtArgs[\"result\"][\"reddit_clone_communities\"]>\n    composites: {}\n  }\n\n  type reddit_clone_communitiesGetPayload<S extends boolean | null | undefined | reddit_clone_communitiesDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_communitiesPayload, S>\n\n  type reddit_clone_communitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_communitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_communitiesCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_communitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_communities'], meta: { name: 'reddit_clone_communities' } }\n    /**\n     * Find zero or one Reddit_clone_communities that matches the filter.\n     * @param {reddit_clone_communitiesFindUniqueArgs} args - Arguments to find a Reddit_clone_communities\n     * @example\n     * // Get one Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_communitiesFindUniqueArgs>(args: SelectSubset<T, reddit_clone_communitiesFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_communities that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_communitiesFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_communities\n     * @example\n     * // Get one Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_communitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_communitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_communities that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesFindFirstArgs} args - Arguments to find a Reddit_clone_communities\n     * @example\n     * // Get one Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_communitiesFindFirstArgs>(args?: SelectSubset<T, reddit_clone_communitiesFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_communities that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_communities\n     * @example\n     * // Get one Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_communitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_communitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_communities that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findMany()\n     * \n     * // Get first 10 Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_communitiesWithIdOnly = await prisma.reddit_clone_communities.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_communitiesFindManyArgs>(args?: SelectSubset<T, reddit_clone_communitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_communities.\n     * @param {reddit_clone_communitiesCreateArgs} args - Arguments to create a Reddit_clone_communities.\n     * @example\n     * // Create one Reddit_clone_communities\n     * const Reddit_clone_communities = await prisma.reddit_clone_communities.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_communities\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_communitiesCreateArgs>(args: SelectSubset<T, reddit_clone_communitiesCreateArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_communities.\n     * @param {reddit_clone_communitiesCreateManyArgs} args - Arguments to create many Reddit_clone_communities.\n     * @example\n     * // Create many Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_communitiesCreateManyArgs>(args?: SelectSubset<T, reddit_clone_communitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_communities and returns the data saved in the database.\n     * @param {reddit_clone_communitiesCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_communities.\n     * @example\n     * // Create many Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_communities and only return the `id`\n     * const reddit_clone_communitiesWithIdOnly = await prisma.reddit_clone_communities.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_communitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_communitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_communities.\n     * @param {reddit_clone_communitiesDeleteArgs} args - Arguments to delete one Reddit_clone_communities.\n     * @example\n     * // Delete one Reddit_clone_communities\n     * const Reddit_clone_communities = await prisma.reddit_clone_communities.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_communities\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_communitiesDeleteArgs>(args: SelectSubset<T, reddit_clone_communitiesDeleteArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_communities.\n     * @param {reddit_clone_communitiesUpdateArgs} args - Arguments to update one Reddit_clone_communities.\n     * @example\n     * // Update one Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_communitiesUpdateArgs>(args: SelectSubset<T, reddit_clone_communitiesUpdateArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_communities.\n     * @param {reddit_clone_communitiesDeleteManyArgs} args - Arguments to filter Reddit_clone_communities to delete.\n     * @example\n     * // Delete a few Reddit_clone_communities\n     * const { count } = await prisma.reddit_clone_communities.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_communitiesDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_communitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_communities.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_communitiesUpdateManyArgs>(args: SelectSubset<T, reddit_clone_communitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_communities and returns the data updated in the database.\n     * @param {reddit_clone_communitiesUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_communities.\n     * @example\n     * // Update many Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_communities and only return the `id`\n     * const reddit_clone_communitiesWithIdOnly = await prisma.reddit_clone_communities.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_communitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_communitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_communities.\n     * @param {reddit_clone_communitiesUpsertArgs} args - Arguments to update or create a Reddit_clone_communities.\n     * @example\n     * // Update or create a Reddit_clone_communities\n     * const reddit_clone_communities = await prisma.reddit_clone_communities.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_communities\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_communities we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_communitiesUpsertArgs>(args: SelectSubset<T, reddit_clone_communitiesUpsertArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_communities.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesCountArgs} args - Arguments to filter Reddit_clone_communities to count.\n     * @example\n     * // Count the number of Reddit_clone_communities\n     * const count = await prisma.reddit_clone_communities.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_communities we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_communitiesCountArgs>(\n      args?: Subset<T, reddit_clone_communitiesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_communitiesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_communities.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_communitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_communitiesAggregateArgs>(args: Subset<T, Reddit_clone_communitiesAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_communitiesAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_communities.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_communitiesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_communitiesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_communitiesGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_communitiesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_communitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_communitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_communities model\n   */\n  readonly fields: reddit_clone_communitiesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_communities.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_communitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    creator<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    reddit_clone_moderator<T extends reddit_clone_communities$reddit_clone_moderatorArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communities$reddit_clone_moderatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_moderatorPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_community_subscriptions<T extends reddit_clone_communities$reddit_clone_community_subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communities$reddit_clone_community_subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_posts<T extends reddit_clone_communities$reddit_clone_postsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communities$reddit_clone_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_communities model\n   */\n  interface reddit_clone_communitiesFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_communities\", 'String'>\n    readonly creator_id: FieldRef<\"reddit_clone_communities\", 'String'>\n    readonly name: FieldRef<\"reddit_clone_communities\", 'String'>\n    readonly description: FieldRef<\"reddit_clone_communities\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_communities\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_communities\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"reddit_clone_communities\", 'DateTime'>\n    readonly is_nsfw: FieldRef<\"reddit_clone_communities\", 'Boolean'>\n    readonly member_count: FieldRef<\"reddit_clone_communities\", 'Int'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_communities findUnique\n   */\n  export type reddit_clone_communitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_communities to fetch.\n     */\n    where: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_communities findUniqueOrThrow\n   */\n  export type reddit_clone_communitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_communities to fetch.\n     */\n    where: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_communities findFirst\n   */\n  export type reddit_clone_communitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_communities to fetch.\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_communities to fetch.\n     */\n    orderBy?: reddit_clone_communitiesOrderByWithRelationInput | reddit_clone_communitiesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_communities.\n     */\n    cursor?: reddit_clone_communitiesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_communities from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_communities.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_communities.\n     */\n    distinct?: Reddit_clone_communitiesScalarFieldEnum | Reddit_clone_communitiesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities findFirstOrThrow\n   */\n  export type reddit_clone_communitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_communities to fetch.\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_communities to fetch.\n     */\n    orderBy?: reddit_clone_communitiesOrderByWithRelationInput | reddit_clone_communitiesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_communities.\n     */\n    cursor?: reddit_clone_communitiesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_communities from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_communities.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_communities.\n     */\n    distinct?: Reddit_clone_communitiesScalarFieldEnum | Reddit_clone_communitiesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities findMany\n   */\n  export type reddit_clone_communitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_communities to fetch.\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_communities to fetch.\n     */\n    orderBy?: reddit_clone_communitiesOrderByWithRelationInput | reddit_clone_communitiesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_communities.\n     */\n    cursor?: reddit_clone_communitiesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_communities from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_communities.\n     */\n    skip?: number\n    distinct?: Reddit_clone_communitiesScalarFieldEnum | Reddit_clone_communitiesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities create\n   */\n  export type reddit_clone_communitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_communities.\n     */\n    data: XOR<reddit_clone_communitiesCreateInput, reddit_clone_communitiesUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_communities createMany\n   */\n  export type reddit_clone_communitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_communities.\n     */\n    data: reddit_clone_communitiesCreateManyInput | reddit_clone_communitiesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_communities createManyAndReturn\n   */\n  export type reddit_clone_communitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_communities.\n     */\n    data: reddit_clone_communitiesCreateManyInput | reddit_clone_communitiesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_communities update\n   */\n  export type reddit_clone_communitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_communities.\n     */\n    data: XOR<reddit_clone_communitiesUpdateInput, reddit_clone_communitiesUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_communities to update.\n     */\n    where: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_communities updateMany\n   */\n  export type reddit_clone_communitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_communities.\n     */\n    data: XOR<reddit_clone_communitiesUpdateManyMutationInput, reddit_clone_communitiesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_communities to update\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * Limit how many reddit_clone_communities to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_communities updateManyAndReturn\n   */\n  export type reddit_clone_communitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_communities.\n     */\n    data: XOR<reddit_clone_communitiesUpdateManyMutationInput, reddit_clone_communitiesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_communities to update\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * Limit how many reddit_clone_communities to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_communities upsert\n   */\n  export type reddit_clone_communitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_communities to update in case it exists.\n     */\n    where: reddit_clone_communitiesWhereUniqueInput\n    /**\n     * In case the reddit_clone_communities found by the `where` argument doesn't exist, create a new reddit_clone_communities with this data.\n     */\n    create: XOR<reddit_clone_communitiesCreateInput, reddit_clone_communitiesUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_communities was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_communitiesUpdateInput, reddit_clone_communitiesUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_communities delete\n   */\n  export type reddit_clone_communitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_communities to delete.\n     */\n    where: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_communities deleteMany\n   */\n  export type reddit_clone_communitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_communities to delete\n     */\n    where?: reddit_clone_communitiesWhereInput\n    /**\n     * Limit how many reddit_clone_communities to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_communities.reddit_clone_moderator\n   */\n  export type reddit_clone_communities$reddit_clone_moderatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_moderator\n     */\n    select?: reddit_clone_moderatorSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_moderator\n     */\n    omit?: reddit_clone_moderatorOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_moderatorInclude<ExtArgs> | null\n    where?: reddit_clone_moderatorWhereInput\n    orderBy?: reddit_clone_moderatorOrderByWithRelationInput | reddit_clone_moderatorOrderByWithRelationInput[]\n    cursor?: reddit_clone_moderatorWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_moderatorScalarFieldEnum | Reddit_clone_moderatorScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities.reddit_clone_community_subscriptions\n   */\n  export type reddit_clone_communities$reddit_clone_community_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    where?: reddit_clone_community_subscriptionsWhereInput\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_community_subscriptionsScalarFieldEnum | Reddit_clone_community_subscriptionsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities.reddit_clone_posts\n   */\n  export type reddit_clone_communities$reddit_clone_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    where?: reddit_clone_postsWhereInput\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    cursor?: reddit_clone_postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_postsScalarFieldEnum | Reddit_clone_postsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_communities without action\n   */\n  export type reddit_clone_communitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_communities\n     */\n    select?: reddit_clone_communitiesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_communities\n     */\n    omit?: reddit_clone_communitiesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_communitiesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_community_subscriptions\n   */\n\n  export type AggregateReddit_clone_community_subscriptions = {\n    _count: Reddit_clone_community_subscriptionsCountAggregateOutputType | null\n    _min: Reddit_clone_community_subscriptionsMinAggregateOutputType | null\n    _max: Reddit_clone_community_subscriptionsMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_community_subscriptionsMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    community_id: string | null\n    subscribed_at: Date | null\n    is_muted: boolean | null\n  }\n\n  export type Reddit_clone_community_subscriptionsMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    community_id: string | null\n    subscribed_at: Date | null\n    is_muted: boolean | null\n  }\n\n  export type Reddit_clone_community_subscriptionsCountAggregateOutputType = {\n    id: number\n    user_id: number\n    community_id: number\n    subscribed_at: number\n    is_muted: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_community_subscriptionsMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    community_id?: true\n    subscribed_at?: true\n    is_muted?: true\n  }\n\n  export type Reddit_clone_community_subscriptionsMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    community_id?: true\n    subscribed_at?: true\n    is_muted?: true\n  }\n\n  export type Reddit_clone_community_subscriptionsCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    community_id?: true\n    subscribed_at?: true\n    is_muted?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_community_subscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_community_subscriptions to aggregate.\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_community_subscriptions to fetch.\n     */\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_community_subscriptions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_community_subscriptions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_community_subscriptions\n    **/\n    _count?: true | Reddit_clone_community_subscriptionsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_community_subscriptionsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_community_subscriptionsMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_community_subscriptionsAggregateType<T extends Reddit_clone_community_subscriptionsAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_community_subscriptions]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_community_subscriptions[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_community_subscriptions[P]>\n  }\n\n\n\n\n  export type reddit_clone_community_subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_community_subscriptionsWhereInput\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithAggregationInput | reddit_clone_community_subscriptionsOrderByWithAggregationInput[]\n    by: Reddit_clone_community_subscriptionsScalarFieldEnum[] | Reddit_clone_community_subscriptionsScalarFieldEnum\n    having?: reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_community_subscriptionsCountAggregateInputType | true\n    _min?: Reddit_clone_community_subscriptionsMinAggregateInputType\n    _max?: Reddit_clone_community_subscriptionsMaxAggregateInputType\n  }\n\n  export type Reddit_clone_community_subscriptionsGroupByOutputType = {\n    id: string\n    user_id: string\n    community_id: string\n    subscribed_at: Date\n    is_muted: boolean\n    _count: Reddit_clone_community_subscriptionsCountAggregateOutputType | null\n    _min: Reddit_clone_community_subscriptionsMinAggregateOutputType | null\n    _max: Reddit_clone_community_subscriptionsMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_community_subscriptionsGroupByPayload<T extends reddit_clone_community_subscriptionsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_community_subscriptionsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_community_subscriptionsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_community_subscriptionsGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_community_subscriptionsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_community_subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    community_id?: boolean\n    subscribed_at?: boolean\n    is_muted?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_community_subscriptions\"]>\n\n  export type reddit_clone_community_subscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    community_id?: boolean\n    subscribed_at?: boolean\n    is_muted?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_community_subscriptions\"]>\n\n  export type reddit_clone_community_subscriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    community_id?: boolean\n    subscribed_at?: boolean\n    is_muted?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_community_subscriptions\"]>\n\n  export type reddit_clone_community_subscriptionsSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    community_id?: boolean\n    subscribed_at?: boolean\n    is_muted?: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"community_id\" | \"subscribed_at\" | \"is_muted\", ExtArgs[\"result\"][\"reddit_clone_community_subscriptions\"]>\n  export type reddit_clone_community_subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_community_subscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_community_subscriptionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_community_subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_community_subscriptions\"\n    objects: {\n      user: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      community: Prisma.$reddit_clone_communitiesPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The user who is subscribed to the community. {@link\n       * reddit_clone_member.id}.\n       */\n      user_id: string\n      /**\n       * The community being subscribed to. {@link reddit_clone_communities.id}.\n       */\n      community_id: string\n      /**\n       * Timestamp when the user subscribed to the community.\n       */\n      subscribed_at: Date\n      /**\n       * Flag indicating if the user has muted notifications from this community.\n       */\n      is_muted: boolean\n    }, ExtArgs[\"result\"][\"reddit_clone_community_subscriptions\"]>\n    composites: {}\n  }\n\n  type reddit_clone_community_subscriptionsGetPayload<S extends boolean | null | undefined | reddit_clone_community_subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload, S>\n\n  type reddit_clone_community_subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_community_subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_community_subscriptionsCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_community_subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_community_subscriptions'], meta: { name: 'reddit_clone_community_subscriptions' } }\n    /**\n     * Find zero or one Reddit_clone_community_subscriptions that matches the filter.\n     * @param {reddit_clone_community_subscriptionsFindUniqueArgs} args - Arguments to find a Reddit_clone_community_subscriptions\n     * @example\n     * // Get one Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_community_subscriptionsFindUniqueArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_community_subscriptions that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_community_subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_community_subscriptions\n     * @example\n     * // Get one Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_community_subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_community_subscriptions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsFindFirstArgs} args - Arguments to find a Reddit_clone_community_subscriptions\n     * @example\n     * // Get one Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_community_subscriptionsFindFirstArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_community_subscriptions that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_community_subscriptions\n     * @example\n     * // Get one Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_community_subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_community_subscriptions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findMany()\n     * \n     * // Get first 10 Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_community_subscriptionsWithIdOnly = await prisma.reddit_clone_community_subscriptions.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_community_subscriptionsFindManyArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsCreateArgs} args - Arguments to create a Reddit_clone_community_subscriptions.\n     * @example\n     * // Create one Reddit_clone_community_subscriptions\n     * const Reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_community_subscriptions\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_community_subscriptionsCreateArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsCreateArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsCreateManyArgs} args - Arguments to create many Reddit_clone_community_subscriptions.\n     * @example\n     * // Create many Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_community_subscriptionsCreateManyArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_community_subscriptions and returns the data saved in the database.\n     * @param {reddit_clone_community_subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_community_subscriptions.\n     * @example\n     * // Create many Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_community_subscriptions and only return the `id`\n     * const reddit_clone_community_subscriptionsWithIdOnly = await prisma.reddit_clone_community_subscriptions.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_community_subscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsDeleteArgs} args - Arguments to delete one Reddit_clone_community_subscriptions.\n     * @example\n     * // Delete one Reddit_clone_community_subscriptions\n     * const Reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_community_subscriptions\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_community_subscriptionsDeleteArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsDeleteArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsUpdateArgs} args - Arguments to update one Reddit_clone_community_subscriptions.\n     * @example\n     * // Update one Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_community_subscriptionsUpdateArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsUpdateArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsDeleteManyArgs} args - Arguments to filter Reddit_clone_community_subscriptions to delete.\n     * @example\n     * // Delete a few Reddit_clone_community_subscriptions\n     * const { count } = await prisma.reddit_clone_community_subscriptions.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_community_subscriptionsDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_community_subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_community_subscriptions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_community_subscriptionsUpdateManyArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_community_subscriptions and returns the data updated in the database.\n     * @param {reddit_clone_community_subscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_community_subscriptions.\n     * @example\n     * // Update many Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_community_subscriptions and only return the `id`\n     * const reddit_clone_community_subscriptionsWithIdOnly = await prisma.reddit_clone_community_subscriptions.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_community_subscriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_community_subscriptions.\n     * @param {reddit_clone_community_subscriptionsUpsertArgs} args - Arguments to update or create a Reddit_clone_community_subscriptions.\n     * @example\n     * // Update or create a Reddit_clone_community_subscriptions\n     * const reddit_clone_community_subscriptions = await prisma.reddit_clone_community_subscriptions.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_community_subscriptions\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_community_subscriptions we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_community_subscriptionsUpsertArgs>(args: SelectSubset<T, reddit_clone_community_subscriptionsUpsertArgs<ExtArgs>>): Prisma__reddit_clone_community_subscriptionsClient<$Result.GetResult<Prisma.$reddit_clone_community_subscriptionsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_community_subscriptions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsCountArgs} args - Arguments to filter Reddit_clone_community_subscriptions to count.\n     * @example\n     * // Count the number of Reddit_clone_community_subscriptions\n     * const count = await prisma.reddit_clone_community_subscriptions.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_community_subscriptions we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_community_subscriptionsCountArgs>(\n      args?: Subset<T, reddit_clone_community_subscriptionsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_community_subscriptionsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_community_subscriptions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_community_subscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_community_subscriptionsAggregateArgs>(args: Subset<T, Reddit_clone_community_subscriptionsAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_community_subscriptionsAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_community_subscriptions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_community_subscriptionsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_community_subscriptionsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_community_subscriptionsGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_community_subscriptionsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_community_subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_community_subscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_community_subscriptions model\n   */\n  readonly fields: reddit_clone_community_subscriptionsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_community_subscriptions.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_community_subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    community<T extends reddit_clone_communitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communitiesDefaultArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_community_subscriptions model\n   */\n  interface reddit_clone_community_subscriptionsFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_community_subscriptions\", 'String'>\n    readonly user_id: FieldRef<\"reddit_clone_community_subscriptions\", 'String'>\n    readonly community_id: FieldRef<\"reddit_clone_community_subscriptions\", 'String'>\n    readonly subscribed_at: FieldRef<\"reddit_clone_community_subscriptions\", 'DateTime'>\n    readonly is_muted: FieldRef<\"reddit_clone_community_subscriptions\", 'Boolean'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_community_subscriptions findUnique\n   */\n  export type reddit_clone_community_subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_community_subscriptions to fetch.\n     */\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_community_subscriptions findUniqueOrThrow\n   */\n  export type reddit_clone_community_subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_community_subscriptions to fetch.\n     */\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_community_subscriptions findFirst\n   */\n  export type reddit_clone_community_subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_community_subscriptions to fetch.\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_community_subscriptions to fetch.\n     */\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_community_subscriptions.\n     */\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_community_subscriptions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_community_subscriptions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_community_subscriptions.\n     */\n    distinct?: Reddit_clone_community_subscriptionsScalarFieldEnum | Reddit_clone_community_subscriptionsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_community_subscriptions findFirstOrThrow\n   */\n  export type reddit_clone_community_subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_community_subscriptions to fetch.\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_community_subscriptions to fetch.\n     */\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_community_subscriptions.\n     */\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_community_subscriptions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_community_subscriptions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_community_subscriptions.\n     */\n    distinct?: Reddit_clone_community_subscriptionsScalarFieldEnum | Reddit_clone_community_subscriptionsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_community_subscriptions findMany\n   */\n  export type reddit_clone_community_subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_community_subscriptions to fetch.\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_community_subscriptions to fetch.\n     */\n    orderBy?: reddit_clone_community_subscriptionsOrderByWithRelationInput | reddit_clone_community_subscriptionsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_community_subscriptions.\n     */\n    cursor?: reddit_clone_community_subscriptionsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_community_subscriptions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_community_subscriptions.\n     */\n    skip?: number\n    distinct?: Reddit_clone_community_subscriptionsScalarFieldEnum | Reddit_clone_community_subscriptionsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_community_subscriptions create\n   */\n  export type reddit_clone_community_subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_community_subscriptions.\n     */\n    data: XOR<reddit_clone_community_subscriptionsCreateInput, reddit_clone_community_subscriptionsUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_community_subscriptions createMany\n   */\n  export type reddit_clone_community_subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_community_subscriptions.\n     */\n    data: reddit_clone_community_subscriptionsCreateManyInput | reddit_clone_community_subscriptionsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_community_subscriptions createManyAndReturn\n   */\n  export type reddit_clone_community_subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_community_subscriptions.\n     */\n    data: reddit_clone_community_subscriptionsCreateManyInput | reddit_clone_community_subscriptionsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_community_subscriptions update\n   */\n  export type reddit_clone_community_subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_community_subscriptions.\n     */\n    data: XOR<reddit_clone_community_subscriptionsUpdateInput, reddit_clone_community_subscriptionsUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_community_subscriptions to update.\n     */\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_community_subscriptions updateMany\n   */\n  export type reddit_clone_community_subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_community_subscriptions.\n     */\n    data: XOR<reddit_clone_community_subscriptionsUpdateManyMutationInput, reddit_clone_community_subscriptionsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_community_subscriptions to update\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * Limit how many reddit_clone_community_subscriptions to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_community_subscriptions updateManyAndReturn\n   */\n  export type reddit_clone_community_subscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_community_subscriptions.\n     */\n    data: XOR<reddit_clone_community_subscriptionsUpdateManyMutationInput, reddit_clone_community_subscriptionsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_community_subscriptions to update\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * Limit how many reddit_clone_community_subscriptions to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_community_subscriptions upsert\n   */\n  export type reddit_clone_community_subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_community_subscriptions to update in case it exists.\n     */\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    /**\n     * In case the reddit_clone_community_subscriptions found by the `where` argument doesn't exist, create a new reddit_clone_community_subscriptions with this data.\n     */\n    create: XOR<reddit_clone_community_subscriptionsCreateInput, reddit_clone_community_subscriptionsUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_community_subscriptions was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_community_subscriptionsUpdateInput, reddit_clone_community_subscriptionsUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_community_subscriptions delete\n   */\n  export type reddit_clone_community_subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_community_subscriptions to delete.\n     */\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_community_subscriptions deleteMany\n   */\n  export type reddit_clone_community_subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_community_subscriptions to delete\n     */\n    where?: reddit_clone_community_subscriptionsWhereInput\n    /**\n     * Limit how many reddit_clone_community_subscriptions to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_community_subscriptions without action\n   */\n  export type reddit_clone_community_subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_community_subscriptions\n     */\n    select?: reddit_clone_community_subscriptionsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_community_subscriptions\n     */\n    omit?: reddit_clone_community_subscriptionsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_community_subscriptionsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_posts\n   */\n\n  export type AggregateReddit_clone_posts = {\n    _count: Reddit_clone_postsCountAggregateOutputType | null\n    _avg: Reddit_clone_postsAvgAggregateOutputType | null\n    _sum: Reddit_clone_postsSumAggregateOutputType | null\n    _min: Reddit_clone_postsMinAggregateOutputType | null\n    _max: Reddit_clone_postsMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_postsAvgAggregateOutputType = {\n    upvote_count: number | null\n    downvote_count: number | null\n    comment_count: number | null\n  }\n\n  export type Reddit_clone_postsSumAggregateOutputType = {\n    upvote_count: number | null\n    downvote_count: number | null\n    comment_count: number | null\n  }\n\n  export type Reddit_clone_postsMinAggregateOutputType = {\n    id: string | null\n    author_id: string | null\n    community_id: string | null\n    title: string | null\n    content: string | null\n    content_type: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    is_locked: boolean | null\n    is_nsfw: boolean | null\n    upvote_count: number | null\n    downvote_count: number | null\n    comment_count: number | null\n  }\n\n  export type Reddit_clone_postsMaxAggregateOutputType = {\n    id: string | null\n    author_id: string | null\n    community_id: string | null\n    title: string | null\n    content: string | null\n    content_type: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    is_locked: boolean | null\n    is_nsfw: boolean | null\n    upvote_count: number | null\n    downvote_count: number | null\n    comment_count: number | null\n  }\n\n  export type Reddit_clone_postsCountAggregateOutputType = {\n    id: number\n    author_id: number\n    community_id: number\n    title: number\n    content: number\n    content_type: number\n    created_at: number\n    updated_at: number\n    is_locked: number\n    is_nsfw: number\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_postsAvgAggregateInputType = {\n    upvote_count?: true\n    downvote_count?: true\n    comment_count?: true\n  }\n\n  export type Reddit_clone_postsSumAggregateInputType = {\n    upvote_count?: true\n    downvote_count?: true\n    comment_count?: true\n  }\n\n  export type Reddit_clone_postsMinAggregateInputType = {\n    id?: true\n    author_id?: true\n    community_id?: true\n    title?: true\n    content?: true\n    content_type?: true\n    created_at?: true\n    updated_at?: true\n    is_locked?: true\n    is_nsfw?: true\n    upvote_count?: true\n    downvote_count?: true\n    comment_count?: true\n  }\n\n  export type Reddit_clone_postsMaxAggregateInputType = {\n    id?: true\n    author_id?: true\n    community_id?: true\n    title?: true\n    content?: true\n    content_type?: true\n    created_at?: true\n    updated_at?: true\n    is_locked?: true\n    is_nsfw?: true\n    upvote_count?: true\n    downvote_count?: true\n    comment_count?: true\n  }\n\n  export type Reddit_clone_postsCountAggregateInputType = {\n    id?: true\n    author_id?: true\n    community_id?: true\n    title?: true\n    content?: true\n    content_type?: true\n    created_at?: true\n    updated_at?: true\n    is_locked?: true\n    is_nsfw?: true\n    upvote_count?: true\n    downvote_count?: true\n    comment_count?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_postsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_posts to aggregate.\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_posts to fetch.\n     */\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_posts\n    **/\n    _count?: true | Reddit_clone_postsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Reddit_clone_postsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Reddit_clone_postsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_postsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_postsMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_postsAggregateType<T extends Reddit_clone_postsAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_posts]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_posts[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_posts[P]>\n  }\n\n\n\n\n  export type reddit_clone_postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_postsWhereInput\n    orderBy?: reddit_clone_postsOrderByWithAggregationInput | reddit_clone_postsOrderByWithAggregationInput[]\n    by: Reddit_clone_postsScalarFieldEnum[] | Reddit_clone_postsScalarFieldEnum\n    having?: reddit_clone_postsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_postsCountAggregateInputType | true\n    _avg?: Reddit_clone_postsAvgAggregateInputType\n    _sum?: Reddit_clone_postsSumAggregateInputType\n    _min?: Reddit_clone_postsMinAggregateInputType\n    _max?: Reddit_clone_postsMaxAggregateInputType\n  }\n\n  export type Reddit_clone_postsGroupByOutputType = {\n    id: string\n    author_id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date\n    updated_at: Date\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    _count: Reddit_clone_postsCountAggregateOutputType | null\n    _avg: Reddit_clone_postsAvgAggregateOutputType | null\n    _sum: Reddit_clone_postsSumAggregateOutputType | null\n    _min: Reddit_clone_postsMinAggregateOutputType | null\n    _max: Reddit_clone_postsMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_postsGroupByPayload<T extends reddit_clone_postsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_postsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_postsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_postsGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_postsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    author_id?: boolean\n    community_id?: boolean\n    title?: boolean\n    content?: boolean\n    content_type?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    is_locked?: boolean\n    is_nsfw?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    comment_count?: boolean\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n    reddit_clone_comments?: boolean | reddit_clone_posts$reddit_clone_commentsArgs<ExtArgs>\n    reddit_clone_post_votes?: boolean | reddit_clone_posts$reddit_clone_post_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_postsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_posts\"]>\n\n  export type reddit_clone_postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    author_id?: boolean\n    community_id?: boolean\n    title?: boolean\n    content?: boolean\n    content_type?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    is_locked?: boolean\n    is_nsfw?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    comment_count?: boolean\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_posts\"]>\n\n  export type reddit_clone_postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    author_id?: boolean\n    community_id?: boolean\n    title?: boolean\n    content?: boolean\n    content_type?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    is_locked?: boolean\n    is_nsfw?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    comment_count?: boolean\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_posts\"]>\n\n  export type reddit_clone_postsSelectScalar = {\n    id?: boolean\n    author_id?: boolean\n    community_id?: boolean\n    title?: boolean\n    content?: boolean\n    content_type?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    is_locked?: boolean\n    is_nsfw?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    comment_count?: boolean\n  }\n\n  export type reddit_clone_postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"author_id\" | \"community_id\" | \"title\" | \"content\" | \"content_type\" | \"created_at\" | \"updated_at\" | \"is_locked\" | \"is_nsfw\" | \"upvote_count\" | \"downvote_count\" | \"comment_count\", ExtArgs[\"result\"][\"reddit_clone_posts\"]>\n  export type reddit_clone_postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n    reddit_clone_comments?: boolean | reddit_clone_posts$reddit_clone_commentsArgs<ExtArgs>\n    reddit_clone_post_votes?: boolean | reddit_clone_posts$reddit_clone_post_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_postsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    community?: boolean | reddit_clone_communitiesDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_posts\"\n    objects: {\n      author: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      community: Prisma.$reddit_clone_communitiesPayload<ExtArgs>\n      reddit_clone_comments: Prisma.$reddit_clone_commentsPayload<ExtArgs>[]\n      reddit_clone_post_votes: Prisma.$reddit_clone_post_votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The author who created the post. {@link reddit_clone_member.id}.\n       */\n      author_id: string\n      /**\n       * The community where the post was created. {@link\n       * reddit_clone_communities.id}.\n       */\n      community_id: string\n      /**\n       * The title of the post.\n       */\n      title: string\n      /**\n       * The content of the post.\n       */\n      content: string\n      /**\n       * The type of content (text, link, image).\n       */\n      content_type: string\n      /**\n       * When the post was created.\n       */\n      created_at: Date\n      /**\n       * When the post was last updated.\n       */\n      updated_at: Date\n      /**\n       * Whether the post is locked (no new comments allowed).\n       */\n      is_locked: boolean\n      /**\n       * Whether the post contains NSFW (Not Safe For Work) content.\n       */\n      is_nsfw: boolean\n      /**\n       * The number of upvotes the post has received.\n       */\n      upvote_count: number\n      /**\n       * The number of downvotes the post has received.\n       */\n      downvote_count: number\n      /**\n       * The number of comments on the post.\n       */\n      comment_count: number\n    }, ExtArgs[\"result\"][\"reddit_clone_posts\"]>\n    composites: {}\n  }\n\n  type reddit_clone_postsGetPayload<S extends boolean | null | undefined | reddit_clone_postsDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_postsPayload, S>\n\n  type reddit_clone_postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_postsCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_posts'], meta: { name: 'reddit_clone_posts' } }\n    /**\n     * Find zero or one Reddit_clone_posts that matches the filter.\n     * @param {reddit_clone_postsFindUniqueArgs} args - Arguments to find a Reddit_clone_posts\n     * @example\n     * // Get one Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_postsFindUniqueArgs>(args: SelectSubset<T, reddit_clone_postsFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_posts that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_postsFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_posts\n     * @example\n     * // Get one Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_postsFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsFindFirstArgs} args - Arguments to find a Reddit_clone_posts\n     * @example\n     * // Get one Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_postsFindFirstArgs>(args?: SelectSubset<T, reddit_clone_postsFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_posts that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_posts\n     * @example\n     * // Get one Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_postsFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findMany()\n     * \n     * // Get first 10 Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_postsWithIdOnly = await prisma.reddit_clone_posts.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_postsFindManyArgs>(args?: SelectSubset<T, reddit_clone_postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_posts.\n     * @param {reddit_clone_postsCreateArgs} args - Arguments to create a Reddit_clone_posts.\n     * @example\n     * // Create one Reddit_clone_posts\n     * const Reddit_clone_posts = await prisma.reddit_clone_posts.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_posts\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_postsCreateArgs>(args: SelectSubset<T, reddit_clone_postsCreateArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_posts.\n     * @param {reddit_clone_postsCreateManyArgs} args - Arguments to create many Reddit_clone_posts.\n     * @example\n     * // Create many Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_postsCreateManyArgs>(args?: SelectSubset<T, reddit_clone_postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_posts and returns the data saved in the database.\n     * @param {reddit_clone_postsCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_posts.\n     * @example\n     * // Create many Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_posts and only return the `id`\n     * const reddit_clone_postsWithIdOnly = await prisma.reddit_clone_posts.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_postsCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_posts.\n     * @param {reddit_clone_postsDeleteArgs} args - Arguments to delete one Reddit_clone_posts.\n     * @example\n     * // Delete one Reddit_clone_posts\n     * const Reddit_clone_posts = await prisma.reddit_clone_posts.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_posts\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_postsDeleteArgs>(args: SelectSubset<T, reddit_clone_postsDeleteArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_posts.\n     * @param {reddit_clone_postsUpdateArgs} args - Arguments to update one Reddit_clone_posts.\n     * @example\n     * // Update one Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_postsUpdateArgs>(args: SelectSubset<T, reddit_clone_postsUpdateArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_posts.\n     * @param {reddit_clone_postsDeleteManyArgs} args - Arguments to filter Reddit_clone_posts to delete.\n     * @example\n     * // Delete a few Reddit_clone_posts\n     * const { count } = await prisma.reddit_clone_posts.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_postsDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_postsUpdateManyArgs>(args: SelectSubset<T, reddit_clone_postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_posts and returns the data updated in the database.\n     * @param {reddit_clone_postsUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_posts.\n     * @example\n     * // Update many Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_posts and only return the `id`\n     * const reddit_clone_postsWithIdOnly = await prisma.reddit_clone_posts.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_postsUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_posts.\n     * @param {reddit_clone_postsUpsertArgs} args - Arguments to update or create a Reddit_clone_posts.\n     * @example\n     * // Update or create a Reddit_clone_posts\n     * const reddit_clone_posts = await prisma.reddit_clone_posts.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_posts\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_posts we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_postsUpsertArgs>(args: SelectSubset<T, reddit_clone_postsUpsertArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsCountArgs} args - Arguments to filter Reddit_clone_posts to count.\n     * @example\n     * // Count the number of Reddit_clone_posts\n     * const count = await prisma.reddit_clone_posts.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_posts we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_postsCountArgs>(\n      args?: Subset<T, reddit_clone_postsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_postsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_postsAggregateArgs>(args: Subset<T, Reddit_clone_postsAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_postsAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_postsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_postsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_postsGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_postsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_posts model\n   */\n  readonly fields: reddit_clone_postsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_posts.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    author<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    community<T extends reddit_clone_communitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_communitiesDefaultArgs<ExtArgs>>): Prisma__reddit_clone_communitiesClient<$Result.GetResult<Prisma.$reddit_clone_communitiesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    reddit_clone_comments<T extends reddit_clone_posts$reddit_clone_commentsArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_posts$reddit_clone_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_post_votes<T extends reddit_clone_posts$reddit_clone_post_votesArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_posts$reddit_clone_post_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_posts model\n   */\n  interface reddit_clone_postsFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly author_id: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly community_id: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly title: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly content: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly content_type: FieldRef<\"reddit_clone_posts\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_posts\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_posts\", 'DateTime'>\n    readonly is_locked: FieldRef<\"reddit_clone_posts\", 'Boolean'>\n    readonly is_nsfw: FieldRef<\"reddit_clone_posts\", 'Boolean'>\n    readonly upvote_count: FieldRef<\"reddit_clone_posts\", 'Int'>\n    readonly downvote_count: FieldRef<\"reddit_clone_posts\", 'Int'>\n    readonly comment_count: FieldRef<\"reddit_clone_posts\", 'Int'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_posts findUnique\n   */\n  export type reddit_clone_postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_posts to fetch.\n     */\n    where: reddit_clone_postsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_posts findUniqueOrThrow\n   */\n  export type reddit_clone_postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_posts to fetch.\n     */\n    where: reddit_clone_postsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_posts findFirst\n   */\n  export type reddit_clone_postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_posts to fetch.\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_posts to fetch.\n     */\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_posts.\n     */\n    cursor?: reddit_clone_postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_posts.\n     */\n    distinct?: Reddit_clone_postsScalarFieldEnum | Reddit_clone_postsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_posts findFirstOrThrow\n   */\n  export type reddit_clone_postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_posts to fetch.\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_posts to fetch.\n     */\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_posts.\n     */\n    cursor?: reddit_clone_postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_posts.\n     */\n    distinct?: Reddit_clone_postsScalarFieldEnum | Reddit_clone_postsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_posts findMany\n   */\n  export type reddit_clone_postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_posts to fetch.\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_posts to fetch.\n     */\n    orderBy?: reddit_clone_postsOrderByWithRelationInput | reddit_clone_postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_posts.\n     */\n    cursor?: reddit_clone_postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_posts.\n     */\n    skip?: number\n    distinct?: Reddit_clone_postsScalarFieldEnum | Reddit_clone_postsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_posts create\n   */\n  export type reddit_clone_postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_posts.\n     */\n    data: XOR<reddit_clone_postsCreateInput, reddit_clone_postsUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_posts createMany\n   */\n  export type reddit_clone_postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_posts.\n     */\n    data: reddit_clone_postsCreateManyInput | reddit_clone_postsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_posts createManyAndReturn\n   */\n  export type reddit_clone_postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_posts.\n     */\n    data: reddit_clone_postsCreateManyInput | reddit_clone_postsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_posts update\n   */\n  export type reddit_clone_postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_posts.\n     */\n    data: XOR<reddit_clone_postsUpdateInput, reddit_clone_postsUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_posts to update.\n     */\n    where: reddit_clone_postsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_posts updateMany\n   */\n  export type reddit_clone_postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_posts.\n     */\n    data: XOR<reddit_clone_postsUpdateManyMutationInput, reddit_clone_postsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_posts to update\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * Limit how many reddit_clone_posts to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_posts updateManyAndReturn\n   */\n  export type reddit_clone_postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_posts.\n     */\n    data: XOR<reddit_clone_postsUpdateManyMutationInput, reddit_clone_postsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_posts to update\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * Limit how many reddit_clone_posts to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_posts upsert\n   */\n  export type reddit_clone_postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_posts to update in case it exists.\n     */\n    where: reddit_clone_postsWhereUniqueInput\n    /**\n     * In case the reddit_clone_posts found by the `where` argument doesn't exist, create a new reddit_clone_posts with this data.\n     */\n    create: XOR<reddit_clone_postsCreateInput, reddit_clone_postsUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_posts was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_postsUpdateInput, reddit_clone_postsUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_posts delete\n   */\n  export type reddit_clone_postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_posts to delete.\n     */\n    where: reddit_clone_postsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_posts deleteMany\n   */\n  export type reddit_clone_postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_posts to delete\n     */\n    where?: reddit_clone_postsWhereInput\n    /**\n     * Limit how many reddit_clone_posts to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_posts.reddit_clone_comments\n   */\n  export type reddit_clone_posts$reddit_clone_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    where?: reddit_clone_commentsWhereInput\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_posts.reddit_clone_post_votes\n   */\n  export type reddit_clone_posts$reddit_clone_post_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    where?: reddit_clone_post_votesWhereInput\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_post_votesScalarFieldEnum | Reddit_clone_post_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_posts without action\n   */\n  export type reddit_clone_postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_posts\n     */\n    select?: reddit_clone_postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_posts\n     */\n    omit?: reddit_clone_postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_postsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_comments\n   */\n\n  export type AggregateReddit_clone_comments = {\n    _count: Reddit_clone_commentsCountAggregateOutputType | null\n    _avg: Reddit_clone_commentsAvgAggregateOutputType | null\n    _sum: Reddit_clone_commentsSumAggregateOutputType | null\n    _min: Reddit_clone_commentsMinAggregateOutputType | null\n    _max: Reddit_clone_commentsMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_commentsAvgAggregateOutputType = {\n    upvote_count: number | null\n    downvote_count: number | null\n  }\n\n  export type Reddit_clone_commentsSumAggregateOutputType = {\n    upvote_count: number | null\n    downvote_count: number | null\n  }\n\n  export type Reddit_clone_commentsMinAggregateOutputType = {\n    id: string | null\n    post_id: string | null\n    author_id: string | null\n    parent_comment_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    upvote_count: number | null\n    downvote_count: number | null\n  }\n\n  export type Reddit_clone_commentsMaxAggregateOutputType = {\n    id: string | null\n    post_id: string | null\n    author_id: string | null\n    parent_comment_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    upvote_count: number | null\n    downvote_count: number | null\n  }\n\n  export type Reddit_clone_commentsCountAggregateOutputType = {\n    id: number\n    post_id: number\n    author_id: number\n    parent_comment_id: number\n    content: number\n    created_at: number\n    updated_at: number\n    upvote_count: number\n    downvote_count: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_commentsAvgAggregateInputType = {\n    upvote_count?: true\n    downvote_count?: true\n  }\n\n  export type Reddit_clone_commentsSumAggregateInputType = {\n    upvote_count?: true\n    downvote_count?: true\n  }\n\n  export type Reddit_clone_commentsMinAggregateInputType = {\n    id?: true\n    post_id?: true\n    author_id?: true\n    parent_comment_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    upvote_count?: true\n    downvote_count?: true\n  }\n\n  export type Reddit_clone_commentsMaxAggregateInputType = {\n    id?: true\n    post_id?: true\n    author_id?: true\n    parent_comment_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    upvote_count?: true\n    downvote_count?: true\n  }\n\n  export type Reddit_clone_commentsCountAggregateInputType = {\n    id?: true\n    post_id?: true\n    author_id?: true\n    parent_comment_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    upvote_count?: true\n    downvote_count?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_commentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_comments to aggregate.\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comments to fetch.\n     */\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_comments\n    **/\n    _count?: true | Reddit_clone_commentsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Reddit_clone_commentsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Reddit_clone_commentsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_commentsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_commentsMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_commentsAggregateType<T extends Reddit_clone_commentsAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_comments]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_comments[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_comments[P]>\n  }\n\n\n\n\n  export type reddit_clone_commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_commentsWhereInput\n    orderBy?: reddit_clone_commentsOrderByWithAggregationInput | reddit_clone_commentsOrderByWithAggregationInput[]\n    by: Reddit_clone_commentsScalarFieldEnum[] | Reddit_clone_commentsScalarFieldEnum\n    having?: reddit_clone_commentsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_commentsCountAggregateInputType | true\n    _avg?: Reddit_clone_commentsAvgAggregateInputType\n    _sum?: Reddit_clone_commentsSumAggregateInputType\n    _min?: Reddit_clone_commentsMinAggregateInputType\n    _max?: Reddit_clone_commentsMaxAggregateInputType\n  }\n\n  export type Reddit_clone_commentsGroupByOutputType = {\n    id: string\n    post_id: string\n    author_id: string\n    parent_comment_id: string | null\n    content: string\n    created_at: Date\n    updated_at: Date\n    upvote_count: number\n    downvote_count: number\n    _count: Reddit_clone_commentsCountAggregateOutputType | null\n    _avg: Reddit_clone_commentsAvgAggregateOutputType | null\n    _sum: Reddit_clone_commentsSumAggregateOutputType | null\n    _min: Reddit_clone_commentsMinAggregateOutputType | null\n    _max: Reddit_clone_commentsMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_commentsGroupByPayload<T extends reddit_clone_commentsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_commentsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_commentsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_commentsGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_commentsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    post_id?: boolean\n    author_id?: boolean\n    parent_comment_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n    recursive?: boolean | reddit_clone_comments$recursiveArgs<ExtArgs>\n    reddit_clone_comment_votes?: boolean | reddit_clone_comments$reddit_clone_comment_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_commentsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comments\"]>\n\n  export type reddit_clone_commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    post_id?: boolean\n    author_id?: boolean\n    parent_comment_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comments\"]>\n\n  export type reddit_clone_commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    post_id?: boolean\n    author_id?: boolean\n    parent_comment_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comments\"]>\n\n  export type reddit_clone_commentsSelectScalar = {\n    id?: boolean\n    post_id?: boolean\n    author_id?: boolean\n    parent_comment_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    upvote_count?: boolean\n    downvote_count?: boolean\n  }\n\n  export type reddit_clone_commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"post_id\" | \"author_id\" | \"parent_comment_id\" | \"content\" | \"created_at\" | \"updated_at\" | \"upvote_count\" | \"downvote_count\", ExtArgs[\"result\"][\"reddit_clone_comments\"]>\n  export type reddit_clone_commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n    recursive?: boolean | reddit_clone_comments$recursiveArgs<ExtArgs>\n    reddit_clone_comment_votes?: boolean | reddit_clone_comments$reddit_clone_comment_votesArgs<ExtArgs>\n    _count?: boolean | Reddit_clone_commentsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n  }\n  export type reddit_clone_commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n    author?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    parent?: boolean | reddit_clone_comments$parentArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_comments\"\n    objects: {\n      post: Prisma.$reddit_clone_postsPayload<ExtArgs>\n      author: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      parent: Prisma.$reddit_clone_commentsPayload<ExtArgs> | null\n      recursive: Prisma.$reddit_clone_commentsPayload<ExtArgs>[]\n      reddit_clone_comment_votes: Prisma.$reddit_clone_comment_votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * The post this comment belongs to. {@link reddit_clone_posts.id}.\n       */\n      post_id: string\n      /**\n       * The author who created the comment. {@link reddit_clone_member.id}.\n       */\n      author_id: string\n      /**\n       * The parent comment ID for nested replies (null for top-level comments).\n       * {@link reddit_clone_comments.id}.\n       */\n      parent_comment_id: string | null\n      /**\n       * The content of the comment.\n       */\n      content: string\n      /**\n       * When the comment was created.\n       */\n      created_at: Date\n      /**\n       * When the comment was last updated.\n       */\n      updated_at: Date\n      /**\n       * The number of upvotes the comment has received.\n       */\n      upvote_count: number\n      /**\n       * The number of downvotes the comment has received.\n       */\n      downvote_count: number\n    }, ExtArgs[\"result\"][\"reddit_clone_comments\"]>\n    composites: {}\n  }\n\n  type reddit_clone_commentsGetPayload<S extends boolean | null | undefined | reddit_clone_commentsDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_commentsPayload, S>\n\n  type reddit_clone_commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_commentsCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_comments'], meta: { name: 'reddit_clone_comments' } }\n    /**\n     * Find zero or one Reddit_clone_comments that matches the filter.\n     * @param {reddit_clone_commentsFindUniqueArgs} args - Arguments to find a Reddit_clone_comments\n     * @example\n     * // Get one Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_commentsFindUniqueArgs>(args: SelectSubset<T, reddit_clone_commentsFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_comments that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_commentsFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_comments\n     * @example\n     * // Get one Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsFindFirstArgs} args - Arguments to find a Reddit_clone_comments\n     * @example\n     * // Get one Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_commentsFindFirstArgs>(args?: SelectSubset<T, reddit_clone_commentsFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_comments that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_comments\n     * @example\n     * // Get one Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findMany()\n     * \n     * // Get first 10 Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_commentsWithIdOnly = await prisma.reddit_clone_comments.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_commentsFindManyArgs>(args?: SelectSubset<T, reddit_clone_commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_comments.\n     * @param {reddit_clone_commentsCreateArgs} args - Arguments to create a Reddit_clone_comments.\n     * @example\n     * // Create one Reddit_clone_comments\n     * const Reddit_clone_comments = await prisma.reddit_clone_comments.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_comments\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_commentsCreateArgs>(args: SelectSubset<T, reddit_clone_commentsCreateArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_comments.\n     * @param {reddit_clone_commentsCreateManyArgs} args - Arguments to create many Reddit_clone_comments.\n     * @example\n     * // Create many Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_commentsCreateManyArgs>(args?: SelectSubset<T, reddit_clone_commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_comments and returns the data saved in the database.\n     * @param {reddit_clone_commentsCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_comments.\n     * @example\n     * // Create many Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_comments and only return the `id`\n     * const reddit_clone_commentsWithIdOnly = await prisma.reddit_clone_comments.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_comments.\n     * @param {reddit_clone_commentsDeleteArgs} args - Arguments to delete one Reddit_clone_comments.\n     * @example\n     * // Delete one Reddit_clone_comments\n     * const Reddit_clone_comments = await prisma.reddit_clone_comments.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_comments\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_commentsDeleteArgs>(args: SelectSubset<T, reddit_clone_commentsDeleteArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_comments.\n     * @param {reddit_clone_commentsUpdateArgs} args - Arguments to update one Reddit_clone_comments.\n     * @example\n     * // Update one Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_commentsUpdateArgs>(args: SelectSubset<T, reddit_clone_commentsUpdateArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_comments.\n     * @param {reddit_clone_commentsDeleteManyArgs} args - Arguments to filter Reddit_clone_comments to delete.\n     * @example\n     * // Delete a few Reddit_clone_comments\n     * const { count } = await prisma.reddit_clone_comments.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_commentsDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_commentsUpdateManyArgs>(args: SelectSubset<T, reddit_clone_commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_comments and returns the data updated in the database.\n     * @param {reddit_clone_commentsUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_comments.\n     * @example\n     * // Update many Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_comments and only return the `id`\n     * const reddit_clone_commentsWithIdOnly = await prisma.reddit_clone_comments.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_comments.\n     * @param {reddit_clone_commentsUpsertArgs} args - Arguments to update or create a Reddit_clone_comments.\n     * @example\n     * // Update or create a Reddit_clone_comments\n     * const reddit_clone_comments = await prisma.reddit_clone_comments.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_comments\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_comments we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_commentsUpsertArgs>(args: SelectSubset<T, reddit_clone_commentsUpsertArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsCountArgs} args - Arguments to filter Reddit_clone_comments to count.\n     * @example\n     * // Count the number of Reddit_clone_comments\n     * const count = await prisma.reddit_clone_comments.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_comments we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_commentsCountArgs>(\n      args?: Subset<T, reddit_clone_commentsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_commentsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_commentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_commentsAggregateArgs>(args: Subset<T, Reddit_clone_commentsAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_commentsAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_commentsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_commentsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_commentsGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_commentsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_commentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_comments model\n   */\n  readonly fields: reddit_clone_commentsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_comments.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    post<T extends reddit_clone_postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_postsDefaultArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    author<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    parent<T extends reddit_clone_comments$parentArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_comments$parentArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    recursive<T extends reddit_clone_comments$recursiveArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_comments$recursiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    reddit_clone_comment_votes<T extends reddit_clone_comments$reddit_clone_comment_votesArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_comments$reddit_clone_comment_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_comments model\n   */\n  interface reddit_clone_commentsFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_comments\", 'String'>\n    readonly post_id: FieldRef<\"reddit_clone_comments\", 'String'>\n    readonly author_id: FieldRef<\"reddit_clone_comments\", 'String'>\n    readonly parent_comment_id: FieldRef<\"reddit_clone_comments\", 'String'>\n    readonly content: FieldRef<\"reddit_clone_comments\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_comments\", 'DateTime'>\n    readonly updated_at: FieldRef<\"reddit_clone_comments\", 'DateTime'>\n    readonly upvote_count: FieldRef<\"reddit_clone_comments\", 'Int'>\n    readonly downvote_count: FieldRef<\"reddit_clone_comments\", 'Int'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_comments findUnique\n   */\n  export type reddit_clone_commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comments to fetch.\n     */\n    where: reddit_clone_commentsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comments findUniqueOrThrow\n   */\n  export type reddit_clone_commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comments to fetch.\n     */\n    where: reddit_clone_commentsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comments findFirst\n   */\n  export type reddit_clone_commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comments to fetch.\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comments to fetch.\n     */\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_comments.\n     */\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_comments.\n     */\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comments findFirstOrThrow\n   */\n  export type reddit_clone_commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comments to fetch.\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comments to fetch.\n     */\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_comments.\n     */\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_comments.\n     */\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comments findMany\n   */\n  export type reddit_clone_commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comments to fetch.\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comments to fetch.\n     */\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_comments.\n     */\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comments.\n     */\n    skip?: number\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comments create\n   */\n  export type reddit_clone_commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_comments.\n     */\n    data: XOR<reddit_clone_commentsCreateInput, reddit_clone_commentsUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_comments createMany\n   */\n  export type reddit_clone_commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_comments.\n     */\n    data: reddit_clone_commentsCreateManyInput | reddit_clone_commentsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_comments createManyAndReturn\n   */\n  export type reddit_clone_commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_comments.\n     */\n    data: reddit_clone_commentsCreateManyInput | reddit_clone_commentsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_comments update\n   */\n  export type reddit_clone_commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_comments.\n     */\n    data: XOR<reddit_clone_commentsUpdateInput, reddit_clone_commentsUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_comments to update.\n     */\n    where: reddit_clone_commentsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comments updateMany\n   */\n  export type reddit_clone_commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_comments.\n     */\n    data: XOR<reddit_clone_commentsUpdateManyMutationInput, reddit_clone_commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_comments to update\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * Limit how many reddit_clone_comments to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_comments updateManyAndReturn\n   */\n  export type reddit_clone_commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_comments.\n     */\n    data: XOR<reddit_clone_commentsUpdateManyMutationInput, reddit_clone_commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_comments to update\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * Limit how many reddit_clone_comments to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_comments upsert\n   */\n  export type reddit_clone_commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_comments to update in case it exists.\n     */\n    where: reddit_clone_commentsWhereUniqueInput\n    /**\n     * In case the reddit_clone_comments found by the `where` argument doesn't exist, create a new reddit_clone_comments with this data.\n     */\n    create: XOR<reddit_clone_commentsCreateInput, reddit_clone_commentsUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_comments was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_commentsUpdateInput, reddit_clone_commentsUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_comments delete\n   */\n  export type reddit_clone_commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_comments to delete.\n     */\n    where: reddit_clone_commentsWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comments deleteMany\n   */\n  export type reddit_clone_commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_comments to delete\n     */\n    where?: reddit_clone_commentsWhereInput\n    /**\n     * Limit how many reddit_clone_comments to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_comments.parent\n   */\n  export type reddit_clone_comments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  /**\n   * reddit_clone_comments.recursive\n   */\n  export type reddit_clone_comments$recursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n    where?: reddit_clone_commentsWhereInput\n    orderBy?: reddit_clone_commentsOrderByWithRelationInput | reddit_clone_commentsOrderByWithRelationInput[]\n    cursor?: reddit_clone_commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_commentsScalarFieldEnum | Reddit_clone_commentsScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comments.reddit_clone_comment_votes\n   */\n  export type reddit_clone_comments$reddit_clone_comment_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    where?: reddit_clone_comment_votesWhereInput\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Reddit_clone_comment_votesScalarFieldEnum | Reddit_clone_comment_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comments without action\n   */\n  export type reddit_clone_commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comments\n     */\n    select?: reddit_clone_commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comments\n     */\n    omit?: reddit_clone_commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_commentsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_post_votes\n   */\n\n  export type AggregateReddit_clone_post_votes = {\n    _count: Reddit_clone_post_votesCountAggregateOutputType | null\n    _min: Reddit_clone_post_votesMinAggregateOutputType | null\n    _max: Reddit_clone_post_votesMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_post_votesMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    vote_type: string | null\n    created_at: Date | null\n  }\n\n  export type Reddit_clone_post_votesMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    vote_type: string | null\n    created_at: Date | null\n  }\n\n  export type Reddit_clone_post_votesCountAggregateOutputType = {\n    id: number\n    user_id: number\n    post_id: number\n    vote_type: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_post_votesMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    vote_type?: true\n    created_at?: true\n  }\n\n  export type Reddit_clone_post_votesMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    vote_type?: true\n    created_at?: true\n  }\n\n  export type Reddit_clone_post_votesCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    vote_type?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_post_votesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_post_votes to aggregate.\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_post_votes to fetch.\n     */\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_post_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_post_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_post_votes\n    **/\n    _count?: true | Reddit_clone_post_votesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_post_votesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_post_votesMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_post_votesAggregateType<T extends Reddit_clone_post_votesAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_post_votes]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_post_votes[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_post_votes[P]>\n  }\n\n\n\n\n  export type reddit_clone_post_votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_post_votesWhereInput\n    orderBy?: reddit_clone_post_votesOrderByWithAggregationInput | reddit_clone_post_votesOrderByWithAggregationInput[]\n    by: Reddit_clone_post_votesScalarFieldEnum[] | Reddit_clone_post_votesScalarFieldEnum\n    having?: reddit_clone_post_votesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_post_votesCountAggregateInputType | true\n    _min?: Reddit_clone_post_votesMinAggregateInputType\n    _max?: Reddit_clone_post_votesMaxAggregateInputType\n  }\n\n  export type Reddit_clone_post_votesGroupByOutputType = {\n    id: string\n    user_id: string\n    post_id: string\n    vote_type: string\n    created_at: Date\n    _count: Reddit_clone_post_votesCountAggregateOutputType | null\n    _min: Reddit_clone_post_votesMinAggregateOutputType | null\n    _max: Reddit_clone_post_votesMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_post_votesGroupByPayload<T extends reddit_clone_post_votesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_post_votesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_post_votesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_post_votesGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_post_votesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_post_votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_post_votes\"]>\n\n  export type reddit_clone_post_votesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_post_votes\"]>\n\n  export type reddit_clone_post_votesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_post_votes\"]>\n\n  export type reddit_clone_post_votesSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n  }\n\n  export type reddit_clone_post_votesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"post_id\" | \"vote_type\" | \"created_at\", ExtArgs[\"result\"][\"reddit_clone_post_votes\"]>\n  export type reddit_clone_post_votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_post_votesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_post_votesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    post?: boolean | reddit_clone_postsDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_post_votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_post_votes\"\n    objects: {\n      user: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      post: Prisma.$reddit_clone_postsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * User who cast the vote. {@link reddit_clone_member.id}.\n       */\n      user_id: string\n      /**\n       * Post that received the vote. {@link reddit_clone_posts.id}.\n       */\n      post_id: string\n      /**\n       * Type of vote (upvote or downvote).\n       */\n      vote_type: string\n      /**\n       * Timestamp when the vote was cast.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_post_votes\"]>\n    composites: {}\n  }\n\n  type reddit_clone_post_votesGetPayload<S extends boolean | null | undefined | reddit_clone_post_votesDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_post_votesPayload, S>\n\n  type reddit_clone_post_votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_post_votesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_post_votesCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_post_votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_post_votes'], meta: { name: 'reddit_clone_post_votes' } }\n    /**\n     * Find zero or one Reddit_clone_post_votes that matches the filter.\n     * @param {reddit_clone_post_votesFindUniqueArgs} args - Arguments to find a Reddit_clone_post_votes\n     * @example\n     * // Get one Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_post_votesFindUniqueArgs>(args: SelectSubset<T, reddit_clone_post_votesFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_post_votes that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_post_votesFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_post_votes\n     * @example\n     * // Get one Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_post_votesFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_post_votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_post_votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesFindFirstArgs} args - Arguments to find a Reddit_clone_post_votes\n     * @example\n     * // Get one Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_post_votesFindFirstArgs>(args?: SelectSubset<T, reddit_clone_post_votesFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_post_votes that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_post_votes\n     * @example\n     * // Get one Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_post_votesFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_post_votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_post_votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findMany()\n     * \n     * // Get first 10 Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_post_votesWithIdOnly = await prisma.reddit_clone_post_votes.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_post_votesFindManyArgs>(args?: SelectSubset<T, reddit_clone_post_votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesCreateArgs} args - Arguments to create a Reddit_clone_post_votes.\n     * @example\n     * // Create one Reddit_clone_post_votes\n     * const Reddit_clone_post_votes = await prisma.reddit_clone_post_votes.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_post_votes\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_post_votesCreateArgs>(args: SelectSubset<T, reddit_clone_post_votesCreateArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesCreateManyArgs} args - Arguments to create many Reddit_clone_post_votes.\n     * @example\n     * // Create many Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_post_votesCreateManyArgs>(args?: SelectSubset<T, reddit_clone_post_votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_post_votes and returns the data saved in the database.\n     * @param {reddit_clone_post_votesCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_post_votes.\n     * @example\n     * // Create many Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_post_votes and only return the `id`\n     * const reddit_clone_post_votesWithIdOnly = await prisma.reddit_clone_post_votes.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_post_votesCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_post_votesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesDeleteArgs} args - Arguments to delete one Reddit_clone_post_votes.\n     * @example\n     * // Delete one Reddit_clone_post_votes\n     * const Reddit_clone_post_votes = await prisma.reddit_clone_post_votes.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_post_votes\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_post_votesDeleteArgs>(args: SelectSubset<T, reddit_clone_post_votesDeleteArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesUpdateArgs} args - Arguments to update one Reddit_clone_post_votes.\n     * @example\n     * // Update one Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_post_votesUpdateArgs>(args: SelectSubset<T, reddit_clone_post_votesUpdateArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesDeleteManyArgs} args - Arguments to filter Reddit_clone_post_votes to delete.\n     * @example\n     * // Delete a few Reddit_clone_post_votes\n     * const { count } = await prisma.reddit_clone_post_votes.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_post_votesDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_post_votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_post_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_post_votesUpdateManyArgs>(args: SelectSubset<T, reddit_clone_post_votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_post_votes and returns the data updated in the database.\n     * @param {reddit_clone_post_votesUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_post_votes.\n     * @example\n     * // Update many Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_post_votes and only return the `id`\n     * const reddit_clone_post_votesWithIdOnly = await prisma.reddit_clone_post_votes.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_post_votesUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_post_votesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_post_votes.\n     * @param {reddit_clone_post_votesUpsertArgs} args - Arguments to update or create a Reddit_clone_post_votes.\n     * @example\n     * // Update or create a Reddit_clone_post_votes\n     * const reddit_clone_post_votes = await prisma.reddit_clone_post_votes.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_post_votes\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_post_votes we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_post_votesUpsertArgs>(args: SelectSubset<T, reddit_clone_post_votesUpsertArgs<ExtArgs>>): Prisma__reddit_clone_post_votesClient<$Result.GetResult<Prisma.$reddit_clone_post_votesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_post_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesCountArgs} args - Arguments to filter Reddit_clone_post_votes to count.\n     * @example\n     * // Count the number of Reddit_clone_post_votes\n     * const count = await prisma.reddit_clone_post_votes.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_post_votes we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_post_votesCountArgs>(\n      args?: Subset<T, reddit_clone_post_votesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_post_votesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_post_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_post_votesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_post_votesAggregateArgs>(args: Subset<T, Reddit_clone_post_votesAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_post_votesAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_post_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_post_votesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_post_votesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_post_votesGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_post_votesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_post_votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_post_votesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_post_votes model\n   */\n  readonly fields: reddit_clone_post_votesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_post_votes.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_post_votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    post<T extends reddit_clone_postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_postsDefaultArgs<ExtArgs>>): Prisma__reddit_clone_postsClient<$Result.GetResult<Prisma.$reddit_clone_postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_post_votes model\n   */\n  interface reddit_clone_post_votesFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_post_votes\", 'String'>\n    readonly user_id: FieldRef<\"reddit_clone_post_votes\", 'String'>\n    readonly post_id: FieldRef<\"reddit_clone_post_votes\", 'String'>\n    readonly vote_type: FieldRef<\"reddit_clone_post_votes\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_post_votes\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_post_votes findUnique\n   */\n  export type reddit_clone_post_votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_post_votes to fetch.\n     */\n    where: reddit_clone_post_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_post_votes findUniqueOrThrow\n   */\n  export type reddit_clone_post_votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_post_votes to fetch.\n     */\n    where: reddit_clone_post_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_post_votes findFirst\n   */\n  export type reddit_clone_post_votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_post_votes to fetch.\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_post_votes to fetch.\n     */\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_post_votes.\n     */\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_post_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_post_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_post_votes.\n     */\n    distinct?: Reddit_clone_post_votesScalarFieldEnum | Reddit_clone_post_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_post_votes findFirstOrThrow\n   */\n  export type reddit_clone_post_votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_post_votes to fetch.\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_post_votes to fetch.\n     */\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_post_votes.\n     */\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_post_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_post_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_post_votes.\n     */\n    distinct?: Reddit_clone_post_votesScalarFieldEnum | Reddit_clone_post_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_post_votes findMany\n   */\n  export type reddit_clone_post_votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_post_votes to fetch.\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_post_votes to fetch.\n     */\n    orderBy?: reddit_clone_post_votesOrderByWithRelationInput | reddit_clone_post_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_post_votes.\n     */\n    cursor?: reddit_clone_post_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_post_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_post_votes.\n     */\n    skip?: number\n    distinct?: Reddit_clone_post_votesScalarFieldEnum | Reddit_clone_post_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_post_votes create\n   */\n  export type reddit_clone_post_votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_post_votes.\n     */\n    data: XOR<reddit_clone_post_votesCreateInput, reddit_clone_post_votesUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_post_votes createMany\n   */\n  export type reddit_clone_post_votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_post_votes.\n     */\n    data: reddit_clone_post_votesCreateManyInput | reddit_clone_post_votesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_post_votes createManyAndReturn\n   */\n  export type reddit_clone_post_votesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_post_votes.\n     */\n    data: reddit_clone_post_votesCreateManyInput | reddit_clone_post_votesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_post_votes update\n   */\n  export type reddit_clone_post_votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_post_votes.\n     */\n    data: XOR<reddit_clone_post_votesUpdateInput, reddit_clone_post_votesUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_post_votes to update.\n     */\n    where: reddit_clone_post_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_post_votes updateMany\n   */\n  export type reddit_clone_post_votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_post_votes.\n     */\n    data: XOR<reddit_clone_post_votesUpdateManyMutationInput, reddit_clone_post_votesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_post_votes to update\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * Limit how many reddit_clone_post_votes to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_post_votes updateManyAndReturn\n   */\n  export type reddit_clone_post_votesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_post_votes.\n     */\n    data: XOR<reddit_clone_post_votesUpdateManyMutationInput, reddit_clone_post_votesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_post_votes to update\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * Limit how many reddit_clone_post_votes to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_post_votes upsert\n   */\n  export type reddit_clone_post_votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_post_votes to update in case it exists.\n     */\n    where: reddit_clone_post_votesWhereUniqueInput\n    /**\n     * In case the reddit_clone_post_votes found by the `where` argument doesn't exist, create a new reddit_clone_post_votes with this data.\n     */\n    create: XOR<reddit_clone_post_votesCreateInput, reddit_clone_post_votesUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_post_votes was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_post_votesUpdateInput, reddit_clone_post_votesUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_post_votes delete\n   */\n  export type reddit_clone_post_votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_post_votes to delete.\n     */\n    where: reddit_clone_post_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_post_votes deleteMany\n   */\n  export type reddit_clone_post_votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_post_votes to delete\n     */\n    where?: reddit_clone_post_votesWhereInput\n    /**\n     * Limit how many reddit_clone_post_votes to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_post_votes without action\n   */\n  export type reddit_clone_post_votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_post_votes\n     */\n    select?: reddit_clone_post_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_post_votes\n     */\n    omit?: reddit_clone_post_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_post_votesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model reddit_clone_comment_votes\n   */\n\n  export type AggregateReddit_clone_comment_votes = {\n    _count: Reddit_clone_comment_votesCountAggregateOutputType | null\n    _min: Reddit_clone_comment_votesMinAggregateOutputType | null\n    _max: Reddit_clone_comment_votesMaxAggregateOutputType | null\n  }\n\n  export type Reddit_clone_comment_votesMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    comment_id: string | null\n    vote_type: string | null\n    created_at: Date | null\n  }\n\n  export type Reddit_clone_comment_votesMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    comment_id: string | null\n    vote_type: string | null\n    created_at: Date | null\n  }\n\n  export type Reddit_clone_comment_votesCountAggregateOutputType = {\n    id: number\n    user_id: number\n    comment_id: number\n    vote_type: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Reddit_clone_comment_votesMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    comment_id?: true\n    vote_type?: true\n    created_at?: true\n  }\n\n  export type Reddit_clone_comment_votesMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    comment_id?: true\n    vote_type?: true\n    created_at?: true\n  }\n\n  export type Reddit_clone_comment_votesCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    comment_id?: true\n    vote_type?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Reddit_clone_comment_votesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_comment_votes to aggregate.\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comment_votes to fetch.\n     */\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comment_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comment_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned reddit_clone_comment_votes\n    **/\n    _count?: true | Reddit_clone_comment_votesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Reddit_clone_comment_votesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Reddit_clone_comment_votesMaxAggregateInputType\n  }\n\n  export type GetReddit_clone_comment_votesAggregateType<T extends Reddit_clone_comment_votesAggregateArgs> = {\n        [P in keyof T & keyof AggregateReddit_clone_comment_votes]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateReddit_clone_comment_votes[P]>\n      : GetScalarType<T[P], AggregateReddit_clone_comment_votes[P]>\n  }\n\n\n\n\n  export type reddit_clone_comment_votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: reddit_clone_comment_votesWhereInput\n    orderBy?: reddit_clone_comment_votesOrderByWithAggregationInput | reddit_clone_comment_votesOrderByWithAggregationInput[]\n    by: Reddit_clone_comment_votesScalarFieldEnum[] | Reddit_clone_comment_votesScalarFieldEnum\n    having?: reddit_clone_comment_votesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Reddit_clone_comment_votesCountAggregateInputType | true\n    _min?: Reddit_clone_comment_votesMinAggregateInputType\n    _max?: Reddit_clone_comment_votesMaxAggregateInputType\n  }\n\n  export type Reddit_clone_comment_votesGroupByOutputType = {\n    id: string\n    user_id: string\n    comment_id: string\n    vote_type: string\n    created_at: Date\n    _count: Reddit_clone_comment_votesCountAggregateOutputType | null\n    _min: Reddit_clone_comment_votesMinAggregateOutputType | null\n    _max: Reddit_clone_comment_votesMaxAggregateOutputType | null\n  }\n\n  type GetReddit_clone_comment_votesGroupByPayload<T extends reddit_clone_comment_votesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Reddit_clone_comment_votesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Reddit_clone_comment_votesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Reddit_clone_comment_votesGroupByOutputType[P]>\n            : GetScalarType<T[P], Reddit_clone_comment_votesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type reddit_clone_comment_votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    comment_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comment_votes\"]>\n\n  export type reddit_clone_comment_votesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    comment_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comment_votes\"]>\n\n  export type reddit_clone_comment_votesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    comment_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"reddit_clone_comment_votes\"]>\n\n  export type reddit_clone_comment_votesSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    comment_id?: boolean\n    vote_type?: boolean\n    created_at?: boolean\n  }\n\n  export type reddit_clone_comment_votesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"comment_id\" | \"vote_type\" | \"created_at\", ExtArgs[\"result\"][\"reddit_clone_comment_votes\"]>\n  export type reddit_clone_comment_votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_comment_votesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }\n  export type reddit_clone_comment_votesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | reddit_clone_memberDefaultArgs<ExtArgs>\n    comment?: boolean | reddit_clone_commentsDefaultArgs<ExtArgs>\n  }\n\n  export type $reddit_clone_comment_votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"reddit_clone_comment_votes\"\n    objects: {\n      user: Prisma.$reddit_clone_memberPayload<ExtArgs>\n      comment: Prisma.$reddit_clone_commentsPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * User who cast the vote. {@link reddit_clone_member.id}.\n       */\n      user_id: string\n      /**\n       * Comment that received the vote. {@link reddit_clone_comments.id}.\n       */\n      comment_id: string\n      /**\n       * Type of vote (upvote or downvote).\n       */\n      vote_type: string\n      /**\n       * Timestamp when the vote was cast.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"reddit_clone_comment_votes\"]>\n    composites: {}\n  }\n\n  type reddit_clone_comment_votesGetPayload<S extends boolean | null | undefined | reddit_clone_comment_votesDefaultArgs> = $Result.GetResult<Prisma.$reddit_clone_comment_votesPayload, S>\n\n  type reddit_clone_comment_votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<reddit_clone_comment_votesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Reddit_clone_comment_votesCountAggregateInputType | true\n    }\n\n  export interface reddit_clone_comment_votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reddit_clone_comment_votes'], meta: { name: 'reddit_clone_comment_votes' } }\n    /**\n     * Find zero or one Reddit_clone_comment_votes that matches the filter.\n     * @param {reddit_clone_comment_votesFindUniqueArgs} args - Arguments to find a Reddit_clone_comment_votes\n     * @example\n     * // Get one Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends reddit_clone_comment_votesFindUniqueArgs>(args: SelectSubset<T, reddit_clone_comment_votesFindUniqueArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Reddit_clone_comment_votes that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {reddit_clone_comment_votesFindUniqueOrThrowArgs} args - Arguments to find a Reddit_clone_comment_votes\n     * @example\n     * // Get one Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends reddit_clone_comment_votesFindUniqueOrThrowArgs>(args: SelectSubset<T, reddit_clone_comment_votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_comment_votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesFindFirstArgs} args - Arguments to find a Reddit_clone_comment_votes\n     * @example\n     * // Get one Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends reddit_clone_comment_votesFindFirstArgs>(args?: SelectSubset<T, reddit_clone_comment_votesFindFirstArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Reddit_clone_comment_votes that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesFindFirstOrThrowArgs} args - Arguments to find a Reddit_clone_comment_votes\n     * @example\n     * // Get one Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends reddit_clone_comment_votesFindFirstOrThrowArgs>(args?: SelectSubset<T, reddit_clone_comment_votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Reddit_clone_comment_votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findMany()\n     * \n     * // Get first 10 Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const reddit_clone_comment_votesWithIdOnly = await prisma.reddit_clone_comment_votes.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends reddit_clone_comment_votesFindManyArgs>(args?: SelectSubset<T, reddit_clone_comment_votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesCreateArgs} args - Arguments to create a Reddit_clone_comment_votes.\n     * @example\n     * // Create one Reddit_clone_comment_votes\n     * const Reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.create({\n     *   data: {\n     *     // ... data to create a Reddit_clone_comment_votes\n     *   }\n     * })\n     * \n     */\n    create<T extends reddit_clone_comment_votesCreateArgs>(args: SelectSubset<T, reddit_clone_comment_votesCreateArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesCreateManyArgs} args - Arguments to create many Reddit_clone_comment_votes.\n     * @example\n     * // Create many Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends reddit_clone_comment_votesCreateManyArgs>(args?: SelectSubset<T, reddit_clone_comment_votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Reddit_clone_comment_votes and returns the data saved in the database.\n     * @param {reddit_clone_comment_votesCreateManyAndReturnArgs} args - Arguments to create many Reddit_clone_comment_votes.\n     * @example\n     * // Create many Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Reddit_clone_comment_votes and only return the `id`\n     * const reddit_clone_comment_votesWithIdOnly = await prisma.reddit_clone_comment_votes.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends reddit_clone_comment_votesCreateManyAndReturnArgs>(args?: SelectSubset<T, reddit_clone_comment_votesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesDeleteArgs} args - Arguments to delete one Reddit_clone_comment_votes.\n     * @example\n     * // Delete one Reddit_clone_comment_votes\n     * const Reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.delete({\n     *   where: {\n     *     // ... filter to delete one Reddit_clone_comment_votes\n     *   }\n     * })\n     * \n     */\n    delete<T extends reddit_clone_comment_votesDeleteArgs>(args: SelectSubset<T, reddit_clone_comment_votesDeleteArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesUpdateArgs} args - Arguments to update one Reddit_clone_comment_votes.\n     * @example\n     * // Update one Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends reddit_clone_comment_votesUpdateArgs>(args: SelectSubset<T, reddit_clone_comment_votesUpdateArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesDeleteManyArgs} args - Arguments to filter Reddit_clone_comment_votes to delete.\n     * @example\n     * // Delete a few Reddit_clone_comment_votes\n     * const { count } = await prisma.reddit_clone_comment_votes.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends reddit_clone_comment_votesDeleteManyArgs>(args?: SelectSubset<T, reddit_clone_comment_votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_comment_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends reddit_clone_comment_votesUpdateManyArgs>(args: SelectSubset<T, reddit_clone_comment_votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Reddit_clone_comment_votes and returns the data updated in the database.\n     * @param {reddit_clone_comment_votesUpdateManyAndReturnArgs} args - Arguments to update many Reddit_clone_comment_votes.\n     * @example\n     * // Update many Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Reddit_clone_comment_votes and only return the `id`\n     * const reddit_clone_comment_votesWithIdOnly = await prisma.reddit_clone_comment_votes.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends reddit_clone_comment_votesUpdateManyAndReturnArgs>(args: SelectSubset<T, reddit_clone_comment_votesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Reddit_clone_comment_votes.\n     * @param {reddit_clone_comment_votesUpsertArgs} args - Arguments to update or create a Reddit_clone_comment_votes.\n     * @example\n     * // Update or create a Reddit_clone_comment_votes\n     * const reddit_clone_comment_votes = await prisma.reddit_clone_comment_votes.upsert({\n     *   create: {\n     *     // ... data to create a Reddit_clone_comment_votes\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Reddit_clone_comment_votes we want to update\n     *   }\n     * })\n     */\n    upsert<T extends reddit_clone_comment_votesUpsertArgs>(args: SelectSubset<T, reddit_clone_comment_votesUpsertArgs<ExtArgs>>): Prisma__reddit_clone_comment_votesClient<$Result.GetResult<Prisma.$reddit_clone_comment_votesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Reddit_clone_comment_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesCountArgs} args - Arguments to filter Reddit_clone_comment_votes to count.\n     * @example\n     * // Count the number of Reddit_clone_comment_votes\n     * const count = await prisma.reddit_clone_comment_votes.count({\n     *   where: {\n     *     // ... the filter for the Reddit_clone_comment_votes we want to count\n     *   }\n     * })\n    **/\n    count<T extends reddit_clone_comment_votesCountArgs>(\n      args?: Subset<T, reddit_clone_comment_votesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Reddit_clone_comment_votesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Reddit_clone_comment_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Reddit_clone_comment_votesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Reddit_clone_comment_votesAggregateArgs>(args: Subset<T, Reddit_clone_comment_votesAggregateArgs>): Prisma.PrismaPromise<GetReddit_clone_comment_votesAggregateType<T>>\n\n    /**\n     * Group by Reddit_clone_comment_votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {reddit_clone_comment_votesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends reddit_clone_comment_votesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: reddit_clone_comment_votesGroupByArgs['orderBy'] }\n        : { orderBy?: reddit_clone_comment_votesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, reddit_clone_comment_votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReddit_clone_comment_votesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the reddit_clone_comment_votes model\n   */\n  readonly fields: reddit_clone_comment_votesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for reddit_clone_comment_votes.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__reddit_clone_comment_votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends reddit_clone_memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_memberDefaultArgs<ExtArgs>>): Prisma__reddit_clone_memberClient<$Result.GetResult<Prisma.$reddit_clone_memberPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    comment<T extends reddit_clone_commentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reddit_clone_commentsDefaultArgs<ExtArgs>>): Prisma__reddit_clone_commentsClient<$Result.GetResult<Prisma.$reddit_clone_commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the reddit_clone_comment_votes model\n   */\n  interface reddit_clone_comment_votesFieldRefs {\n    readonly id: FieldRef<\"reddit_clone_comment_votes\", 'String'>\n    readonly user_id: FieldRef<\"reddit_clone_comment_votes\", 'String'>\n    readonly comment_id: FieldRef<\"reddit_clone_comment_votes\", 'String'>\n    readonly vote_type: FieldRef<\"reddit_clone_comment_votes\", 'String'>\n    readonly created_at: FieldRef<\"reddit_clone_comment_votes\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * reddit_clone_comment_votes findUnique\n   */\n  export type reddit_clone_comment_votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comment_votes to fetch.\n     */\n    where: reddit_clone_comment_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comment_votes findUniqueOrThrow\n   */\n  export type reddit_clone_comment_votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comment_votes to fetch.\n     */\n    where: reddit_clone_comment_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comment_votes findFirst\n   */\n  export type reddit_clone_comment_votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comment_votes to fetch.\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comment_votes to fetch.\n     */\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_comment_votes.\n     */\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comment_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comment_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_comment_votes.\n     */\n    distinct?: Reddit_clone_comment_votesScalarFieldEnum | Reddit_clone_comment_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comment_votes findFirstOrThrow\n   */\n  export type reddit_clone_comment_votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comment_votes to fetch.\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comment_votes to fetch.\n     */\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for reddit_clone_comment_votes.\n     */\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comment_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comment_votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of reddit_clone_comment_votes.\n     */\n    distinct?: Reddit_clone_comment_votesScalarFieldEnum | Reddit_clone_comment_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comment_votes findMany\n   */\n  export type reddit_clone_comment_votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter, which reddit_clone_comment_votes to fetch.\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of reddit_clone_comment_votes to fetch.\n     */\n    orderBy?: reddit_clone_comment_votesOrderByWithRelationInput | reddit_clone_comment_votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing reddit_clone_comment_votes.\n     */\n    cursor?: reddit_clone_comment_votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` reddit_clone_comment_votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` reddit_clone_comment_votes.\n     */\n    skip?: number\n    distinct?: Reddit_clone_comment_votesScalarFieldEnum | Reddit_clone_comment_votesScalarFieldEnum[]\n  }\n\n  /**\n   * reddit_clone_comment_votes create\n   */\n  export type reddit_clone_comment_votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a reddit_clone_comment_votes.\n     */\n    data: XOR<reddit_clone_comment_votesCreateInput, reddit_clone_comment_votesUncheckedCreateInput>\n  }\n\n  /**\n   * reddit_clone_comment_votes createMany\n   */\n  export type reddit_clone_comment_votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many reddit_clone_comment_votes.\n     */\n    data: reddit_clone_comment_votesCreateManyInput | reddit_clone_comment_votesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * reddit_clone_comment_votes createManyAndReturn\n   */\n  export type reddit_clone_comment_votesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * The data used to create many reddit_clone_comment_votes.\n     */\n    data: reddit_clone_comment_votesCreateManyInput | reddit_clone_comment_votesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_comment_votes update\n   */\n  export type reddit_clone_comment_votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a reddit_clone_comment_votes.\n     */\n    data: XOR<reddit_clone_comment_votesUpdateInput, reddit_clone_comment_votesUncheckedUpdateInput>\n    /**\n     * Choose, which reddit_clone_comment_votes to update.\n     */\n    where: reddit_clone_comment_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comment_votes updateMany\n   */\n  export type reddit_clone_comment_votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update reddit_clone_comment_votes.\n     */\n    data: XOR<reddit_clone_comment_votesUpdateManyMutationInput, reddit_clone_comment_votesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_comment_votes to update\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * Limit how many reddit_clone_comment_votes to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_comment_votes updateManyAndReturn\n   */\n  export type reddit_clone_comment_votesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * The data used to update reddit_clone_comment_votes.\n     */\n    data: XOR<reddit_clone_comment_votesUpdateManyMutationInput, reddit_clone_comment_votesUncheckedUpdateManyInput>\n    /**\n     * Filter which reddit_clone_comment_votes to update\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * Limit how many reddit_clone_comment_votes to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * reddit_clone_comment_votes upsert\n   */\n  export type reddit_clone_comment_votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the reddit_clone_comment_votes to update in case it exists.\n     */\n    where: reddit_clone_comment_votesWhereUniqueInput\n    /**\n     * In case the reddit_clone_comment_votes found by the `where` argument doesn't exist, create a new reddit_clone_comment_votes with this data.\n     */\n    create: XOR<reddit_clone_comment_votesCreateInput, reddit_clone_comment_votesUncheckedCreateInput>\n    /**\n     * In case the reddit_clone_comment_votes was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<reddit_clone_comment_votesUpdateInput, reddit_clone_comment_votesUncheckedUpdateInput>\n  }\n\n  /**\n   * reddit_clone_comment_votes delete\n   */\n  export type reddit_clone_comment_votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n    /**\n     * Filter which reddit_clone_comment_votes to delete.\n     */\n    where: reddit_clone_comment_votesWhereUniqueInput\n  }\n\n  /**\n   * reddit_clone_comment_votes deleteMany\n   */\n  export type reddit_clone_comment_votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which reddit_clone_comment_votes to delete\n     */\n    where?: reddit_clone_comment_votesWhereInput\n    /**\n     * Limit how many reddit_clone_comment_votes to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * reddit_clone_comment_votes without action\n   */\n  export type reddit_clone_comment_votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the reddit_clone_comment_votes\n     */\n    select?: reddit_clone_comment_votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the reddit_clone_comment_votes\n     */\n    omit?: reddit_clone_comment_votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: reddit_clone_comment_votesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Reddit_clone_configurationsScalarFieldEnum: {\n    id: 'id',\n    key: 'key',\n    value: 'value',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Reddit_clone_configurationsScalarFieldEnum = (typeof Reddit_clone_configurationsScalarFieldEnum)[keyof typeof Reddit_clone_configurationsScalarFieldEnum]\n\n\n  export const Reddit_clone_guestScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Reddit_clone_guestScalarFieldEnum = (typeof Reddit_clone_guestScalarFieldEnum)[keyof typeof Reddit_clone_guestScalarFieldEnum]\n\n\n  export const Reddit_clone_memberScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    username: 'username',\n    karma: 'karma',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Reddit_clone_memberScalarFieldEnum = (typeof Reddit_clone_memberScalarFieldEnum)[keyof typeof Reddit_clone_memberScalarFieldEnum]\n\n\n  export const Reddit_clone_moderatorScalarFieldEnum: {\n    id: 'id',\n    member_id: 'member_id',\n    community_id: 'community_id',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Reddit_clone_moderatorScalarFieldEnum = (typeof Reddit_clone_moderatorScalarFieldEnum)[keyof typeof Reddit_clone_moderatorScalarFieldEnum]\n\n\n  export const Reddit_clone_adminScalarFieldEnum: {\n    id: 'id',\n    member_id: 'member_id',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Reddit_clone_adminScalarFieldEnum = (typeof Reddit_clone_adminScalarFieldEnum)[keyof typeof Reddit_clone_adminScalarFieldEnum]\n\n\n  export const Reddit_clone_communitiesScalarFieldEnum: {\n    id: 'id',\n    creator_id: 'creator_id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at',\n    is_nsfw: 'is_nsfw',\n    member_count: 'member_count'\n  };\n\n  export type Reddit_clone_communitiesScalarFieldEnum = (typeof Reddit_clone_communitiesScalarFieldEnum)[keyof typeof Reddit_clone_communitiesScalarFieldEnum]\n\n\n  export const Reddit_clone_community_subscriptionsScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    community_id: 'community_id',\n    subscribed_at: 'subscribed_at',\n    is_muted: 'is_muted'\n  };\n\n  export type Reddit_clone_community_subscriptionsScalarFieldEnum = (typeof Reddit_clone_community_subscriptionsScalarFieldEnum)[keyof typeof Reddit_clone_community_subscriptionsScalarFieldEnum]\n\n\n  export const Reddit_clone_postsScalarFieldEnum: {\n    id: 'id',\n    author_id: 'author_id',\n    community_id: 'community_id',\n    title: 'title',\n    content: 'content',\n    content_type: 'content_type',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    is_locked: 'is_locked',\n    is_nsfw: 'is_nsfw',\n    upvote_count: 'upvote_count',\n    downvote_count: 'downvote_count',\n    comment_count: 'comment_count'\n  };\n\n  export type Reddit_clone_postsScalarFieldEnum = (typeof Reddit_clone_postsScalarFieldEnum)[keyof typeof Reddit_clone_postsScalarFieldEnum]\n\n\n  export const Reddit_clone_commentsScalarFieldEnum: {\n    id: 'id',\n    post_id: 'post_id',\n    author_id: 'author_id',\n    parent_comment_id: 'parent_comment_id',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    upvote_count: 'upvote_count',\n    downvote_count: 'downvote_count'\n  };\n\n  export type Reddit_clone_commentsScalarFieldEnum = (typeof Reddit_clone_commentsScalarFieldEnum)[keyof typeof Reddit_clone_commentsScalarFieldEnum]\n\n\n  export const Reddit_clone_post_votesScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    post_id: 'post_id',\n    vote_type: 'vote_type',\n    created_at: 'created_at'\n  };\n\n  export type Reddit_clone_post_votesScalarFieldEnum = (typeof Reddit_clone_post_votesScalarFieldEnum)[keyof typeof Reddit_clone_post_votesScalarFieldEnum]\n\n\n  export const Reddit_clone_comment_votesScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    comment_id: 'comment_id',\n    vote_type: 'vote_type',\n    created_at: 'created_at'\n  };\n\n  export type Reddit_clone_comment_votesScalarFieldEnum = (typeof Reddit_clone_comment_votesScalarFieldEnum)[keyof typeof Reddit_clone_comment_votesScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type reddit_clone_configurationsWhereInput = {\n    AND?: reddit_clone_configurationsWhereInput | reddit_clone_configurationsWhereInput[]\n    OR?: reddit_clone_configurationsWhereInput[]\n    NOT?: reddit_clone_configurationsWhereInput | reddit_clone_configurationsWhereInput[]\n    id?: UuidFilter<\"reddit_clone_configurations\"> | string\n    key?: StringFilter<\"reddit_clone_configurations\"> | string\n    value?: StringFilter<\"reddit_clone_configurations\"> | string\n    description?: StringNullableFilter<\"reddit_clone_configurations\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_configurations\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_configurations\"> | Date | string\n  }\n\n  export type reddit_clone_configurationsOrderByWithRelationInput = {\n    id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_configurationsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    key?: string\n    AND?: reddit_clone_configurationsWhereInput | reddit_clone_configurationsWhereInput[]\n    OR?: reddit_clone_configurationsWhereInput[]\n    NOT?: reddit_clone_configurationsWhereInput | reddit_clone_configurationsWhereInput[]\n    value?: StringFilter<\"reddit_clone_configurations\"> | string\n    description?: StringNullableFilter<\"reddit_clone_configurations\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_configurations\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_configurations\"> | Date | string\n  }, \"id\" | \"key\">\n\n  export type reddit_clone_configurationsOrderByWithAggregationInput = {\n    id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: reddit_clone_configurationsCountOrderByAggregateInput\n    _max?: reddit_clone_configurationsMaxOrderByAggregateInput\n    _min?: reddit_clone_configurationsMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_configurationsScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_configurationsScalarWhereWithAggregatesInput | reddit_clone_configurationsScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_configurationsScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_configurationsScalarWhereWithAggregatesInput | reddit_clone_configurationsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_configurations\"> | string\n    key?: StringWithAggregatesFilter<\"reddit_clone_configurations\"> | string\n    value?: StringWithAggregatesFilter<\"reddit_clone_configurations\"> | string\n    description?: StringNullableWithAggregatesFilter<\"reddit_clone_configurations\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_configurations\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_configurations\"> | Date | string\n  }\n\n  export type reddit_clone_guestWhereInput = {\n    AND?: reddit_clone_guestWhereInput | reddit_clone_guestWhereInput[]\n    OR?: reddit_clone_guestWhereInput[]\n    NOT?: reddit_clone_guestWhereInput | reddit_clone_guestWhereInput[]\n    id?: UuidFilter<\"reddit_clone_guest\"> | string\n    email?: StringNullableFilter<\"reddit_clone_guest\"> | string | null\n    password_hash?: StringNullableFilter<\"reddit_clone_guest\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_guest\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_guest\"> | Date | string\n  }\n\n  export type reddit_clone_guestOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrderInput | SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_guestWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: reddit_clone_guestWhereInput | reddit_clone_guestWhereInput[]\n    OR?: reddit_clone_guestWhereInput[]\n    NOT?: reddit_clone_guestWhereInput | reddit_clone_guestWhereInput[]\n    password_hash?: StringNullableFilter<\"reddit_clone_guest\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_guest\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_guest\"> | Date | string\n  }, \"id\" | \"email\">\n\n  export type reddit_clone_guestOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrderInput | SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: reddit_clone_guestCountOrderByAggregateInput\n    _max?: reddit_clone_guestMaxOrderByAggregateInput\n    _min?: reddit_clone_guestMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_guestScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_guestScalarWhereWithAggregatesInput | reddit_clone_guestScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_guestScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_guestScalarWhereWithAggregatesInput | reddit_clone_guestScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_guest\"> | string\n    email?: StringNullableWithAggregatesFilter<\"reddit_clone_guest\"> | string | null\n    password_hash?: StringNullableWithAggregatesFilter<\"reddit_clone_guest\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_guest\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_guest\"> | Date | string\n  }\n\n  export type reddit_clone_memberWhereInput = {\n    AND?: reddit_clone_memberWhereInput | reddit_clone_memberWhereInput[]\n    OR?: reddit_clone_memberWhereInput[]\n    NOT?: reddit_clone_memberWhereInput | reddit_clone_memberWhereInput[]\n    id?: UuidFilter<\"reddit_clone_member\"> | string\n    email?: StringFilter<\"reddit_clone_member\"> | string\n    password_hash?: StringFilter<\"reddit_clone_member\"> | string\n    username?: StringFilter<\"reddit_clone_member\"> | string\n    karma?: IntFilter<\"reddit_clone_member\"> | number\n    created_at?: DateTimeFilter<\"reddit_clone_member\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_member\"> | Date | string\n    reddit_clone_moderator?: Reddit_clone_moderatorListRelationFilter\n    reddit_clone_admin?: Reddit_clone_adminListRelationFilter\n    reddit_clone_communities?: Reddit_clone_communitiesListRelationFilter\n    reddit_clone_community_subscriptions?: Reddit_clone_community_subscriptionsListRelationFilter\n    reddit_clone_posts?: Reddit_clone_postsListRelationFilter\n    reddit_clone_comments?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_post_votes?: Reddit_clone_post_votesListRelationFilter\n    reddit_clone_comment_votes?: Reddit_clone_comment_votesListRelationFilter\n  }\n\n  export type reddit_clone_memberOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    username?: SortOrder\n    karma?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    reddit_clone_moderator?: reddit_clone_moderatorOrderByRelationAggregateInput\n    reddit_clone_admin?: reddit_clone_adminOrderByRelationAggregateInput\n    reddit_clone_communities?: reddit_clone_communitiesOrderByRelationAggregateInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsOrderByRelationAggregateInput\n    reddit_clone_posts?: reddit_clone_postsOrderByRelationAggregateInput\n    reddit_clone_comments?: reddit_clone_commentsOrderByRelationAggregateInput\n    reddit_clone_post_votes?: reddit_clone_post_votesOrderByRelationAggregateInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesOrderByRelationAggregateInput\n  }\n\n  export type reddit_clone_memberWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    username?: string\n    AND?: reddit_clone_memberWhereInput | reddit_clone_memberWhereInput[]\n    OR?: reddit_clone_memberWhereInput[]\n    NOT?: reddit_clone_memberWhereInput | reddit_clone_memberWhereInput[]\n    password_hash?: StringFilter<\"reddit_clone_member\"> | string\n    karma?: IntFilter<\"reddit_clone_member\"> | number\n    created_at?: DateTimeFilter<\"reddit_clone_member\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_member\"> | Date | string\n    reddit_clone_moderator?: Reddit_clone_moderatorListRelationFilter\n    reddit_clone_admin?: Reddit_clone_adminListRelationFilter\n    reddit_clone_communities?: Reddit_clone_communitiesListRelationFilter\n    reddit_clone_community_subscriptions?: Reddit_clone_community_subscriptionsListRelationFilter\n    reddit_clone_posts?: Reddit_clone_postsListRelationFilter\n    reddit_clone_comments?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_post_votes?: Reddit_clone_post_votesListRelationFilter\n    reddit_clone_comment_votes?: Reddit_clone_comment_votesListRelationFilter\n  }, \"id\" | \"email\" | \"username\">\n\n  export type reddit_clone_memberOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    username?: SortOrder\n    karma?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: reddit_clone_memberCountOrderByAggregateInput\n    _avg?: reddit_clone_memberAvgOrderByAggregateInput\n    _max?: reddit_clone_memberMaxOrderByAggregateInput\n    _min?: reddit_clone_memberMinOrderByAggregateInput\n    _sum?: reddit_clone_memberSumOrderByAggregateInput\n  }\n\n  export type reddit_clone_memberScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_memberScalarWhereWithAggregatesInput | reddit_clone_memberScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_memberScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_memberScalarWhereWithAggregatesInput | reddit_clone_memberScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_member\"> | string\n    email?: StringWithAggregatesFilter<\"reddit_clone_member\"> | string\n    password_hash?: StringWithAggregatesFilter<\"reddit_clone_member\"> | string\n    username?: StringWithAggregatesFilter<\"reddit_clone_member\"> | string\n    karma?: IntWithAggregatesFilter<\"reddit_clone_member\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_member\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_member\"> | Date | string\n  }\n\n  export type reddit_clone_moderatorWhereInput = {\n    AND?: reddit_clone_moderatorWhereInput | reddit_clone_moderatorWhereInput[]\n    OR?: reddit_clone_moderatorWhereInput[]\n    NOT?: reddit_clone_moderatorWhereInput | reddit_clone_moderatorWhereInput[]\n    id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    member_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    community_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n    member?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n  }\n\n  export type reddit_clone_moderatorOrderByWithRelationInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    community_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    member?: reddit_clone_memberOrderByWithRelationInput\n    community?: reddit_clone_communitiesOrderByWithRelationInput\n  }\n\n  export type reddit_clone_moderatorWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    member_id_community_id?: reddit_clone_moderatorMember_idCommunity_idCompoundUniqueInput\n    AND?: reddit_clone_moderatorWhereInput | reddit_clone_moderatorWhereInput[]\n    OR?: reddit_clone_moderatorWhereInput[]\n    NOT?: reddit_clone_moderatorWhereInput | reddit_clone_moderatorWhereInput[]\n    member_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    community_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n    member?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n  }, \"id\" | \"member_id_community_id\">\n\n  export type reddit_clone_moderatorOrderByWithAggregationInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    community_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: reddit_clone_moderatorCountOrderByAggregateInput\n    _max?: reddit_clone_moderatorMaxOrderByAggregateInput\n    _min?: reddit_clone_moderatorMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_moderatorScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_moderatorScalarWhereWithAggregatesInput | reddit_clone_moderatorScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_moderatorScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_moderatorScalarWhereWithAggregatesInput | reddit_clone_moderatorScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_moderator\"> | string\n    member_id?: UuidWithAggregatesFilter<\"reddit_clone_moderator\"> | string\n    community_id?: UuidWithAggregatesFilter<\"reddit_clone_moderator\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_moderator\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_moderator\"> | Date | string\n  }\n\n  export type reddit_clone_adminWhereInput = {\n    AND?: reddit_clone_adminWhereInput | reddit_clone_adminWhereInput[]\n    OR?: reddit_clone_adminWhereInput[]\n    NOT?: reddit_clone_adminWhereInput | reddit_clone_adminWhereInput[]\n    id?: UuidFilter<\"reddit_clone_admin\"> | string\n    member_id?: UuidFilter<\"reddit_clone_admin\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n    member?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n  }\n\n  export type reddit_clone_adminOrderByWithRelationInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    member?: reddit_clone_memberOrderByWithRelationInput\n  }\n\n  export type reddit_clone_adminWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    member_id?: string\n    AND?: reddit_clone_adminWhereInput | reddit_clone_adminWhereInput[]\n    OR?: reddit_clone_adminWhereInput[]\n    NOT?: reddit_clone_adminWhereInput | reddit_clone_adminWhereInput[]\n    created_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n    member?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n  }, \"id\" | \"member_id\">\n\n  export type reddit_clone_adminOrderByWithAggregationInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: reddit_clone_adminCountOrderByAggregateInput\n    _max?: reddit_clone_adminMaxOrderByAggregateInput\n    _min?: reddit_clone_adminMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_adminScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_adminScalarWhereWithAggregatesInput | reddit_clone_adminScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_adminScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_adminScalarWhereWithAggregatesInput | reddit_clone_adminScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_admin\"> | string\n    member_id?: UuidWithAggregatesFilter<\"reddit_clone_admin\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_admin\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_admin\"> | Date | string\n  }\n\n  export type reddit_clone_communitiesWhereInput = {\n    AND?: reddit_clone_communitiesWhereInput | reddit_clone_communitiesWhereInput[]\n    OR?: reddit_clone_communitiesWhereInput[]\n    NOT?: reddit_clone_communitiesWhereInput | reddit_clone_communitiesWhereInput[]\n    id?: UuidFilter<\"reddit_clone_communities\"> | string\n    creator_id?: UuidFilter<\"reddit_clone_communities\"> | string\n    name?: StringFilter<\"reddit_clone_communities\"> | string\n    description?: StringNullableFilter<\"reddit_clone_communities\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"reddit_clone_communities\"> | Date | string | null\n    is_nsfw?: BoolFilter<\"reddit_clone_communities\"> | boolean\n    member_count?: IntFilter<\"reddit_clone_communities\"> | number\n    creator?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    reddit_clone_moderator?: Reddit_clone_moderatorListRelationFilter\n    reddit_clone_community_subscriptions?: Reddit_clone_community_subscriptionsListRelationFilter\n    reddit_clone_posts?: Reddit_clone_postsListRelationFilter\n  }\n\n  export type reddit_clone_communitiesOrderByWithRelationInput = {\n    id?: SortOrder\n    creator_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    is_nsfw?: SortOrder\n    member_count?: SortOrder\n    creator?: reddit_clone_memberOrderByWithRelationInput\n    reddit_clone_moderator?: reddit_clone_moderatorOrderByRelationAggregateInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsOrderByRelationAggregateInput\n    reddit_clone_posts?: reddit_clone_postsOrderByRelationAggregateInput\n  }\n\n  export type reddit_clone_communitiesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: reddit_clone_communitiesWhereInput | reddit_clone_communitiesWhereInput[]\n    OR?: reddit_clone_communitiesWhereInput[]\n    NOT?: reddit_clone_communitiesWhereInput | reddit_clone_communitiesWhereInput[]\n    creator_id?: UuidFilter<\"reddit_clone_communities\"> | string\n    description?: StringNullableFilter<\"reddit_clone_communities\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"reddit_clone_communities\"> | Date | string | null\n    is_nsfw?: BoolFilter<\"reddit_clone_communities\"> | boolean\n    member_count?: IntFilter<\"reddit_clone_communities\"> | number\n    creator?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    reddit_clone_moderator?: Reddit_clone_moderatorListRelationFilter\n    reddit_clone_community_subscriptions?: Reddit_clone_community_subscriptionsListRelationFilter\n    reddit_clone_posts?: Reddit_clone_postsListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type reddit_clone_communitiesOrderByWithAggregationInput = {\n    id?: SortOrder\n    creator_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    is_nsfw?: SortOrder\n    member_count?: SortOrder\n    _count?: reddit_clone_communitiesCountOrderByAggregateInput\n    _avg?: reddit_clone_communitiesAvgOrderByAggregateInput\n    _max?: reddit_clone_communitiesMaxOrderByAggregateInput\n    _min?: reddit_clone_communitiesMinOrderByAggregateInput\n    _sum?: reddit_clone_communitiesSumOrderByAggregateInput\n  }\n\n  export type reddit_clone_communitiesScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_communitiesScalarWhereWithAggregatesInput | reddit_clone_communitiesScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_communitiesScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_communitiesScalarWhereWithAggregatesInput | reddit_clone_communitiesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_communities\"> | string\n    creator_id?: UuidWithAggregatesFilter<\"reddit_clone_communities\"> | string\n    name?: StringWithAggregatesFilter<\"reddit_clone_communities\"> | string\n    description?: StringNullableWithAggregatesFilter<\"reddit_clone_communities\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_communities\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_communities\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"reddit_clone_communities\"> | Date | string | null\n    is_nsfw?: BoolWithAggregatesFilter<\"reddit_clone_communities\"> | boolean\n    member_count?: IntWithAggregatesFilter<\"reddit_clone_communities\"> | number\n  }\n\n  export type reddit_clone_community_subscriptionsWhereInput = {\n    AND?: reddit_clone_community_subscriptionsWhereInput | reddit_clone_community_subscriptionsWhereInput[]\n    OR?: reddit_clone_community_subscriptionsWhereInput[]\n    NOT?: reddit_clone_community_subscriptionsWhereInput | reddit_clone_community_subscriptionsWhereInput[]\n    id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    user_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    community_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    subscribed_at?: DateTimeFilter<\"reddit_clone_community_subscriptions\"> | Date | string\n    is_muted?: BoolFilter<\"reddit_clone_community_subscriptions\"> | boolean\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n  }\n\n  export type reddit_clone_community_subscriptionsOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    community_id?: SortOrder\n    subscribed_at?: SortOrder\n    is_muted?: SortOrder\n    user?: reddit_clone_memberOrderByWithRelationInput\n    community?: reddit_clone_communitiesOrderByWithRelationInput\n  }\n\n  export type reddit_clone_community_subscriptionsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    user_id_community_id?: reddit_clone_community_subscriptionsUser_idCommunity_idCompoundUniqueInput\n    AND?: reddit_clone_community_subscriptionsWhereInput | reddit_clone_community_subscriptionsWhereInput[]\n    OR?: reddit_clone_community_subscriptionsWhereInput[]\n    NOT?: reddit_clone_community_subscriptionsWhereInput | reddit_clone_community_subscriptionsWhereInput[]\n    user_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    community_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    subscribed_at?: DateTimeFilter<\"reddit_clone_community_subscriptions\"> | Date | string\n    is_muted?: BoolFilter<\"reddit_clone_community_subscriptions\"> | boolean\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n  }, \"id\" | \"user_id_community_id\">\n\n  export type reddit_clone_community_subscriptionsOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    community_id?: SortOrder\n    subscribed_at?: SortOrder\n    is_muted?: SortOrder\n    _count?: reddit_clone_community_subscriptionsCountOrderByAggregateInput\n    _max?: reddit_clone_community_subscriptionsMaxOrderByAggregateInput\n    _min?: reddit_clone_community_subscriptionsMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput | reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput | reddit_clone_community_subscriptionsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_community_subscriptions\"> | string\n    user_id?: UuidWithAggregatesFilter<\"reddit_clone_community_subscriptions\"> | string\n    community_id?: UuidWithAggregatesFilter<\"reddit_clone_community_subscriptions\"> | string\n    subscribed_at?: DateTimeWithAggregatesFilter<\"reddit_clone_community_subscriptions\"> | Date | string\n    is_muted?: BoolWithAggregatesFilter<\"reddit_clone_community_subscriptions\"> | boolean\n  }\n\n  export type reddit_clone_postsWhereInput = {\n    AND?: reddit_clone_postsWhereInput | reddit_clone_postsWhereInput[]\n    OR?: reddit_clone_postsWhereInput[]\n    NOT?: reddit_clone_postsWhereInput | reddit_clone_postsWhereInput[]\n    id?: UuidFilter<\"reddit_clone_posts\"> | string\n    author_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    community_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    title?: StringFilter<\"reddit_clone_posts\"> | string\n    content?: StringFilter<\"reddit_clone_posts\"> | string\n    content_type?: StringFilter<\"reddit_clone_posts\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    is_locked?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    is_nsfw?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    upvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    comment_count?: IntFilter<\"reddit_clone_posts\"> | number\n    author?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n    reddit_clone_comments?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_post_votes?: Reddit_clone_post_votesListRelationFilter\n  }\n\n  export type reddit_clone_postsOrderByWithRelationInput = {\n    id?: SortOrder\n    author_id?: SortOrder\n    community_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    content_type?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    is_locked?: SortOrder\n    is_nsfw?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n    author?: reddit_clone_memberOrderByWithRelationInput\n    community?: reddit_clone_communitiesOrderByWithRelationInput\n    reddit_clone_comments?: reddit_clone_commentsOrderByRelationAggregateInput\n    reddit_clone_post_votes?: reddit_clone_post_votesOrderByRelationAggregateInput\n  }\n\n  export type reddit_clone_postsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: reddit_clone_postsWhereInput | reddit_clone_postsWhereInput[]\n    OR?: reddit_clone_postsWhereInput[]\n    NOT?: reddit_clone_postsWhereInput | reddit_clone_postsWhereInput[]\n    author_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    community_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    title?: StringFilter<\"reddit_clone_posts\"> | string\n    content?: StringFilter<\"reddit_clone_posts\"> | string\n    content_type?: StringFilter<\"reddit_clone_posts\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    is_locked?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    is_nsfw?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    upvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    comment_count?: IntFilter<\"reddit_clone_posts\"> | number\n    author?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    community?: XOR<Reddit_clone_communitiesScalarRelationFilter, reddit_clone_communitiesWhereInput>\n    reddit_clone_comments?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_post_votes?: Reddit_clone_post_votesListRelationFilter\n  }, \"id\">\n\n  export type reddit_clone_postsOrderByWithAggregationInput = {\n    id?: SortOrder\n    author_id?: SortOrder\n    community_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    content_type?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    is_locked?: SortOrder\n    is_nsfw?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n    _count?: reddit_clone_postsCountOrderByAggregateInput\n    _avg?: reddit_clone_postsAvgOrderByAggregateInput\n    _max?: reddit_clone_postsMaxOrderByAggregateInput\n    _min?: reddit_clone_postsMinOrderByAggregateInput\n    _sum?: reddit_clone_postsSumOrderByAggregateInput\n  }\n\n  export type reddit_clone_postsScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_postsScalarWhereWithAggregatesInput | reddit_clone_postsScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_postsScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_postsScalarWhereWithAggregatesInput | reddit_clone_postsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    author_id?: UuidWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    community_id?: UuidWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    title?: StringWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    content?: StringWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    content_type?: StringWithAggregatesFilter<\"reddit_clone_posts\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_posts\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_posts\"> | Date | string\n    is_locked?: BoolWithAggregatesFilter<\"reddit_clone_posts\"> | boolean\n    is_nsfw?: BoolWithAggregatesFilter<\"reddit_clone_posts\"> | boolean\n    upvote_count?: IntWithAggregatesFilter<\"reddit_clone_posts\"> | number\n    downvote_count?: IntWithAggregatesFilter<\"reddit_clone_posts\"> | number\n    comment_count?: IntWithAggregatesFilter<\"reddit_clone_posts\"> | number\n  }\n\n  export type reddit_clone_commentsWhereInput = {\n    AND?: reddit_clone_commentsWhereInput | reddit_clone_commentsWhereInput[]\n    OR?: reddit_clone_commentsWhereInput[]\n    NOT?: reddit_clone_commentsWhereInput | reddit_clone_commentsWhereInput[]\n    id?: UuidFilter<\"reddit_clone_comments\"> | string\n    post_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    author_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    parent_comment_id?: UuidNullableFilter<\"reddit_clone_comments\"> | string | null\n    content?: StringFilter<\"reddit_clone_comments\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    upvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n    post?: XOR<Reddit_clone_postsScalarRelationFilter, reddit_clone_postsWhereInput>\n    author?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    parent?: XOR<Reddit_clone_commentsNullableScalarRelationFilter, reddit_clone_commentsWhereInput> | null\n    recursive?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_comment_votes?: Reddit_clone_comment_votesListRelationFilter\n  }\n\n  export type reddit_clone_commentsOrderByWithRelationInput = {\n    id?: SortOrder\n    post_id?: SortOrder\n    author_id?: SortOrder\n    parent_comment_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    post?: reddit_clone_postsOrderByWithRelationInput\n    author?: reddit_clone_memberOrderByWithRelationInput\n    parent?: reddit_clone_commentsOrderByWithRelationInput\n    recursive?: reddit_clone_commentsOrderByRelationAggregateInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesOrderByRelationAggregateInput\n  }\n\n  export type reddit_clone_commentsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: reddit_clone_commentsWhereInput | reddit_clone_commentsWhereInput[]\n    OR?: reddit_clone_commentsWhereInput[]\n    NOT?: reddit_clone_commentsWhereInput | reddit_clone_commentsWhereInput[]\n    post_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    author_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    parent_comment_id?: UuidNullableFilter<\"reddit_clone_comments\"> | string | null\n    content?: StringFilter<\"reddit_clone_comments\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    upvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n    post?: XOR<Reddit_clone_postsScalarRelationFilter, reddit_clone_postsWhereInput>\n    author?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    parent?: XOR<Reddit_clone_commentsNullableScalarRelationFilter, reddit_clone_commentsWhereInput> | null\n    recursive?: Reddit_clone_commentsListRelationFilter\n    reddit_clone_comment_votes?: Reddit_clone_comment_votesListRelationFilter\n  }, \"id\">\n\n  export type reddit_clone_commentsOrderByWithAggregationInput = {\n    id?: SortOrder\n    post_id?: SortOrder\n    author_id?: SortOrder\n    parent_comment_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    _count?: reddit_clone_commentsCountOrderByAggregateInput\n    _avg?: reddit_clone_commentsAvgOrderByAggregateInput\n    _max?: reddit_clone_commentsMaxOrderByAggregateInput\n    _min?: reddit_clone_commentsMinOrderByAggregateInput\n    _sum?: reddit_clone_commentsSumOrderByAggregateInput\n  }\n\n  export type reddit_clone_commentsScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_commentsScalarWhereWithAggregatesInput | reddit_clone_commentsScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_commentsScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_commentsScalarWhereWithAggregatesInput | reddit_clone_commentsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_comments\"> | string\n    post_id?: UuidWithAggregatesFilter<\"reddit_clone_comments\"> | string\n    author_id?: UuidWithAggregatesFilter<\"reddit_clone_comments\"> | string\n    parent_comment_id?: UuidNullableWithAggregatesFilter<\"reddit_clone_comments\"> | string | null\n    content?: StringWithAggregatesFilter<\"reddit_clone_comments\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_comments\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"reddit_clone_comments\"> | Date | string\n    upvote_count?: IntWithAggregatesFilter<\"reddit_clone_comments\"> | number\n    downvote_count?: IntWithAggregatesFilter<\"reddit_clone_comments\"> | number\n  }\n\n  export type reddit_clone_post_votesWhereInput = {\n    AND?: reddit_clone_post_votesWhereInput | reddit_clone_post_votesWhereInput[]\n    OR?: reddit_clone_post_votesWhereInput[]\n    NOT?: reddit_clone_post_votesWhereInput | reddit_clone_post_votesWhereInput[]\n    id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    user_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    post_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_post_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_post_votes\"> | Date | string\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    post?: XOR<Reddit_clone_postsScalarRelationFilter, reddit_clone_postsWhereInput>\n  }\n\n  export type reddit_clone_post_votesOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n    user?: reddit_clone_memberOrderByWithRelationInput\n    post?: reddit_clone_postsOrderByWithRelationInput\n  }\n\n  export type reddit_clone_post_votesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    user_id_post_id?: reddit_clone_post_votesUser_idPost_idCompoundUniqueInput\n    AND?: reddit_clone_post_votesWhereInput | reddit_clone_post_votesWhereInput[]\n    OR?: reddit_clone_post_votesWhereInput[]\n    NOT?: reddit_clone_post_votesWhereInput | reddit_clone_post_votesWhereInput[]\n    user_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    post_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_post_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_post_votes\"> | Date | string\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    post?: XOR<Reddit_clone_postsScalarRelationFilter, reddit_clone_postsWhereInput>\n  }, \"id\" | \"user_id_post_id\">\n\n  export type reddit_clone_post_votesOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n    _count?: reddit_clone_post_votesCountOrderByAggregateInput\n    _max?: reddit_clone_post_votesMaxOrderByAggregateInput\n    _min?: reddit_clone_post_votesMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_post_votesScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_post_votesScalarWhereWithAggregatesInput | reddit_clone_post_votesScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_post_votesScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_post_votesScalarWhereWithAggregatesInput | reddit_clone_post_votesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_post_votes\"> | string\n    user_id?: UuidWithAggregatesFilter<\"reddit_clone_post_votes\"> | string\n    post_id?: UuidWithAggregatesFilter<\"reddit_clone_post_votes\"> | string\n    vote_type?: StringWithAggregatesFilter<\"reddit_clone_post_votes\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_post_votes\"> | Date | string\n  }\n\n  export type reddit_clone_comment_votesWhereInput = {\n    AND?: reddit_clone_comment_votesWhereInput | reddit_clone_comment_votesWhereInput[]\n    OR?: reddit_clone_comment_votesWhereInput[]\n    NOT?: reddit_clone_comment_votesWhereInput | reddit_clone_comment_votesWhereInput[]\n    id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    user_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    comment_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_comment_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comment_votes\"> | Date | string\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    comment?: XOR<Reddit_clone_commentsScalarRelationFilter, reddit_clone_commentsWhereInput>\n  }\n\n  export type reddit_clone_comment_votesOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    comment_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n    user?: reddit_clone_memberOrderByWithRelationInput\n    comment?: reddit_clone_commentsOrderByWithRelationInput\n  }\n\n  export type reddit_clone_comment_votesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    user_id_comment_id?: reddit_clone_comment_votesUser_idComment_idCompoundUniqueInput\n    AND?: reddit_clone_comment_votesWhereInput | reddit_clone_comment_votesWhereInput[]\n    OR?: reddit_clone_comment_votesWhereInput[]\n    NOT?: reddit_clone_comment_votesWhereInput | reddit_clone_comment_votesWhereInput[]\n    user_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    comment_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_comment_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comment_votes\"> | Date | string\n    user?: XOR<Reddit_clone_memberScalarRelationFilter, reddit_clone_memberWhereInput>\n    comment?: XOR<Reddit_clone_commentsScalarRelationFilter, reddit_clone_commentsWhereInput>\n  }, \"id\" | \"user_id_comment_id\">\n\n  export type reddit_clone_comment_votesOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    comment_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n    _count?: reddit_clone_comment_votesCountOrderByAggregateInput\n    _max?: reddit_clone_comment_votesMaxOrderByAggregateInput\n    _min?: reddit_clone_comment_votesMinOrderByAggregateInput\n  }\n\n  export type reddit_clone_comment_votesScalarWhereWithAggregatesInput = {\n    AND?: reddit_clone_comment_votesScalarWhereWithAggregatesInput | reddit_clone_comment_votesScalarWhereWithAggregatesInput[]\n    OR?: reddit_clone_comment_votesScalarWhereWithAggregatesInput[]\n    NOT?: reddit_clone_comment_votesScalarWhereWithAggregatesInput | reddit_clone_comment_votesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"reddit_clone_comment_votes\"> | string\n    user_id?: UuidWithAggregatesFilter<\"reddit_clone_comment_votes\"> | string\n    comment_id?: UuidWithAggregatesFilter<\"reddit_clone_comment_votes\"> | string\n    vote_type?: StringWithAggregatesFilter<\"reddit_clone_comment_votes\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"reddit_clone_comment_votes\"> | Date | string\n  }\n\n  export type reddit_clone_configurationsCreateInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_configurationsUncheckedCreateInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_configurationsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_configurationsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_configurationsCreateManyInput = {\n    id: string\n    key: string\n    value: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_configurationsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_configurationsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    key?: StringFieldUpdateOperationsInput | string\n    value?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_guestCreateInput = {\n    id: string\n    email?: string | null\n    password_hash?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_guestUncheckedCreateInput = {\n    id: string\n    email?: string | null\n    password_hash?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_guestUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_guestUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_guestCreateManyInput = {\n    id: string\n    email?: string | null\n    password_hash?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_guestUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_guestUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_memberCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_memberUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_memberUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorCreateInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    member: reddit_clone_memberCreateNestedOneWithoutReddit_clone_moderatorInput\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_moderatorInput\n  }\n\n  export type reddit_clone_moderatorUncheckedCreateInput = {\n    id: string\n    member_id: string\n    community_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_moderatorUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorCreateManyInput = {\n    id: string\n    member_id: string\n    community_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_moderatorUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminCreateInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    member: reddit_clone_memberCreateNestedOneWithoutReddit_clone_adminInput\n  }\n\n  export type reddit_clone_adminUncheckedCreateInput = {\n    id: string\n    member_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_adminUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_adminNestedInput\n  }\n\n  export type reddit_clone_adminUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminCreateManyInput = {\n    id: string\n    member_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_adminUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_communitiesCreateInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    creator: reddit_clone_memberCreateNestedOneWithoutReddit_clone_communitiesInput\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateInput = {\n    id: string\n    creator_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    creator?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_communitiesNestedInput\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    creator_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesCreateManyInput = {\n    id: string\n    creator_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n  }\n\n  export type reddit_clone_communitiesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    creator_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_community_subscriptionsCreateInput = {\n    id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_community_subscriptionsInput\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_community_subscriptionsInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedCreateInput = {\n    id: string\n    user_id: string\n    community_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_community_subscriptionsCreateManyInput = {\n    id: string\n    user_id: string\n    community_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_postsCreateInput = {\n    id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_postsInput\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_postsInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUncheckedCreateInput = {\n    id: string\n    author_id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsCreateManyInput = {\n    id: string\n    author_id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n  }\n\n  export type reddit_clone_postsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_postsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_commentsCreateInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput\n    parent?: reddit_clone_commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: reddit_clone_commentsCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateInput = {\n    id: string\n    post_id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    recursive?: reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    parent?: reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: reddit_clone_commentsUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    recursive?: reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsCreateManyInput = {\n    id: string\n    post_id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n  }\n\n  export type reddit_clone_commentsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_post_votesCreateInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_post_votesInput\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_post_votesInput\n  }\n\n  export type reddit_clone_post_votesUncheckedCreateInput = {\n    id: string\n    user_id: string\n    post_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_post_votesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_post_votesCreateManyInput = {\n    id: string\n    user_id: string\n    post_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_post_votesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesCreateInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_comment_votesInput\n    comment: reddit_clone_commentsCreateNestedOneWithoutReddit_clone_comment_votesInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedCreateInput = {\n    id: string\n    user_id: string\n    comment_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_comment_votesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput\n    comment?: reddit_clone_commentsUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesCreateManyInput = {\n    id: string\n    user_id: string\n    comment_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_comment_votesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type reddit_clone_configurationsCountOrderByAggregateInput = {\n    id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_configurationsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_configurationsMinOrderByAggregateInput = {\n    id?: SortOrder\n    key?: SortOrder\n    value?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type reddit_clone_guestCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_guestMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_guestMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type IntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type Reddit_clone_moderatorListRelationFilter = {\n    every?: reddit_clone_moderatorWhereInput\n    some?: reddit_clone_moderatorWhereInput\n    none?: reddit_clone_moderatorWhereInput\n  }\n\n  export type Reddit_clone_adminListRelationFilter = {\n    every?: reddit_clone_adminWhereInput\n    some?: reddit_clone_adminWhereInput\n    none?: reddit_clone_adminWhereInput\n  }\n\n  export type Reddit_clone_communitiesListRelationFilter = {\n    every?: reddit_clone_communitiesWhereInput\n    some?: reddit_clone_communitiesWhereInput\n    none?: reddit_clone_communitiesWhereInput\n  }\n\n  export type Reddit_clone_community_subscriptionsListRelationFilter = {\n    every?: reddit_clone_community_subscriptionsWhereInput\n    some?: reddit_clone_community_subscriptionsWhereInput\n    none?: reddit_clone_community_subscriptionsWhereInput\n  }\n\n  export type Reddit_clone_postsListRelationFilter = {\n    every?: reddit_clone_postsWhereInput\n    some?: reddit_clone_postsWhereInput\n    none?: reddit_clone_postsWhereInput\n  }\n\n  export type Reddit_clone_commentsListRelationFilter = {\n    every?: reddit_clone_commentsWhereInput\n    some?: reddit_clone_commentsWhereInput\n    none?: reddit_clone_commentsWhereInput\n  }\n\n  export type Reddit_clone_post_votesListRelationFilter = {\n    every?: reddit_clone_post_votesWhereInput\n    some?: reddit_clone_post_votesWhereInput\n    none?: reddit_clone_post_votesWhereInput\n  }\n\n  export type Reddit_clone_comment_votesListRelationFilter = {\n    every?: reddit_clone_comment_votesWhereInput\n    some?: reddit_clone_comment_votesWhereInput\n    none?: reddit_clone_comment_votesWhereInput\n  }\n\n  export type reddit_clone_moderatorOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_adminOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_communitiesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_community_subscriptionsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_postsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_commentsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_post_votesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_comment_votesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type reddit_clone_memberCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    username?: SortOrder\n    karma?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_memberAvgOrderByAggregateInput = {\n    karma?: SortOrder\n  }\n\n  export type reddit_clone_memberMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    username?: SortOrder\n    karma?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_memberMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    username?: SortOrder\n    karma?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_memberSumOrderByAggregateInput = {\n    karma?: SortOrder\n  }\n\n  export type IntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type Reddit_clone_memberScalarRelationFilter = {\n    is?: reddit_clone_memberWhereInput\n    isNot?: reddit_clone_memberWhereInput\n  }\n\n  export type Reddit_clone_communitiesScalarRelationFilter = {\n    is?: reddit_clone_communitiesWhereInput\n    isNot?: reddit_clone_communitiesWhereInput\n  }\n\n  export type reddit_clone_moderatorMember_idCommunity_idCompoundUniqueInput = {\n    member_id: string\n    community_id: string\n  }\n\n  export type reddit_clone_moderatorCountOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    community_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_moderatorMaxOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    community_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_moderatorMinOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    community_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_adminCountOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_adminMaxOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type reddit_clone_adminMinOrderByAggregateInput = {\n    id?: SortOrder\n    member_id?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type reddit_clone_communitiesCountOrderByAggregateInput = {\n    id?: SortOrder\n    creator_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    is_nsfw?: SortOrder\n    member_count?: SortOrder\n  }\n\n  export type reddit_clone_communitiesAvgOrderByAggregateInput = {\n    member_count?: SortOrder\n  }\n\n  export type reddit_clone_communitiesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    creator_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    is_nsfw?: SortOrder\n    member_count?: SortOrder\n  }\n\n  export type reddit_clone_communitiesMinOrderByAggregateInput = {\n    id?: SortOrder\n    creator_id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    is_nsfw?: SortOrder\n    member_count?: SortOrder\n  }\n\n  export type reddit_clone_communitiesSumOrderByAggregateInput = {\n    member_count?: SortOrder\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type reddit_clone_community_subscriptionsUser_idCommunity_idCompoundUniqueInput = {\n    user_id: string\n    community_id: string\n  }\n\n  export type reddit_clone_community_subscriptionsCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    community_id?: SortOrder\n    subscribed_at?: SortOrder\n    is_muted?: SortOrder\n  }\n\n  export type reddit_clone_community_subscriptionsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    community_id?: SortOrder\n    subscribed_at?: SortOrder\n    is_muted?: SortOrder\n  }\n\n  export type reddit_clone_community_subscriptionsMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    community_id?: SortOrder\n    subscribed_at?: SortOrder\n    is_muted?: SortOrder\n  }\n\n  export type reddit_clone_postsCountOrderByAggregateInput = {\n    id?: SortOrder\n    author_id?: SortOrder\n    community_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    content_type?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    is_locked?: SortOrder\n    is_nsfw?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n  }\n\n  export type reddit_clone_postsAvgOrderByAggregateInput = {\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n  }\n\n  export type reddit_clone_postsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    author_id?: SortOrder\n    community_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    content_type?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    is_locked?: SortOrder\n    is_nsfw?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n  }\n\n  export type reddit_clone_postsMinOrderByAggregateInput = {\n    id?: SortOrder\n    author_id?: SortOrder\n    community_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    content_type?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    is_locked?: SortOrder\n    is_nsfw?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n  }\n\n  export type reddit_clone_postsSumOrderByAggregateInput = {\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n    comment_count?: SortOrder\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type Reddit_clone_postsScalarRelationFilter = {\n    is?: reddit_clone_postsWhereInput\n    isNot?: reddit_clone_postsWhereInput\n  }\n\n  export type Reddit_clone_commentsNullableScalarRelationFilter = {\n    is?: reddit_clone_commentsWhereInput | null\n    isNot?: reddit_clone_commentsWhereInput | null\n  }\n\n  export type reddit_clone_commentsCountOrderByAggregateInput = {\n    id?: SortOrder\n    post_id?: SortOrder\n    author_id?: SortOrder\n    parent_comment_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n  }\n\n  export type reddit_clone_commentsAvgOrderByAggregateInput = {\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n  }\n\n  export type reddit_clone_commentsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    post_id?: SortOrder\n    author_id?: SortOrder\n    parent_comment_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n  }\n\n  export type reddit_clone_commentsMinOrderByAggregateInput = {\n    id?: SortOrder\n    post_id?: SortOrder\n    author_id?: SortOrder\n    parent_comment_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n  }\n\n  export type reddit_clone_commentsSumOrderByAggregateInput = {\n    upvote_count?: SortOrder\n    downvote_count?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type reddit_clone_post_votesUser_idPost_idCompoundUniqueInput = {\n    user_id: string\n    post_id: string\n  }\n\n  export type reddit_clone_post_votesCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type reddit_clone_post_votesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type reddit_clone_post_votesMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type Reddit_clone_commentsScalarRelationFilter = {\n    is?: reddit_clone_commentsWhereInput\n    isNot?: reddit_clone_commentsWhereInput\n  }\n\n  export type reddit_clone_comment_votesUser_idComment_idCompoundUniqueInput = {\n    user_id: string\n    comment_id: string\n  }\n\n  export type reddit_clone_comment_votesCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    comment_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type reddit_clone_comment_votesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    comment_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type reddit_clone_comment_votesMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    comment_id?: SortOrder\n    vote_type?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type reddit_clone_moderatorCreateNestedManyWithoutMemberInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput> | reddit_clone_moderatorCreateWithoutMemberInput[] | reddit_clone_moderatorUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutMemberInput | reddit_clone_moderatorCreateOrConnectWithoutMemberInput[]\n    createMany?: reddit_clone_moderatorCreateManyMemberInputEnvelope\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n  }\n\n  export type reddit_clone_adminCreateNestedManyWithoutMemberInput = {\n    create?: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput> | reddit_clone_adminCreateWithoutMemberInput[] | reddit_clone_adminUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_adminCreateOrConnectWithoutMemberInput | reddit_clone_adminCreateOrConnectWithoutMemberInput[]\n    createMany?: reddit_clone_adminCreateManyMemberInputEnvelope\n    connect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n  }\n\n  export type reddit_clone_communitiesCreateNestedManyWithoutCreatorInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput> | reddit_clone_communitiesCreateWithoutCreatorInput[] | reddit_clone_communitiesUncheckedCreateWithoutCreatorInput[]\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutCreatorInput | reddit_clone_communitiesCreateOrConnectWithoutCreatorInput[]\n    createMany?: reddit_clone_communitiesCreateManyCreatorInputEnvelope\n    connect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput> | reddit_clone_community_subscriptionsCreateWithoutUserInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyUserInputEnvelope\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_postsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput> | reddit_clone_postsCreateWithoutAuthorInput[] | reddit_clone_postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutAuthorInput | reddit_clone_postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: reddit_clone_postsCreateManyAuthorInputEnvelope\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_commentsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput> | reddit_clone_commentsCreateWithoutAuthorInput[] | reddit_clone_commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutAuthorInput | reddit_clone_commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: reddit_clone_commentsCreateManyAuthorInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_post_votesCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput> | reddit_clone_post_votesCreateWithoutUserInput[] | reddit_clone_post_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutUserInput | reddit_clone_post_votesCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_post_votesCreateManyUserInputEnvelope\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_comment_votesCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput> | reddit_clone_comment_votesCreateWithoutUserInput[] | reddit_clone_comment_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutUserInput | reddit_clone_comment_votesCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_comment_votesCreateManyUserInputEnvelope\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput> | reddit_clone_moderatorCreateWithoutMemberInput[] | reddit_clone_moderatorUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutMemberInput | reddit_clone_moderatorCreateOrConnectWithoutMemberInput[]\n    createMany?: reddit_clone_moderatorCreateManyMemberInputEnvelope\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n  }\n\n  export type reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput = {\n    create?: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput> | reddit_clone_adminCreateWithoutMemberInput[] | reddit_clone_adminUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_adminCreateOrConnectWithoutMemberInput | reddit_clone_adminCreateOrConnectWithoutMemberInput[]\n    createMany?: reddit_clone_adminCreateManyMemberInputEnvelope\n    connect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput> | reddit_clone_communitiesCreateWithoutCreatorInput[] | reddit_clone_communitiesUncheckedCreateWithoutCreatorInput[]\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutCreatorInput | reddit_clone_communitiesCreateOrConnectWithoutCreatorInput[]\n    createMany?: reddit_clone_communitiesCreateManyCreatorInputEnvelope\n    connect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput> | reddit_clone_community_subscriptionsCreateWithoutUserInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyUserInputEnvelope\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput> | reddit_clone_postsCreateWithoutAuthorInput[] | reddit_clone_postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutAuthorInput | reddit_clone_postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: reddit_clone_postsCreateManyAuthorInputEnvelope\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput> | reddit_clone_commentsCreateWithoutAuthorInput[] | reddit_clone_commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutAuthorInput | reddit_clone_commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: reddit_clone_commentsCreateManyAuthorInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput> | reddit_clone_post_votesCreateWithoutUserInput[] | reddit_clone_post_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutUserInput | reddit_clone_post_votesCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_post_votesCreateManyUserInputEnvelope\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput> | reddit_clone_comment_votesCreateWithoutUserInput[] | reddit_clone_comment_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutUserInput | reddit_clone_comment_votesCreateOrConnectWithoutUserInput[]\n    createMany?: reddit_clone_comment_votesCreateManyUserInputEnvelope\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type reddit_clone_moderatorUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput> | reddit_clone_moderatorCreateWithoutMemberInput[] | reddit_clone_moderatorUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutMemberInput | reddit_clone_moderatorCreateOrConnectWithoutMemberInput[]\n    upsert?: reddit_clone_moderatorUpsertWithWhereUniqueWithoutMemberInput | reddit_clone_moderatorUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: reddit_clone_moderatorCreateManyMemberInputEnvelope\n    set?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    disconnect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    delete?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    update?: reddit_clone_moderatorUpdateWithWhereUniqueWithoutMemberInput | reddit_clone_moderatorUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: reddit_clone_moderatorUpdateManyWithWhereWithoutMemberInput | reddit_clone_moderatorUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n  }\n\n  export type reddit_clone_adminUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput> | reddit_clone_adminCreateWithoutMemberInput[] | reddit_clone_adminUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_adminCreateOrConnectWithoutMemberInput | reddit_clone_adminCreateOrConnectWithoutMemberInput[]\n    upsert?: reddit_clone_adminUpsertWithWhereUniqueWithoutMemberInput | reddit_clone_adminUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: reddit_clone_adminCreateManyMemberInputEnvelope\n    set?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    disconnect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    delete?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    connect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    update?: reddit_clone_adminUpdateWithWhereUniqueWithoutMemberInput | reddit_clone_adminUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: reddit_clone_adminUpdateManyWithWhereWithoutMemberInput | reddit_clone_adminUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: reddit_clone_adminScalarWhereInput | reddit_clone_adminScalarWhereInput[]\n  }\n\n  export type reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput> | reddit_clone_communitiesCreateWithoutCreatorInput[] | reddit_clone_communitiesUncheckedCreateWithoutCreatorInput[]\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutCreatorInput | reddit_clone_communitiesCreateOrConnectWithoutCreatorInput[]\n    upsert?: reddit_clone_communitiesUpsertWithWhereUniqueWithoutCreatorInput | reddit_clone_communitiesUpsertWithWhereUniqueWithoutCreatorInput[]\n    createMany?: reddit_clone_communitiesCreateManyCreatorInputEnvelope\n    set?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    disconnect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    delete?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    connect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    update?: reddit_clone_communitiesUpdateWithWhereUniqueWithoutCreatorInput | reddit_clone_communitiesUpdateWithWhereUniqueWithoutCreatorInput[]\n    updateMany?: reddit_clone_communitiesUpdateManyWithWhereWithoutCreatorInput | reddit_clone_communitiesUpdateManyWithWhereWithoutCreatorInput[]\n    deleteMany?: reddit_clone_communitiesScalarWhereInput | reddit_clone_communitiesScalarWhereInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput> | reddit_clone_community_subscriptionsCreateWithoutUserInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutUserInput | reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyUserInputEnvelope\n    set?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    disconnect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    delete?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    update?: reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutUserInput | reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutUserInput | reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n  }\n\n  export type reddit_clone_postsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput> | reddit_clone_postsCreateWithoutAuthorInput[] | reddit_clone_postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutAuthorInput | reddit_clone_postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: reddit_clone_postsUpsertWithWhereUniqueWithoutAuthorInput | reddit_clone_postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: reddit_clone_postsCreateManyAuthorInputEnvelope\n    set?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    disconnect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    delete?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    update?: reddit_clone_postsUpdateWithWhereUniqueWithoutAuthorInput | reddit_clone_postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: reddit_clone_postsUpdateManyWithWhereWithoutAuthorInput | reddit_clone_postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n  }\n\n  export type reddit_clone_commentsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput> | reddit_clone_commentsCreateWithoutAuthorInput[] | reddit_clone_commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutAuthorInput | reddit_clone_commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutAuthorInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: reddit_clone_commentsCreateManyAuthorInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutAuthorInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutAuthorInput | reddit_clone_commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_post_votesUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput> | reddit_clone_post_votesCreateWithoutUserInput[] | reddit_clone_post_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutUserInput | reddit_clone_post_votesCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_post_votesUpsertWithWhereUniqueWithoutUserInput | reddit_clone_post_votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_post_votesCreateManyUserInputEnvelope\n    set?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    delete?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    update?: reddit_clone_post_votesUpdateWithWhereUniqueWithoutUserInput | reddit_clone_post_votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_post_votesUpdateManyWithWhereWithoutUserInput | reddit_clone_post_votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_comment_votesUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput> | reddit_clone_comment_votesCreateWithoutUserInput[] | reddit_clone_comment_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutUserInput | reddit_clone_comment_votesCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_comment_votesUpsertWithWhereUniqueWithoutUserInput | reddit_clone_comment_votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_comment_votesCreateManyUserInputEnvelope\n    set?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    delete?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    update?: reddit_clone_comment_votesUpdateWithWhereUniqueWithoutUserInput | reddit_clone_comment_votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_comment_votesUpdateManyWithWhereWithoutUserInput | reddit_clone_comment_votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput> | reddit_clone_moderatorCreateWithoutMemberInput[] | reddit_clone_moderatorUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutMemberInput | reddit_clone_moderatorCreateOrConnectWithoutMemberInput[]\n    upsert?: reddit_clone_moderatorUpsertWithWhereUniqueWithoutMemberInput | reddit_clone_moderatorUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: reddit_clone_moderatorCreateManyMemberInputEnvelope\n    set?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    disconnect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    delete?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    update?: reddit_clone_moderatorUpdateWithWhereUniqueWithoutMemberInput | reddit_clone_moderatorUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: reddit_clone_moderatorUpdateManyWithWhereWithoutMemberInput | reddit_clone_moderatorUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n  }\n\n  export type reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput = {\n    create?: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput> | reddit_clone_adminCreateWithoutMemberInput[] | reddit_clone_adminUncheckedCreateWithoutMemberInput[]\n    connectOrCreate?: reddit_clone_adminCreateOrConnectWithoutMemberInput | reddit_clone_adminCreateOrConnectWithoutMemberInput[]\n    upsert?: reddit_clone_adminUpsertWithWhereUniqueWithoutMemberInput | reddit_clone_adminUpsertWithWhereUniqueWithoutMemberInput[]\n    createMany?: reddit_clone_adminCreateManyMemberInputEnvelope\n    set?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    disconnect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    delete?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    connect?: reddit_clone_adminWhereUniqueInput | reddit_clone_adminWhereUniqueInput[]\n    update?: reddit_clone_adminUpdateWithWhereUniqueWithoutMemberInput | reddit_clone_adminUpdateWithWhereUniqueWithoutMemberInput[]\n    updateMany?: reddit_clone_adminUpdateManyWithWhereWithoutMemberInput | reddit_clone_adminUpdateManyWithWhereWithoutMemberInput[]\n    deleteMany?: reddit_clone_adminScalarWhereInput | reddit_clone_adminScalarWhereInput[]\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput> | reddit_clone_communitiesCreateWithoutCreatorInput[] | reddit_clone_communitiesUncheckedCreateWithoutCreatorInput[]\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutCreatorInput | reddit_clone_communitiesCreateOrConnectWithoutCreatorInput[]\n    upsert?: reddit_clone_communitiesUpsertWithWhereUniqueWithoutCreatorInput | reddit_clone_communitiesUpsertWithWhereUniqueWithoutCreatorInput[]\n    createMany?: reddit_clone_communitiesCreateManyCreatorInputEnvelope\n    set?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    disconnect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    delete?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    connect?: reddit_clone_communitiesWhereUniqueInput | reddit_clone_communitiesWhereUniqueInput[]\n    update?: reddit_clone_communitiesUpdateWithWhereUniqueWithoutCreatorInput | reddit_clone_communitiesUpdateWithWhereUniqueWithoutCreatorInput[]\n    updateMany?: reddit_clone_communitiesUpdateManyWithWhereWithoutCreatorInput | reddit_clone_communitiesUpdateManyWithWhereWithoutCreatorInput[]\n    deleteMany?: reddit_clone_communitiesScalarWhereInput | reddit_clone_communitiesScalarWhereInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput> | reddit_clone_community_subscriptionsCreateWithoutUserInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutUserInput | reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyUserInputEnvelope\n    set?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    disconnect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    delete?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    update?: reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutUserInput | reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutUserInput | reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n  }\n\n  export type reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput> | reddit_clone_postsCreateWithoutAuthorInput[] | reddit_clone_postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutAuthorInput | reddit_clone_postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: reddit_clone_postsUpsertWithWhereUniqueWithoutAuthorInput | reddit_clone_postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: reddit_clone_postsCreateManyAuthorInputEnvelope\n    set?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    disconnect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    delete?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    update?: reddit_clone_postsUpdateWithWhereUniqueWithoutAuthorInput | reddit_clone_postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: reddit_clone_postsUpdateManyWithWhereWithoutAuthorInput | reddit_clone_postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput> | reddit_clone_commentsCreateWithoutAuthorInput[] | reddit_clone_commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutAuthorInput | reddit_clone_commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutAuthorInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: reddit_clone_commentsCreateManyAuthorInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutAuthorInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutAuthorInput | reddit_clone_commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput> | reddit_clone_post_votesCreateWithoutUserInput[] | reddit_clone_post_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutUserInput | reddit_clone_post_votesCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_post_votesUpsertWithWhereUniqueWithoutUserInput | reddit_clone_post_votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_post_votesCreateManyUserInputEnvelope\n    set?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    delete?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    update?: reddit_clone_post_votesUpdateWithWhereUniqueWithoutUserInput | reddit_clone_post_votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_post_votesUpdateManyWithWhereWithoutUserInput | reddit_clone_post_votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput> | reddit_clone_comment_votesCreateWithoutUserInput[] | reddit_clone_comment_votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutUserInput | reddit_clone_comment_votesCreateOrConnectWithoutUserInput[]\n    upsert?: reddit_clone_comment_votesUpsertWithWhereUniqueWithoutUserInput | reddit_clone_comment_votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: reddit_clone_comment_votesCreateManyUserInputEnvelope\n    set?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    delete?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    update?: reddit_clone_comment_votesUpdateWithWhereUniqueWithoutUserInput | reddit_clone_comment_votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: reddit_clone_comment_votesUpdateManyWithWhereWithoutUserInput | reddit_clone_comment_votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_moderatorInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_moderatorInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_moderatorInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_moderatorInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_moderatorInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_moderatorInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_moderatorInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_moderatorInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_moderatorInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_moderatorInput, reddit_clone_memberUpdateWithoutReddit_clone_moderatorInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_moderatorInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_moderatorInput\n    upsert?: reddit_clone_communitiesUpsertWithoutReddit_clone_moderatorInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUpdateWithoutReddit_clone_moderatorInput>, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_adminInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_adminInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_adminInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_adminNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_adminInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_adminInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_adminInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_adminInput, reddit_clone_memberUpdateWithoutReddit_clone_adminInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_adminInput>\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_communitiesInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_communitiesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_communitiesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_moderatorCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput> | reddit_clone_moderatorCreateWithoutCommunityInput[] | reddit_clone_moderatorUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutCommunityInput | reddit_clone_moderatorCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_moderatorCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput> | reddit_clone_community_subscriptionsCreateWithoutCommunityInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_postsCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput> | reddit_clone_postsCreateWithoutCommunityInput[] | reddit_clone_postsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutCommunityInput | reddit_clone_postsCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_postsCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_moderatorUncheckedCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput> | reddit_clone_moderatorCreateWithoutCommunityInput[] | reddit_clone_moderatorUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutCommunityInput | reddit_clone_moderatorCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_moderatorCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput> | reddit_clone_community_subscriptionsCreateWithoutCommunityInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_postsUncheckedCreateNestedManyWithoutCommunityInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput> | reddit_clone_postsCreateWithoutCommunityInput[] | reddit_clone_postsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutCommunityInput | reddit_clone_postsCreateOrConnectWithoutCommunityInput[]\n    createMany?: reddit_clone_postsCreateManyCommunityInputEnvelope\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_communitiesNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_communitiesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_communitiesInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_communitiesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_communitiesInput, reddit_clone_memberUpdateWithoutReddit_clone_communitiesInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_communitiesInput>\n  }\n\n  export type reddit_clone_moderatorUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput> | reddit_clone_moderatorCreateWithoutCommunityInput[] | reddit_clone_moderatorUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutCommunityInput | reddit_clone_moderatorCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_moderatorUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_moderatorUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_moderatorCreateManyCommunityInputEnvelope\n    set?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    disconnect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    delete?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    update?: reddit_clone_moderatorUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_moderatorUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_moderatorUpdateManyWithWhereWithoutCommunityInput | reddit_clone_moderatorUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput> | reddit_clone_community_subscriptionsCreateWithoutCommunityInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyCommunityInputEnvelope\n    set?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    disconnect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    delete?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    update?: reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutCommunityInput | reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n  }\n\n  export type reddit_clone_postsUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput> | reddit_clone_postsCreateWithoutCommunityInput[] | reddit_clone_postsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutCommunityInput | reddit_clone_postsCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_postsUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_postsUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_postsCreateManyCommunityInputEnvelope\n    set?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    disconnect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    delete?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    update?: reddit_clone_postsUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_postsUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_postsUpdateManyWithWhereWithoutCommunityInput | reddit_clone_postsUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput> | reddit_clone_moderatorCreateWithoutCommunityInput[] | reddit_clone_moderatorUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_moderatorCreateOrConnectWithoutCommunityInput | reddit_clone_moderatorCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_moderatorUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_moderatorUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_moderatorCreateManyCommunityInputEnvelope\n    set?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    disconnect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    delete?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    connect?: reddit_clone_moderatorWhereUniqueInput | reddit_clone_moderatorWhereUniqueInput[]\n    update?: reddit_clone_moderatorUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_moderatorUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_moderatorUpdateManyWithWhereWithoutCommunityInput | reddit_clone_moderatorUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput> | reddit_clone_community_subscriptionsCreateWithoutCommunityInput[] | reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput | reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_community_subscriptionsCreateManyCommunityInputEnvelope\n    set?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    disconnect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    delete?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    connect?: reddit_clone_community_subscriptionsWhereUniqueInput | reddit_clone_community_subscriptionsWhereUniqueInput[]\n    update?: reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutCommunityInput | reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n  }\n\n  export type reddit_clone_postsUncheckedUpdateManyWithoutCommunityNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput> | reddit_clone_postsCreateWithoutCommunityInput[] | reddit_clone_postsUncheckedCreateWithoutCommunityInput[]\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutCommunityInput | reddit_clone_postsCreateOrConnectWithoutCommunityInput[]\n    upsert?: reddit_clone_postsUpsertWithWhereUniqueWithoutCommunityInput | reddit_clone_postsUpsertWithWhereUniqueWithoutCommunityInput[]\n    createMany?: reddit_clone_postsCreateManyCommunityInputEnvelope\n    set?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    disconnect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    delete?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    connect?: reddit_clone_postsWhereUniqueInput | reddit_clone_postsWhereUniqueInput[]\n    update?: reddit_clone_postsUpdateWithWhereUniqueWithoutCommunityInput | reddit_clone_postsUpdateWithWhereUniqueWithoutCommunityInput[]\n    updateMany?: reddit_clone_postsUpdateManyWithWhereWithoutCommunityInput | reddit_clone_postsUpdateManyWithWhereWithoutCommunityInput[]\n    deleteMany?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_community_subscriptionsInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_community_subscriptionsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_community_subscriptionsInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_community_subscriptionsInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_community_subscriptionsInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_community_subscriptionsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUpdateWithoutReddit_clone_community_subscriptionsInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_community_subscriptionsInput\n    upsert?: reddit_clone_communitiesUpsertWithoutReddit_clone_community_subscriptionsInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUpdateWithoutReddit_clone_community_subscriptionsInput>, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_postsInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_postsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_postsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_postsInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_postsInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_postsInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n  }\n\n  export type reddit_clone_commentsCreateNestedManyWithoutPostInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput> | reddit_clone_commentsCreateWithoutPostInput[] | reddit_clone_commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutPostInput | reddit_clone_commentsCreateOrConnectWithoutPostInput[]\n    createMany?: reddit_clone_commentsCreateManyPostInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_post_votesCreateNestedManyWithoutPostInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput> | reddit_clone_post_votesCreateWithoutPostInput[] | reddit_clone_post_votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutPostInput | reddit_clone_post_votesCreateOrConnectWithoutPostInput[]\n    createMany?: reddit_clone_post_votesCreateManyPostInputEnvelope\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput> | reddit_clone_commentsCreateWithoutPostInput[] | reddit_clone_commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutPostInput | reddit_clone_commentsCreateOrConnectWithoutPostInput[]\n    createMany?: reddit_clone_commentsCreateManyPostInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_post_votesUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput> | reddit_clone_post_votesCreateWithoutPostInput[] | reddit_clone_post_votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutPostInput | reddit_clone_post_votesCreateOrConnectWithoutPostInput[]\n    createMany?: reddit_clone_post_votesCreateManyPostInputEnvelope\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_postsNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_postsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_postsInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_postsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_postsInput, reddit_clone_memberUpdateWithoutReddit_clone_postsInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_postsNestedInput = {\n    create?: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_postsInput>\n    connectOrCreate?: reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_postsInput\n    upsert?: reddit_clone_communitiesUpsertWithoutReddit_clone_postsInput\n    connect?: reddit_clone_communitiesWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_postsInput, reddit_clone_communitiesUpdateWithoutReddit_clone_postsInput>, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_commentsUpdateManyWithoutPostNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput> | reddit_clone_commentsCreateWithoutPostInput[] | reddit_clone_commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutPostInput | reddit_clone_commentsCreateOrConnectWithoutPostInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutPostInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: reddit_clone_commentsCreateManyPostInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutPostInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutPostInput | reddit_clone_commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_post_votesUpdateManyWithoutPostNestedInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput> | reddit_clone_post_votesCreateWithoutPostInput[] | reddit_clone_post_votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutPostInput | reddit_clone_post_votesCreateOrConnectWithoutPostInput[]\n    upsert?: reddit_clone_post_votesUpsertWithWhereUniqueWithoutPostInput | reddit_clone_post_votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: reddit_clone_post_votesCreateManyPostInputEnvelope\n    set?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    delete?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    update?: reddit_clone_post_votesUpdateWithWhereUniqueWithoutPostInput | reddit_clone_post_votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: reddit_clone_post_votesUpdateManyWithWhereWithoutPostInput | reddit_clone_post_votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput> | reddit_clone_commentsCreateWithoutPostInput[] | reddit_clone_commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutPostInput | reddit_clone_commentsCreateOrConnectWithoutPostInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutPostInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: reddit_clone_commentsCreateManyPostInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutPostInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutPostInput | reddit_clone_commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput> | reddit_clone_post_votesCreateWithoutPostInput[] | reddit_clone_post_votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: reddit_clone_post_votesCreateOrConnectWithoutPostInput | reddit_clone_post_votesCreateOrConnectWithoutPostInput[]\n    upsert?: reddit_clone_post_votesUpsertWithWhereUniqueWithoutPostInput | reddit_clone_post_votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: reddit_clone_post_votesCreateManyPostInputEnvelope\n    set?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    delete?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    connect?: reddit_clone_post_votesWhereUniqueInput | reddit_clone_post_votesWhereUniqueInput[]\n    update?: reddit_clone_post_votesUpdateWithWhereUniqueWithoutPostInput | reddit_clone_post_votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: reddit_clone_post_votesUpdateManyWithWhereWithoutPostInput | reddit_clone_post_votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_commentsInput>\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutReddit_clone_commentsInput\n    connect?: reddit_clone_postsWhereUniqueInput\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_commentsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_commentsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_commentsCreateNestedOneWithoutRecursiveInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutRecursiveInput, reddit_clone_commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutRecursiveInput\n    connect?: reddit_clone_commentsWhereUniqueInput\n  }\n\n  export type reddit_clone_commentsCreateNestedManyWithoutParentInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput> | reddit_clone_commentsCreateWithoutParentInput[] | reddit_clone_commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutParentInput | reddit_clone_commentsCreateOrConnectWithoutParentInput[]\n    createMany?: reddit_clone_commentsCreateManyParentInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_comment_votesCreateNestedManyWithoutCommentInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput> | reddit_clone_comment_votesCreateWithoutCommentInput[] | reddit_clone_comment_votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutCommentInput | reddit_clone_comment_votesCreateOrConnectWithoutCommentInput[]\n    createMany?: reddit_clone_comment_votesCreateManyCommentInputEnvelope\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput> | reddit_clone_commentsCreateWithoutParentInput[] | reddit_clone_commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutParentInput | reddit_clone_commentsCreateOrConnectWithoutParentInput[]\n    createMany?: reddit_clone_commentsCreateManyParentInputEnvelope\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n  }\n\n  export type reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput> | reddit_clone_comment_votesCreateWithoutCommentInput[] | reddit_clone_comment_votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutCommentInput | reddit_clone_comment_votesCreateOrConnectWithoutCommentInput[]\n    createMany?: reddit_clone_comment_votesCreateManyCommentInputEnvelope\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n  }\n\n  export type reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_commentsInput>\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutReddit_clone_commentsInput\n    upsert?: reddit_clone_postsUpsertWithoutReddit_clone_commentsInput\n    connect?: reddit_clone_postsWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_postsUpdateToOneWithWhereWithoutReddit_clone_commentsInput, reddit_clone_postsUpdateWithoutReddit_clone_commentsInput>, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_commentsInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_commentsInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_commentsInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_commentsInput, reddit_clone_memberUpdateWithoutReddit_clone_commentsInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutRecursiveInput, reddit_clone_commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutRecursiveInput\n    upsert?: reddit_clone_commentsUpsertWithoutRecursiveInput\n    disconnect?: reddit_clone_commentsWhereInput | boolean\n    delete?: reddit_clone_commentsWhereInput | boolean\n    connect?: reddit_clone_commentsWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_commentsUpdateToOneWithWhereWithoutRecursiveInput, reddit_clone_commentsUpdateWithoutRecursiveInput>, reddit_clone_commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type reddit_clone_commentsUpdateManyWithoutParentNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput> | reddit_clone_commentsCreateWithoutParentInput[] | reddit_clone_commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutParentInput | reddit_clone_commentsCreateOrConnectWithoutParentInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutParentInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: reddit_clone_commentsCreateManyParentInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutParentInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutParentInput | reddit_clone_commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput> | reddit_clone_comment_votesCreateWithoutCommentInput[] | reddit_clone_comment_votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutCommentInput | reddit_clone_comment_votesCreateOrConnectWithoutCommentInput[]\n    upsert?: reddit_clone_comment_votesUpsertWithWhereUniqueWithoutCommentInput | reddit_clone_comment_votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: reddit_clone_comment_votesCreateManyCommentInputEnvelope\n    set?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    delete?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    update?: reddit_clone_comment_votesUpdateWithWhereUniqueWithoutCommentInput | reddit_clone_comment_votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: reddit_clone_comment_votesUpdateManyWithWhereWithoutCommentInput | reddit_clone_comment_votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput> | reddit_clone_commentsCreateWithoutParentInput[] | reddit_clone_commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutParentInput | reddit_clone_commentsCreateOrConnectWithoutParentInput[]\n    upsert?: reddit_clone_commentsUpsertWithWhereUniqueWithoutParentInput | reddit_clone_commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: reddit_clone_commentsCreateManyParentInputEnvelope\n    set?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    disconnect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    delete?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    connect?: reddit_clone_commentsWhereUniqueInput | reddit_clone_commentsWhereUniqueInput[]\n    update?: reddit_clone_commentsUpdateWithWhereUniqueWithoutParentInput | reddit_clone_commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: reddit_clone_commentsUpdateManyWithWhereWithoutParentInput | reddit_clone_commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput> | reddit_clone_comment_votesCreateWithoutCommentInput[] | reddit_clone_comment_votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: reddit_clone_comment_votesCreateOrConnectWithoutCommentInput | reddit_clone_comment_votesCreateOrConnectWithoutCommentInput[]\n    upsert?: reddit_clone_comment_votesUpsertWithWhereUniqueWithoutCommentInput | reddit_clone_comment_votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: reddit_clone_comment_votesCreateManyCommentInputEnvelope\n    set?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    disconnect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    delete?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    connect?: reddit_clone_comment_votesWhereUniqueInput | reddit_clone_comment_votesWhereUniqueInput[]\n    update?: reddit_clone_comment_votesUpdateWithWhereUniqueWithoutCommentInput | reddit_clone_comment_votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: reddit_clone_comment_votesUpdateManyWithWhereWithoutCommentInput | reddit_clone_comment_votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_post_votesInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_post_votesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_post_votesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_postsCreateNestedOneWithoutReddit_clone_post_votesInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_post_votesInput>\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutReddit_clone_post_votesInput\n    connect?: reddit_clone_postsWhereUniqueInput\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_post_votesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_post_votesInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_post_votesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_post_votesInput, reddit_clone_memberUpdateWithoutReddit_clone_post_votesInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput = {\n    create?: XOR<reddit_clone_postsCreateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_post_votesInput>\n    connectOrCreate?: reddit_clone_postsCreateOrConnectWithoutReddit_clone_post_votesInput\n    upsert?: reddit_clone_postsUpsertWithoutReddit_clone_post_votesInput\n    connect?: reddit_clone_postsWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_postsUpdateToOneWithWhereWithoutReddit_clone_post_votesInput, reddit_clone_postsUpdateWithoutReddit_clone_post_votesInput>, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_memberCreateNestedOneWithoutReddit_clone_comment_votesInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_comment_votesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n  }\n\n  export type reddit_clone_commentsCreateNestedOneWithoutReddit_clone_comment_votesInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutReddit_clone_comment_votesInput\n    connect?: reddit_clone_commentsWhereUniqueInput\n  }\n\n  export type reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput = {\n    create?: XOR<reddit_clone_memberCreateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    connectOrCreate?: reddit_clone_memberCreateOrConnectWithoutReddit_clone_comment_votesInput\n    upsert?: reddit_clone_memberUpsertWithoutReddit_clone_comment_votesInput\n    connect?: reddit_clone_memberWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_comment_votesInput, reddit_clone_memberUpdateWithoutReddit_clone_comment_votesInput>, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type reddit_clone_commentsUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput = {\n    create?: XOR<reddit_clone_commentsCreateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    connectOrCreate?: reddit_clone_commentsCreateOrConnectWithoutReddit_clone_comment_votesInput\n    upsert?: reddit_clone_commentsUpsertWithoutReddit_clone_comment_votesInput\n    connect?: reddit_clone_commentsWhereUniqueInput\n    update?: XOR<XOR<reddit_clone_commentsUpdateToOneWithWhereWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUpdateWithoutReddit_clone_comment_votesInput>, reddit_clone_commentsUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type reddit_clone_moderatorCreateWithoutMemberInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_moderatorInput\n  }\n\n  export type reddit_clone_moderatorUncheckedCreateWithoutMemberInput = {\n    id: string\n    community_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_moderatorCreateOrConnectWithoutMemberInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    create: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput>\n  }\n\n  export type reddit_clone_moderatorCreateManyMemberInputEnvelope = {\n    data: reddit_clone_moderatorCreateManyMemberInput | reddit_clone_moderatorCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_adminCreateWithoutMemberInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_adminUncheckedCreateWithoutMemberInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_adminCreateOrConnectWithoutMemberInput = {\n    where: reddit_clone_adminWhereUniqueInput\n    create: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput>\n  }\n\n  export type reddit_clone_adminCreateManyMemberInputEnvelope = {\n    data: reddit_clone_adminCreateManyMemberInput | reddit_clone_adminCreateManyMemberInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_communitiesCreateWithoutCreatorInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateWithoutCreatorInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesCreateOrConnectWithoutCreatorInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    create: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput>\n  }\n\n  export type reddit_clone_communitiesCreateManyCreatorInputEnvelope = {\n    data: reddit_clone_communitiesCreateManyCreatorInput | reddit_clone_communitiesCreateManyCreatorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsCreateWithoutUserInput = {\n    id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_community_subscriptionsInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput = {\n    id: string\n    community_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsCreateOrConnectWithoutUserInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    create: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_community_subscriptionsCreateManyUserInputEnvelope = {\n    data: reddit_clone_community_subscriptionsCreateManyUserInput | reddit_clone_community_subscriptionsCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_postsCreateWithoutAuthorInput = {\n    id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_postsInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsCreateOrConnectWithoutAuthorInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    create: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_postsCreateManyAuthorInputEnvelope = {\n    data: reddit_clone_postsCreateManyAuthorInput | reddit_clone_postsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_commentsCreateWithoutAuthorInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput\n    parent?: reddit_clone_commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: reddit_clone_commentsCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    post_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    recursive?: reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsCreateOrConnectWithoutAuthorInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    create: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_commentsCreateManyAuthorInputEnvelope = {\n    data: reddit_clone_commentsCreateManyAuthorInput | reddit_clone_commentsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_post_votesCreateWithoutUserInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_post_votesInput\n  }\n\n  export type reddit_clone_post_votesUncheckedCreateWithoutUserInput = {\n    id: string\n    post_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_post_votesCreateOrConnectWithoutUserInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    create: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_post_votesCreateManyUserInputEnvelope = {\n    data: reddit_clone_post_votesCreateManyUserInput | reddit_clone_post_votesCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_comment_votesCreateWithoutUserInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    comment: reddit_clone_commentsCreateNestedOneWithoutReddit_clone_comment_votesInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedCreateWithoutUserInput = {\n    id: string\n    comment_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_comment_votesCreateOrConnectWithoutUserInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    create: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_comment_votesCreateManyUserInputEnvelope = {\n    data: reddit_clone_comment_votesCreateManyUserInput | reddit_clone_comment_votesCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_moderatorUpsertWithWhereUniqueWithoutMemberInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    update: XOR<reddit_clone_moderatorUpdateWithoutMemberInput, reddit_clone_moderatorUncheckedUpdateWithoutMemberInput>\n    create: XOR<reddit_clone_moderatorCreateWithoutMemberInput, reddit_clone_moderatorUncheckedCreateWithoutMemberInput>\n  }\n\n  export type reddit_clone_moderatorUpdateWithWhereUniqueWithoutMemberInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    data: XOR<reddit_clone_moderatorUpdateWithoutMemberInput, reddit_clone_moderatorUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type reddit_clone_moderatorUpdateManyWithWhereWithoutMemberInput = {\n    where: reddit_clone_moderatorScalarWhereInput\n    data: XOR<reddit_clone_moderatorUpdateManyMutationInput, reddit_clone_moderatorUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type reddit_clone_moderatorScalarWhereInput = {\n    AND?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n    OR?: reddit_clone_moderatorScalarWhereInput[]\n    NOT?: reddit_clone_moderatorScalarWhereInput | reddit_clone_moderatorScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    member_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    community_id?: UuidFilter<\"reddit_clone_moderator\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_moderator\"> | Date | string\n  }\n\n  export type reddit_clone_adminUpsertWithWhereUniqueWithoutMemberInput = {\n    where: reddit_clone_adminWhereUniqueInput\n    update: XOR<reddit_clone_adminUpdateWithoutMemberInput, reddit_clone_adminUncheckedUpdateWithoutMemberInput>\n    create: XOR<reddit_clone_adminCreateWithoutMemberInput, reddit_clone_adminUncheckedCreateWithoutMemberInput>\n  }\n\n  export type reddit_clone_adminUpdateWithWhereUniqueWithoutMemberInput = {\n    where: reddit_clone_adminWhereUniqueInput\n    data: XOR<reddit_clone_adminUpdateWithoutMemberInput, reddit_clone_adminUncheckedUpdateWithoutMemberInput>\n  }\n\n  export type reddit_clone_adminUpdateManyWithWhereWithoutMemberInput = {\n    where: reddit_clone_adminScalarWhereInput\n    data: XOR<reddit_clone_adminUpdateManyMutationInput, reddit_clone_adminUncheckedUpdateManyWithoutMemberInput>\n  }\n\n  export type reddit_clone_adminScalarWhereInput = {\n    AND?: reddit_clone_adminScalarWhereInput | reddit_clone_adminScalarWhereInput[]\n    OR?: reddit_clone_adminScalarWhereInput[]\n    NOT?: reddit_clone_adminScalarWhereInput | reddit_clone_adminScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_admin\"> | string\n    member_id?: UuidFilter<\"reddit_clone_admin\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_admin\"> | Date | string\n  }\n\n  export type reddit_clone_communitiesUpsertWithWhereUniqueWithoutCreatorInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    update: XOR<reddit_clone_communitiesUpdateWithoutCreatorInput, reddit_clone_communitiesUncheckedUpdateWithoutCreatorInput>\n    create: XOR<reddit_clone_communitiesCreateWithoutCreatorInput, reddit_clone_communitiesUncheckedCreateWithoutCreatorInput>\n  }\n\n  export type reddit_clone_communitiesUpdateWithWhereUniqueWithoutCreatorInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    data: XOR<reddit_clone_communitiesUpdateWithoutCreatorInput, reddit_clone_communitiesUncheckedUpdateWithoutCreatorInput>\n  }\n\n  export type reddit_clone_communitiesUpdateManyWithWhereWithoutCreatorInput = {\n    where: reddit_clone_communitiesScalarWhereInput\n    data: XOR<reddit_clone_communitiesUpdateManyMutationInput, reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorInput>\n  }\n\n  export type reddit_clone_communitiesScalarWhereInput = {\n    AND?: reddit_clone_communitiesScalarWhereInput | reddit_clone_communitiesScalarWhereInput[]\n    OR?: reddit_clone_communitiesScalarWhereInput[]\n    NOT?: reddit_clone_communitiesScalarWhereInput | reddit_clone_communitiesScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_communities\"> | string\n    creator_id?: UuidFilter<\"reddit_clone_communities\"> | string\n    name?: StringFilter<\"reddit_clone_communities\"> | string\n    description?: StringNullableFilter<\"reddit_clone_communities\"> | string | null\n    created_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_communities\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"reddit_clone_communities\"> | Date | string | null\n    is_nsfw?: BoolFilter<\"reddit_clone_communities\"> | boolean\n    member_count?: IntFilter<\"reddit_clone_communities\"> | number\n  }\n\n  export type reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    update: XOR<reddit_clone_community_subscriptionsUpdateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedUpdateWithoutUserInput>\n    create: XOR<reddit_clone_community_subscriptionsCreateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    data: XOR<reddit_clone_community_subscriptionsUpdateWithoutUserInput, reddit_clone_community_subscriptionsUncheckedUpdateWithoutUserInput>\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutUserInput = {\n    where: reddit_clone_community_subscriptionsScalarWhereInput\n    data: XOR<reddit_clone_community_subscriptionsUpdateManyMutationInput, reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type reddit_clone_community_subscriptionsScalarWhereInput = {\n    AND?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n    OR?: reddit_clone_community_subscriptionsScalarWhereInput[]\n    NOT?: reddit_clone_community_subscriptionsScalarWhereInput | reddit_clone_community_subscriptionsScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    user_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    community_id?: UuidFilter<\"reddit_clone_community_subscriptions\"> | string\n    subscribed_at?: DateTimeFilter<\"reddit_clone_community_subscriptions\"> | Date | string\n    is_muted?: BoolFilter<\"reddit_clone_community_subscriptions\"> | boolean\n  }\n\n  export type reddit_clone_postsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    update: XOR<reddit_clone_postsUpdateWithoutAuthorInput, reddit_clone_postsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<reddit_clone_postsCreateWithoutAuthorInput, reddit_clone_postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_postsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    data: XOR<reddit_clone_postsUpdateWithoutAuthorInput, reddit_clone_postsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_postsUpdateManyWithWhereWithoutAuthorInput = {\n    where: reddit_clone_postsScalarWhereInput\n    data: XOR<reddit_clone_postsUpdateManyMutationInput, reddit_clone_postsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type reddit_clone_postsScalarWhereInput = {\n    AND?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n    OR?: reddit_clone_postsScalarWhereInput[]\n    NOT?: reddit_clone_postsScalarWhereInput | reddit_clone_postsScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_posts\"> | string\n    author_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    community_id?: UuidFilter<\"reddit_clone_posts\"> | string\n    title?: StringFilter<\"reddit_clone_posts\"> | string\n    content?: StringFilter<\"reddit_clone_posts\"> | string\n    content_type?: StringFilter<\"reddit_clone_posts\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_posts\"> | Date | string\n    is_locked?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    is_nsfw?: BoolFilter<\"reddit_clone_posts\"> | boolean\n    upvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_posts\"> | number\n    comment_count?: IntFilter<\"reddit_clone_posts\"> | number\n  }\n\n  export type reddit_clone_commentsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    update: XOR<reddit_clone_commentsUpdateWithoutAuthorInput, reddit_clone_commentsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<reddit_clone_commentsCreateWithoutAuthorInput, reddit_clone_commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_commentsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    data: XOR<reddit_clone_commentsUpdateWithoutAuthorInput, reddit_clone_commentsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type reddit_clone_commentsUpdateManyWithWhereWithoutAuthorInput = {\n    where: reddit_clone_commentsScalarWhereInput\n    data: XOR<reddit_clone_commentsUpdateManyMutationInput, reddit_clone_commentsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type reddit_clone_commentsScalarWhereInput = {\n    AND?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n    OR?: reddit_clone_commentsScalarWhereInput[]\n    NOT?: reddit_clone_commentsScalarWhereInput | reddit_clone_commentsScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_comments\"> | string\n    post_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    author_id?: UuidFilter<\"reddit_clone_comments\"> | string\n    parent_comment_id?: UuidNullableFilter<\"reddit_clone_comments\"> | string | null\n    content?: StringFilter<\"reddit_clone_comments\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"reddit_clone_comments\"> | Date | string\n    upvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n    downvote_count?: IntFilter<\"reddit_clone_comments\"> | number\n  }\n\n  export type reddit_clone_post_votesUpsertWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    update: XOR<reddit_clone_post_votesUpdateWithoutUserInput, reddit_clone_post_votesUncheckedUpdateWithoutUserInput>\n    create: XOR<reddit_clone_post_votesCreateWithoutUserInput, reddit_clone_post_votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_post_votesUpdateWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    data: XOR<reddit_clone_post_votesUpdateWithoutUserInput, reddit_clone_post_votesUncheckedUpdateWithoutUserInput>\n  }\n\n  export type reddit_clone_post_votesUpdateManyWithWhereWithoutUserInput = {\n    where: reddit_clone_post_votesScalarWhereInput\n    data: XOR<reddit_clone_post_votesUpdateManyMutationInput, reddit_clone_post_votesUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type reddit_clone_post_votesScalarWhereInput = {\n    AND?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n    OR?: reddit_clone_post_votesScalarWhereInput[]\n    NOT?: reddit_clone_post_votesScalarWhereInput | reddit_clone_post_votesScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    user_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    post_id?: UuidFilter<\"reddit_clone_post_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_post_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_post_votes\"> | Date | string\n  }\n\n  export type reddit_clone_comment_votesUpsertWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    update: XOR<reddit_clone_comment_votesUpdateWithoutUserInput, reddit_clone_comment_votesUncheckedUpdateWithoutUserInput>\n    create: XOR<reddit_clone_comment_votesCreateWithoutUserInput, reddit_clone_comment_votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type reddit_clone_comment_votesUpdateWithWhereUniqueWithoutUserInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    data: XOR<reddit_clone_comment_votesUpdateWithoutUserInput, reddit_clone_comment_votesUncheckedUpdateWithoutUserInput>\n  }\n\n  export type reddit_clone_comment_votesUpdateManyWithWhereWithoutUserInput = {\n    where: reddit_clone_comment_votesScalarWhereInput\n    data: XOR<reddit_clone_comment_votesUpdateManyMutationInput, reddit_clone_comment_votesUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type reddit_clone_comment_votesScalarWhereInput = {\n    AND?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n    OR?: reddit_clone_comment_votesScalarWhereInput[]\n    NOT?: reddit_clone_comment_votesScalarWhereInput | reddit_clone_comment_votesScalarWhereInput[]\n    id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    user_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    comment_id?: UuidFilter<\"reddit_clone_comment_votes\"> | string\n    vote_type?: StringFilter<\"reddit_clone_comment_votes\"> | string\n    created_at?: DateTimeFilter<\"reddit_clone_comment_votes\"> | Date | string\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_moderatorInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_moderatorInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_moderatorInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_communitiesCreateWithoutReddit_clone_moderatorInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    creator: reddit_clone_memberCreateNestedOneWithoutReddit_clone_communitiesInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_moderatorInput = {\n    id: string\n    creator_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_moderatorInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_moderatorInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_moderatorInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_moderatorInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_moderatorInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_moderatorInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_moderatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_moderatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_communitiesUpsertWithoutReddit_clone_moderatorInput = {\n    update: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_moderatorInput>\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_moderatorInput>\n    where?: reddit_clone_communitiesWhereInput\n  }\n\n  export type reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_moderatorInput = {\n    where?: reddit_clone_communitiesWhereInput\n    data: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_moderatorInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_moderatorInput>\n  }\n\n  export type reddit_clone_communitiesUpdateWithoutReddit_clone_moderatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    creator?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_communitiesNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_moderatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    creator_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_adminInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_adminInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_adminInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_adminInput>\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_adminInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_adminInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_adminInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_adminInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_adminInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_adminInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_adminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_adminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_communitiesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_communitiesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_communitiesInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_communitiesInput>\n  }\n\n  export type reddit_clone_moderatorCreateWithoutCommunityInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n    member: reddit_clone_memberCreateNestedOneWithoutReddit_clone_moderatorInput\n  }\n\n  export type reddit_clone_moderatorUncheckedCreateWithoutCommunityInput = {\n    id: string\n    member_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_moderatorCreateOrConnectWithoutCommunityInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    create: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_moderatorCreateManyCommunityInputEnvelope = {\n    data: reddit_clone_moderatorCreateManyCommunityInput | reddit_clone_moderatorCreateManyCommunityInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsCreateWithoutCommunityInput = {\n    id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_community_subscriptionsInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput = {\n    id: string\n    user_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_community_subscriptionsCreateOrConnectWithoutCommunityInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    create: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_community_subscriptionsCreateManyCommunityInputEnvelope = {\n    data: reddit_clone_community_subscriptionsCreateManyCommunityInput | reddit_clone_community_subscriptionsCreateManyCommunityInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_postsCreateWithoutCommunityInput = {\n    id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_postsInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUncheckedCreateWithoutCommunityInput = {\n    id: string\n    author_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutPostInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsCreateOrConnectWithoutCommunityInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    create: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_postsCreateManyCommunityInputEnvelope = {\n    data: reddit_clone_postsCreateManyCommunityInput | reddit_clone_postsCreateManyCommunityInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_communitiesInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_communitiesInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_communitiesInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_communitiesInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_communitiesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_communitiesInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_communitiesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_communitiesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_moderatorUpsertWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    update: XOR<reddit_clone_moderatorUpdateWithoutCommunityInput, reddit_clone_moderatorUncheckedUpdateWithoutCommunityInput>\n    create: XOR<reddit_clone_moderatorCreateWithoutCommunityInput, reddit_clone_moderatorUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_moderatorUpdateWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_moderatorWhereUniqueInput\n    data: XOR<reddit_clone_moderatorUpdateWithoutCommunityInput, reddit_clone_moderatorUncheckedUpdateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_moderatorUpdateManyWithWhereWithoutCommunityInput = {\n    where: reddit_clone_moderatorScalarWhereInput\n    data: XOR<reddit_clone_moderatorUpdateManyMutationInput, reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityInput>\n  }\n\n  export type reddit_clone_community_subscriptionsUpsertWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    update: XOR<reddit_clone_community_subscriptionsUpdateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedUpdateWithoutCommunityInput>\n    create: XOR<reddit_clone_community_subscriptionsCreateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_community_subscriptionsWhereUniqueInput\n    data: XOR<reddit_clone_community_subscriptionsUpdateWithoutCommunityInput, reddit_clone_community_subscriptionsUncheckedUpdateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateManyWithWhereWithoutCommunityInput = {\n    where: reddit_clone_community_subscriptionsScalarWhereInput\n    data: XOR<reddit_clone_community_subscriptionsUpdateManyMutationInput, reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityInput>\n  }\n\n  export type reddit_clone_postsUpsertWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    update: XOR<reddit_clone_postsUpdateWithoutCommunityInput, reddit_clone_postsUncheckedUpdateWithoutCommunityInput>\n    create: XOR<reddit_clone_postsCreateWithoutCommunityInput, reddit_clone_postsUncheckedCreateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_postsUpdateWithWhereUniqueWithoutCommunityInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    data: XOR<reddit_clone_postsUpdateWithoutCommunityInput, reddit_clone_postsUncheckedUpdateWithoutCommunityInput>\n  }\n\n  export type reddit_clone_postsUpdateManyWithWhereWithoutCommunityInput = {\n    where: reddit_clone_postsScalarWhereInput\n    data: XOR<reddit_clone_postsUpdateManyMutationInput, reddit_clone_postsUncheckedUpdateManyWithoutCommunityInput>\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_community_subscriptionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_community_subscriptionsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_community_subscriptionsInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_communitiesCreateWithoutReddit_clone_community_subscriptionsInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    creator: reddit_clone_memberCreateNestedOneWithoutReddit_clone_communitiesInput\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_community_subscriptionsInput = {\n    id: string\n    creator_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_community_subscriptionsInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_community_subscriptionsInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_community_subscriptionsInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_community_subscriptionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_communitiesUpsertWithoutReddit_clone_community_subscriptionsInput = {\n    update: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_community_subscriptionsInput>\n    where?: reddit_clone_communitiesWhereInput\n  }\n\n  export type reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_community_subscriptionsInput = {\n    where?: reddit_clone_communitiesWhereInput\n    data: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_community_subscriptionsInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput>\n  }\n\n  export type reddit_clone_communitiesUpdateWithoutReddit_clone_community_subscriptionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    creator?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_communitiesNestedInput\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_community_subscriptionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    creator_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_postsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_postsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_postsInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_communitiesCreateWithoutReddit_clone_postsInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    creator: reddit_clone_memberCreateNestedOneWithoutReddit_clone_communitiesInput\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_postsInput = {\n    id: string\n    creator_id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutCommunityInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutCommunityInput\n  }\n\n  export type reddit_clone_communitiesCreateOrConnectWithoutReddit_clone_postsInput = {\n    where: reddit_clone_communitiesWhereUniqueInput\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_commentsCreateWithoutPostInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput\n    parent?: reddit_clone_commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: reddit_clone_commentsCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateWithoutPostInput = {\n    id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    recursive?: reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsCreateOrConnectWithoutPostInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    create: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type reddit_clone_commentsCreateManyPostInputEnvelope = {\n    data: reddit_clone_commentsCreateManyPostInput | reddit_clone_commentsCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_post_votesCreateWithoutPostInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_post_votesInput\n  }\n\n  export type reddit_clone_post_votesUncheckedCreateWithoutPostInput = {\n    id: string\n    user_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_post_votesCreateOrConnectWithoutPostInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    create: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type reddit_clone_post_votesCreateManyPostInputEnvelope = {\n    data: reddit_clone_post_votesCreateManyPostInput | reddit_clone_post_votesCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_postsInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_postsInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_postsInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_postsInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_postsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_postsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_postsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_communitiesUpsertWithoutReddit_clone_postsInput = {\n    update: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_postsInput>\n    create: XOR<reddit_clone_communitiesCreateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedCreateWithoutReddit_clone_postsInput>\n    where?: reddit_clone_communitiesWhereInput\n  }\n\n  export type reddit_clone_communitiesUpdateToOneWithWhereWithoutReddit_clone_postsInput = {\n    where?: reddit_clone_communitiesWhereInput\n    data: XOR<reddit_clone_communitiesUpdateWithoutReddit_clone_postsInput, reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_postsInput>\n  }\n\n  export type reddit_clone_communitiesUpdateWithoutReddit_clone_postsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    creator?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_communitiesNestedInput\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateWithoutReddit_clone_postsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    creator_id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_commentsUpsertWithWhereUniqueWithoutPostInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    update: XOR<reddit_clone_commentsUpdateWithoutPostInput, reddit_clone_commentsUncheckedUpdateWithoutPostInput>\n    create: XOR<reddit_clone_commentsCreateWithoutPostInput, reddit_clone_commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type reddit_clone_commentsUpdateWithWhereUniqueWithoutPostInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    data: XOR<reddit_clone_commentsUpdateWithoutPostInput, reddit_clone_commentsUncheckedUpdateWithoutPostInput>\n  }\n\n  export type reddit_clone_commentsUpdateManyWithWhereWithoutPostInput = {\n    where: reddit_clone_commentsScalarWhereInput\n    data: XOR<reddit_clone_commentsUpdateManyMutationInput, reddit_clone_commentsUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type reddit_clone_post_votesUpsertWithWhereUniqueWithoutPostInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    update: XOR<reddit_clone_post_votesUpdateWithoutPostInput, reddit_clone_post_votesUncheckedUpdateWithoutPostInput>\n    create: XOR<reddit_clone_post_votesCreateWithoutPostInput, reddit_clone_post_votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type reddit_clone_post_votesUpdateWithWhereUniqueWithoutPostInput = {\n    where: reddit_clone_post_votesWhereUniqueInput\n    data: XOR<reddit_clone_post_votesUpdateWithoutPostInput, reddit_clone_post_votesUncheckedUpdateWithoutPostInput>\n  }\n\n  export type reddit_clone_post_votesUpdateManyWithWhereWithoutPostInput = {\n    where: reddit_clone_post_votesScalarWhereInput\n    data: XOR<reddit_clone_post_votesUpdateManyMutationInput, reddit_clone_post_votesUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type reddit_clone_postsCreateWithoutReddit_clone_commentsInput = {\n    id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_postsInput\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_postsInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUncheckedCreateWithoutReddit_clone_commentsInput = {\n    id: string\n    author_id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsCreateOrConnectWithoutReddit_clone_commentsInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    create: XOR<reddit_clone_postsCreateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_commentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_commentsInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_commentsInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_commentsCreateWithoutRecursiveInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput\n    parent?: reddit_clone_commentsCreateNestedOneWithoutRecursiveInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateWithoutRecursiveInput = {\n    id: string\n    post_id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsCreateOrConnectWithoutRecursiveInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    create: XOR<reddit_clone_commentsCreateWithoutRecursiveInput, reddit_clone_commentsUncheckedCreateWithoutRecursiveInput>\n  }\n\n  export type reddit_clone_commentsCreateWithoutParentInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput\n    recursive?: reddit_clone_commentsCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateWithoutParentInput = {\n    id: string\n    post_id: string\n    author_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    recursive?: reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type reddit_clone_commentsCreateOrConnectWithoutParentInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    create: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type reddit_clone_commentsCreateManyParentInputEnvelope = {\n    data: reddit_clone_commentsCreateManyParentInput | reddit_clone_commentsCreateManyParentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_comment_votesCreateWithoutCommentInput = {\n    id: string\n    vote_type: string\n    created_at: Date | string\n    user: reddit_clone_memberCreateNestedOneWithoutReddit_clone_comment_votesInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedCreateWithoutCommentInput = {\n    id: string\n    user_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_comment_votesCreateOrConnectWithoutCommentInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    create: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type reddit_clone_comment_votesCreateManyCommentInputEnvelope = {\n    data: reddit_clone_comment_votesCreateManyCommentInput | reddit_clone_comment_votesCreateManyCommentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type reddit_clone_postsUpsertWithoutReddit_clone_commentsInput = {\n    update: XOR<reddit_clone_postsUpdateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_commentsInput>\n    create: XOR<reddit_clone_postsCreateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_commentsInput>\n    where?: reddit_clone_postsWhereInput\n  }\n\n  export type reddit_clone_postsUpdateToOneWithWhereWithoutReddit_clone_commentsInput = {\n    where?: reddit_clone_postsWhereInput\n    data: XOR<reddit_clone_postsUpdateWithoutReddit_clone_commentsInput, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_postsUpdateWithoutReddit_clone_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateWithoutReddit_clone_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_commentsInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_commentsInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_commentsInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_commentsInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_commentsInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_commentsInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_commentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_commentsUpsertWithoutRecursiveInput = {\n    update: XOR<reddit_clone_commentsUpdateWithoutRecursiveInput, reddit_clone_commentsUncheckedUpdateWithoutRecursiveInput>\n    create: XOR<reddit_clone_commentsCreateWithoutRecursiveInput, reddit_clone_commentsUncheckedCreateWithoutRecursiveInput>\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  export type reddit_clone_commentsUpdateToOneWithWhereWithoutRecursiveInput = {\n    where?: reddit_clone_commentsWhereInput\n    data: XOR<reddit_clone_commentsUpdateWithoutRecursiveInput, reddit_clone_commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type reddit_clone_commentsUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    parent?: reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUpsertWithWhereUniqueWithoutParentInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    update: XOR<reddit_clone_commentsUpdateWithoutParentInput, reddit_clone_commentsUncheckedUpdateWithoutParentInput>\n    create: XOR<reddit_clone_commentsCreateWithoutParentInput, reddit_clone_commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type reddit_clone_commentsUpdateWithWhereUniqueWithoutParentInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    data: XOR<reddit_clone_commentsUpdateWithoutParentInput, reddit_clone_commentsUncheckedUpdateWithoutParentInput>\n  }\n\n  export type reddit_clone_commentsUpdateManyWithWhereWithoutParentInput = {\n    where: reddit_clone_commentsScalarWhereInput\n    data: XOR<reddit_clone_commentsUpdateManyMutationInput, reddit_clone_commentsUncheckedUpdateManyWithoutParentInput>\n  }\n\n  export type reddit_clone_comment_votesUpsertWithWhereUniqueWithoutCommentInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    update: XOR<reddit_clone_comment_votesUpdateWithoutCommentInput, reddit_clone_comment_votesUncheckedUpdateWithoutCommentInput>\n    create: XOR<reddit_clone_comment_votesCreateWithoutCommentInput, reddit_clone_comment_votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type reddit_clone_comment_votesUpdateWithWhereUniqueWithoutCommentInput = {\n    where: reddit_clone_comment_votesWhereUniqueInput\n    data: XOR<reddit_clone_comment_votesUpdateWithoutCommentInput, reddit_clone_comment_votesUncheckedUpdateWithoutCommentInput>\n  }\n\n  export type reddit_clone_comment_votesUpdateManyWithWhereWithoutCommentInput = {\n    where: reddit_clone_comment_votesScalarWhereInput\n    data: XOR<reddit_clone_comment_votesUpdateManyMutationInput, reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentInput>\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_post_votesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_post_votesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_post_votesInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_postsCreateWithoutReddit_clone_post_votesInput = {\n    id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_postsInput\n    community: reddit_clone_communitiesCreateNestedOneWithoutReddit_clone_postsInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsUncheckedCreateWithoutReddit_clone_post_votesInput = {\n    id: string\n    author_id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type reddit_clone_postsCreateOrConnectWithoutReddit_clone_post_votesInput = {\n    where: reddit_clone_postsWhereUniqueInput\n    create: XOR<reddit_clone_postsCreateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_post_votesInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_post_votesInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_post_votesInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_post_votesInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_post_votesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_post_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_post_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_postsUpsertWithoutReddit_clone_post_votesInput = {\n    update: XOR<reddit_clone_postsUpdateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_post_votesInput>\n    create: XOR<reddit_clone_postsCreateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedCreateWithoutReddit_clone_post_votesInput>\n    where?: reddit_clone_postsWhereInput\n  }\n\n  export type reddit_clone_postsUpdateToOneWithWhereWithoutReddit_clone_post_votesInput = {\n    where?: reddit_clone_postsWhereInput\n    data: XOR<reddit_clone_postsUpdateWithoutReddit_clone_post_votesInput, reddit_clone_postsUncheckedUpdateWithoutReddit_clone_post_votesInput>\n  }\n\n  export type reddit_clone_postsUpdateWithoutReddit_clone_post_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateWithoutReddit_clone_post_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_memberCreateWithoutReddit_clone_comment_votesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberUncheckedCreateWithoutReddit_clone_comment_votesInput = {\n    id: string\n    email: string\n    password_hash: string\n    username: string\n    karma: number\n    created_at: Date | string\n    updated_at: Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedCreateNestedManyWithoutMemberInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedCreateNestedManyWithoutCreatorInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedCreateNestedManyWithoutUserInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedCreateNestedManyWithoutAuthorInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type reddit_clone_memberCreateOrConnectWithoutReddit_clone_comment_votesInput = {\n    where: reddit_clone_memberWhereUniqueInput\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type reddit_clone_commentsCreateWithoutReddit_clone_comment_votesInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    post: reddit_clone_postsCreateNestedOneWithoutReddit_clone_commentsInput\n    author: reddit_clone_memberCreateNestedOneWithoutReddit_clone_commentsInput\n    parent?: reddit_clone_commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: reddit_clone_commentsCreateNestedManyWithoutParentInput\n  }\n\n  export type reddit_clone_commentsUncheckedCreateWithoutReddit_clone_comment_votesInput = {\n    id: string\n    post_id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n    recursive?: reddit_clone_commentsUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type reddit_clone_commentsCreateOrConnectWithoutReddit_clone_comment_votesInput = {\n    where: reddit_clone_commentsWhereUniqueInput\n    create: XOR<reddit_clone_commentsCreateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedCreateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type reddit_clone_memberUpsertWithoutReddit_clone_comment_votesInput = {\n    update: XOR<reddit_clone_memberUpdateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n    create: XOR<reddit_clone_memberCreateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    where?: reddit_clone_memberWhereInput\n  }\n\n  export type reddit_clone_memberUpdateToOneWithWhereWithoutReddit_clone_comment_votesInput = {\n    where?: reddit_clone_memberWhereInput\n    data: XOR<reddit_clone_memberUpdateWithoutReddit_clone_comment_votesInput, reddit_clone_memberUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type reddit_clone_memberUpdateWithoutReddit_clone_comment_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_memberUncheckedUpdateWithoutReddit_clone_comment_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    karma?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_admin?: reddit_clone_adminUncheckedUpdateManyWithoutMemberNestedInput\n    reddit_clone_communities?: reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type reddit_clone_commentsUpsertWithoutReddit_clone_comment_votesInput = {\n    update: XOR<reddit_clone_commentsUpdateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n    create: XOR<reddit_clone_commentsCreateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedCreateWithoutReddit_clone_comment_votesInput>\n    where?: reddit_clone_commentsWhereInput\n  }\n\n  export type reddit_clone_commentsUpdateToOneWithWhereWithoutReddit_clone_comment_votesInput = {\n    where?: reddit_clone_commentsWhereInput\n    data: XOR<reddit_clone_commentsUpdateWithoutReddit_clone_comment_votesInput, reddit_clone_commentsUncheckedUpdateWithoutReddit_clone_comment_votesInput>\n  }\n\n  export type reddit_clone_commentsUpdateWithoutReddit_clone_comment_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    parent?: reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: reddit_clone_commentsUpdateManyWithoutParentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateWithoutReddit_clone_comment_votesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    recursive?: reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type reddit_clone_moderatorCreateManyMemberInput = {\n    id: string\n    community_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_adminCreateManyMemberInput = {\n    id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_communitiesCreateManyCreatorInput = {\n    id: string\n    name: string\n    description?: string | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    is_nsfw: boolean\n    member_count: number\n  }\n\n  export type reddit_clone_community_subscriptionsCreateManyUserInput = {\n    id: string\n    community_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_postsCreateManyAuthorInput = {\n    id: string\n    community_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n  }\n\n  export type reddit_clone_commentsCreateManyAuthorInput = {\n    id: string\n    post_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n  }\n\n  export type reddit_clone_post_votesCreateManyUserInput = {\n    id: string\n    post_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_comment_votesCreateManyUserInput = {\n    id: string\n    comment_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_moderatorUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminUncheckedUpdateWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_adminUncheckedUpdateManyWithoutMemberInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_communitiesUpdateWithoutCreatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_moderator?: reddit_clone_moderatorUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateWithoutCreatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_moderator?: reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_community_subscriptions?: reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityNestedInput\n    reddit_clone_posts?: reddit_clone_postsUncheckedUpdateManyWithoutCommunityNestedInput\n  }\n\n  export type reddit_clone_communitiesUncheckedUpdateManyWithoutCreatorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    member_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_postsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    community?: reddit_clone_communitiesUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    community_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_commentsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    parent?: reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: reddit_clone_commentsUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    recursive?: reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_post_votesUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    comment?: reddit_clone_commentsUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    comment_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    comment_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorCreateManyCommunityInput = {\n    id: string\n    member_id: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type reddit_clone_community_subscriptionsCreateManyCommunityInput = {\n    id: string\n    user_id: string\n    subscribed_at: Date | string\n    is_muted: boolean\n  }\n\n  export type reddit_clone_postsCreateManyCommunityInput = {\n    id: string\n    author_id: string\n    title: string\n    content: string\n    content_type: string\n    created_at: Date | string\n    updated_at: Date | string\n    is_locked: boolean\n    is_nsfw: boolean\n    upvote_count: number\n    downvote_count: number\n    comment_count: number\n  }\n\n  export type reddit_clone_moderatorUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    member?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_moderatorNestedInput\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_moderatorUncheckedUpdateManyWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    member_id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_community_subscriptionsUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_community_subscriptionsNestedInput\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_community_subscriptionsUncheckedUpdateManyWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    subscribed_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_muted?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type reddit_clone_postsUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_postsNestedInput\n    reddit_clone_comments?: reddit_clone_commentsUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n    reddit_clone_comments?: reddit_clone_commentsUncheckedUpdateManyWithoutPostNestedInput\n    reddit_clone_post_votes?: reddit_clone_post_votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type reddit_clone_postsUncheckedUpdateManyWithoutCommunityInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    content_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    is_locked?: BoolFieldUpdateOperationsInput | boolean\n    is_nsfw?: BoolFieldUpdateOperationsInput | boolean\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    comment_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_commentsCreateManyPostInput = {\n    id: string\n    author_id: string\n    parent_comment_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n  }\n\n  export type reddit_clone_post_votesCreateManyPostInput = {\n    id: string\n    user_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_commentsUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    parent?: reddit_clone_commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: reddit_clone_commentsUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    recursive?: reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_post_votesUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_post_votesNestedInput\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_post_votesUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_commentsCreateManyParentInput = {\n    id: string\n    post_id: string\n    author_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    upvote_count: number\n    downvote_count: number\n  }\n\n  export type reddit_clone_comment_votesCreateManyCommentInput = {\n    id: string\n    user_id: string\n    vote_type: string\n    created_at: Date | string\n  }\n\n  export type reddit_clone_commentsUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    post?: reddit_clone_postsUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    author?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_commentsNestedInput\n    recursive?: reddit_clone_commentsUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n    recursive?: reddit_clone_commentsUncheckedUpdateManyWithoutParentNestedInput\n    reddit_clone_comment_votes?: reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type reddit_clone_commentsUncheckedUpdateManyWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    author_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    upvote_count?: IntFieldUpdateOperationsInput | number\n    downvote_count?: IntFieldUpdateOperationsInput | number\n  }\n\n  export type reddit_clone_comment_votesUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: reddit_clone_memberUpdateOneRequiredWithoutReddit_clone_comment_votesNestedInput\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type reddit_clone_comment_votesUncheckedUpdateManyWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    vote_type?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Systematic](#systematic)\n- [Actors](#actors)\n- [Communities](#communities)\n- [Content](#content)\n- [Voting](#voting)\n\n## Systematic\n\n```mermaid\nerDiagram\n\"reddit_clone_configurations\" {\n  String id PK\n  String key UK\n  String value\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n```\n\n### `reddit_clone_configurations`\n\nSystem configuration settings for the Reddit-like community platform.\nStores platform-wide settings, feature flags, and system parameters that\ncontrol platform behavior.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `key`: Configuration key identifier.\n- `value`: Configuration value.\n- `description`: Description of the configuration setting.\n- `created_at`: Timestamp when the configuration was created.\n- `updated_at`: Timestamp when the configuration was last updated.\n\n## Actors\n\n```mermaid\nerDiagram\n\"reddit_clone_guest\" {\n  String id PK\n  String email UK \"nullable\"\n  String password_hash \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_member\" {\n  String id PK\n  String email UK\n  String password_hash\n  String username UK\n  Int karma\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_moderator\" {\n  String id PK\n  String member_id FK\n  String community_id FK\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_admin\" {\n  String id PK\n  String member_id FK,UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_moderator\" }o--|| \"reddit_clone_member\" : member\n\"reddit_clone_admin\" |o--|| \"reddit_clone_member\" : member\n```\n\n### `reddit_clone_guest`\n\nGuest users who can view public content and register/login. This table\nstores temporary session information for unauthenticated users.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Email address for registration (optional for guests).\n- `password_hash`: Password hash for login (optional for guests).\n- `created_at`: Timestamp when the guest session was created.\n- `updated_at`: Timestamp when the guest session was last updated.\n\n### `reddit_clone_member`\n\nAuthenticated members who can create content, vote, and manage their\nprofile. This table stores all regular user accounts.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Unique email address for authentication.\n- `password_hash`: Secure password hash for login.\n- `username`: Unique username for display.\n- `karma`: User's karma score based on votes.\n- `created_at`: Timestamp when the account was created.\n- `updated_at`: Timestamp when the account was last updated.\n\n### `reddit_clone_moderator`\n\nUsers with moderation privileges in specific communities. This table\nstores moderator-specific information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `member_id`: Reference to the member account. [reddit_clone_member.id](#reddit_clone_member).\n- `community_id`\n  > Community where the user is a moderator. {@link\n  > reddit_clone_communities.id}.\n- `created_at`: Timestamp when moderator privileges were granted.\n- `updated_at`: Timestamp when moderator privileges were last updated.\n\n### `reddit_clone_admin`\n\nSystem administrators with full access to manage all users and\ncommunities. This table stores admin-specific information.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `member_id`: Reference to the member account. [reddit_clone_member.id](#reddit_clone_member).\n- `created_at`: Timestamp when admin privileges were granted.\n- `updated_at`: Timestamp when admin privileges were last updated.\n\n## Communities\n\n```mermaid\nerDiagram\n\"reddit_clone_communities\" {\n  String id PK\n  String creator_id FK\n  String name UK\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n  Boolean is_nsfw\n  Int member_count\n}\n\"reddit_clone_community_subscriptions\" {\n  String id PK\n  String user_id FK\n  String community_id FK\n  DateTime subscribed_at\n  Boolean is_muted\n}\n\"reddit_clone_community_subscriptions\" }o--|| \"reddit_clone_communities\" : community\n```\n\n### `reddit_clone_communities`\n\nCore community entity representing subreddit-like communities where users\ncan post content, subscribe, and interact. This table stores all\ncommunity metadata and serves as the central hub for community\noperations.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `creator_id`: The member who created this community. [reddit_clone_member.id](#reddit_clone_member).\n- `name`: Unique name of the community (e.g., 'programming', 'gaming').\n- `description`: Detailed description of the community's purpose and topics.\n- `created_at`: Timestamp when the community was created.\n- `updated_at`: Timestamp when the community was last updated.\n- `deleted_at`: Timestamp when the community was soft deleted, if applicable.\n- `is_nsfw`: Flag indicating if the community contains adult content.\n- `member_count`: Current number of subscribers to this community.\n\n### `reddit_clone_community_subscriptions`\n\nJunction table representing the many-to-many relationship between users\nand communities. Tracks which users are subscribed to which communities\nand manages subscription metadata.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `user_id`\n  > The user who is subscribed to the community. {@link\n  > reddit_clone_member.id}.\n- `community_id`: The community being subscribed to. [reddit_clone_communities.id](#reddit_clone_communities).\n- `subscribed_at`: Timestamp when the user subscribed to the community.\n- `is_muted`: Flag indicating if the user has muted notifications from this community.\n\n## Content\n\n```mermaid\nerDiagram\n\"reddit_clone_posts\" {\n  String id PK\n  String author_id FK\n  String community_id FK\n  String title\n  String content\n  String content_type\n  DateTime created_at\n  DateTime updated_at\n  Boolean is_locked\n  Boolean is_nsfw\n  Int upvote_count\n  Int downvote_count\n  Int comment_count\n}\n\"reddit_clone_comments\" {\n  String id PK\n  String post_id FK\n  String author_id FK\n  String parent_comment_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  Int upvote_count\n  Int downvote_count\n}\n\"reddit_clone_comments\" }o--|| \"reddit_clone_posts\" : post\n\"reddit_clone_comments\" }o--o| \"reddit_clone_comments\" : parent\n```\n\n### `reddit_clone_posts`\n\nRepresents user-created posts in the Reddit-like community platform.\nPosts are the primary content entities that users create, edit, and\nmanage. Each post belongs to a community and has an author. Posts can be\ntext, links, or images and support voting functionality.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `author_id`: The author who created the post. [reddit_clone_member.id](#reddit_clone_member).\n- `community_id`\n  > The community where the post was created. {@link\n  > reddit_clone_communities.id}.\n- `title`: The title of the post.\n- `content`: The content of the post.\n- `content_type`: The type of content (text, link, image).\n- `created_at`: When the post was created.\n- `updated_at`: When the post was last updated.\n- `is_locked`: Whether the post is locked (no new comments allowed).\n- `is_nsfw`: Whether the post contains NSFW (Not Safe For Work) content.\n- `upvote_count`: The number of upvotes the post has received.\n- `downvote_count`: The number of downvotes the post has received.\n- `comment_count`: The number of comments on the post.\n\n### `reddit_clone_comments`\n\nRepresents user comments on posts in the Reddit-like community platform.\nComments are primary content entities that users create, edit, and\nmanage. Each comment belongs to a post and has an author. Comments\nsupport nested replies and voting functionality.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `post_id`: The post this comment belongs to. [reddit_clone_posts.id](#reddit_clone_posts).\n- `author_id`: The author who created the comment. [reddit_clone_member.id](#reddit_clone_member).\n- `parent_comment_id`\n  > The parent comment ID for nested replies (null for top-level comments).\n  > [reddit_clone_comments.id](#reddit_clone_comments).\n- `content`: The content of the comment.\n- `created_at`: When the comment was created.\n- `updated_at`: When the comment was last updated.\n- `upvote_count`: The number of upvotes the comment has received.\n- `downvote_count`: The number of downvotes the comment has received.\n\n## Voting\n\n```mermaid\nerDiagram\n\"reddit_clone_post_votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String vote_type\n  DateTime created_at\n}\n\"reddit_clone_comment_votes\" {\n  String id PK\n  String user_id FK\n  String comment_id FK\n  String vote_type\n  DateTime created_at\n}\n```\n\n### `reddit_clone_post_votes`\n\nTracks user votes on posts in the Reddit-like community platform. This\ntable records each user's vote (upvote or downvote) on specific posts,\nensuring data integrity through composite primary keys and enforcing that\nusers can only vote once per post. The table supports the core voting\nfunctionality and enables features like vote counting, user vote history,\nand content ranking.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `user_id`: User who cast the vote. [reddit_clone_member.id](#reddit_clone_member).\n- `post_id`: Post that received the vote. [reddit_clone_posts.id](#reddit_clone_posts).\n- `vote_type`: Type of vote (upvote or downvote).\n- `created_at`: Timestamp when the vote was cast.\n\n### `reddit_clone_comment_votes`\n\nTracks user votes on comments in the Reddit-like community platform. This\ntable records each user's vote (upvote or downvote) on specific comments,\nensuring data integrity through composite primary keys and enforcing that\nusers can only vote once per comment. The table supports nested comment\nvoting and enables features like comment ranking, user vote history, and\nreputation systems.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `user_id`: User who cast the vote. [reddit_clone_member.id](#reddit_clone_member).\n- `comment_id`: Comment that received the vote. [reddit_clone_comments.id](#reddit_clone_comments).\n- `vote_type`: Type of vote (upvote or downvote).\n- `created_at`: Timestamp when the vote was cast.\n","diagrams":{"Systematic":"```mermaid\nerDiagram\n\"reddit_clone_configurations\" {\n  String id PK\n  String key UK\n  String value\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n```","Actors":"```mermaid\nerDiagram\n\"reddit_clone_guest\" {\n  String id PK\n  String email UK \"nullable\"\n  String password_hash \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_member\" {\n  String id PK\n  String email UK\n  String password_hash\n  String username UK\n  Int karma\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_moderator\" {\n  String id PK\n  String member_id FK\n  String community_id FK\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_admin\" {\n  String id PK\n  String member_id FK,UK\n  DateTime created_at\n  DateTime updated_at\n}\n\"reddit_clone_moderator\" }o--|| \"reddit_clone_member\" : member\n\"reddit_clone_admin\" |o--|| \"reddit_clone_member\" : member\n```","Communities":"```mermaid\nerDiagram\n\"reddit_clone_communities\" {\n  String id PK\n  String creator_id FK\n  String name UK\n  String description \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n  Boolean is_nsfw\n  Int member_count\n}\n\"reddit_clone_community_subscriptions\" {\n  String id PK\n  String user_id FK\n  String community_id FK\n  DateTime subscribed_at\n  Boolean is_muted\n}\n\"reddit_clone_community_subscriptions\" }o--|| \"reddit_clone_communities\" : community\n```","Content":"```mermaid\nerDiagram\n\"reddit_clone_posts\" {\n  String id PK\n  String author_id FK\n  String community_id FK\n  String title\n  String content\n  String content_type\n  DateTime created_at\n  DateTime updated_at\n  Boolean is_locked\n  Boolean is_nsfw\n  Int upvote_count\n  Int downvote_count\n  Int comment_count\n}\n\"reddit_clone_comments\" {\n  String id PK\n  String post_id FK\n  String author_id FK\n  String parent_comment_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  Int upvote_count\n  Int downvote_count\n}\n\"reddit_clone_comments\" }o--|| \"reddit_clone_posts\" : post\n\"reddit_clone_comments\" }o--o| \"reddit_clone_comments\" : parent\n```","Voting":"```mermaid\nerDiagram\n\"reddit_clone_post_votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String vote_type\n  DateTime created_at\n}\n\"reddit_clone_comment_votes\" {\n  String id PK\n  String user_id FK\n  String comment_id FK\n  String vote_type\n  DateTime created_at\n}\n```"}},"created_at":"2025-10-14T15:17:14.885Z","completed_at":"2025-10-14T15:20:17.703Z","step":0}]