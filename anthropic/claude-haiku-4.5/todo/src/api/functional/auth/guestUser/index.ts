import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppGuestUser } from "../../../structures/ITodoAppGuestUser";
import { ITodoAppAuthenticatedUser } from "../../../structures/ITodoAppAuthenticatedUser";

/**
 * Register a new guest user account with email and password credentials.
 *
 * This endpoint allows unregistered guest users to create a new account by
 * providing email and password credentials. The registration process includes
 * comprehensive input validation, password strength enforcement, email
 * uniqueness verification, and account creation in the
 * todo_app_authenticateduser table.
 *
 * WHEN a guest user submits a registration request with email and password, THE
 * system SHALL validate the email follows RFC 5321 standard format and is not
 * already registered in the database. THE system SHALL validate the password
 * meets minimum 8 characters, includes uppercase letter, lowercase letter,
 * numeric digit, and special character. THE system SHALL create a new
 * todo_app_authenticateduser record with hashed and salted password (minimum 10
 * bcrypt rounds), setting status to 'active', email_verified to false, and
 * created_at/updated_at to current UTC timestamp.
 *
 * THE system SHALL NOT store passwords in plaintext and SHALL use bcrypt or
 * Argon2 for secure hashing. THE system SHALL generate unique verification
 * email with time-limited token (24-hour expiration) and send to registered
 * email address. THE system SHALL return HTTP 201 with newly created user
 * object containing user ID, email, account status, and email verification
 * status.
 *
 * IF email already exists in database, THE system SHALL return HTTP 409
 * Conflict with error 'Email already registered'. IF password fails strength
 * validation, THE system SHALL return HTTP 400 Bad Request with specific error
 * message indicating which requirement failed (e.g., 'Password must contain
 * uppercase letter'). IF email format invalid, THE system SHALL return HTTP 400
 * Bad Request with error 'Invalid email format'. THE system SHALL NOT reveal
 * whether email exists or not during validation to prevent user enumeration.
 *
 * @param props.connection
 * @param props.body User registration credentials with email and password
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/join
 * @accessor api.functional.auth.guestUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** User registration credentials with email and password */
    body: ITodoAppGuestUser.IJoin;
  };
  export type Body = ITodoAppGuestUser.IJoin;
  export type Response = ITodoAppAuthenticatedUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/join";
  export const random = (): ITodoAppAuthenticatedUser.IAuthorized =>
    typia.random<ITodoAppAuthenticatedUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh expired access token using valid refresh token.
 *
 * This endpoint allows authenticated users to refresh their access tokens
 * without submitting email/password credentials. The refresh process accepts a
 * valid refresh token, validates its signature and expiration, and issues a new
 * short-lived access token with 15-minute expiration if validation succeeds.
 *
 * WHEN a user submits a refresh token request, THE system SHALL extract the
 * refresh token from request (typically from httpOnly cookie or Authorization
 * header). THE system SHALL validate the refresh token signature using the
 * secret key. THE system SHALL verify the refresh token has not expired
 * (comparing exp claim to current time). THE system SHALL verify the refresh
 * token has not been marked as revoked or used.
 *
 * IF refresh token valid and not expired, THE system SHALL generate new JWT
 * access token containing userId, email, role from original token, iat (current
 * time), exp (30 minutes from iat), and tokenType 'access'. THE system SHALL
 * sign the new access token using HS256 algorithm. THE system SHALL optionally
 * generate new refresh token with 7-day expiration if implementing token
 * rotation. THE system SHALL mark the old refresh token as used (preventing
 * reuse for security). THE system SHALL return HTTP 200 with new access token
 * and optionally new refresh token.
 *
 * IF refresh token signature invalid, THE system SHALL return HTTP 401
 * Unauthorized with error code 'AUTH_INVALID_TOKEN' and message 'Invalid
 * refresh token. Please log in again.'. IF refresh token expired, THE system
 * SHALL return HTTP 401 with error code 'AUTH_REFRESH_TOKEN_INVALID' and
 * message 'Refresh token expired. Please log in again.'. IF refresh token
 * already used (revoked), THE system SHALL return HTTP 401 with error code
 * 'AUTH_TOKEN_REVOKED' and message 'Refresh token has already been used. Please
 * log in again.'
 *
 * THE system SHALL NOT accept tokens that have been tampered with or have
 * invalid signatures. THE system SHALL log all token refresh attempts
 * (successful and failed) in todo_app_audit_logs with actor_type
 * 'authenticatedUser', action_type 'TOKEN_REFRESH', entity_type 'SESSION', and
 * operation_status reflecting success or failure.
 *
 * @param props.connection
 * @param props.body Refresh token for obtaining new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/refresh
 * @accessor api.functional.auth.guestUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for obtaining new access token */
    body: ITodoAppGuestUser.IRefresh;
  };
  export type Body = ITodoAppGuestUser.IRefresh;
  export type Response = ITodoAppAuthenticatedUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/refresh";
  export const random = (): ITodoAppAuthenticatedUser.IAuthorized =>
    typia.random<ITodoAppAuthenticatedUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
