import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAuthenticatedUser } from "../../../structures/ITodoAppAuthenticatedUser";

/**
 * Register a new authenticated user account with email and password
 * credentials.
 *
 * WHEN a new user submits registration credentials (email and password), THE
 * system SHALL validate the email format (RFC 5321 standard) and check
 * uniqueness across all accounts. THE system SHALL validate the password meets
 * security requirements: minimum 8 characters, at least one uppercase letter,
 * one lowercase letter, one numeric digit, and one special character. THE
 * system SHALL reject duplicate email addresses with error 'This email is
 * already registered' and reject weak passwords with specific error messages
 * indicating missing requirement.
 *
 * WHEN all validations pass, THE system SHALL create a new user account in the
 * todo_app_authenticateduser table with: user email address, securely hashed
 * and salted password (using bcrypt with minimum 10 rounds), account status set
 * to 'inactive' until email verification, email_verified flag set to false,
 * account creation timestamp, and unique user ID (UUID).
 *
 * THE system SHALL generate a time-limited email verification token (valid 24
 * hours) and send verification email to registered address. User MUST verify
 * email within 24 hours to fully activate account and be able to log in. THE
 * system SHALL return success response with user ID and message 'Registration
 * successful. Verification email sent to [email]. Please verify your email to
 * complete registration.'
 *
 * This operation creates permanent user record in the authenticated user table
 * and initiates the email verification workflow as a prerequisite to account
 * activation. Password is never stored in plaintext, only cryptographically
 * hashed with unique salt.
 *
 * @param props.connection
 * @param props.body User registration credentials including email and password
 *   meeting security requirements
 * @setHeader token.access Authorization
 *
 * @path /auth/authenticatedUser/join
 * @accessor api.functional.auth.authenticatedUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * User registration credentials including email and password meeting
     * security requirements
     */
    body: ITodoAppAuthenticatedUser.ICreate;
  };
  export type Body = ITodoAppAuthenticatedUser.ICreate;
  export type Response = ITodoAppAuthenticatedUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/authenticatedUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/authenticatedUser/join";
  export const random = (): ITodoAppAuthenticatedUser.IAuthorized =>
    typia.random<ITodoAppAuthenticatedUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an existing user with email and password to receive JWT access
 * token.
 *
 * WHEN an existing user submits email and password credentials at login, THE
 * system SHALL validate the credentials against stored user data in the
 * todo_app_authenticateduser table. THE system SHALL query for user account by
 * email address and verify password matches stored password hash using secure
 * comparison (never plaintext comparison).
 *
 * IF credentials are valid, THE system SHALL generate a JWT access token
 * containing user claims (userId, email, role, timestamps). THE system SHALL
 * sign token using HMAC-SHA256 algorithm with secure key. THE system SHALL set
 * token expiration to 15 minutes from creation. THE system SHALL return token
 * to user with 30-minute idle session timeout. THE system SHALL record
 * successful login in user account with last_login_at timestamp.
 *
 * IF credentials are invalid (email not found OR password incorrect), THE
 * system SHALL return generic authentication error 'Invalid email or password.
 * Please try again.' WITHOUT indicating whether email exists or password wrong
 * (prevents user enumeration attacks). THE system SHALL track failed attempt in
 * todo_app_failed_login_attempts table with email, IP address, timestamp, and
 * failure reason.
 *
 * WHEN failed login attempts reach 5 within 15-minute window, THE system SHALL
 * lock the user account by setting locked_until timestamp to 15 minutes in
 * future. THE system SHALL return error 'Account temporarily locked due to
 * multiple failed login attempts. Please try again in 15 minutes.' Locked
 * accounts cannot authenticate until lockout expires. THE system SHALL send
 * security notification email to account holder about failed login attempts.
 *
 * THE system SHALL initialize user session with authenticated user ID, record
 * session creation timestamp, establish session timeout (30 minutes idle, 24
 * hours absolute), and make authenticated endpoints accessible for this user.
 * THE system SHALL transmit JWT token ONLY over HTTPS/TLS encrypted connection
 * in httpOnly secure cookie.
 *
 * @param props.connection
 * @param props.body User login credentials with email address and password for
 *   authentication
 * @setHeader token.access Authorization
 *
 * @path /auth/authenticatedUser/login
 * @accessor api.functional.auth.authenticatedUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * User login credentials with email address and password for
     * authentication
     */
    body: ITodoAppAuthenticatedUser.ILogin;
  };
  export type Body = ITodoAppAuthenticatedUser.ILogin;
  export type Response = ITodoAppAuthenticatedUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/authenticatedUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/authenticatedUser/login";
  export const random = (): ITodoAppAuthenticatedUser.IAuthorized =>
    typia.random<ITodoAppAuthenticatedUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh expired access token using valid refresh token to continue
 * authenticated session.
 *
 * WHEN a user submits a refresh token to obtain a new access token (typically
 * when current access token is about to expire or has expired), THE system
 * SHALL validate the refresh token's signature using the same secret key used
 * for generation. THE system SHALL verify refresh token has not exceeded its
 * 7-day expiration time. THE system SHALL confirm the refresh token has not
 * been previously used (one-time use enforcement to prevent token reuse
 * attacks).
 *
 * IF refresh token is valid and not expired, THE system SHALL extract user ID
 * from token claims and retrieve user account from todo_app_authenticateduser
 * table. THE system SHALL verify user account is in 'active' status (not
 * locked, disabled, or deleted). THE system SHALL generate new JWT access token
 * containing updated user claims (userId, email, role, fresh timestamps) signed
 * with HMAC-SHA256.
 *
 * THE new access token SHALL expire 15 minutes from current time. THE system
 * SHALL generate new refresh token (7-day expiration) if token rotation is
 * implemented. THE system SHALL mark the old refresh token as used to prevent
 * reuse. THE system SHALL return both access token and new refresh token to
 * user for continued session.
 *
 * IF refresh token is expired, invalid, or already used, THE system SHALL
 * return error 'Refresh token invalid or expired. Please log in again.' and
 * HTTP 401 status, requiring user to authenticate again. THE system SHALL NOT
 * issue new tokens for invalid refresh tokens. THE system SHALL log the token
 * refresh attempt for security audit.
 *
 * THE system SHALL transmit tokens ONLY over HTTPS/TLS encrypted connection in
 * httpOnly secure cookies. This operation enables seamless session continuation
 * without forcing re-authentication while maintaining security through
 * short-lived access tokens.
 *
 * @param props.connection
 * @param props.body Refresh token request containing the current refresh token
 *   for obtaining new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/authenticatedUser/refresh
 * @accessor api.functional.auth.authenticatedUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing the current refresh token for
     * obtaining new access token
     */
    body: ITodoAppAuthenticatedUser.IRefresh;
  };
  export type Body = ITodoAppAuthenticatedUser.IRefresh;
  export type Response = ITodoAppAuthenticatedUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/authenticatedUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/authenticatedUser/refresh";
  export const random = (): ITodoAppAuthenticatedUser.IAuthorized =>
    typia.random<ITodoAppAuthenticatedUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
