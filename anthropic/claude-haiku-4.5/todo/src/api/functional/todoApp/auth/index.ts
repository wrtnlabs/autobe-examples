import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAuthenticatedUser } from "../../../structures/ITodoAppAuthenticatedUser";
import { ITodoAppAuth } from "../../../structures/ITodoAppAuth";
export * as verify_email from "./verify_email/index";
export * as request_password_reset from "./request_password_reset/index";
export * as reset_password from "./reset_password/index";

/**
 * Register a new user account with email and password credentials.
 *
 * Register a new user account by providing email address and password meeting
 * security requirements. THE system SHALL validate email format conforming to
 * RFC 5321 standard and reject invalid email addresses. THE system SHALL
 * validate password contains minimum 8 characters including at least one
 * uppercase letter, one lowercase letter, one numeric digit, and one special
 * character (!@#$%^&*). THE system SHALL check email uniqueness and reject if
 * email already registered. THE system SHALL securely hash password using
 * bcrypt with minimum 10 rounds and unique salt before storage. THE system
 * SHALL create new todo_app_authenticateduser record with email, password_hash,
 * status='active', email_verified=false, created_at and updated_at set to
 * current UTC timestamp, and all other fields initialized appropriately.
 *
 * Upon successful registration, THE system SHALL return HTTP 201 (Created)
 * status with newly created user details (id, email, created_at) and send
 * verification email to the provided address containing verification link with
 * 24-hour expiration token. THE user must verify email within 24 hours to fully
 * activate account and gain login capability. THE registration endpoint
 * completes successfully regardless of email verification completion.
 *
 * IF email is already registered, THE system SHALL return HTTP 409 (Conflict)
 * with error message indicating email already exists and suggesting login or
 * using different email. IF password fails validation, THE system SHALL return
 * HTTP 400 (Bad Request) with specific error message indicating which password
 * requirement was not met. IF email format is invalid, THE system SHALL return
 * HTTP 400 (Bad Request) with error message indicating invalid email format.
 *
 * @param props.connection
 * @param props.body User registration credentials including email and password
 *   meeting security requirements
 * @path /todoApp/auth/register
 * @accessor api.functional.todoApp.auth.register
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function register(
  connection: IConnection,
  props: register.Props,
): Promise<register.Response> {
  return true === connection.simulate
    ? register.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...register.METADATA,
          path: register.path(),
          status: null,
        },
        props.body,
      );
}
export namespace register {
  export type Props = {
    /**
     * User registration credentials including email and password meeting
     * security requirements
     */
    body: ITodoAppAuthenticatedUser.IRegister;
  };
  export type Body = ITodoAppAuthenticatedUser.IRegister;
  export type Response = ITodoAppAuthenticatedUser.IRegistered;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/auth/register",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/auth/register";
  export const random = (): ITodoAppAuthenticatedUser.IRegistered =>
    typia.random<ITodoAppAuthenticatedUser.IRegistered>();
  export const simulate = (
    connection: IConnection,
    props: register.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: register.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate user and issue JWT access token for authenticated requests.
 *
 * Authenticate existing user account by providing email and password
 * credentials matching registered account. THE system SHALL verify email exists
 * in todo_app_authenticateduser table by querying on email field using
 * case-insensitive comparison. THE system SHALL validate password by hashing
 * submitted password using same bcrypt algorithm and salt as stored
 * password_hash, then comparing computed hash to stored hash value. THE system
 * SHALL verify account status equals 'active' preventing login with inactive or
 * locked accounts. THE system SHALL verify email_verified flag is true,
 * requiring email verification before login access. THE system SHALL check
 * locked_until timestamp is null or in past, denying login if account currently
 * locked.
 *
 * Upon successful authentication after all validations pass, THE system SHALL:
 *
 * 1. Generate JWT access token containing userId from
 *    todo_app_authenticateduser.id, email address, role='authenticatedUser',
 *    iat set to current Unix timestamp, exp set to iat + 900 seconds (15
 *    minutes), tokenType='access'
 * 2. Sign token using HMAC-SHA256 algorithm with secure cryptographic key
 * 3. Reset failed_login_attempts counter to 0 for the user
 * 4. Update last_login_at timestamp on user record to current UTC time
 * 5. Return HTTP 200 (OK) with token and user details
 * 6. Log successful authentication in todo_app_audit_logs with
 *    action_type='LOGIN', operation_status='SUCCESS'
 *
 * The issued JWT token SHALL be transmitted to client via httpOnly secure
 * cookie (preferred for security) or in response body for client-side storage.
 * Client SHALL include token in Authorization header of all subsequent requests
 * as 'Bearer [token]' for authentication. Token automatically expires after 15
 * minutes requiring re-authentication.
 *
 * For failed authentication, THE system SHALL track attempt in
 * todo_app_failed_login_attempts with email_address, failure_reason
 * ('INVALID_EMAIL' or 'INVALID_PASSWORD'), ip_address, and
 * attempt_number_in_window calculated as count of failures for this email in
 * last 15 minutes. After 5 failed attempts within 15 minutes, THE system SHALL
 * set locked_until to current time + 15 minutes on todo_app_authenticateduser
 * record and update lockout_status in failed_login_attempts to 'LOCKED'. THE
 * system SHALL return HTTP 401 (Unauthorized) with error message 'Invalid email
 * or password' for both invalid email and invalid password to prevent user
 * enumeration. THE system SHALL return HTTP 429 (Too Many Requests) if account
 * currently locked with message indicating lockout period remaining.
 *
 * Generic error message 'Invalid email or password' is used intentionally for
 * both email not found and password mismatch scenarios. This prevents attackers
 * from determining which accounts exist in the system, protecting user privacy
 * and security. THE system logs failure_reason internally ('INVALID_EMAIL' vs
 * 'INVALID_PASSWORD') for administrator analysis and security monitoring, but
 * this distinction is never revealed to the requesting user.
 *
 * @param props.connection
 * @param props.body User login credentials including email and password for
 *   authentication
 * @path /todoApp/auth/login
 * @accessor api.functional.todoApp.auth.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  return true === connection.simulate
    ? login.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...login.METADATA,
          path: login.path(),
          status: null,
        },
        props.body,
      );
}
export namespace login {
  export type Props = {
    /**
     * User login credentials including email and password for
     * authentication
     */
    body: ITodoAppAuthenticatedUser.ILogin;
  };
  export type Body = ITodoAppAuthenticatedUser.ILogin;
  export type Response = ITodoAppAuthenticatedUser.ILoggedIn;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/auth/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/auth/login";
  export const random = (): ITodoAppAuthenticatedUser.ILoggedIn =>
    typia.random<ITodoAppAuthenticatedUser.ILoggedIn>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh authentication token to obtain a new access token.
 *
 * Refresh the user's authentication token by submitting a valid refresh token.
 * This operation extends the user's session without requiring re-entry of
 * credentials, improving user experience while maintaining security through
 * token expiration and rotation.
 *
 * WHEN an authenticated user's access token approaches expiration or has
 * expired, THE user can submit their refresh token to obtain a new access
 * token. THE system SHALL validate the refresh token to ensure it is valid, not
 * expired, and has not been previously used (preventing token replay attacks).
 * THE refresh token must match the user's current session context.
 *
 * Upon successful refresh token validation, THE system SHALL generate a new
 * access token with standard 15-minute expiration time. THE system SHALL also
 * issue a replacement refresh token (token rotation) to maintain security. THE
 * previous refresh token is invalidated and cannot be reused, detecting any
 * unauthorized token usage attempts.
 *
 * The new tokens are returned to the client for use in subsequent authenticated
 * requests. This operation maintains session continuity across token
 * expirations while ensuring strong security through automatic token rotation
 * and one-time use enforcement. The refresh token endpoint is protected and
 * only accepts requests with valid, non-expired refresh tokens.
 *
 * **SECURITY REQUIREMENT**: Token storage and revocation must be implemented in
 * the database. Without this infrastructure, the promised one-time use
 * enforcement and token rotation cannot be properly enforced.
 *
 * @param props.connection
 * @param props.body Refresh token request containing the user's current refresh
 *   token for validation and token rotation
 * @path /todoApp/auth/refresh
 * @accessor api.functional.todoApp.auth.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  return true === connection.simulate
    ? refresh.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...refresh.METADATA,
          path: refresh.path(),
          status: null,
        },
        props.body,
      );
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing the user's current refresh token for
     * validation and token rotation
     */
    body: ITodoAppAuth.IRefreshTokenRequest;
  };
  export type Body = ITodoAppAuth.IRefreshTokenRequest;
  export type Response = ITodoAppAuth.ITokenResponse;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/auth/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/auth/refresh";
  export const random = (): ITodoAppAuth.ITokenResponse =>
    typia.random<ITodoAppAuth.ITokenResponse>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout user and invalidate authentication tokens.
 *
 * Terminate the user's current authenticated session by invalidating all JWT
 * tokens (access token and refresh token). This operation removes the user's
 * authentication credentials, preventing further access to protected resources
 * with the invalidated tokens. All tokens are revoked and logged for security
 * audit trail purposes.
 *
 * WHEN an authenticated user chooses to logout, THE system SHALL invalidate
 * their current access token immediately. THE system SHALL also revoke any
 * associated refresh tokens to prevent token reuse. THE server marks the tokens
 * as revoked in security event logs for forensic and compliance audit trail
 * purposes.
 *
 * Upon successful logout, THE system SHALL return confirmation to the client,
 * indicating the session has been terminated. THE client application SHALL
 * remove stored tokens from secure storage (httpOnly cookies, local storage, or
 * session storage). THE user is redirected to the login page or public landing
 * page, preventing access to protected resources.
 *
 * Logout is a clean termination that ensures session isolation and data
 * security, particularly important on shared or public devices where the next
 * user should not have access to the previous user's authenticated session. The
 * logout operation is protected by the current access token requirement,
 * preventing unauthorized session termination by unauthenticated users.
 *
 * **SECURITY CONSIDERATION**: To properly enforce logout server-side (prevent
 * token reuse after logout), implement token revocation checking in
 * authentication middleware. With current implementation, this requires a token
 * storage table. Without revocation enforcement, logout removes client tokens
 * but server continues accepting the token until natural 15-minute expiration.
 *
 * @param props.connection
 * @path /todoApp/auth/logout
 * @accessor api.functional.todoApp.auth.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export type Response = ITodoAppAuth.ILogoutResponse;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/auth/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/auth/logout";
  export const random = (): ITodoAppAuth.ILogoutResponse =>
    typia.random<ITodoAppAuth.ILogoutResponse>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
