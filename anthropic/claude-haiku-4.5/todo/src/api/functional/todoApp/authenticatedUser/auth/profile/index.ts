import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAuthenticatedUser } from "../../../../../structures/ITodoAppAuthenticatedUser";

/**
 * Retrieve authenticated user profile information.
 *
 * This operation retrieves the complete profile information of the currently
 * authenticated user. The endpoint returns comprehensive user account details
 * associated with the todo_app_authenticateduser table, including email
 * address, first name, last name, account status, email verification status,
 * last login timestamp, account creation timestamp, and account modification
 * timestamp.
 *
 * The operation is read-only and does not modify any user data. Only the
 * authenticated user can retrieve their own profile information. WHEN an
 * authenticated user requests their profile, THE system SHALL return all
 * profile fields for that user. WHEN a user attempts to retrieve another user's
 * profile, THE system SHALL deny access with authorization error.
 *
 * Security considerations include authentication verification before profile
 * retrieval. The system SHALL verify that the requesting user has a valid JWT
 * token or authentication session. WHEN a user's session token is expired or
 * invalid, THE system SHALL return HTTP 401 Unauthorized and require
 * re-authentication.
 *
 * The operation integrates with the todo_app_authenticateduser table from the
 * Prisma schema, returning only fields relevant to user profile display and
 * management. The response includes account lifecycle information (creation
 * time, last login) and account status information (active/inactive/locked
 * status) that users need for account management decisions.
 *
 * Related operations include PUT /auth/profile for updating profile information
 * and DELETE /auth/profile (future enhancement) for account deletion requests.
 * Users may call GET /auth/profile before PUT /auth/profile to retrieve current
 * values for editing, or to verify their current account information is
 * correct.
 *
 * @param props.connection
 * @path /todoApp/authenticatedUser/auth/profile
 * @accessor api.functional.todoApp.authenticatedUser.auth.profile.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(connection: IConnection): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(),
          status: null,
        },
      );
}
export namespace at {
  export type Response = ITodoAppAuthenticatedUser;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/authenticatedUser/auth/profile",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/authenticatedUser/auth/profile";
  export const random = (): ITodoAppAuthenticatedUser =>
    typia.random<ITodoAppAuthenticatedUser>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Update authenticated user profile information.
 *
 * This operation updates the profile information of the currently authenticated
 * user. The endpoint accepts updates to user account details stored in the
 * todo_app_authenticateduser table, including email address, first name, and
 * last name fields. The operation validates all submitted data before applying
 * updates to ensure data integrity and consistency.
 *
 * Authentication and authorization verification is required before processing
 * updates. WHEN an authenticated user submits profile update request, THE
 * system SHALL verify the user's authentication status and authorization to
 * modify their own profile. WHEN a user attempts to update another user's
 * profile, THE system SHALL deny access with HTTP 403 Forbidden authorization
 * error.
 *
 * The operation validates email address format and uniqueness before applying
 * updates. WHEN a user updates their email address, THE system SHALL verify the
 * new email follows RFC 5321 standard format. THE system SHALL check that the
 * new email is not already registered to another account. WHEN email validation
 * fails, THE system SHALL return HTTP 400 Bad Request with specific validation
 * error message.
 *
 * Name field validation ensures data quality. WHEN a user submits first name or
 * last name, THE system SHALL validate that field length does not exceed
 * reasonable limits (typically 100 characters). THE system SHALL accept any
 * UTF-8 characters in name fields including international characters and
 * accents.
 *
 * The operation updates the modified timestamp (updated_at) to current UTC time
 * upon successful update. The account creation timestamp (created_at) remains
 * immutable. Success response returns HTTP 200 OK with complete updated profile
 * data reflecting all changes. The system automatically logs the profile
 * modification for audit trail compliance.
 *
 * Related operations include GET /auth/profile for retrieving current profile
 * before editing, and authentication endpoints for changing password or
 * verifying email separately. Users typically call GET /auth/profile first to
 * retrieve current values, then submit PUT /auth/profile with modified values.
 *
 * @param props.connection
 * @param props.body User profile update information including email, first
 *   name, and last name fields
 * @path /todoApp/authenticatedUser/auth/profile
 * @accessor api.functional.todoApp.authenticatedUser.auth.profile.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * User profile update information including email, first name, and last
     * name fields
     */
    body: ITodoAppAuthenticatedUser.IUpdate;
  };
  export type Body = ITodoAppAuthenticatedUser.IUpdate;
  export type Response = ITodoAppAuthenticatedUser;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/authenticatedUser/auth/profile",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/authenticatedUser/auth/profile";
  export const random = (): ITodoAppAuthenticatedUser =>
    typia.random<ITodoAppAuthenticatedUser>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
