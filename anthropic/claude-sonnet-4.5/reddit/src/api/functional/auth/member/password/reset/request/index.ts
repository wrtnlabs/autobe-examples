import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeMember } from "../../../../../../structures/IRedditLikeMember";

/**
 * Request password reset for member account by email, creating time-limited
 * reset token in reddit_like_password_resets table and sending reset link.
 *
 * Initiates password reset workflow by generating and sending time-limited
 * reset token to user's registered email address.
 *
 * This endpoint implements the forgot password mechanism defined in
 * requirements section 2.2 (Password Reset Requirements). When users cannot
 * access their accounts because they've forgotten their password, they can
 * initiate account recovery through this publicly accessible endpoint by
 * providing their registered email address. This is the first step in a
 * two-step password reset workflow.
 *
 * The password reset initiation process validates the submitted email address
 * exists in reddit_like_members table. If the email is not found, the system
 * still displays a generic success message ("If that email address is
 * registered, you will receive a password reset link") to prevent email
 * enumeration attacks where malicious actors could determine which email
 * addresses have accounts on the platform. This security practice protects user
 * privacy.
 *
 * For valid email addresses associated with active accounts, the system
 * generates a cryptographically secure random reset token using secure random
 * number generation per security requirements section 10. This unique token
 * serves as a time-limited authorization credential for password reset. The
 * system creates a new record in reddit_like_password_resets table containing
 * the user's ID (reddit_like_user_id foreign key), the submitted email address
 * for validation, the generated reset_token, and an expires_at timestamp set to
 * exactly 1 hour in the future per requirements.
 *
 * The system immediately sends a password reset email to the provided address
 * containing a unique reset link with the token embedded as a parameter (e.g.,
 * https://platform.com/auth/member/password/reset?token=XXXXX). The email
 * explains the reset process, warns that the link expires in 1 hour, and
 * advises users to ignore the email if they didn't request the reset. The email
 * send operation occurs asynchronously to avoid blocking the API response.
 *
 * Multiple password reset requests for the same account are allowed - each
 * generates a new token and sends a new email. Previous unused tokens remain
 * valid until their individual expiration times, though only the most recent
 * token is typically used. The used_at field in reddit_like_password_resets
 * remains null for all tokens until one is successfully used to reset the
 * password.
 *
 * Security considerations include rate limiting to prevent email spam abuse
 * (limiting reset requests per email address to reasonable frequency like 3 per
 * hour), logging all reset requests for security monitoring, and ensuring the
 * reset token is sufficiently long and random to prevent guessing attacks
 * (recommended minimum 32 characters of cryptographically random data).
 *
 * The response provides generic confirmation without revealing whether the
 * email exists in the system, protecting user privacy while still being helpful
 * to legitimate users. After submitting, users should check their email inbox
 * (and spam folder) for the reset link within 5 minutes.
 *
 * @param props.connection
 * @param props.body Password reset request containing the email address of the
 *   account to recover
 * @path /auth/member/password/reset/request
 * @accessor api.functional.auth.member.password.reset.request.requestPasswordReset
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function requestPasswordReset(
  connection: IConnection,
  props: requestPasswordReset.Props,
): Promise<requestPasswordReset.Response> {
  return true === connection.simulate
    ? requestPasswordReset.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...requestPasswordReset.METADATA,
          path: requestPasswordReset.path(),
          status: null,
        },
        props.body,
      );
}
export namespace requestPasswordReset {
  export type Props = {
    /**
     * Password reset request containing the email address of the account to
     * recover
     */
    body: IRedditLikeMember.IRequestPasswordReset;
  };
  export type Body = IRedditLikeMember.IRequestPasswordReset;
  export type Response = IRedditLikeMember.IPasswordResetRequested;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/password/reset/request",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/password/reset/request";
  export const random = (): IRedditLikeMember.IPasswordResetRequested =>
    typia.random<IRedditLikeMember.IPasswordResetRequested>();
  export const simulate = (
    connection: IConnection,
    props: requestPasswordReset.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: requestPasswordReset.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
