import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeMember } from "../../../../../../structures/IRedditLikeMember";

/**
 * Complete password reset using token from reddit_like_password_resets,
 * updating reddit_like_members.password_hash and invalidating all sessions.
 *
 * Completes password reset by validating reset token and updating member
 * account password.
 *
 * This endpoint implements the password reset completion workflow defined in
 * requirements section 2.2 (Password Reset Requirements). After a user requests
 * password reset via the initiation endpoint and receives a reset email, they
 * click the link in that email which directs them to a password reset form.
 * Upon submitting their new password, this endpoint processes the reset token
 * and updates their account credentials.
 *
 * The password reset validation process begins by querying
 * reddit_like_password_resets table for a record matching the submitted
 * reset_token. If no matching token exists, the system rejects the reset
 * attempt with error "Invalid or expired reset token." This protects against
 * random token guessing and ensures only properly generated tokens can reset
 * passwords.
 *
 * Next, the system validates the token hasn't expired by comparing current
 * timestamp against the expires_at field. Per requirements, password reset
 * tokens expire exactly 1 hour after generation. If current time exceeds
 * expires_at, the system rejects the reset with error message "This password
 * reset link has expired. Please request a new password reset." The response
 * includes a link or action to initiate a new reset request, providing clear
 * recovery path for users.
 *
 * The system also checks the used_at field to ensure the token hasn't already
 * been consumed. Each reset token can only be used once per requirements - if
 * used_at is not null, the token was previously used to reset the password and
 * the system rejects subsequent attempts with error "This reset token has
 * already been used. Please request a new password reset if needed." This
 * prevents token replay attacks.
 *
 * For valid, non-expired, unused tokens, the system validates the new password
 * meets all security requirements identical to registration: minimum 8
 * characters, at least one uppercase letter, one lowercase letter, one number,
 * and one special character. If the new password fails validation, the system
 * returns specific error messages listing which requirements are not met,
 * allowing users to correct their password without consuming the token.
 *
 * Upon successful validation, the system performs the following atomic
 * operations: updates password_hash in reddit_like_members table for the user
 * identified by reddit_like_user_id foreign key in the reset record, using the
 * same secure hashing algorithm as registration; sets used_at timestamp to
 * current time in reddit_like_password_resets record to mark token as consumed;
 * and sets deleted_at timestamp on ALL records in reddit_like_sessions table
 * belonging to this user, immediately invalidating all existing sessions and
 * forcing re-authentication on all devices per security requirement.
 *
 * The system sends a confirmation email to the account's email address (the one
 * in reddit_like_members, not necessarily the one in the reset request)
 * notifying the user their password was successfully changed. This security
 * notification includes timestamp and warns users to contact support if they
 * did not authorize the change. The notification serves as breach detection for
 * unauthorized password resets.
 *
 * After successful password reset, the user must log in again with their new
 * password using the standard login endpoint. The reset process does not
 * automatically authenticate the user - they must use the login endpoint with
 * their email and new password to obtain new JWT tokens and establish a fresh
 * session. This ensures the user confirms possession of the new password and
 * establishes a clean authentication state.
 *
 * Security logging records all password reset completion attempts (successful
 * and failed) for audit trail and security monitoring, including token
 * validation failures, expired token attempts, and successful password
 * updates.
 *
 * @param props.connection
 * @param props.body Password reset completion request with reset token and new
 *   password meeting complexity requirements
 * @path /auth/member/password/reset/complete
 * @accessor api.functional.auth.member.password.reset.complete.resetPassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resetPassword(
  connection: IConnection,
  props: resetPassword.Props,
): Promise<resetPassword.Response> {
  return true === connection.simulate
    ? resetPassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resetPassword.METADATA,
          path: resetPassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resetPassword {
  export type Props = {
    /**
     * Password reset completion request with reset token and new password
     * meeting complexity requirements
     */
    body: IRedditLikeMember.IResetPassword;
  };
  export type Body = IRedditLikeMember.IResetPassword;
  export type Response = IRedditLikeMember.IPasswordResetCompleted;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/password/reset/complete",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/password/reset/complete";
  export const random = (): IRedditLikeMember.IPasswordResetCompleted =>
    typia.random<IRedditLikeMember.IPasswordResetCompleted>();
  export const simulate = (
    connection: IConnection,
    props: resetPassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resetPassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
