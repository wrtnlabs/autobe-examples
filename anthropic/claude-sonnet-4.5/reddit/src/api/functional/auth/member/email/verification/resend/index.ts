import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeMember } from "../../../../../../structures/IRedditLikeMember";

/**
 * Resend email verification link by creating new token in
 * reddit_like_email_verifications with fresh 24-hour expiration.
 *
 * Resends email verification link with fresh token when users didn't receive or
 * lost original verification email.
 *
 * This endpoint implements the verification email resend mechanism described in
 * requirements section 2.1 (Post-Registration Behavior) and section 2 (Email
 * Verification and Password Management). Users who registered but haven't
 * verified their email may not receive the initial verification email due to
 * spam filters, email delivery issues, or accidental deletion. This endpoint
 * allows them to request a new verification email with a fresh token and
 * updated expiration timestamp.
 *
 * The resend process supports two usage patterns: authenticated users can
 * request resend for their own account (identified from JWT token), or
 * unauthenticated users can request resend by providing their email address.
 * For authenticated requests, the system uses the user ID from the JWT token to
 * identify the account. For unauthenticated requests, the system queries
 * reddit_like_members table by the submitted email address.
 *
 * Before generating a new verification token, the system validates the
 * account's current verification status by checking the email_verified field in
 * reddit_like_members. If email_verified is already true, the email has been
 * verified and no new verification is needed. The system responds with message
 * "This email address is already verified" and provides option to proceed to
 * login. This prevents unnecessary verification emails for already-verified
 * accounts.
 *
 * For unverified accounts (email_verified = false), the system generates a new
 * cryptographically secure verification token using secure random number
 * generation. The system creates a new record in
 * reddit_like_email_verifications table containing: the user's ID
 * (reddit_like_user_id foreign key), the email address being verified (from
 * reddit_like_members.email), the newly generated verification_token (unique
 * across all verification records), verification_type set to 'registration' (or
 * 'email_change' if this is email update verification), expires_at timestamp
 * set to 24 hours from current time per requirements, and verified_at set to
 * null indicating pending verification.
 *
 * The system then sends a new verification email to the email address
 * containing the fresh verification link with the new token embedded. The email
 * explains this is a resend of the verification link, includes the 24-hour
 * expiration timeframe, and provides the clickable verification link that will
 * call the email verification endpoint with the token parameter.
 *
 * Previous unused verification tokens for the same user remain in
 * reddit_like_email_verifications table but are effectively superseded by the
 * new token. The system doesn't delete old tokens to maintain audit trail, but
 * typically only the most recent token is used for verification. When the user
 * successfully verifies via any valid token, the email_verified status updates
 * and all pending verifications become moot.
 *
 * Security considerations include rate limiting to prevent email spam abuse -
 * the system limits verification email resends to reasonable frequency such as
 * maximum 5 per email address per hour. The system also logs all resend
 * requests for security monitoring to detect abuse patterns. For privacy
 * protection, the system returns generic success message regardless of whether
 * the email exists in the system when processing unauthenticated resend
 * requests, preventing email enumeration.
 *
 * The response confirms the verification email has been sent (or will be sent
 * shortly) and instructs the user to check their inbox and spam folder. The
 * confirmation includes the expiration timeframe (24 hours) to set user
 * expectations.
 *
 * @param props.connection
 * @param props.body Verification resend request containing email address for
 *   which to generate new verification token
 * @path /auth/member/email/verification/resend
 * @accessor api.functional.auth.member.email.verification.resend.resendVerification
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resendVerification(
  connection: IConnection,
  props: resendVerification.Props,
): Promise<resendVerification.Response> {
  return true === connection.simulate
    ? resendVerification.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resendVerification.METADATA,
          path: resendVerification.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resendVerification {
  export type Props = {
    /**
     * Verification resend request containing email address for which to
     * generate new verification token
     */
    body: IRedditLikeMember.IResendVerification;
  };
  export type Body = IRedditLikeMember.IResendVerification;
  export type Response = IRedditLikeMember.IVerificationResent;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/email/verification/resend",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/email/verification/resend";
  export const random = (): IRedditLikeMember.IVerificationResent =>
    typia.random<IRedditLikeMember.IVerificationResent>();
  export const simulate = (
    connection: IConnection,
    props: resendVerification.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resendVerification.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
