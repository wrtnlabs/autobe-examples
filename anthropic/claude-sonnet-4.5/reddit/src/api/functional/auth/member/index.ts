import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeMember } from "../../../structures/IRedditLikeMember";
export * as password from "./password/index";
export * as email from "./email/index";

/**
 * Register new member account with username, email, and password, creating
 * reddit_like_members record and issuing JWT tokens.
 *
 * Registers a new member user account and issues initial JWT authentication
 * tokens for immediate platform access.
 *
 * This endpoint handles the complete user registration workflow defined in
 * requirements section 2 (User Registration Requirements). When a guest visitor
 * decides to join the platform, they submit registration credentials (username,
 * email, password) through this endpoint. The system validates all input
 * according to strict requirements: username must be 3-20 characters with only
 * alphanumeric characters, underscores, and hyphens; email must be unique and
 * valid format; password must be minimum 8 characters with uppercase,
 * lowercase, number, and special character.
 *
 * Upon successful validation, the system creates a new record in
 * reddit_like_members table with securely hashed password (never plain text),
 * generates unique user identifier, sets email_verified to false initially,
 * assigns default member role, and initializes both post_karma and
 * comment_karma to zero as specified in karma system requirements. The
 * registration process also creates related records in
 * reddit_like_auth_credentials for security tracking and reddit_like_user_karma
 * for reputation management.
 *
 * Immediately after account creation, the system generates JWT tokens per
 * session management requirements: access token with 30-minute expiration and
 * refresh token with 30-day expiration. Both tokens contain user ID, username,
 * and role in the payload. A verification email is sent asynchronously to the
 * provided email address with a unique time-limited verification link expiring
 * in 24 hours per requirements section 2.3.
 *
 * The response includes complete user profile information (id, username, email,
 * karma scores, account timestamps) along with both access and refresh tokens,
 * enabling the newly registered user to immediately begin authenticated
 * participation without additional login. This follows the requirement that
 * successful registration automatically logs in the new user as a Member.
 *
 * Security considerations include rate limiting to prevent registration abuse,
 * CAPTCHA verification for suspicious patterns, username and email uniqueness
 * validation with helpful error messages when duplicates detected, and secure
 * password hashing using industry-standard algorithms (bcrypt, Argon2, or
 * PBKDF2). All authentication communications occur over HTTPS per security
 * requirements.
 *
 * @param props.connection
 * @param props.body Member registration credentials including unique username,
 *   email address, and secure password meeting complexity requirements
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Member registration credentials including unique username, email
     * address, and secure password meeting complexity requirements
     */
    body: IRedditLikeMember.ICreate;
  };
  export type Body = IRedditLikeMember.ICreate;
  export type Response = IRedditLikeMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): IRedditLikeMember.IAuthorized =>
    typia.random<IRedditLikeMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate member user with email and password, validating against
 * reddit_like_members table and issuing JWT session tokens.
 *
 * Authenticates existing member users with email and password credentials,
 * issuing JWT tokens for platform access.
 *
 * This endpoint implements the login workflow defined in requirements section 3
 * (Login and Session Management). When a registered member wants to access
 * their account, they submit their email address and password through this
 * endpoint. The system validates these credentials against stored account
 * information in the reddit_like_members table, comparing the submitted
 * password against the securely stored password_hash using cryptographic
 * verification.
 *
 * The authentication process follows strict security requirements: passwords
 * are never transmitted or stored in plain text, all authentication occurs over
 * HTTPS, and rate limiting prevents brute-force attacks by allowing maximum 5
 * failed attempts within 15 minutes before temporarily locking the account for
 * 30 minutes. The reddit_like_auth_credentials table tracks failed login
 * attempts, last failed login timestamp, and account lock status to enforce
 * these security measures.
 *
 * If credentials are invalid (email doesn't exist or password doesn't match),
 * the system rejects login with generic error message "Invalid email or
 * password" to prevent username enumeration attacks. If the account is
 * temporarily locked due to multiple failed attempts, the system denies access
 * and notifies user of lock duration. If the account has been suspended by
 * administrators (checked in reddit_like_platform_suspensions with
 * is_active=true), the system prevents login and directs user to contact
 * support.
 *
 * Upon successful credential validation, the system generates new JWT tokens
 * per session management requirements: access token expiring in 30 minutes
 * containing user ID, username, and role; refresh token expiring in 30 days for
 * obtaining new access tokens without re-login. These tokens are stored in a
 * new reddit_like_sessions record along with IP address, user agent, and
 * activity timestamp for security monitoring. The system also updates
 * reddit_like_auth_credentials with successful login timestamp and IP address,
 * resetting failed attempt counter to zero.
 *
 * The response returns complete user profile information from
 * reddit_like_members (id, username, email, profile_bio, avatar_url,
 * email_verified status) along with denormalized karma scores (post_karma and
 * comment_karma) and both JWT tokens, enabling the authenticated user to
 * immediately access all member-level features including posting, commenting,
 * voting, and community subscription management.
 *
 * Security logging captures all authentication events including successful
 * logins, failed attempts, and account lock triggers for security monitoring
 * and forensic analysis per requirements section 3.6.
 *
 * @param props.connection
 * @param props.body Member login credentials containing registered email
 *   address and password for authentication validation
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Member login credentials containing registered email address and
     * password for authentication validation
     */
    body: IRedditLikeMember.ILogin;
  };
  export type Body = IRedditLikeMember.ILogin;
  export type Response = IRedditLikeMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): IRedditLikeMember.IAuthorized =>
    typia.random<IRedditLikeMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT access token using valid refresh token from reddit_like_sessions,
 * generating new 30-minute access token.
 *
 * Refreshes expired access tokens using valid refresh tokens, issuing new
 * access tokens without requiring credential re-entry.
 *
 * This endpoint implements the token refresh mechanism defined in requirements
 * section 3.2 (Session Management Requirements). When a member's access token
 * expires after 30 minutes of validity, they can obtain a new access token by
 * presenting their still-valid refresh token through this endpoint, avoiding
 * the need to re-enter email and password credentials. This creates a seamless
 * user experience for active platform participants.
 *
 * The refresh process validates the submitted refresh token against records in
 * reddit_like_sessions table, checking that the token matches an existing
 * session record, the refresh token hasn't expired (refresh_token_expires_at is
 * in the future), and the session hasn't been explicitly revoked (deleted_at is
 * null). If any of these validations fail, the system rejects the refresh
 * request and requires the user to log in again with full credentials.
 *
 * Refresh tokens expire 30 days after issuance per requirements. This longer
 * validity period compared to access tokens (30 minutes) balances security with
 * user convenience - users remain authenticated for a month without re-login,
 * but their access tokens expire frequently to limit exposure if compromised.
 * When a refresh token has expired, the system returns an authentication error
 * requiring full re-login with email and password.
 *
 * Upon successful refresh token validation, the system generates a new JWT
 * access token with fresh 30-minute expiration timestamp, containing the user's
 * current ID, username, and role in the payload. The refresh token itself
 * remains unchanged and maintains its original expiration timestamp - only the
 * access token is regenerated. The system updates the reddit_like_sessions
 * record's last_activity_at timestamp to reflect current usage and updates the
 * access_token field with the newly generated token.
 *
 * The response includes the new access token along with current user profile
 * information from reddit_like_members, including any updates to username,
 * profile_bio, avatar_url, or email_verified status that may have occurred
 * since the original login. The response also includes current karma scores
 * (post_karma and comment_karma) reflecting all voting activity on the user's
 * content since last token refresh.
 *
 * Security considerations include validating that the session's user account
 * still exists and hasn't been suspended (checking
 * reddit_like_platform_suspensions for active suspensions), ensuring HTTPS-only
 * communication for token transmission, and logging all token refresh events in
 * reddit_like_auth_credentials for security monitoring. If a user changes their
 * password, all existing sessions are invalidated (deleted_at set) per
 * requirements section 2.6, forcing re-authentication and preventing refresh
 * token usage.
 *
 * @param props.connection
 * @param props.body Refresh token request containing the valid refresh token
 *   string from previous authentication
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing the valid refresh token string from
     * previous authentication
     */
    body: IRedditLikeMember.IRefresh;
  };
  export type Body = IRedditLikeMember.IRefresh;
  export type Response = IRedditLikeMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): IRedditLikeMember.IAuthorized =>
    typia.random<IRedditLikeMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
