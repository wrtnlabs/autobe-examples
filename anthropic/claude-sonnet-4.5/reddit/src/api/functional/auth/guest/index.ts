import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeGuest } from "../../../structures/IRedditLikeGuest";

/**
 * Register a new temporary guest account and issue guest session tokens.
 *
 * Creates a temporary guest account for unauthenticated visitors to the
 * Reddit-like community platform. This endpoint enables anonymous users to
 * obtain a tracked session identity without providing personal credentials like
 * email or password. Guest accounts are designed for visitors who want to
 * browse public communities, view posts and comments, but are not yet ready to
 * commit to full membership.
 *
 * The registration process generates a unique session identifier that tracks
 * the guest's activity for analytics purposes, including first visit timestamp,
 * IP address, and user agent information. This data helps the platform
 * understand guest behavior patterns and optimize conversion to full member
 * accounts. The session identifier persists across visits until the guest
 * either registers as a member or the session expires.
 *
 * Upon successful registration, the system issues JWT authentication tokens
 * (access token with 30-minute expiration and refresh token with 30-day
 * expiration) that enable the guest to make authenticated API requests within
 * their limited permission scope. Guest users can browse public communities,
 * view posts, read comments, and access user profiles, but cannot vote,
 * comment, post, subscribe to communities, or create communities.
 *
 * The response contains the complete guest user profile including their unique
 * session identifier, role designation ('guest'), timestamps for first and last
 * visit, and the JWT tokens required for subsequent authenticated requests.
 * Security measures include IP address and user agent tracking for abuse
 * prevention and rate limiting, though guests are not subject to the same
 * strict rate limits as authenticated members for content creation since they
 * cannot create content.
 *
 * This endpoint serves as the entry point for anonymous platform exploration
 * and is critical for converting casual visitors into registered members. By
 * providing a low-friction registration mechanism, the platform can track guest
 * behavior, demonstrate value, and encourage eventual conversion to full
 * membership through the member registration endpoint.
 *
 * @param props.connection
 * @param props.body Guest registration information including optional tracking
 *   data for analytics
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Guest registration information including optional tracking data for
     * analytics
     */
    body: IRedditLikeGuest.ICreate;
  };
  export type Body = IRedditLikeGuest.ICreate;
  export type Response = IRedditLikeGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): IRedditLikeGuest.IAuthorized =>
    typia.random<IRedditLikeGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh guest session access token using refresh token.
 *
 * Refreshes the JWT access token for an existing guest session using a valid
 * refresh token. This endpoint is essential for maintaining continuous guest
 * sessions without requiring the guest to re-register when their access token
 * expires after the standard 30-minute window.
 *
 * Guest users receive both an access token (short-lived, 30 minutes) and a
 * refresh token (long-lived, 30 days) during initial registration through the
 * join endpoint. The access token is used to authenticate API requests, while
 * the refresh token enables obtaining new access tokens without
 * re-authentication. This token refresh mechanism follows industry-standard JWT
 * security patterns, minimizing the exposure window of access tokens while
 * providing convenient session continuity.
 *
 * The refresh process validates that the provided refresh token is authentic,
 * not expired, and belongs to an active guest session. Upon successful
 * validation, the system generates a new access token with a fresh 30-minute
 * expiration and returns it to the client. The refresh token itself typically
 * remains valid and unchanged, though the implementation may optionally issue a
 * new refresh token as part of a token rotation strategy for enhanced
 * security.
 *
 * If the refresh token has expired (after 30 days), is invalid, or belongs to a
 * deleted/revoked session, the refresh request fails and the guest must
 * re-register through the join endpoint to obtain new tokens. This expiration
 * mechanism ensures that abandoned guest sessions eventually terminate,
 * preventing indefinite session persistence.
 *
 * The response contains the new access token, its expiration timestamp, and
 * optionally a new refresh token if token rotation is implemented. The guest
 * can immediately use the new access token for authenticated requests,
 * maintaining seamless browsing continuity. The system tracks the last activity
 * timestamp on the guest session, updating it during refresh operations to
 * monitor session usage patterns.
 *
 * This endpoint requires a valid refresh token but does not require the access
 * token (which may be expired). Rate limiting is applied to prevent abuse of
 * the refresh mechanism, with stricter limits than the join endpoint to detect
 * and prevent token theft or replay attacks.
 *
 * @param props.connection
 * @param props.body Refresh token information for obtaining new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token information for obtaining new access token */
    body: IRedditLikeGuest.IRefresh;
  };
  export type Body = IRedditLikeGuest.IRefresh;
  export type Response = IRedditLikeGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): IRedditLikeGuest.IAuthorized =>
    typia.random<IRedditLikeGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
