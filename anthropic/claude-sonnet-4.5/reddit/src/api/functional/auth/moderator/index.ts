import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerator } from "../../../structures/IRedditLikeModerator";
export * as password from "./password/index";
export * as email from "./email/index";

/**
 * Register new moderator account and issue JWT tokens.
 *
 * Creates a new moderator account and issues initial JWT authentication tokens
 * for immediate platform access. This endpoint establishes the moderator's
 * identity by inserting a record into the reddit_like_moderators table with
 * securely hashed password credentials, unique username and email validation,
 * and initial email verification status set to false.
 *
 * The registration process validates that the provided username meets platform
 * requirements (3-20 characters, alphanumeric with underscores and hyphens) and
 * ensures global uniqueness across the platform. Email addresses must be valid
 * format and unique across all moderator accounts. Passwords are hashed using
 * bcrypt, Argon2, or PBKDF2 before storage, never persisted in plain text.
 *
 * Upon successful account creation, the system generates a verification email
 * containing a unique time-limited verification link expiring after 24 hours as
 * tracked in reddit_like_email_verifications table. The verification workflow
 * follows the standard email verification pattern defined in the authentication
 * requirements, where users can verify their email by clicking the link or
 * request a new verification email if expired.
 *
 * The response includes both an access token (30-minute expiration) and refresh
 * token (30-day expiration) as JWT tokens, enabling immediate authenticated
 * access without requiring a separate login call. The tokens contain the
 * moderator's user ID, username, and role ('moderator') in the payload. A
 * corresponding session record is created in reddit_like_sessions tracking the
 * access token, refresh token, expiration timestamps, IP address, and user
 * agent for security monitoring.
 *
 * This operation is publicly accessible (no authentication required) as it
 * represents the entry point for new moderators joining the platform. After
 * registration, moderators have the same participation rights as members plus
 * the ability to be assigned moderation permissions for specific communities
 * through the reddit_like_community_moderators table.
 *
 * @param props.connection
 * @param props.body Moderator registration information including username,
 *   email, and password credentials
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Moderator registration information including username, email, and
     * password credentials
     */
    body: IRedditLikeModerator.ICreate;
  };
  export type Body = IRedditLikeModerator.ICreate;
  export type Response = IRedditLikeModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): IRedditLikeModerator.IAuthorized =>
    typia.random<IRedditLikeModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate moderator and issue JWT session tokens.
 *
 * Authenticates moderator credentials and issues JWT access and refresh tokens
 * for establishing an authenticated session. This endpoint validates the
 * provided email and password against moderator records in the
 * reddit_like_moderators table, verifying the password hash matches the stored
 * bcrypt/Argon2/PBKDF2 hashed credential.
 *
 * The authentication process implements security measures including rate
 * limiting through the reddit_like_auth_credentials table. The system tracks
 * failed login attempts, incrementing the counter on each failure and recording
 * the timestamp in last_failed_login_at. When 5 failed attempts occur within a
 * 15-minute window, the account is temporarily locked by setting
 * account_locked_until to 30 minutes from the current time. Locked accounts
 * display an error message directing users to wait or reset their password.
 *
 * Upon successful credential validation, the system generates two JWT tokens:
 * an access token with 30-minute expiration containing the moderator's ID,
 * username, and role ('moderator'), and a refresh token with 30-day expiration
 * for obtaining new access tokens without re-authentication. The tokens follow
 * the JWT specification with issue timestamp (iat) and expiration timestamp
 * (exp) claims.
 *
 * A new session record is created in reddit_like_sessions storing both tokens,
 * their expiration timestamps, the requester's IP address and user agent for
 * security monitoring, and last_activity_at set to the current timestamp. The
 * session enables tracking active moderator sessions and supports security
 * features like session revocation on password changes.
 *
 * Successful login updates reddit_like_auth_credentials by resetting
 * failed_login_attempts to zero, recording last_successful_login_at timestamp,
 * and storing last_login_ip for security monitoring and suspicious activity
 * detection. This operation is publicly accessible as it represents the
 * authentication entry point for returning moderators.
 *
 * If credentials are invalid (email not found or password mismatch), the system
 * returns a generic error message 'Invalid email or password' without revealing
 * which credential was incorrect, preventing username enumeration attacks.
 *
 * @param props.connection
 * @param props.body Moderator login credentials with email and password
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Moderator login credentials with email and password */
    body: IRedditLikeModerator.ILogin;
  };
  export type Body = IRedditLikeModerator.ILogin;
  export type Response = IRedditLikeModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): IRedditLikeModerator.IAuthorized =>
    typia.random<IRedditLikeModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh moderator access token using valid refresh token.
 *
 * Refreshes an expired or expiring access token using a valid refresh token,
 * issuing a new access token with renewed 30-minute expiration. This endpoint
 * validates the provided refresh token against records in the
 * reddit_like_sessions table, checking that the token exists, hasn't been
 * revoked (deleted_at is null), and hasn't exceeded its 30-day expiration
 * period tracked in refresh_token_expires_at.
 *
 * The refresh process verifies the refresh token's cryptographic signature and
 * payload integrity, extracting the moderator's user ID from the token claims.
 * The system confirms the associated moderator account still exists in
 * reddit_like_moderators, is not soft-deleted (deleted_at is null), and hasn't
 * been suspended from the platform via reddit_like_platform_suspensions.
 *
 * Upon successful validation, a new JWT access token is generated containing
 * the moderator's ID, username, and role ('moderator') with a fresh expiration
 * timestamp set to 30 minutes from the current time. The new access token is
 * returned to the client while the refresh token remains unchanged and valid
 * for its original 30-day expiration period.
 *
 * The corresponding session record in reddit_like_sessions is updated with the
 * new access_token value, updated access_token_expires_at timestamp, and
 * current timestamp in last_activity_at to track session activity. This
 * operation enables continuous authenticated access without the security risks
 * of long-lived access tokens or the user experience friction of frequent
 * re-authentication.
 *
 * If the refresh token is expired (current time exceeds
 * refresh_token_expires_at), invalid, or belongs to a deleted session
 * (deleted_at is not null), the system rejects the request requiring the user
 * to log in again with email and password credentials. This operation requires
 * a valid refresh token but does not require an active access token, as its
 * purpose is to renew expired access tokens.
 *
 * @param props.connection
 * @param props.body Refresh token for obtaining new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for obtaining new access token */
    body: IRedditLikeModerator.IRefresh;
  };
  export type Body = IRedditLikeModerator.IRefresh;
  export type Response = IRedditLikeModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): IRedditLikeModerator.IAuthorized =>
    typia.random<IRedditLikeModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout moderator and invalidate current session tokens.
 *
 * Terminates the moderator's current authenticated session by invalidating
 * their JWT tokens and marking the session as ended. This endpoint requires
 * valid moderator authentication via JWT access token, retrieves the
 * corresponding session record from reddit_like_sessions matching the token,
 * and soft-deletes the session to prevent continued token usage.
 *
 * The logout process identifies the current session by matching the provided
 * access token against reddit_like_sessions.access_token field. Once the
 * session is located and ownership verified (reddit_like_user_id matches the
 * authenticated moderator's ID from the JWT payload), the system sets the
 * session's deleted_at timestamp to the current time, effectively invalidating
 * the session.
 *
 * While JWT tokens are stateless and cannot be truly revoked without a token
 * blacklist or similar mechanism, marking the session as deleted enables the
 * platform to reject subsequent requests using those tokens. Authentication
 * middleware checks that the session associated with a token has deleted_at as
 * null before granting access. This soft-delete approach maintains audit trail
 * of all sessions including when they ended.
 *
 * After successful logout, the moderator is redirected to the public homepage
 * or login page per requirements. The client application should clear stored
 * tokens from local storage or cookies to complete the logout process
 * client-side. Attempting to use invalidated tokens results in authentication
 * errors requiring the moderator to log in again.
 *
 * This operation requires moderator role authentication and operates on the
 * authenticated user's current session. It does not affect other active
 * sessions the moderator may have on different devices - each session must be
 * explicitly logged out. For security-critical scenarios like password changes,
 * all sessions except the current one are invalidated automatically as
 * specified in the password change operation.
 *
 * @param props.connection
 * @path /auth/moderator/logout
 * @accessor api.functional.auth.moderator.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export type Response = IRedditLikeModerator.ILogoutConfirmation;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/logout";
  export const random = (): IRedditLikeModerator.ILogoutConfirmation =>
    typia.random<IRedditLikeModerator.ILogoutConfirmation>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
