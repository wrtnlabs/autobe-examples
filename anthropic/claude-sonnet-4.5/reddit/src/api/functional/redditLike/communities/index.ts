import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunity } from "../../../structures/IRedditLikeCommunity";
import { IPageIRedditLikeCommunity } from "../../../structures/IPageIRedditLikeCommunity";
export * as rules from "./rules/index";
export * as subscriptions from "./subscriptions/index";
export * as moderators from "./moderators/index";
export * as posts from "./posts/index";

/**
 * Search and retrieve filtered, paginated list of communities.
 *
 * Retrieve a comprehensive filtered and paginated list of communities from the
 * Reddit-like platform. This operation provides advanced search capabilities
 * for discovering communities based on multiple criteria including name
 * matching, description keywords, category filters, privacy settings, and
 * activity status.
 *
 * The operation supports comprehensive pagination with configurable page sizes
 * and multiple sorting options. Users can sort communities by subscriber count,
 * creation date, community name, or activity level in ascending or descending
 * order. This enables efficient community discovery for both new users
 * exploring the platform and existing users finding new communities to join.
 *
 * Security considerations include appropriate filtering of private communities
 * based on the requesting user's authorization level. Guest users and members
 * can discover public communities freely, while private communities are hidden
 * from general search unless the user has been granted access. The operation
 * enforces community privacy settings defined in the reddit_like_communities
 * table.
 *
 * This operation integrates with the Community table as defined in the Prisma
 * schema (reddit_like_communities), incorporating all available community
 * fields and relationships including creator information, subscriber counts,
 * category tags, and privacy settings. The response includes community summary
 * information optimized for list displays in browse and search interfaces.
 *
 * The search functionality supports partial matching on community names and
 * descriptions using PostgreSQL trigram indexes (gin_trgm_ops) for efficient
 * full-text search performance. Filter options include primary category
 * selection, privacy type filtering (public/private), archived status
 * filtering, and minimum subscriber count thresholds. Time range filters allow
 * discovering recently created communities or filtering by creation date
 * ranges.
 *
 * This operation is essential for the community discovery workflow described in
 * requirements section 3.1-3.4, enabling users to browse communities by
 * category, search for specific topics, find trending communities, and discover
 * new communities based on their interests. The operation powers the community
 * directory interface and search functionality that helps users navigate the
 * platform's organizational structure.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, and pagination
 *   configuration for community discovery
 * @path /redditLike/communities
 * @accessor api.functional.redditLike.communities.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, and pagination configuration
     * for community discovery
     */
    body: IRedditLikeCommunity.IRequest;
  };
  export type Body = IRedditLikeCommunity.IRequest;
  export type Response = IPageIRedditLikeCommunity.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/communities";
  export const random = (): IPageIRedditLikeCommunity.ISummary =>
    typia.random<IPageIRedditLikeCommunity.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific community by ID.
 *
 * Retrieve complete detailed information about a specific community on the
 * Reddit-like platform. This operation provides comprehensive community data
 * necessary for rendering the community page, including all community metadata,
 * configuration settings, rules, moderator information, and engagement
 * statistics.
 *
 * The operation returns the community's core identification and branding
 * information including the unique community code (used in URLs), display name,
 * description, icon URL, and banner URL. Visual branding elements enable
 * community identity and recognition throughout the platform. The description
 * field contains the 10-500 character explanation of the community's purpose
 * and topic as defined during community creation.
 *
 * Community configuration settings are included in the response, such as
 * privacy type (public or private), posting permissions (anyone_subscribed,
 * approved_only, or moderators_only), and content type restrictions (whether
 * text posts, link posts, and image posts are allowed). These settings control
 * who can participate in the community and what types of content can be shared,
 * as specified in the community management requirements.
 *
 * The response includes categorization and discovery metadata such as the
 * primary category assignment (Technology, Gaming, Sports, Entertainment,
 * Education, Science, Arts, News, Lifestyle, Business, Other) and up to three
 * secondary tags for improved discoverability. These fields power community
 * search and recommendation features as described in requirements section 7.2.
 *
 * Engagement statistics are provided including the total subscriber count
 * (denormalized for performance) and archived status flag. The subscriber count
 * reflects the community's size and popularity, while the archived flag
 * indicates whether the community is still accepting new content or has been
 * archived due to inactivity per requirements section 9.3.
 *
 * Security considerations include enforcing privacy settings based on the
 * requesting user's authorization. Public communities return full information
 * to all users including guests. Private communities require the user to be an
 * approved member or moderator before revealing detailed information. Guest
 * users and non-members attempting to access private communities receive
 * limited information with a prompt to request access.
 *
 * This operation integrates with the reddit_like_communities table from the
 * Prisma schema, utilizing the creator relationship to include creator
 * information, and accessing related community rules through the
 * reddit_like_community_rules relationship. The operation serves as the
 * foundation for displaying community pages where users view posts, subscribe,
 * and understand community standards.
 *
 * The response includes temporal metadata such as creation timestamp (when the
 * community was founded) and last update timestamp (when community settings
 * were modified), enabling users to understand community age and activity
 * recency. The soft deletion timestamp (deleted_at) is checked to prevent
 * access to communities in the 30-day deletion cooldown period.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community to
 *   retrieve
 * @path /redditLike/communities/:communityId
 * @accessor api.functional.redditLike.communities.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target community to retrieve */
    communityId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommunity;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): IRedditLikeCommunity =>
    typia.random<IRedditLikeCommunity>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
