import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunity } from "../../../../structures/IRedditLikeCommunity";
import { IPageIRedditLikePost } from "../../../../structures/IPageIRedditLikePost";
import { IRedditLikePost } from "../../../../structures/IRedditLikePost";

/**
 * Search and retrieve filtered, paginated list of posts in a community.
 *
 * Retrieve a comprehensive filtered and paginated list of posts within a
 * specific community from the Reddit-like platform. This operation provides
 * advanced search and discovery capabilities for finding posts based on
 * multiple criteria including post type (text, link, image), time range
 * filters, voting thresholds, and sorting preferences.
 *
 * The operation supports all four core sorting algorithms defined in the
 * Content Sorting Algorithms specification: Hot (trending content with time
 * decay and engagement velocity), New (strict chronological ordering), Top
 * (highest vote scores with time range filters), and Controversial (polarizing
 * content with balanced voting patterns). The default sorting is Hot to surface
 * currently trending content.
 *
 * This endpoint serves multiple user scenarios: casual browsing for interesting
 * content, community exploration for new members discovering top posts, active
 * community members checking latest submissions via New sorting, and users
 * seeking debates through Controversial sorting. The operation integrates with
 * the voting system to calculate vote scores, the karma system for content
 * quality signals, and the comment system to display engagement metrics.
 *
 * Security considerations include respecting community privacy settings (public
 * vs private communities), enforcing read permissions based on user
 * authentication and community membership for private communities, and applying
 * rate limiting for search operations to prevent abuse. Guest users can access
 * public community posts, while private community posts require authenticated
 * membership or approval.
 *
 * The operation returns post summary information optimized for feed displays,
 * including post metadata (title, type, author, timestamps, vote scores,
 * comment counts), type-specific preview content (text excerpt, link metadata
 * with thumbnails, image thumbnails), and engagement metrics from the
 * mv_reddit_like_post_metrics materialized view for performance optimization.
 * Pagination parameters control result set size and offset for efficient
 * browsing of large post collections.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to retrieve posts
 *   from
 * @param props.body Search criteria, filtering options, sorting preferences,
 *   and pagination parameters for post discovery
 * @path /redditLike/communities/:communityId/posts
 * @accessor api.functional.redditLike.communities.posts.searchPosts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchPosts(
  connection: IConnection,
  props: searchPosts.Props,
): Promise<searchPosts.Response> {
  return true === connection.simulate
    ? searchPosts.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchPosts.METADATA,
          path: searchPosts.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace searchPosts {
  export type Props = {
    /** Unique identifier of the community to retrieve posts from */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria, filtering options, sorting preferences, and
     * pagination parameters for post discovery
     */
    body: IRedditLikeCommunity.IPostSearchRequest;
  };
  export type Body = IRedditLikeCommunity.IPostSearchRequest;
  export type Response = IPageIRedditLikePost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): IPageIRedditLikePost.ISummary =>
    typia.random<IPageIRedditLikePost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: searchPosts.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchPosts.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve hot-sorted trending posts from a specific community.
 *
 * Retrieve a paginated list of posts from a specific community sorted by the
 * Hot algorithm, which surfaces trending content that is currently gaining
 * momentum and engagement. This operation serves as the primary content
 * discovery mechanism for community feeds, implementing the Hot sorting
 * algorithm defined in the Content Sorting Algorithms requirements.
 *
 * The Hot sorting algorithm balances multiple factors to determine post
 * ranking. It uses net vote score (upvotes minus downvotes) from the
 * mv_reddit_like_post_metrics materialized view as the primary popularity
 * factor, applies time decay so older posts gradually decrease in ranking even
 * with high vote counts, and provides engagement velocity boosts for posts
 * receiving rapid votes within their first hours. Posts created within the last
 * 6-12 hours receive advantages over older posts with similar vote counts, and
 * posts gaining 10+ votes in the first hour rank higher than posts with the
 * same votes accumulated over 6 hours.
 *
 * The operation queries the reddit_like_posts table filtered by the
 * community_id path parameter, joining with mv_reddit_like_post_metrics for
 * denormalized vote scores and comment counts to optimize query performance.
 * The Hot score is recalculated periodically to ensure feed freshness and
 * accurate trending status. Posts with net negative votes are assigned very low
 * hot scores to suppress poor quality content, while newly created posts
 * receive initial hot scores that provide brief visibility opportunity before
 * time decay applies.
 *
 * The request body supports pagination parameters (page number, page size) and
 * optional filtering criteria such as time range restrictions to limit posts to
 * recent time windows. The response returns post summary information optimized
 * for feed display, including post ID, title, author information, community
 * association, vote scores, comment counts, post type, creation timestamp, and
 * Hot ranking score. Posts are ordered from highest Hot score to lowest,
 * creating a dynamic, ever-changing feed that encourages frequent user visits.
 *
 * Security considerations include rate limiting for feed requests to prevent
 * abuse, and appropriate filtering based on the requesting user's authorization
 * level and community access permissions. Public communities allow all users
 * including guests to access Hot-sorted posts, while private communities
 * restrict access to approved members only. The operation integrates with the
 * community subscription system to power personalized home feeds aggregating
 * Hot posts from multiple subscribed communities.
 *
 * This operation is critical for user engagement and retention, as it surfaces
 * fresh, relevant content that keeps users engaged and returning to the
 * platform. Performance expectations require displaying results within 2
 * seconds under normal load conditions, with efficient caching of frequently
 * accessed community feeds to reduce database load.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community whose hot
 *   posts should be retrieved
 * @param props.body Pagination and filtering parameters for hot post retrieval
 *   including page number, page size, and optional time range restrictions
 * @path /redditLike/communities/:communityId/posts/hot
 * @accessor api.functional.redditLike.communities.posts.hot
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function hot(
  connection: IConnection,
  props: hot.Props,
): Promise<hot.Response> {
  return true === connection.simulate
    ? hot.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...hot.METADATA,
          path: hot.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace hot {
  export type Props = {
    /**
     * Unique identifier of the target community whose hot posts should be
     * retrieved
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Pagination and filtering parameters for hot post retrieval including
     * page number, page size, and optional time range restrictions
     */
    body: IRedditLikePost.IHotRequest;
  };
  export type Body = IRedditLikePost.IHotRequest;
  export type Response = IPageIRedditLikePost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/communities/:communityId/posts/hot",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/hot`;
  export const random = (): IPageIRedditLikePost.ISummary =>
    typia.random<IPageIRedditLikePost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: hot.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: hot.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
