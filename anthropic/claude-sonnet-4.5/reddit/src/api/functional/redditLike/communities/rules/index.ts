import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIRedditLikeCommunityRule } from "../../../../structures/IPageIRedditLikeCommunityRule";
import { IRedditLikeCommunityRule } from "../../../../structures/IRedditLikeCommunityRule";

/**
 * Retrieve all rules for a specific community.
 *
 * Retrieve the complete list of community-specific rules for a given community
 * by its unique identifier. This operation returns all rules defined by
 * community moderators to guide user behavior and maintain community standards
 * within that specific community.
 *
 * This endpoint provides essential information for users before they create
 * posts or comments in the community, helping them understand community
 * expectations and avoid rule violations. The rules are displayed on the
 * community page, in the post creation interface, and can be referenced during
 * content moderation workflows.
 *
 * The operation fetches rules from the reddit_like_community_rules table, which
 * stores up to 15 custom rules per community. Each rule includes a title (3-100
 * characters), optional description (up to 500 characters), rule type
 * (required, prohibited, or etiquette), and display order for proper
 * presentation.
 *
 * Rules are ordered by their display_order field to ensure consistent
 * presentation as configured by moderators. The response includes all rule
 * metadata to enable proper display in the user interface, including rule types
 * that help categorize rules as mandatory requirements, prohibitions, or
 * etiquette guidelines.
 *
 * This is a public read-only operation accessible to all users including
 * guests, as community rules must be visible to anyone considering
 * participation in the community. No authentication is required to view
 * community rules, supporting transparency and informed participation.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community whose rules are
 *   being retrieved
 * @path /redditLike/communities/:communityId/rules
 * @accessor api.functional.redditLike.communities.rules.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the community whose rules are being retrieved */
    communityId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIRedditLikeCommunityRule;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/communities/:communityId/rules",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): IPageIRedditLikeCommunityRule =>
    typia.random<IPageIRedditLikeCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific community rule.
 *
 * Retrieve comprehensive details about a single community rule identified by
 * its unique identifier within a specific community. This operation provides
 * access to the complete rule definition including the title, detailed
 * description, rule type classification, and display ordering information.
 *
 * This endpoint serves multiple stakeholders and use cases. General users
 * access rule details to understand community standards before posting content
 * or when they receive moderation notices citing specific rules. Moderators
 * retrieve rule information when reviewing reported content to verify
 * violations against community standards. The platform displays rule details in
 * moderation interfaces, post creation workflows, and community information
 * pages.
 *
 * The operation integrates with the community management system defined in the
 * Community Management Requirements document. Rules are community-specific
 * entities created and managed by community moderators, with each community
 * supporting up to 15 custom rules as specified in requirement R-CAT-006. Rules
 * are categorized by type (required, prohibited, etiquette) and displayed in
 * order determined by the display_order field.
 *
 * Security considerations include verifying that the requested rule belongs to
 * the specified community to prevent unauthorized cross-community rule access.
 * The endpoint returns public rule information visible to all users regardless
 * of authentication status, supporting the platform's transparency principle
 * that community rules must be visible to users before they post content.
 *
 * Related operations include listing all rules for a community (GET
 * /communities/{communityId}/rules), creating new rules (POST
 * /communities/{communityId}/rules), and updating rule definitions (PUT
 * /communities/{communityId}/rules/{ruleId}). This operation is frequently used
 * in conjunction with post creation workflows where users review rules before
 * submitting content, and moderation workflows where moderators reference
 * specific rules when taking actions.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   rule
 * @param props.ruleId Unique identifier of the specific rule to retrieve
 * @path /redditLike/communities/:communityId/rules/:ruleId
 * @accessor api.functional.redditLike.communities.rules.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the community containing the rule */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific rule to retrieve */
    ruleId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommunityRule;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IRedditLikeCommunityRule =>
    typia.random<IRedditLikeCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
