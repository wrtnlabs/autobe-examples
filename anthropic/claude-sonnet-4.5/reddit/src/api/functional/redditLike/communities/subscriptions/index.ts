import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIRedditLikeMember } from "../../../../structures/IPageIRedditLikeMember";

/**
 * Retrieve paginated list of members subscribed to a specific community.
 *
 * Fetches the complete subscriber list for a specified community, returning
 * member summary information ordered by subscription date. This operation
 * provides visibility into community membership composition and supports
 * analytics about community growth and member demographics.
 *
 * The operation queries the reddit_like_community_subscriptions junction table
 * to identify all active subscriptions for the specified community. For each
 * subscription record, the system joins with the reddit_like_users table to
 * retrieve member profile information including username, total karma
 * (calculated from post_karma and comment_karma fields in the unified user
 * table), account creation date, and the timestamp when they subscribed to this
 * specific community.
 *
 * Access control is enforced based on community privacy settings defined in
 * section 8 of the Community Management Requirements. For public communities,
 * this information is accessible to all users including guests. For private
 * communities, only approved members of that community and community moderators
 * can view the subscriber list. The system validates the requesting user's
 * access rights before returning subscription data.
 *
 * The response includes member summary information optimized for list displays
 * rather than complete member profiles. Each subscriber entry contains their
 * username (for identification and navigation to profile), total karma score
 * (as a trust and reputation indicator), account age (to distinguish veteran
 * members from new joiners), and subscription timestamp (showing when they
 * joined the community). This data enables communities to understand their
 * member base demographics and growth patterns.
 *
 * Pagination is implemented to handle communities with large subscriber counts
 * efficiently. The system returns subscribers in reverse chronological order by
 * default (most recent subscribers first), allowing communities to see their
 * newest members. Alternative sorting options may include alphabetical by
 * username or by member karma score to identify high-reputation community
 * members.
 *
 * The operation integrates with the subscription tracking system defined in
 * section 4.4 of the Community Management Requirements. The subscriber count
 * displayed on the community page is denormalized in the
 * reddit_like_communities table for performance, while this endpoint provides
 * the detailed member-level subscription data by querying the normalized
 * reddit_like_community_subscriptions junction table.
 *
 * Performance considerations ensure that even communities with hundreds of
 * thousands of subscribers can return the first page of results within 2
 * seconds. The system uses efficient database indexing on the (community_id,
 * subscribed_at) compound index to enable fast retrieval and sorting of
 * subscription records.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community whose subscriber
 *   list is being retrieved
 * @path /redditLike/communities/:communityId/subscriptions
 * @accessor api.functional.redditLike.communities.subscriptions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the community whose subscriber list is being
     * retrieved
     */
    communityId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIRedditLikeMember.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/communities/:communityId/subscriptions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/communities/${encodeURIComponent(props.communityId ?? "null")}/subscriptions`;
  export const random = (): IPageIRedditLikeMember.ISummary =>
    typia.random<IPageIRedditLikeMember.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
