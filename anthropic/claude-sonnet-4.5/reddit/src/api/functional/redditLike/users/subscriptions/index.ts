import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIRedditLikeCommunitySubscription } from "../../../../structures/IPageIRedditLikeCommunitySubscription";
import { IRedditLikeUser } from "../../../../structures/IRedditLikeUser";
import { IRedditLikeCommunitySubscription } from "../../../../structures/IRedditLikeCommunitySubscription";
import { IPageIRedditLikeCommunity } from "../../../../structures/IPageIRedditLikeCommunity";

/**
 * Retrieve a user's subscribed communities list.
 *
 * Retrieves the complete list of communities that the specified user has
 * subscribed to, providing insight into their interests and community
 * affiliations. This operation supports the user profile subscription
 * management feature defined in the requirements, enabling users to view and
 * manage their community subscriptions.
 *
 * The operation respects user privacy settings as defined in the
 * reddit_like_users table. When a user has set show_subscriptions_publicly to
 * false, their subscription list is only visible to themselves. When viewing
 * their own profile, authenticated users always see their complete subscription
 * list with management options. When viewing another user's profile, the
 * subscription list is only displayed if that user has chosen to make their
 * subscriptions public.
 *
 * The returned subscription list includes essential community information for
 * each subscribed community: community identifier, community name, community
 * icon, subscriber count, and the timestamp when the user subscribed. This data
 * enables users to quickly navigate to their favorite communities and
 * understand their subscription history.
 *
 * For users viewing their own subscriptions, the response includes additional
 * management capabilities through the UI, such as quick unsubscribe actions and
 * subscription organization features. The subscription list is ordered by
 * subscription date with most recently subscribed communities appearing first,
 * though this can be customized through query parameters.
 *
 * This operation integrates with the community management system and user
 * profile features, ensuring that subscription data accurately reflects the
 * current state of user-community relationships. The subscription count
 * displayed for each community is maintained in real-time as users subscribe
 * and unsubscribe.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose community
 *   subscriptions will be retrieved
 * @path /redditLike/users/:userId/subscriptions
 * @accessor api.functional.redditLike.users.subscriptions.getByUserid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByUserid(
  connection: IConnection,
  props: getByUserid.Props,
): Promise<getByUserid.Response> {
  return true === connection.simulate
    ? getByUserid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByUserid.METADATA,
          path: getByUserid.path(props),
          status: null,
        },
      );
}
export namespace getByUserid {
  export type Props = {
    /**
     * Unique identifier of the user whose community subscriptions will be
     * retrieved
     */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIRedditLikeCommunitySubscription.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/users/:userId/subscriptions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/users/${encodeURIComponent(props.userId ?? "null")}/subscriptions`;
  export const random = (): IPageIRedditLikeCommunitySubscription.ISummary =>
    typia.random<IPageIRedditLikeCommunitySubscription.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: getByUserid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByUserid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Subscribe user to a community.
 *
 * Create a new subscription relationship between a user and a community,
 * enabling the user to receive content from that community in their
 * personalized feed. This operation implements the community subscription
 * workflow defined in the Community Management requirements document section
 * 4.2.
 *
 * The operation validates several prerequisites before creating the
 * subscription. First, it verifies that the target community exists in the
 * reddit_like_communities table and is not soft-deleted or archived. Second, it
 * checks whether the user is already subscribed to prevent duplicate
 * subscription records, enforcing the unique constraint on (community_id,
 * member_id) in reddit_like_community_subscriptions.
 *
 * For public communities (privacy_type='public'), subscription is immediate and
 * automatic. For private communities (privacy_type='private'), this operation
 * initiates a join request workflow rather than creating an immediate
 * subscription. Private community subscriptions require moderator approval
 * before the subscription record is created, as specified in Community
 * Management requirements section 8.2.
 *
 * When a valid subscription is created, the operation performs several actions
 * atomically: creates the reddit_like_community_subscriptions record with
 * current timestamp as subscribed_at, increments the subscriber_count field in
 * reddit_like_communities by 1, and triggers feed composition updates to
 * immediately include posts from the newly subscribed community in the user's
 * personalized home feed.
 *
 * Security and authorization checks ensure that the requesting user matches the
 * userId path parameter, preventing users from creating subscriptions on behalf
 * of other users. The operation verifies the user is authenticated as a member,
 * moderator, or admin, denying access to guest users per User Roles and
 * Authentication requirements section on subscription permissions.
 *
 * The operation integrates with the personalized feed system defined in User
 * Profiles and Feeds requirements document section 9, where new subscriptions
 * immediately affect feed composition. Posts from the subscribed community
 * begin appearing in the user's home feed sorted by the user's preferred
 * algorithm (hot, new, top, or controversial).
 *
 * Response includes the complete created subscription record with community
 * details, enabling the UI to immediately reflect the subscription state change
 * without requiring a separate fetch. The response provides confirmation of
 * subscription success, the subscription timestamp, and updated subscriber
 * count for the community.
 *
 * Error scenarios include attempting to subscribe to non-existent communities,
 * duplicate subscription attempts (returns existing subscription), subscribing
 * to archived communities (rejected with explanation), and private community
 * subscription requests (returns pending request status instead of completed
 * subscription).
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who is subscribing to the
 *   community
 * @param props.body Community subscription creation data including the target
 *   community identifier to subscribe to
 * @path /redditLike/users/:userId/subscriptions
 * @accessor api.functional.redditLike.users.subscriptions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the user who is subscribing to the community */
    userId: string & tags.Format<"uuid">;

    /**
     * Community subscription creation data including the target community
     * identifier to subscribe to
     */
    body: IRedditLikeUser.ISubscriptionCreate;
  };
  export type Body = IRedditLikeUser.ISubscriptionCreate;
  export type Response = IRedditLikeCommunitySubscription;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/users/:userId/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/users/${encodeURIComponent(props.userId ?? "null")}/subscriptions`;
  export const random = (): IRedditLikeCommunitySubscription =>
    typia.random<IRedditLikeCommunitySubscription>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve filtered and paginated list of user's subscribed communities.
 *
 * Retrieve a comprehensive, filtered, and paginated list of communities that a
 * specific user has subscribed to. This operation provides advanced search and
 * filtering capabilities for managing community subscriptions, allowing users
 * to efficiently browse and organize their followed communities.
 *
 * The operation queries the reddit_like_community_subscriptions junction table
 * to identify all communities the user has subscribed to, joining with the
 * reddit_like_communities table to provide full community details including
 * name, description, subscriber counts, category information, and privacy
 * settings. The response includes subscription metadata such as when the user
 * subscribed to each community.
 *
 * Filtering capabilities enable users to narrow down their subscriptions by
 * community category (Technology, Gaming, Sports, etc.), privacy type (public
 * or private), subscription date ranges, and activity status (archived vs
 * active communities). The search functionality supports partial matching on
 * community names and descriptions using PostgreSQL trigram indexes for
 * efficient text search.
 *
 * Sorting options include ordering by subscription date (most recently
 * subscribed first or oldest first), community subscriber count (most popular
 * first), or alphabetically by community name. Pagination parameters control
 * result set size and enable efficient browsing of large subscription lists.
 *
 * Security considerations include verifying the requesting user has permission
 * to view the target user's subscriptions based on the profile owner's
 * show_subscriptions_publicly privacy setting defined in reddit_like_users
 * table. When show_subscriptions_publicly is false, only the profile owner can
 * retrieve their subscription list. Public subscription lists are visible to
 * all authenticated users.
 *
 * This operation integrates with the community subscription system defined in
 * the Community Management requirements document section 4, supporting the
 * personalized feed composition workflows and subscription management
 * interfaces. The returned data enables users to manage their subscriptions,
 * understand their community participation patterns, and provides the
 * foundation for personalized content feed generation.
 *
 * The response includes denormalized subscriber counts from
 * reddit_like_communities for display performance, avoiding real-time
 * aggregation. Community metadata such as icons, banners, and primary
 * categories enable rich UI presentation of subscription lists.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose subscriptions are
 *   being retrieved
 * @param props.body Search criteria, filtering parameters, sorting preferences,
 *   and pagination settings for retrieving user subscriptions
 * @path /redditLike/users/:userId/subscriptions
 * @accessor api.functional.redditLike.users.subscriptions.patchByUserid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByUserid(
  connection: IConnection,
  props: patchByUserid.Props,
): Promise<patchByUserid.Response> {
  return true === connection.simulate
    ? patchByUserid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByUserid.METADATA,
          path: patchByUserid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByUserid {
  export type Props = {
    /** Unique identifier of the user whose subscriptions are being retrieved */
    userId: string & tags.Format<"uuid">;

    /**
     * Search criteria, filtering parameters, sorting preferences, and
     * pagination settings for retrieving user subscriptions
     */
    body: IRedditLikeUser.ISubscriptionsRequest;
  };
  export type Body = IRedditLikeUser.ISubscriptionsRequest;
  export type Response = IPageIRedditLikeCommunity.ISubscriptionSummary;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/users/:userId/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/users/${encodeURIComponent(props.userId ?? "null")}/subscriptions`;
  export const random = (): IPageIRedditLikeCommunity.ISubscriptionSummary =>
    typia.random<IPageIRedditLikeCommunity.ISubscriptionSummary>();
  export const simulate = (
    connection: IConnection,
    props: patchByUserid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByUserid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
