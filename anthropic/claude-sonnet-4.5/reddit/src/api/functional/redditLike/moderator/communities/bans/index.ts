import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunityBan } from "../../../../../structures/IRedditLikeCommunityBan";
import { IPageIRedditLikeCommunityBan } from "../../../../../structures/IPageIRedditLikeCommunityBan";

/**
 * Issue a community ban to prevent a member from participating in the
 * community.
 *
 * Create a new community-level ban preventing a specific member from
 * participating in the community. This operation enforces community standards
 * by restricting users who violate community rules or engage in disruptive
 * behavior. The ban prevents the user from creating posts, writing comments,
 * voting on content, and reporting content within the banned community, while
 * still allowing them to view public content and participate in other
 * communities.
 *
 * Community bans are scoped to a single community and do not affect the user's
 * ability to participate elsewhere on the platform. This distributed moderation
 * model empowers community moderators to manage their communities while
 * limiting the scope of their authority. Only moderators assigned to the
 * specific community or platform administrators can issue community bans.
 *
 * The operation supports both temporary and permanent bans. Temporary bans
 * include an expiration date (configurable in increments of 1 day, 7 days, 30
 * days, or custom duration), after which the system automatically restores the
 * user's permissions. Permanent bans remain in effect until explicitly lifted
 * by a moderator or administrator.
 *
 * All bans require detailed reasoning through both a predefined reason category
 * and explanatory text. The reason text is displayed to the banned user in
 * notifications and serves as the basis for any subsequent appeals. Internal
 * notes can be added for moderator-only context sharing. The banned user
 * receives a notification within 5 minutes containing the ban details,
 * duration, reason, and information about the appeal process.
 *
 * This operation integrates with the moderation logging system, creating an
 * immutable audit trail of all ban issuances. Ban history is tracked for each
 * user to identify repeat offenders and inform future moderation decisions. The
 * operation validates that the issuing moderator has appropriate permissions
 * for the specified community before processing the ban request.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the ban is
 *   being issued
 * @param props.body Ban creation details including target member, duration, and
 *   reasoning
 * @path /redditLike/moderator/communities/:communityId/bans
 * @accessor api.functional.redditLike.moderator.communities.bans.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the community where the ban is being issued */
    communityId: string & tags.Format<"uuid">;

    /** Ban creation details including target member, duration, and reasoning */
    body: IRedditLikeCommunityBan.ICreate;
  };
  export type Body = IRedditLikeCommunityBan.ICreate;
  export type Response = IRedditLikeCommunityBan;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/communities/:communityId/bans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/bans`;
  export const random = (): IRedditLikeCommunityBan =>
    typia.random<IRedditLikeCommunityBan>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve filtered and paginated list of community bans with search
 * capabilities.
 *
 * Search and retrieve community bans for a specific community with advanced
 * filtering, pagination, and sorting capabilities. This operation enables
 * moderators and administrators to review ban history, identify currently
 * banned users, track repeat offenders, and audit moderation decisions within
 * their community.
 *
 * The operation supports comprehensive filtering options to narrow down the ban
 * list based on multiple criteria. Moderators can filter by active status to
 * see only currently enforced bans versus historical lifted or expired bans.
 * The system supports filtering by ban type (permanent versus temporary),
 * expiration date ranges for identifying soon-to-expire bans, and ban reason
 * categories for analyzing common violation patterns.
 *
 * Search capabilities include text search across ban reason descriptions and
 * internal moderator notes, enabling keyword-based discovery of specific ban
 * incidents. The operation also supports filtering by the moderator who issued
 * the ban, useful for reviewing individual moderator actions or training
 * purposes.
 *
 * Pagination controls allow efficient browsing through large ban lists with
 * configurable page sizes. Sorting options include ordering by ban creation
 * date (newest or oldest first), expiration date (for temporary bans), banned
 * member username (alphabetically), or ban reason category. Default sorting
 * displays the most recently issued bans first to prioritize current moderation
 * activity.
 *
 * This operation integrates with the reddit_like_community_bans table,
 * accessing ban records, associated member information, issuing moderator
 * details, and ban metadata. The response includes ban status, duration
 * information, reasoning, and timestamps. Security enforcement ensures
 * moderators can only access ban lists for communities they moderate, while
 * administrators have unrestricted access to all community ban records.
 *
 * The operation supports moderation workflows by providing the data foundation
 * for ban management interfaces, moderator dashboards, and community health
 * monitoring. It enables identification of problematic users, tracking of
 * moderation patterns, and assessment of ban effectiveness over time.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community whose bans are
 *   being retrieved
 * @param props.body Search criteria and pagination parameters for filtering
 *   community bans
 * @path /redditLike/moderator/communities/:communityId/bans
 * @accessor api.functional.redditLike.moderator.communities.bans.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the community whose bans are being retrieved */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for filtering community
     * bans
     */
    body: IRedditLikeCommunityBan.IRequest;
  };
  export type Body = IRedditLikeCommunityBan.IRequest;
  export type Response = IPageIRedditLikeCommunityBan;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/moderator/communities/:communityId/bans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/bans`;
  export const random = (): IPageIRedditLikeCommunityBan =>
    typia.random<IPageIRedditLikeCommunityBan>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific community ban.
 *
 * Retrieve comprehensive details of a specific community ban issued within a
 * community. This operation fetches complete ban information including the
 * banned member's identity, the moderator who issued the ban, the reason for
 * the ban, ban duration and expiration details, and current ban status.
 *
 * This operation is primarily used by community moderators to review existing
 * bans when managing their community's banned users list, or when users appeal
 * bans and moderators need to review the ban details to make informed decisions
 * about the appeal. The endpoint enables moderators to access full ban context
 * including internal notes that may have been added by the issuing moderator.
 *
 * The operation integrates with the reddit_like_community_bans table from the
 * Prisma schema, which stores community-level bans with support for both
 * temporary and permanent bans. The table includes soft delete support through
 * the deleted_at field, allowing lifted bans to be preserved in audit history
 * while being marked as inactive.
 *
 * Security considerations include ensuring only authorized moderators of the
 * specific community can access ban details, as this information contains
 * sensitive moderation data including internal notes and ban reasoning. The
 * system validates that the requesting moderator has permissions for the
 * specified community before returning ban information.
 *
 * The response includes all ban metadata such as whether the ban is permanent
 * or temporary, the expiration date for temporary bans, whether the ban is
 * currently active, the complete ban reason provided by the issuing moderator,
 * and any internal notes. This comprehensive view enables moderators to make
 * informed decisions when reviewing appeals or managing community access.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the ban was
 *   issued
 * @param props.banId Unique identifier of the specific community ban to
 *   retrieve
 * @path /redditLike/moderator/communities/:communityId/bans/:banId
 * @accessor api.functional.redditLike.moderator.communities.bans.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the community where the ban was issued */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific community ban to retrieve */
    banId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommunityBan;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/moderator/communities/:communityId/bans/:banId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/bans/${encodeURIComponent(props.banId ?? "null")}`;
  export const random = (): IRedditLikeCommunityBan =>
    typia.random<IRedditLikeCommunityBan>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("banId")(() => typia.assert(props.banId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Lift a community ban and restore member access (soft delete).
 *
 * Lifts a community ban by setting the deleted_at timestamp to the current
 * time, marking the ban as inactive while preserving the complete ban record
 * for audit history. This soft delete approach maintains the ban record in the
 * reddit_like_community_bans table for moderation log purposes and historical
 * review, while immediately restoring the banned member's ability to post,
 * comment, and vote in the community.
 *
 * This endpoint is used by community moderators when they decide to lift a ban,
 * either due to successful appeal, manual removal of an expired temporary ban,
 * or reconsideration of the ban decision. The soft delete pattern ensures that
 * the platform maintains a complete audit trail of all moderation actions
 * including lifted bans, supporting accountability and enabling moderators to
 * review past ban patterns for repeat offenders.
 *
 * The operation integrates with the reddit_like_community_bans table from the
 * Prisma schema, which includes a deleted_at field specifically for soft
 * deletion. When the deleted_at timestamp is set, the ban is no longer enforced
 * for access control checks, but the record remains queryable by moderators and
 * administrators for historical review and audit purposes. The complete ban
 * history including issue date, reason, duration, and lift date is preserved.
 *
 * Security considerations include strict authorization validation ensuring only
 * moderators of the specific community can lift bans within their communities.
 * The operation verifies the ban exists, belongs to the specified community,
 * and is currently active before performing the soft delete. After successful
 * deletion, the system logs the ban removal action in the
 * reddit_like_moderation_logs audit trail and may send a notification to the
 * previously banned member informing them that their access has been restored.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the ban was
 *   issued
 * @param props.banId Unique identifier of the community ban to lift
 * @path /redditLike/moderator/communities/:communityId/bans/:banId
 * @accessor api.functional.redditLike.moderator.communities.bans.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the community where the ban was issued */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the community ban to lift */
    banId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/moderator/communities/:communityId/bans/:banId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/bans/${encodeURIComponent(props.banId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("banId")(() => typia.assert(props.banId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
