import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunityRule } from "../../../../../structures/IRedditLikeCommunityRule";

/**
 * Create a new rule for a specific community.
 *
 * Create a new community-specific rule within the specified community. This
 * operation allows community moderators to define custom guidelines that help
 * maintain community standards, guide user behavior, and establish clear
 * expectations for participation.
 *
 * Community rules are essential for setting behavioral expectations and
 * moderating content effectively. Each community can have up to 15 custom rules
 * as defined in the business requirements (document 03-community-management.md,
 * section 6.1). Rules include a title, optional description, type
 * classification, and display order.
 *
 * The operation validates that the requesting user has moderator permissions
 * for the target community as defined in the reddit_like_community_moderators
 * table. Only users with 'manage_settings' permission or primary moderators can
 * create new rules for their communities. Administrators can create rules for
 * any community.
 *
 * Rule creation involves inserting a new record into the
 * reddit_like_community_rules table with the provided title (3-100 characters),
 * optional description (up to 500 characters), rule type (required, prohibited,
 * or etiquette), and display order (1-15) to control presentation sequence. The
 * system validates that adding this rule does not exceed the 15-rule maximum
 * limit per community.
 *
 * Once created, rules become immediately visible to all community members on
 * the community page and during the post creation workflow, helping users
 * understand expectations before contributing content. Rules also serve as
 * reference points during content moderation when moderators remove posts or
 * comments for rule violations.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the rule is
 *   being created
 * @param props.body Community rule creation data including title, description,
 *   type, and display order
 * @path /redditLike/moderator/communities/:communityId/rules
 * @accessor api.functional.redditLike.moderator.communities.rules.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the community where the rule is being created */
    communityId: string & tags.Format<"uuid">;

    /**
     * Community rule creation data including title, description, type, and
     * display order
     */
    body: IRedditLikeCommunityRule.ICreate;
  };
  export type Body = IRedditLikeCommunityRule.ICreate;
  export type Response = IRedditLikeCommunityRule;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/communities/:communityId/rules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): IRedditLikeCommunityRule =>
    typia.random<IRedditLikeCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing community rule definition.
 *
 * Modify the definition of an existing community rule by providing updated
 * values for the rule's title, description, type classification, and display
 * order. This operation enables community moderators to refine, clarify, or
 * reorganize their community's rules as community needs evolve over time.
 *
 * This endpoint is restricted to moderators of the specific community as
 * defined in the Community Management Requirements document section 6.1, which
 * specifies that only moderators with appropriate permissions can create and
 * update community rules. The operation validates that the authenticated user
 * has moderator status for the target community and that the specified rule
 * exists within that community before allowing modifications.
 *
 * The rule update workflow supports several use cases. Moderators refine rule
 * wording to improve clarity based on user confusion or moderation experiences.
 * They adjust rule descriptions to provide more detailed guidance and examples.
 * They reorganize rules by changing display_order values to prioritize more
 * important or frequently violated rules. They reclassify rules between types
 * (required, prohibited, etiquette) as community culture evolves.
 *
 * Validation requirements mirror those for rule creation as specified in the
 * Community Management document. Rule titles must be 3-100 characters in
 * length. Rule descriptions are optional but limited to 500 characters when
 * provided. The rule_type field must contain valid values (required,
 * prohibited, or etiquette). The display_order must be a positive integer
 * between 1 and 15, corresponding to the maximum of 15 rules per community
 * specified in requirement R-CAT-006.
 *
 * The operation integrates with the content moderation system defined in the
 * Content Moderation and Reporting Requirements document. When moderators
 * update rules, existing content violations and moderation actions remain
 * associated with the original rule definitions to maintain moderation history
 * integrity. Updated rules apply to future content submissions and moderation
 * decisions.
 *
 * Related operations include retrieving rule details (GET
 * /communities/{communityId}/rules/{ruleId}), listing all community rules (GET
 * /communities/{communityId}/rules), creating new rules (POST
 * /communities/{communityId}/rules), and deleting rules (DELETE
 * /communities/{communityId}/rules/{ruleId}). This operation is often used
 * alongside community settings management and moderation queue workflows.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   rule to update
 * @param props.ruleId Unique identifier of the specific rule to update
 * @param props.body Updated rule information including title, description,
 *   type, and display order
 * @path /redditLike/moderator/communities/:communityId/rules/:ruleId
 * @accessor api.functional.redditLike.moderator.communities.rules.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the community containing the rule to update */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific rule to update */
    ruleId: string & tags.Format<"uuid">;

    /**
     * Updated rule information including title, description, type, and
     * display order
     */
    body: IRedditLikeCommunityRule.IUpdate;
  };
  export type Body = IRedditLikeCommunityRule.IUpdate;
  export type Response = IRedditLikeCommunityRule;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/moderator/communities/:communityId/rules/:ruleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IRedditLikeCommunityRule =>
    typia.random<IRedditLikeCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific community rule.
 *
 * This operation permanently removes a specific rule from a community's rule
 * set. Community moderators use this endpoint to delete rules that are no
 * longer relevant, redundant, or need to be replaced with updated guidelines.
 * The operation targets the reddit_like_community_rules table in the Prisma
 * schema and requires both the community ID and the specific rule ID to
 * identify which rule should be removed.
 *
 * The deletion is permanent and immediately removes the rule from display on
 * the community page, post creation interfaces, and moderation tools. Once
 * deleted, the rule will no longer be available for moderators to cite when
 * removing content or banning users. The display order of remaining rules will
 * be preserved, though moderators may want to reorder rules after deletion if
 * gaps in numbering are created.
 *
 * Security considerations include verifying that the requesting user is a
 * moderator of the specified community with 'manage_settings' permission as
 * defined in the reddit_like_community_moderators table. The operation
 * validates that both the community and rule exist and that the rule belongs to
 * the specified community before proceeding with deletion. Only moderators
 * assigned to the community can delete its rules, preventing unauthorized rule
 * manipulation.
 *
 * This operation integrates with the community management system by updating
 * the community's rule configuration. After deletion, the community will have
 * one fewer rule in its rule set (maximum 15 rules per community as per
 * requirements). Users creating posts in the community will no longer see the
 * deleted rule in the rule acknowledgment interface, and moderators will no
 * longer be able to select this rule when taking moderation actions.
 *
 * Expected behavior includes immediate removal from all community interfaces,
 * validation that the rule exists and belongs to the specified community, and
 * proper authorization checks ensuring only community moderators can delete
 * rules. Error scenarios include attempting to delete non-existent rules,
 * attempting to delete rules from communities where the user lacks moderator
 * permissions, and attempting to delete rules that belong to different
 * communities than specified.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   rule to delete
 * @param props.ruleId Unique identifier of the specific rule to permanently
 *   delete
 * @path /redditLike/moderator/communities/:communityId/rules/:ruleId
 * @accessor api.functional.redditLike.moderator.communities.rules.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the community containing the rule to delete */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific rule to permanently delete */
    ruleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/moderator/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
