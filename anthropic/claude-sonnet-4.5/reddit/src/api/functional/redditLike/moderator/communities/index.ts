import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunity } from "../../../../structures/IRedditLikeCommunity";
export * as rules from "./rules/index";
export * as moderators from "./moderators/index";
export * as posts from "./posts/index";
export * as bans from "./bans/index";
export * as moderation_log from "./moderation_log/index";

/**
 * Update community settings and configuration for the specified community.
 *
 * Updates the configuration and settings of an existing community identified by
 * communityId. This operation allows community moderators and platform
 * administrators to modify various aspects of their community including the
 * description, visual branding elements (icon and banner images), posting
 * permission rules, allowed content types, category classifications, and
 * privacy settings.
 *
 * The operation references the reddit_like_communities table from the Prisma
 * schema. Moderators can update fields including description (10-500
 * characters), icon_url, banner_url, privacy_type (public or private),
 * posting_permission (anyone_subscribed, approved_only, moderators_only),
 * content type toggles (allow_text_posts, allow_link_posts, allow_image_posts),
 * primary_category, and secondary_tags.
 *
 * Security considerations include verification that the requesting user is
 * either a moderator of the specified community with manage_settings permission
 * or a platform administrator. Community moderators can only modify communities
 * they have been assigned to moderate, while administrators have system-wide
 * override capabilities. The community code field is immutable and cannot be
 * changed through this endpoint to maintain URL stability. Granular permission
 * checking (manage_settings permission) is handled in the provider function
 * implementation layer.
 *
 * Validation rules include enforcing description length requirements (10-500
 * characters), validating privacy_type and posting_permission values against
 * allowed enums, ensuring primary_category matches predefined categories, and
 * limiting secondary_tags to 3 comma-separated values. Image URLs for icon and
 * banner must be valid and point to accessible resources.
 *
 * This operation integrates with the community management system defined in the
 * requirements document section 3 (Community Settings and Configuration). When
 * privacy settings are changed from public to private or vice versa, the system
 * must handle existing subscribers appropriately. When posting permissions are
 * modified, the changes take effect immediately for all subsequent post
 * attempts.
 *
 * Related operations include GET /communities/{communityId} for retrieving
 * current community settings before modification, which should be called as a
 * prerequisite to verify community existence and obtain current state. The POST
 * /communities endpoint handles initial community creation.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to update
 * @param props.body Updated community configuration including description,
 *   privacy settings, posting permissions, and visual branding
 * @path /redditLike/moderator/communities/:communityId
 * @accessor api.functional.redditLike.moderator.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the community to update */
    communityId: string & tags.Format<"uuid">;

    /**
     * Updated community configuration including description, privacy
     * settings, posting permissions, and visual branding
     */
    body: IRedditLikeCommunity.IUpdate;
  };
  export type Body = IRedditLikeCommunity.IUpdate;
  export type Response = IRedditLikeCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/moderator/communities/:communityId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): IRedditLikeCommunity =>
    typia.random<IRedditLikeCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete the specified community with 30-day recovery period.
 *
 * Soft deletes an existing community from the platform by setting the
 * deleted_at timestamp field in the reddit_like_communities table. This
 * operation is restricted to the primary moderator (community creator) who
 * originally founded the community or platform administrators who have
 * system-wide override capabilities. Regular moderators who were added to the
 * community after creation cannot delete communities per the business
 * requirements.
 *
 * The operation implements the soft-delete pattern using the deleted_at
 * timestamp field defined in the reddit_like_communities Prisma schema. When a
 * community is deleted, the system sets the deleted_at field to the current
 * timestamp, effectively marking the community as removed while preserving all
 * data for potential recovery during the 30-day cooldown period specified in
 * the requirements.
 *
 * Upon successful deletion, the system performs several coordinated actions:
 * removes the community from all public directories and search results,
 * unsubscribes all members from the community (affecting their personalized
 * feeds), archives all posts and comments within the community (marking them as
 * inaccessible but preserved), and prevents any new posts or comments from
 * being created. The community page displays a 'This community has been
 * deleted' message to anyone attempting to access it.
 *
 * Security considerations include strict verification that the requesting user
 * is either the primary moderator (identified by checking is_primary=true in
 * reddit_like_community_moderators table for the authenticated moderator) or a
 * platform administrator. The operation must validate the community exists and
 * is not already deleted before proceeding. This primary moderator verification
 * happens in the provider function implementation layer. Administrators may
 * delete communities that violate platform-wide policies regardless of
 * moderator status.
 *
 * The soft deletion follows a 30-day cooldown period before permanent archival
 * per requirements section 9.2. During this cooldown, the primary moderator or
 * administrators can restore the community through a separate restoration
 * endpoint. After 30 days, the system permanently archives all community data.
 * This cooldown mechanism protects against accidental deletions and provides
 * recovery options.
 *
 * Validation rules include confirming the community exists, verifying it is not
 * already in deleted status (deleted_at is null), and ensuring the requesting
 * user has appropriate authorization (primary moderator or administrator). The
 * operation returns no response body upon successful deletion, following
 * standard RESTful DELETE semantics.
 *
 * This operation integrates with the community management requirements
 * specified in section 9 (Community Deletion and Archival). Related operations
 * include POST /communities for community creation and PATCH
 * /communities/{communityId}/restore for recovering deleted communities during
 * the cooldown period. The GET /communities/{communityId} endpoint should be
 * called as a prerequisite to verify community existence before deletion.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to soft delete
 * @path /redditLike/moderator/communities/:communityId
 * @accessor api.functional.redditLike.moderator.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the community to soft delete */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/moderator/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
