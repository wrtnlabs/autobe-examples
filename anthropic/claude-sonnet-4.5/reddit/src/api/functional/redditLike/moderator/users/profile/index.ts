import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeUser } from "../../../../../structures/IRedditLikeUser";

/**
 * Update profile information for the authenticated user.
 *
 * Update editable profile information for the authenticated user identified by
 * the userId path parameter. This operation modifies user profile data in the
 * reddit_like_users table, allowing users to customize their profile biography,
 * avatar image, and privacy settings that control how their profile and
 * activity are displayed to other platform members.
 *
 * This endpoint serves the critical use case of profile customization and
 * privacy management. Users access their account settings or profile page to
 * modify their public presentation, add or update biographical information,
 * change their profile picture, or adjust privacy controls for karma
 * visibility, profile access, and subscription list display. The operation
 * empowers users to manage their platform identity and control what information
 * they share with the community.
 *
 * Authorization enforcement is critical for this operation. The system must
 * verify that the authenticated user's ID matches the userId path parameter,
 * ensuring users can only modify their own profiles. Moderators and
 * administrators do not have special privileges to edit other users' profiles -
 * profile editing is strictly limited to the profile owner. If the
 * authenticated user ID does not match the userId in the path, the system
 * returns a permission error.
 *
 * Editable fields include profile_bio (limited to 200-500 characters per
 * requirements document 02-user-roles-authentication.md section 2.3),
 * avatar_url (must be valid image URL or uploaded image reference),
 * show_karma_publicly (boolean controlling karma visibility), profile_privacy
 * (values: 'public', 'members_only', 'private'), and
 * show_subscriptions_publicly (boolean controlling subscription list
 * visibility). The username, email, password_hash, role, karma scores
 * (post_karma, comment_karma), and timestamps are immutable through this
 * endpoint and must be modified through dedicated specialized endpoints.
 *
 * Validation rules enforce profile_bio length constraints, avatar_url format
 * validation (must point to valid image), and profile_privacy enumeration
 * values. The system validates that all provided values meet business
 * requirements before applying updates. If validation fails, the system returns
 * detailed error messages indicating which fields failed validation and why.
 *
 * The operation updates the updated_at timestamp to reflect when profile
 * modifications occurred. This timestamp is used for tracking profile edit
 * history and identifying recently active users. The operation returns the
 * complete updated profile information after successful modification, allowing
 * clients to refresh their display with confirmed changes.
 *
 * This operation integrates with the user authentication system defined in
 * requirement document 02-user-roles-authentication.md, requiring valid JWT
 * token authentication and enforcing member-level permissions. It implements
 * privacy controls specified in document 09-user-profiles-feeds.md section 8 on
 * profile privacy settings, allowing users to configure their public visibility
 * preferences.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose profile is being
 *   updated, must match the authenticated user's ID
 * @param props.body Updated profile information including biography, avatar,
 *   and privacy settings for the user
 * @path /redditLike/moderator/users/:userId/profile
 * @accessor api.functional.redditLike.moderator.users.profile.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the user whose profile is being updated, must
     * match the authenticated user's ID
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Updated profile information including biography, avatar, and privacy
     * settings for the user
     */
    body: IRedditLikeUser.IProfileUpdate;
  };
  export type Body = IRedditLikeUser.IProfileUpdate;
  export type Response = IRedditLikeUser.IProfile;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/moderator/users/:userId/profile",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): IRedditLikeUser.IProfile =>
    typia.random<IRedditLikeUser.IProfile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
