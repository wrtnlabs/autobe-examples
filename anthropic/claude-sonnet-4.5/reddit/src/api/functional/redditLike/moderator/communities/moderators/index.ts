import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunityModerator } from "../../../../../structures/IRedditLikeCommunityModerator";

/**
 * Assign a new moderator to a community with specified permissions.
 *
 * Assign a new moderator to manage a specific community by creating a moderator
 * assignment record with customizable permission grants. This operation enables
 * existing community moderators with 'manage_moderators' permission to expand
 * their moderation team by inviting additional moderators from the member
 * base.
 *
 * The operation implements the moderator invitation workflow defined in the
 * Community Management requirements document section 5.2. When a moderator
 * invites a new moderator, the system verifies the invited user is a registered
 * member, ensures they are not already a moderator of this community, and
 * validates that the community has not reached the maximum limit of 25
 * moderators. The inviting moderator can customize which specific permissions
 * to grant, choosing from manage_posts, manage_comments, manage_users,
 * manage_settings, manage_moderators, and access_reports.
 *
 * This operation references the reddit_like_community_moderators table which
 * tracks the many-to-many relationship between moderators and communities. Each
 * assignment record includes the moderator being assigned, the community they
 * are managing, who assigned them (for seniority tracking), the timestamp of
 * assignment (for seniority-based removal rules), whether they are the primary
 * moderator (always false for invited moderators), and the JSON or
 * comma-separated list of granted permissions.
 *
 * The default permission set for newly invited moderators includes
 * 'manage_posts', 'manage_comments', and 'access_reports' as specified in the
 * requirements, though the inviting moderator can customize this set during the
 * invitation. Primary moderators (community creators) automatically receive all
 * permissions and have irrevocable status, but this operation is for inviting
 * additional moderators, not creating communities.
 *
 * Authorization for this operation requires the requesting user to be an
 * authenticated moderator with 'manage_moderators' permission in the target
 * community, or a platform administrator who can manage moderators in any
 * community. The operation validates these permissions before allowing
 * moderator assignment to maintain proper community governance hierarchy.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the new
 *   moderator is being assigned
 * @param props.body Moderator assignment information including the user to be
 *   assigned and their permission set
 * @path /redditLike/moderator/communities/:communityId/moderators
 * @accessor api.functional.redditLike.moderator.communities.moderators.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the community where the new moderator is being
     * assigned
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Moderator assignment information including the user to be assigned
     * and their permission set
     */
    body: IRedditLikeCommunityModerator.ICreate;
  };
  export type Body = IRedditLikeCommunityModerator.ICreate;
  export type Response = IRedditLikeCommunityModerator;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/communities/:communityId/moderators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/moderators`;
  export const random = (): IRedditLikeCommunityModerator =>
    typia.random<IRedditLikeCommunityModerator>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific moderator assignment in a
 * community.
 *
 * This operation retrieves comprehensive information about a specific moderator
 * assignment within a community. The endpoint accesses the
 * reddit_like_community_moderators junction table which manages the
 * many-to-many relationship between communities and their assigned moderators.
 *
 * The response includes critical moderator assignment details such as the
 * moderator's unique identifier, the timestamp when they were assigned to the
 * community (assigned_at), whether they hold primary moderator status indicated
 * by the is_primary boolean field (community creator with irrevocable
 * permissions), and their granted permission set stored in the permissions
 * field (manage_posts, manage_comments, manage_users, manage_settings,
 * manage_moderators, access_reports).
 *
 * This operation is essential for community management workflows, enabling
 * moderators and administrators to review the moderator team composition,
 * understand permission distributions, and verify moderator credentials. The
 * information helps in making informed decisions about moderator role changes,
 * permission adjustments, or moderator removals based on seniority tracked via
 * the assigned_at timestamp field from the Prisma schema.
 *
 * Security considerations include restricting access to this endpoint to
 * authenticated users with appropriate permissions - typically current
 * community moderators who need to view the moderator team, or administrators
 * who oversee all communities. The endpoint enforces community-specific scope,
 * ensuring moderators can only view moderator details for communities they
 * manage.
 *
 * The endpoint integrates with the user roles and authentication system defined
 * in the requirements, enforcing role-based access control. It also connects to
 * the community management workflows, supporting the moderator assignment and
 * hierarchy features specified in the community management requirements
 * document.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community whose moderator
 *   assignment information is being retrieved
 * @param props.moderatorId Unique identifier of the specific moderator
 *   assignment record in the reddit_like_community_moderators table
 * @path /redditLike/moderator/communities/:communityId/moderators/:moderatorId
 * @accessor api.functional.redditLike.moderator.communities.moderators.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the community whose moderator assignment
     * information is being retrieved
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the specific moderator assignment record in the
     * reddit_like_community_moderators table
     */
    moderatorId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommunityModerator;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/moderator/communities/:communityId/moderators/:moderatorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): IRedditLikeCommunityModerator =>
    typia.random<IRedditLikeCommunityModerator>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update moderator assignment permissions and details for a specific moderator
 * in a community.
 *
 * This operation updates the moderator assignment record for a specific
 * moderator within a community, enabling management of moderator permissions
 * and assignment attributes. The endpoint modifies records in the
 * reddit_like_community_moderators junction table which tracks community
 * moderator assignments with fields including community_id, moderator_id,
 * assigned_by_moderator_id, assigned_at, is_primary, and permissions.
 *
 * The primary use case is adjusting the permissions field which stores the
 * granted permissions for a moderator within a community. Per the community
 * management requirements section 5.3, moderators can have granular permissions
 * including manage_posts, manage_comments, manage_users, manage_settings,
 * manage_moderators, and access_reports. This endpoint allows the primary
 * moderator or moderators with 'manage_moderators' permission to customize
 * which permissions each moderator possesses by updating the permissions string
 * field.
 *
 * Authorization for this operation is carefully controlled per requirements
 * section 5.3. Only the primary moderator (where is_primary=true) can modify
 * permissions for any moderator, or moderators with the 'manage_moderators'
 * permission can adjust permissions for moderators who were assigned after them
 * based on the assigned_at timestamp (seniority-based permission model). The
 * endpoint enforces these business rules by validating the requesting user's
 * moderator status and permission set before allowing updates.
 *
 * The update operation cannot modify certain immutable fields as defined in the
 * Prisma schema including the community_id, moderator_id, is_primary flag,
 * assigned_at timestamp, or assigned_by_moderator_id references. These fields
 * establish the foundational moderator relationship and must remain stable for
 * referential integrity. Only the permissions string can be modified through
 * this endpoint to adjust the moderator's granted capabilities.
 *
 * Security considerations include verifying the requesting user is a moderator
 * of the specified community, has appropriate permission levels to modify other
 * moderators per the seniority rules, and is not attempting to escalate their
 * own permissions or modify the primary moderator's irrevocable permissions.
 * The operation logs all permission changes for audit trail purposes in the
 * moderation logging system.
 *
 * This endpoint integrates with the community management system defined in
 * requirements document 03-community-management.md, supporting the moderator
 * hierarchy and permission management features specified in sections 5.3 and
 * 5.4. It enables the distributed moderation model where communities manage
 * their own moderator teams within platform guidelines.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   moderator assignment to update
 * @param props.moderatorId Unique identifier of the specific moderator
 *   assignment record in the reddit_like_community_moderators table to update
 * @param props.body Updated moderator assignment data including modified
 *   permissions string and any other editable attributes
 * @path /redditLike/moderator/communities/:communityId/moderators/:moderatorId
 * @accessor api.functional.redditLike.moderator.communities.moderators.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the community containing the moderator
     * assignment to update
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the specific moderator assignment record in the
     * reddit_like_community_moderators table to update
     */
    moderatorId: string & tags.Format<"uuid">;

    /**
     * Updated moderator assignment data including modified permissions
     * string and any other editable attributes
     */
    body: IRedditLikeCommunityModerator.IUpdate;
  };
  export type Body = IRedditLikeCommunityModerator.IUpdate;
  export type Response = IRedditLikeCommunityModerator;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/moderator/communities/:communityId/moderators/:moderatorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): IRedditLikeCommunityModerator =>
    typia.random<IRedditLikeCommunityModerator>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a moderator from a community.
 *
 * Removes a moderator assignment from a specific community, immediately
 * revoking all their moderator permissions for that community. This operation
 * implements the community governance model where moderators can be removed by
 * authorized users based on seniority and permission hierarchies.
 *
 * The operation enforces strict authorization rules defined in the community
 * management requirements. Only the primary moderator (community creator) has
 * irrevocable permissions and can remove any other moderator from the
 * community. Additionally, moderators with 'manage_moderators' permission can
 * remove moderators who were assigned after them, implementing a
 * seniority-based removal system.
 *
 * When a moderator is removed, the system immediately revokes all their
 * moderator permissions for the specified community. The removed moderator
 * receives a notification informing them of the removal. However, their status
 * as a regular community member is retained - they remain subscribed to the
 * community unless they choose to unsubscribe manually. This ensures that
 * moderator removal doesn't forcibly disconnect users from communities they
 * care about.
 *
 * This operation is permanent and cannot be undone directly. If a moderator is
 * removed by mistake, they must be re-invited through the standard moderator
 * invitation workflow. The removal is logged in the moderation system for audit
 * trail purposes.
 *
 * The operation validates that the requesting user has appropriate permissions
 * to remove the specified moderator from the community. It also verifies that
 * the community exists and that the target moderator is currently assigned to
 * that community before processing the removal.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community from which the
 *   moderator will be removed
 * @param props.moderatorId Unique identifier of the moderator to be removed
 *   from the community
 * @path /redditLike/moderator/communities/:communityId/moderators/:moderatorId
 * @accessor api.functional.redditLike.moderator.communities.moderators.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the community from which the moderator will be
     * removed
     */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the moderator to be removed from the community */
    moderatorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/moderator/communities/:communityId/moderators/:moderatorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/communities/${encodeURIComponent(props.communityId ?? "null")}/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
