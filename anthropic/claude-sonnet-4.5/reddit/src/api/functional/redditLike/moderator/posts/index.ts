import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikePost } from "../../../../structures/IRedditLikePost";
export * as votes from "./votes/index";

/**
 * Create a new post in a community.
 *
 * Create a new post within a specified community on the Reddit-like platform.
 * This operation enables authenticated members to share content with
 * communities through three distinct post types: text posts for written
 * discussions and questions, link posts for sharing external web content, and
 * image posts for uploading and sharing visual media.
 *
 * The operation integrates with the reddit_like_posts table as the main post
 * entity, along with type-specific content tables based on the post type
 * discriminator. When creating a text post, the system stores the body content
 * in reddit_like_post_text_content with support for markdown formatting up to
 * 40,000 characters. For link posts, the system validates the URL, stores it in
 * reddit_like_post_link_content, and attempts to extract Open Graph metadata
 * including preview title, description, and thumbnail image. Image posts
 * require file upload with validation of format (JPEG, PNG, GIF, WebP), size
 * (maximum 20MB), and automatic generation of multiple image versions
 * (original, medium 640px, thumbnail 150x150) stored in
 * reddit_like_post_image_content.
 *
 * Security considerations include verifying the user is authenticated as a
 * member, moderator, or administrator per the reddit_like_users role field. The
 * system must validate the user is not banned from the target community by
 * checking reddit_like_community_bans for active bans where banned_member_id
 * matches the authenticated user and community_id matches the target community.
 * Community-specific posting permissions from
 * reddit_like_communities.posting_permission must be enforced, restricting
 * posting based on subscription status or moderator approval. Content
 * validation prevents XSS attacks through sanitization, validates URLs against
 * malicious site databases, and enforces anti-spam rate limiting (maximum 10
 * posts per hour, 5 posts per day for accounts less than 24 hours old).
 *
 * The operation initializes new posts with vote_score of 0, created_at
 * timestamp, and associates the post with the authenticated user's ID
 * (reddit_like_member_id) and selected community ID (reddit_like_community_id).
 * All post titles must be 3-300 characters with leading/trailing whitespace
 * trimmed. The type-specific content undergoes additional validation: text body
 * limited to 40,000 characters with markdown support, URLs validated for
 * HTTP/HTTPS protocol and maximum 2,000 characters, and images validated for
 * format, size, dimensions, and integrity.
 *
 * Related API operations include PATCH /posts for searching and retrieving
 * posts with filtering, GET /posts/{postId} for viewing individual post
 * details, PUT /posts/{postId} for editing post content within allowed time
 * windows, and DELETE /posts/{postId} for soft-deleting posts. Community
 * subscription status affects posting permissions and is validated through
 * reddit_like_community_subscriptions. The created post immediately becomes
 * available for voting through the reddit_like_post_votes table and commenting
 * through the reddit_like_comments table, contributing to the author's post
 * karma tracked in reddit_like_user_karma.
 *
 * @param props.connection
 * @param props.body Post creation data including community selection, post
 *   type, title, and type-specific content
 * @path /redditLike/moderator/posts
 * @accessor api.functional.redditLike.moderator.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Post creation data including community selection, post type, title,
     * and type-specific content
     */
    body: IRedditLikePost.ICreate;
  };
  export type Body = IRedditLikePost.ICreate;
  export type Response = IRedditLikePost;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/moderator/posts";
  export const random = (): IRedditLikePost => typia.random<IRedditLikePost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a post by ID from the reddit_like_posts table.
 *
 * Remove a specific post identified by its unique post ID as part of community
 * moderation responsibilities. When a moderator removes a post, the content is
 * hidden from public view while preserving the database record for audit
 * purposes and referential integrity. The removal marks the post as deleted,
 * making it invisible to community members while maintaining the record for
 * moderation review and appeal processes.
 *
 * This operation is available to three user roles with different authorization
 * contexts: the post author (member who created the post) can delete their own
 * content at any time as part of content ownership rights, community moderators
 * can remove posts within the communities they moderate as part of their
 * content moderation responsibilities, and platform administrators can delete
 * any post across all communities for platform-wide policy enforcement.
 *
 * When a post is removed by a moderator, the content is hidden from public view
 * and removed from community feeds, search results, and sorting algorithms. The
 * system displays a placeholder message 'This post has been removed by
 * moderators' to indicate moderator action rather than author deletion. The
 * post record remains in the database with all metadata intact including the
 * post ID, title, community association, author information, and timestamps,
 * enabling moderators to review the removal history and users to understand
 * moderation patterns.
 *
 * Associated comments remain accessible and visible to maintain thread
 * integrity and preserve valuable discussions. The comment section displays
 * with a notice indicating the parent post has been removed by moderators, but
 * all comment content, voting, and threading functionality continues to work
 * normally. This design ensures that community discussions are not lost when
 * posts are removed for moderation reasons, maintaining the value of user
 * contributions in comment threads.
 *
 * Vote scores and karma points previously earned from the deleted post are
 * preserved according to the karma system requirements defined in document
 * 07-karma-system.md section 4.4. This prevents users from manipulating their
 * reputation by creating content to gain karma and then deleting
 * poorly-received posts to avoid karma loss. The karma earned from a post
 * persists even after deletion, maintaining the integrity of the reputation
 * system.
 *
 * The deletion workflow requires the authenticated user making the request to
 * have appropriate authorization based on their role and relationship to the
 * content. Moderators must have moderator status for the specific community
 * where the post exists, verified through the reddit_like_community_moderators
 * table and community_id association in the reddit_like_posts record. The
 * system validates that the moderator has the manage_posts permission for the
 * target community before proceeding with the removal operation. Administrators
 * have unrestricted deletion capabilities across all communities.
 *
 * Related operations include POST /communities/{communityId}/posts for creating
 * posts that may later require moderation, GET /posts/{postId} for retrieving
 * post details before making removal decisions, the content reporting system
 * defined in Content Moderation and Reporting requirements for community
 * members to flag rule violations, and the moderation action logging system
 * that records all moderator removals with reasoning and context for
 * transparency and accountability.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post to be deleted
 * @path /redditLike/moderator/posts/:postId
 * @accessor api.functional.redditLike.moderator.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target post to be deleted */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/moderator/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a post from a community for rule violations.
 *
 * Remove a specific post from a community due to content policy violations or
 * community rule infractions. This operation is available to community
 * moderators within their assigned communities and to platform administrators
 * across all communities. The operation implements soft deletion by setting the
 * deleted_at timestamp on the reddit_like_posts record while preserving all
 * post data for audit trail and potential appeal processes.
 *
 * When a post is removed, the system creates detailed records in both
 * reddit_like_moderation_actions and reddit_like_moderation_logs tables to
 * maintain a comprehensive audit trail. The moderation action record captures
 * the removal type (community, platform, or spam), the reason category and
 * detailed explanation, and any internal notes for the moderation team. The
 * moderation log provides an immutable historical record of the removal event
 * with full context.
 *
 * Security and authorization are enforced at multiple levels. Moderators must
 * have the 'manage_posts' permission in the specific community where the post
 * exists. The system validates that the moderator's role assignments in
 * reddit_like_community_moderators table grant them authority over the target
 * community. Administrators bypass community-specific checks and can remove
 * posts platform-wide. The operation rejects requests from regular members
 * attempting to remove posts they don't own.
 *
 * The removal process immediately hides the post content from public feeds,
 * search results, and community listings by filtering based on the deleted_at
 * timestamp. However, the post structure, metadata, title, and community
 * association are preserved. All associated comments remain accessible with a
 * notice indicating the parent post was removed, maintaining discussion
 * continuity and preserving valuable community conversations. The post author
 * receives a notification within 5 minutes explaining which content was
 * removed, the stated reason, and information about the appeal process.
 *
 * Removal types determine the scope of content hiding. Community-level removals
 * hide content from the specific community but may remain visible in the
 * author's profile. Platform-level removals by administrators hide content from
 * all views due to platform-wide policy violations. Spam removals not only hide
 * the content but also reverse any karma earned from that content according to
 * anti-manipulation measures. The removal_type field in the request body
 * specifies which removal scope to apply.
 *
 * This operation integrates with the broader content moderation system defined
 * in the Content Moderation and Reporting requirements document. Removals can
 * be triggered either reactively (in response to content reports in
 * reddit_like_content_reports) or proactively by moderators. When removing
 * content in response to a report, the moderator provides the report_id to link
 * the action to the triggering report. The moderation action updates the report
 * status to 'reviewed' and creates the connection for tracking report
 * resolution metrics.
 *
 * The operation supports the appeal workflow by preserving all removed content
 * and maintaining detailed reasoning. Users can appeal removals through the
 * reddit_like_moderation_appeals table, referencing the moderation action
 * record created by this operation. Moderators and administrators reviewing
 * appeals have access to the complete context including the original removal
 * reason, internal notes, and content state at time of removal.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be removed
 * @param props.body Details about the post removal including reason category,
 *   explanation text, removal scope, and optional report reference
 * @path /redditLike/moderator/posts/:postId/remove
 * @accessor api.functional.redditLike.moderator.posts.remove
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function remove(
  connection: IConnection,
  props: remove.Props,
): Promise<void> {
  return true === connection.simulate
    ? remove.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...remove.METADATA,
          path: remove.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace remove {
  export type Props = {
    /** Unique identifier of the post to be removed */
    postId: string & tags.Format<"uuid">;

    /**
     * Details about the post removal including reason category, explanation
     * text, removal scope, and optional report reference
     */
    body: IRedditLikePost.IRemove;
  };
  export type Body = IRedditLikePost.IRemove;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/posts/:postId/remove",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/moderator/posts/${encodeURIComponent(props.postId ?? "null")}/remove`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: remove.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: remove.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore a soft-deleted post to make it visible again.
 *
 * Restores a previously soft-deleted post by clearing its deleted_at timestamp,
 * making the post visible again in the community platform. This operation is
 * essential for recovering posts that were deleted by mistake or removed during
 * moderation but later approved through appeals.
 *
 * When a post is deleted in the platform, it undergoes soft deletion where the
 * deleted_at timestamp is set but the post data remains in the
 * reddit_like_posts table along with all associated content in type-specific
 * tables (reddit_like_post_text_content, reddit_like_post_link_content, or
 * reddit_like_post_image_content). Soft deletion preserves the post structure,
 * comments, votes, and karma attribution while hiding the content from public
 * view.
 *
 * This restoration endpoint reverses the soft deletion by clearing the
 * deleted_at field, immediately making the post visible in community feeds,
 * user profiles, and search results. All previously earned karma from the post
 * remains intact per business requirements, and the post's engagement metrics
 * (votes, comments) are preserved.
 *
 * Authorization for post restoration depends on the context: post authors can
 * restore their own deleted posts, community moderators can restore posts
 * removed as part of moderation actions in their communities, and platform
 * administrators can restore any post platform-wide. The operation validates
 * that the requesting user has appropriate permissions before executing the
 * restoration.
 *
 * The restored post retains all its original metadata including creation
 * timestamp, vote scores, comment count, and karma attribution. The post
 * immediately appears in sorted feeds according to its original creation time
 * and current vote score, not the restoration time. This ensures restored
 * content integrates naturally into the existing content chronology rather than
 * appearing artificially recent.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the soft-deleted post to restore
 * @path /redditLike/moderator/posts/:postId/restore
 * @accessor api.functional.redditLike.moderator.posts.restore
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function restore(
  connection: IConnection,
  props: restore.Props,
): Promise<restore.Response> {
  return true === connection.simulate
    ? restore.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...restore.METADATA,
          path: restore.path(props),
          status: null,
        },
      );
}
export namespace restore {
  export type Props = {
    /** Unique identifier of the soft-deleted post to restore */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikePost;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/moderator/posts/:postId/restore",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/posts/${encodeURIComponent(props.postId ?? "null")}/restore`;
  export const random = (): IRedditLikePost => typia.random<IRedditLikePost>();
  export const simulate = (
    connection: IConnection,
    props: restore.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: restore.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
