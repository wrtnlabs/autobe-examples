import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeContentReport } from "../../../../structures/IRedditLikeContentReport";
import { IPageIRedditLikeContentReport } from "../../../../structures/IPageIRedditLikeContentReport";

/**
 * Retrieve filtered list of content reports for moderation queue.
 *
 * Retrieves a filtered and paginated list of content reports submitted by users
 * for moderator and administrator review. This operation provides the primary
 * interface for the moderation queue, enabling moderators to efficiently
 * process reports of potentially rule-violating content.
 *
 * The operation supports comprehensive filtering and search capabilities to
 * help moderators manage large volumes of reports effectively. Moderators can
 * filter by report status (pending review, already reviewed, or dismissed),
 * violation category (spam, harassment, hate speech, etc.), specific community,
 * content type (posts vs comments), priority level (high-priority reports
 * flagged by the system), and date ranges. Multiple filters can be combined to
 * narrow down the queue to specific subsets of reports requiring attention.
 *
 * Access control ensures moderators only see reports for communities where they
 * have moderation permissions, while platform administrators have visibility
 * into all reports across the entire platform. This scoped access prevents
 * unauthorized review of reports outside a moderator's jurisdiction while
 * enabling centralized oversight by administrators.
 *
 * The response includes detailed report information for each item in the queue:
 * the reported content preview, content author details, violation categories
 * selected by reporters, number of reports for the same content, submission
 * timestamps, and current review status. When multiple users report the same
 * content, these reports are grouped together with a count indicator to signal
 * widespread community concern.
 *
 * The operation supports sorting by various criteria including submission time
 * (newest or oldest first), priority level (high-priority reports first), and
 * report count (most-reported content first). Pagination enables efficient
 * loading of large report queues without performance degradation. The default
 * sort order presents newest reports first to ensure timely review of fresh
 * submissions.
 *
 * This operation integrates with the broader moderation workflow by providing
 * the entry point where moderators access reports before taking actions such as
 * content removal, user bans, or report dismissal. The queue interface helps
 * moderators meet expected review timeframes and maintain community standards
 * through efficient report processing.
 *
 * @param props.connection
 * @param props.body Search criteria and filters for content reports including
 *   status, violation categories, community, priority level, and pagination
 *   parameters
 * @path /redditLike/moderator/content-reports
 * @accessor api.functional.redditLike.moderator.content_reports.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and filters for content reports including status,
     * violation categories, community, priority level, and pagination
     * parameters
     */
    body: IRedditLikeContentReport.IRequest;
  };
  export type Body = IRedditLikeContentReport.IRequest;
  export type Response = IPageIRedditLikeContentReport;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/moderator/content-reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/moderator/content-reports";
  export const random = (): IPageIRedditLikeContentReport =>
    typia.random<IPageIRedditLikeContentReport>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific content report.
 *
 * Retrieve comprehensive details for a specific content report identified by
 * its unique report ID. This operation provides moderators and administrators
 * with all information necessary to review and act on user-submitted reports of
 * potentially inappropriate content.
 *
 * The operation returns complete report information including the type of
 * content being reported (post or comment), the violation categories selected
 * by the reporter, any additional context provided, the current review status,
 * and metadata about when the report was submitted. For authenticated
 * reporters, the system includes the reporter's username to help moderators
 * assess report credibility. For anonymous guest reports, the reporter is
 * identified as 'Anonymous'.
 *
 * This endpoint integrates with the content moderation workflow defined in the
 * Content Moderation and Reporting requirements document. The retrieved report
 * information enables moderators to make informed decisions about whether to
 * remove content, dismiss reports as false positives, ban users, or escalate to
 * administrators. The response includes references to the reported content
 * (post ID or comment ID) allowing moderators to view the content in context
 * before taking action.
 *
 * Security considerations include restricting access to moderators and
 * administrators only, as content reports contain sensitive information about
 * reporters and reported users. The system enforces role-based access control
 * ensuring moderators can only access reports for communities they moderate,
 * while administrators have platform-wide report access.
 *
 * This operation supports the moderator review queue functionality by providing
 * the detailed view when moderators click on queue items to investigate reports
 * thoroughly. The comprehensive report details enable fair and informed
 * moderation decisions that balance community safety with user rights.
 *
 * @param props.connection
 * @param props.reportId Unique identifier of the content report to retrieve
 * @path /redditLike/moderator/content-reports/:reportId
 * @accessor api.functional.redditLike.moderator.content_reports.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the content report to retrieve */
    reportId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeContentReport;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/moderator/content-reports/:reportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/content-reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): IRedditLikeContentReport =>
    typia.random<IRedditLikeContentReport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportId")(() => typia.assert(props.reportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
