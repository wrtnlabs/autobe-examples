import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerationLog } from "../../../../../structures/IRedditLikeModerationLog";
import { IPageIRedditLikeModerationLog } from "../../../../../structures/IPageIRedditLikeModerationLog";

/**
 * Search and retrieve filtered moderation log entries with pagination and
 * advanced filtering.
 *
 * Retrieve a filtered and paginated list of moderation log entries from the
 * comprehensive audit trail system. This operation provides access to the
 * reddit_like_moderation_logs table, which records all moderation system
 * activities including report submissions, moderation actions, ban issuances,
 * appeal submissions, and appeal decisions.
 *
 * The moderation logs serve as a permanent, immutable audit trail for
 * accountability, transparency, and legal compliance per requirements R-LOG-001
 * through R-LOG-005. Each log entry captures complete context including the
 * actor who performed the action (member, moderator, or admin), the related
 * moderation entities (reports, actions, bans, suspensions, appeals), the
 * community context, event type, human-readable action description, and precise
 * timestamp with second precision.
 *
 * This operation supports comprehensive filtering and search capabilities to
 * help moderators and administrators efficiently find relevant log entries.
 * Filters include log type (report_submitted, action_taken, ban_issued, etc.),
 * actor role (member, moderator, admin), community context, time ranges, and
 * full-text search within action descriptions and metadata. The search
 * functionality uses the GIN trigram index on action_description for efficient
 * text matching.
 *
 * Access control enforces requirement R-LOG-008 allowing moderators to view
 * logs only for communities they moderate, while requirement R-LOG-009 grants
 * administrators access to complete platform-wide moderation history. The
 * system filters results based on the authenticated user's role and community
 * moderation assignments, ensuring proper data access boundaries.
 *
 * The operation returns paginated results with sorting options by timestamp
 * (newest first by default per R-LOG-010), log type, or community. Each log
 * entry includes comprehensive details about the moderation event, references
 * to related entities (with IDs for further lookup), and metadata context. The
 * pagination structure supports efficient browsing of large log datasets while
 * maintaining query performance through proper indexing on log_type,
 * created_at, actor IDs, and community_id.
 *
 * This operation integrates with the broader moderation system, providing
 * transparency into moderation decisions and enabling pattern analysis for
 * improving moderation effectiveness. The logs support moderator
 * accountability, user transparency (through public moderation logs per
 * R-LOG-015 through R-LOG-018), and administrative oversight of moderation
 * practices across the platform.
 *
 * @param props.connection
 * @param props.body Search criteria and filters for retrieving moderation log
 *   entries including log type, actor filters, community scope, time ranges,
 *   text search, and pagination parameters
 * @path /redditLike/moderator/moderation/logs
 * @accessor api.functional.redditLike.moderator.moderation.logs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and filters for retrieving moderation log entries
     * including log type, actor filters, community scope, time ranges, text
     * search, and pagination parameters
     */
    body: IRedditLikeModerationLog.IRequest;
  };
  export type Body = IRedditLikeModerationLog.IRequest;
  export type Response = IPageIRedditLikeModerationLog;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/moderator/moderation/logs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/moderator/moderation/logs";
  export const random = (): IPageIRedditLikeModerationLog =>
    typia.random<IPageIRedditLikeModerationLog>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific moderation log entry by ID.
 *
 * Retrieve detailed information about a specific moderation log entry from the
 * platform's comprehensive audit trail. This operation returns complete details
 * of a single moderation event including the type of action performed, who
 * performed it (member, moderator, or administrator), what content or user was
 * affected, associated reports or appeals, community context, and full event
 * metadata.
 *
 * Moderation logs serve as the immutable historical record of all moderation
 * system activities on the platform. They provide accountability, transparency,
 * and audit capabilities for content reports, moderator actions, community
 * bans, platform suspensions, and appeal decisions. Each log entry captures a
 * snapshot of a moderation event with complete context preserved for legal
 * compliance and dispute resolution.
 *
 * This operation integrates with the reddit_like_moderation_logs table as
 * defined in the Prisma schema. The table maintains permanent records with
 * foreign key references to related entities including content reports,
 * moderation actions, community bans, platform suspensions, appeals, and the
 * communities where events occurred. The logs track the actor who performed
 * each action (which can be a member submitting a report, a moderator taking
 * action, or an administrator making decisions), along with IP addresses for
 * security auditing.
 *
 * Security considerations include role-based access control where moderators
 * can view logs for their assigned communities while administrators have
 * platform-wide log access. The operation returns complete log details
 * including internal notes and metadata that may contain sensitive moderation
 * context, so proper authorization verification is critical.
 *
 * The log entry includes comprehensive event information such as log type
 * categorization (report_submitted, action_taken, ban_issued, etc.),
 * human-readable action descriptions, JSON metadata with event-specific
 * details, and references to all related moderation entities. This enables full
 * reconstruction of moderation event timelines and provides the transparency
 * needed for user appeals and administrative oversight.
 *
 * @param props.connection
 * @param props.logId Unique identifier of the moderation log entry to retrieve
 * @path /redditLike/moderator/moderation/logs/:logId
 * @accessor api.functional.redditLike.moderator.moderation.logs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the moderation log entry to retrieve */
    logId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeModerationLog;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/moderator/moderation/logs/:logId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/moderator/moderation/logs/${encodeURIComponent(props.logId ?? "null")}`;
  export const random = (): IRedditLikeModerationLog =>
    typia.random<IRedditLikeModerationLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("logId")(() => typia.assert(props.logId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
