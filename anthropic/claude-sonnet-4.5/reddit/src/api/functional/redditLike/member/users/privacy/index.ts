import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeUser } from "../../../../../structures/IRedditLikeUser";

/**
 * Retrieve user privacy settings and preferences.
 *
 * Retrieve the complete privacy settings for a user account, including profile
 * visibility preferences, karma display settings, and subscription list privacy
 * controls. This operation accesses the reddit_like_users table to return the
 * user's current privacy configuration as defined in the business
 * requirements.
 *
 * The privacy settings control multiple aspects of profile visibility as
 * specified in the User Profiles and Feeds requirements document. Users can
 * configure whether their profile is public (visible to all including guests),
 * members_only (authenticated users only), or private (only visible to
 * themselves). Additionally, users control whether their karma scores are
 * publicly displayed and whether their community subscription list is visible
 * to others.
 *
 * Security considerations include ensuring that users can only retrieve their
 * own privacy settings unless they have administrative privileges. The
 * operation validates that the authenticated user matches the userId path
 * parameter to prevent unauthorized access to privacy configuration.
 * Administrators may access privacy settings for any user for support and
 * moderation purposes.
 *
 * This operation integrates with the profile display system, where privacy
 * settings determine what information is shown to different user types. The
 * settings directly impact profile visibility, karma display, and subscription
 * list access as defined in section 9 of the User Profiles and Feeds
 * requirements. The operation returns the current privacy state without
 * exposing sensitive account information beyond privacy preferences.
 *
 * The privacy settings returned by this operation inform the frontend
 * application how to render privacy controls and help users understand their
 * current visibility settings. Users typically access this operation when
 * reviewing or preparing to modify their privacy preferences through the
 * account settings interface.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose privacy settings are
 *   being retrieved
 * @path /redditLike/member/users/:userId/privacy
 * @accessor api.functional.redditLike.member.users.privacy.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the user whose privacy settings are being
     * retrieved
     */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeUser.IPrivacySettings;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/member/users/:userId/privacy",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/users/${encodeURIComponent(props.userId ?? "null")}/privacy`;
  export const random = (): IRedditLikeUser.IPrivacySettings =>
    typia.random<IRedditLikeUser.IPrivacySettings>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update user privacy settings controlling profile visibility, subscription
 * list, and karma display.
 *
 * Update the privacy settings for an authenticated user's profile, enabling
 * control over public visibility of profile information, community
 * subscriptions, and karma scores. This operation modifies the
 * reddit_like_users table fields that govern privacy: profile_privacy
 * (determines overall profile visibility level), show_subscriptions_publicly
 * (controls subscription list visibility), and show_karma_publicly (controls
 * karma score display).
 *
 * The profile_privacy field supports three visibility levels defined in the
 * requirements: 'public' (visible to all users including guests),
 * 'members_only' (visible only to authenticated members), and 'private'
 * (visible only to the profile owner). The show_subscriptions_publicly field
 * controls whether the user's community subscription list is visible to others,
 * independent of overall profile privacy. The show_karma_publicly field
 * determines whether post karma and comment karma scores are displayed on the
 * user's profile.
 *
 * This operation implements the privacy control requirements from the User
 * Profiles and Feeds specification sections 10.1-10.4, ensuring users have
 * granular control over their information visibility. When privacy settings are
 * updated, the changes apply immediately to the public profile view, affecting
 * how other users (both authenticated and guest) see the profile information.
 *
 * Security considerations include verifying that only the profile owner can
 * modify their own privacy settings. The operation requires authentication and
 * validates that the authenticated user's ID matches the userId path parameter.
 * Unauthorized attempts to modify other users' privacy settings are rejected
 * with appropriate error responses.
 *
 * The operation integrates with the user profile display system to ensure
 * privacy settings are respected when profiles are viewed. Changes to
 * profile_privacy immediately affect profile accessibility, changes to
 * show_subscriptions_publicly affect subscription list visibility, and changes
 * to show_karma_publicly affect karma display in all contexts where the user's
 * karma appears.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose privacy settings are
 *   being updated
 * @param props.body Updated privacy settings including profile visibility
 *   level, subscription list visibility, and karma display preferences
 * @path /redditLike/member/users/:userId/privacy
 * @accessor api.functional.redditLike.member.users.privacy.updatePrivacy
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updatePrivacy(
  connection: IConnection,
  props: updatePrivacy.Props,
): Promise<updatePrivacy.Response> {
  return true === connection.simulate
    ? updatePrivacy.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updatePrivacy.METADATA,
          path: updatePrivacy.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updatePrivacy {
  export type Props = {
    /**
     * Unique identifier of the user whose privacy settings are being
     * updated
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Updated privacy settings including profile visibility level,
     * subscription list visibility, and karma display preferences
     */
    body: IRedditLikeUser.IUpdatePrivacy;
  };
  export type Body = IRedditLikeUser.IUpdatePrivacy;
  export type Response = IRedditLikeUser.IPrivacySettings;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/member/users/:userId/privacy",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/member/users/${encodeURIComponent(props.userId ?? "null")}/privacy`;
  export const random = (): IRedditLikeUser.IPrivacySettings =>
    typia.random<IRedditLikeUser.IPrivacySettings>();
  export const simulate = (
    connection: IConnection,
    props: updatePrivacy.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updatePrivacy.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
