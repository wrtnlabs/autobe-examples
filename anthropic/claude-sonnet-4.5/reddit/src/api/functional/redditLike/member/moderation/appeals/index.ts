import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerationAppeal } from "../../../../../structures/IRedditLikeModerationAppeal";
import { IPageIRedditLikeModerationAppeal } from "../../../../../structures/IPageIRedditLikeModerationAppeal";
export * as escalate from "./escalate/index";

/**
 * Submit a new appeal challenging a moderation action, community ban, or
 * platform suspension.
 *
 * Create a new moderation appeal allowing users to contest decisions made by
 * moderators or administrators. This operation implements the platform's due
 * process system as defined in the Content Moderation and Reporting
 * requirements section 8.
 *
 * When a user submits an appeal, they must provide written reasoning explaining
 * why they believe the moderation action should be reversed. The appeal text
 * must be between 50 and 1000 characters per business requirements R-APP-006,
 * ensuring sufficient detail while preventing excessive submissions. Users must
 * identify what they are appealing (content removal, community ban, or platform
 * suspension) through the appeal_type field.
 *
 * The system validates that the user is the affected party for the moderation
 * action being appealed. For content removals, the user must be the content
 * author. For community bans, the user must be the banned member. For platform
 * suspensions, the user must be the suspended account. This prevents users from
 * appealing actions that don't affect them.
 *
 * Appeals are routed based on the action type per requirements R-APP-011 and
 * R-APP-012. Community-level appeals (content removals, community bans) are
 * sent to the community's moderator review queue. Platform suspension appeals
 * are routed to the administrator review queue. The routing ensures the
 * appropriate authority level reviews each appeal type.
 *
 * The system enforces the one appeal per action rule specified in requirements
 * R-APP-002 and R-APP-003. Users cannot submit multiple appeals for the same
 * moderation action, preventing appeal spam and ensuring efficient review
 * processes. If a user has already appealed a specific action, subsequent
 * appeal attempts are rejected.
 *
 * Upon successful submission, the appeal is marked with status 'pending' and
 * assigned an expected resolution timestamp calculated based on appeal type.
 * Community appeals target 2-3 day review, platform suspensions target 5-7
 * days, and escalated appeals target 7-10 days per requirement R-APP-029. These
 * expected timeframes enable SLA monitoring and automated reminder
 * notifications.
 *
 * The content author receives immediate confirmation of appeal submission per
 * requirement R-APP-009, including the expected review timeframe and
 * information about the review process. The appeal enters the moderation queue
 * where moderators or administrators can review, approve, deny, or reduce
 * penalties.
 *
 * This operation integrates with the reddit_like_moderation_appeals table to
 * persist appeal data, the reddit_like_moderation_logs table to create audit
 * trail entries, and the notification system to alert review queues and provide
 * status updates to appellants. Security considerations include validating that
 * the requesting user has permission to appeal the specific action and
 * preventing abuse through rate limiting on appeal submissions.
 *
 * @param props.connection
 * @param props.body Appeal submission data including the action being appealed,
 *   appeal type, and user's written reasoning
 * @path /redditLike/member/moderation/appeals
 * @accessor api.functional.redditLike.member.moderation.appeals.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Appeal submission data including the action being appealed, appeal
     * type, and user's written reasoning
     */
    body: IRedditLikeModerationAppeal.ICreate;
  };
  export type Body = IRedditLikeModerationAppeal.ICreate;
  export type Response = IRedditLikeModerationAppeal;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/moderation/appeals",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/member/moderation/appeals";
  export const random = (): IRedditLikeModerationAppeal =>
    typia.random<IRedditLikeModerationAppeal>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of moderation appeals based on
 * user permissions.
 *
 * Retrieve moderation appeals with advanced filtering, sorting, and pagination
 * capabilities. This operation provides role-specific access to appeals based
 * on the requesting user's authorization level and implements the appeal review
 * queue functionality defined in Content Moderation requirements section 8.3.
 *
 * For members (regular authenticated users), this operation returns only
 * appeals they have personally submitted. Members can view their appeal
 * history, track the status of pending appeals, and review decisions made on
 * their past appeals. This enables users to monitor their own due process
 * interactions without accessing other users' appeals. The filtering is
 * automatically scoped to appellant_member_id matching the authenticated user's
 * ID.
 *
 * For moderators, this operation returns appeals related to communities they
 * moderate. Moderators see appeals challenging actions taken in their
 * communities, including content removal appeals and community ban appeals per
 * requirement R-APP-011. The system filters results to only show appeals where
 * the community_id (inferred from the moderation action being appealed) matches
 * communities where the moderator has active moderator status. This ensures
 * moderators only access appeals within their moderation scope.
 *
 * For administrators, this operation returns all appeals across the entire
 * platform. Administrators can view community-level appeals, escalated appeals,
 * and platform suspension appeals per requirement R-APP-012. No community
 * filtering is applied for admin users, enabling platform-wide appeal oversight
 * and the ability to review escalated cases that moderators couldn't resolve.
 *
 * The operation supports comprehensive filtering capabilities to help reviewers
 * manage appeal queues efficiently. Filter options include appeal status
 * (pending, under_review, upheld, overturned, reduced), appeal type
 * (content_removal, community_ban, platform_suspension), submission date
 * ranges, escalation status, and expected resolution timeframes. These filters
 * enable moderators and administrators to prioritize urgent appeals, identify
 * overdue reviews per requirement R-APP-030, and organize their review
 * workflows.
 *
 * Sorting options include submission time (newest or oldest first), expected
 * resolution date (most urgent first), appeal type, and status. The default
 * sorting shows pending appeals ordered by expected resolution date to surface
 * the most time-sensitive reviews first. This aligns with the SLA monitoring
 * requirements and helps ensure timely appeal resolution.
 *
 * Pagination parameters allow control over page size and navigation through
 * large appeal datasets. The response includes total appeal counts, current
 * page information, and pagination metadata to support efficient queue
 * browsing. For moderators managing active communities and administrators
 * handling platform-wide appeals, pagination prevents overwhelming data loads
 * while maintaining comprehensive access.
 *
 * The operation integrates with the reddit_like_moderation_appeals table for
 * appeal data retrieval, joins with reddit_like_moderation_actions,
 * reddit_like_community_bans, and reddit_like_platform_suspensions tables to
 * provide complete appeal context, and enforces row-level security based on
 * user roles to ensure proper access control. Performance optimizations include
 * indexed queries on status and expected_resolution_at fields to support fast
 * filtering and sorting.
 *
 * Security considerations include strict role-based access control enforced at
 * the database query level, validation that moderators only access appeals for
 * their assigned communities, prevention of unauthorized access to other users'
 * appeal data, and audit logging of all appeal list accesses for security
 * monitoring. The operation also implements rate limiting to prevent abuse of
 * the search functionality.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, sorting preferences, and
 *   pagination parameters for retrieving moderation appeals
 * @path /redditLike/member/moderation/appeals
 * @accessor api.functional.redditLike.member.moderation.appeals.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, sorting preferences, and pagination
     * parameters for retrieving moderation appeals
     */
    body: IRedditLikeModerationAppeal.IRequest;
  };
  export type Body = IRedditLikeModerationAppeal.IRequest;
  export type Response = IPageIRedditLikeModerationAppeal;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/member/moderation/appeals",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/member/moderation/appeals";
  export const random = (): IPageIRedditLikeModerationAppeal =>
    typia.random<IPageIRedditLikeModerationAppeal>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
