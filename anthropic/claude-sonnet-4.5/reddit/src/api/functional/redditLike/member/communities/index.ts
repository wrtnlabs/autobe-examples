import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunity } from "../../../../structures/IRedditLikeCommunity";
export * as subscribe from "./subscribe/index";
export * as posts from "./posts/index";

/**
 * Create a new community with the authenticated member as primary moderator.
 *
 * This operation enables authenticated members to create new communities
 * (analogous to subreddits) where users can gather around shared interests and
 * topics. Communities serve as the foundational organizational structure of the
 * platform, with each community having its own rules, moderators, and
 * subscriber base.
 *
 * When a member creates a community, they provide required information
 * including a unique community identifier (code), display name, and description
 * explaining the community's purpose. The creator can optionally configure
 * additional settings such as privacy type (public or private), posting
 * permissions (who can create posts), allowed post types (text, link, image),
 * category classification, and visual branding (icon and banner images).
 *
 * The system validates that the community code is globally unique
 * (case-insensitive) and meets format requirements (3-25 characters,
 * alphanumeric and underscores only). The description must be between 10-500
 * characters and clearly explain the community's purpose. Per business
 * requirements, members are limited to creating 3 communities per day to
 * prevent abuse.
 *
 * Upon successful creation, the system automatically assigns the creator as the
 * primary moderator with irrevocable full permissions for managing the
 * community. The new community is initialized with default settings (public,
 * anyone subscribed can post, all post types allowed) unless custom values are
 * provided. The subscriber count starts at zero.
 *
 * Security considerations include enforcing the daily creation limit,
 * validating community names against a blacklist of prohibited terms, and
 * preventing names that impersonate platform entities. The operation integrates
 * with the community management system defined in the requirements and
 * establishes the foundation for community-specific content, subscriptions, and
 * moderation workflows.
 *
 * This operation is essential for platform growth as it enables distributed
 * community creation by members, allowing the platform to scale organically
 * through user-driven community formation around diverse interests and topics.
 *
 * @param props.connection
 * @param props.body Community creation data including unique identifier, name,
 *   description, privacy settings, posting permissions, allowed post types,
 *   category, and optional branding
 * @path /redditLike/member/communities
 * @accessor api.functional.redditLike.member.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Community creation data including unique identifier, name,
     * description, privacy settings, posting permissions, allowed post
     * types, category, and optional branding
     */
    body: IRedditLikeCommunity.ICreate;
  };
  export type Body = IRedditLikeCommunity.ICreate;
  export type Response = IRedditLikeCommunity;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/member/communities";
  export const random = (): IRedditLikeCommunity =>
    typia.random<IRedditLikeCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Unsubscribe authenticated member from a specific community.
 *
 * Removes the subscription relationship between the currently authenticated
 * member and the specified community, as defined in the Community Management
 * Requirements section 4.3. This operation decrements the community's
 * subscriber count and immediately updates the member's personalized feed to
 * exclude posts from this community.
 *
 * When a member unsubscribes from a community, the system performs several
 * coordinated actions: First, it removes the corresponding record from the
 * reddit_like_community_subscriptions table. Second, it decrements the
 * subscriber_count field in the reddit_like_communities table by 1 to maintain
 * accurate subscription metrics. Third, it updates the member's personalized
 * home feed composition to stop including posts from the unsubscribed
 * community, as specified in the User Profiles and Feeds Requirements.
 *
 * The operation validates that the member is currently subscribed to the
 * specified community before processing the unsubscription. If the member is
 * not subscribed, the system handles this gracefully as an idempotent
 * operation, returning success without making changes. The visual feedback
 * requirement from section 4.3 states that the system must provide immediate
 * visual confirmation within 200 milliseconds of the unsubscription action.
 *
 * This operation integrates with the subscription management system defined in
 * section 4 of the Community Management Requirements. Per section 4.2, the
 * unsubscription can be initiated from multiple access points including the
 * community page, the user's subscription management page, or the sidebar of
 * the home feed. The operation enforces authentication requirements - only
 * authenticated members can unsubscribe from communities.
 *
 * The subscriber count denormalization in the reddit_like_communities table is
 * updated synchronously to ensure consistency. The feed composition changes are
 * applied immediately, with the requirement that posts from the unsubscribed
 * community stop appearing in the member's feed within 60 seconds as specified
 * in the subscription workflow requirements.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community from which the
 *   member wishes to unsubscribe
 * @path /redditLike/member/communities/:communityId/unsubscribe
 * @accessor api.functional.redditLike.member.communities.unsubscribe
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function unsubscribe(
  connection: IConnection,
  props: unsubscribe.Props,
): Promise<void> {
  return true === connection.simulate
    ? unsubscribe.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...unsubscribe.METADATA,
          path: unsubscribe.path(props),
          status: null,
        },
      );
}
export namespace unsubscribe {
  export type Props = {
    /**
     * Unique identifier of the community from which the member wishes to
     * unsubscribe
     */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/communities/:communityId/unsubscribe",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/communities/${encodeURIComponent(props.communityId ?? "null")}/unsubscribe`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: unsubscribe.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: unsubscribe.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
