import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeUser } from "../../../../../structures/IRedditLikeUser";
import { IRedditLikeCommunitySubscription } from "../../../../../structures/IRedditLikeCommunitySubscription";

/**
 * Subscribe user to a community.
 *
 * Create a new subscription relationship between a user and a community,
 * enabling the user to receive content from that community in their
 * personalized feed. This operation implements the community subscription
 * workflow defined in the Community Management requirements document section
 * 4.2.
 *
 * The operation validates several prerequisites before creating the
 * subscription. First, it verifies that the target community exists in the
 * reddit_like_communities table and is not soft-deleted or archived. Second, it
 * checks whether the user is already subscribed to prevent duplicate
 * subscription records, enforcing the unique constraint on (community_id,
 * member_id) in reddit_like_community_subscriptions.
 *
 * For public communities (privacy_type='public'), subscription is immediate and
 * automatic. For private communities (privacy_type='private'), this operation
 * initiates a join request workflow rather than creating an immediate
 * subscription. Private community subscriptions require moderator approval
 * before the subscription record is created, as specified in Community
 * Management requirements section 8.2.
 *
 * When a valid subscription is created, the operation performs several actions
 * atomically: creates the reddit_like_community_subscriptions record with
 * current timestamp as subscribed_at, increments the subscriber_count field in
 * reddit_like_communities by 1, and triggers feed composition updates to
 * immediately include posts from the newly subscribed community in the user's
 * personalized home feed.
 *
 * Security and authorization checks ensure that the requesting user matches the
 * userId path parameter, preventing users from creating subscriptions on behalf
 * of other users. The operation verifies the user is authenticated as a member,
 * moderator, or admin, denying access to guest users per User Roles and
 * Authentication requirements section on subscription permissions.
 *
 * The operation integrates with the personalized feed system defined in User
 * Profiles and Feeds requirements document section 9, where new subscriptions
 * immediately affect feed composition. Posts from the subscribed community
 * begin appearing in the user's home feed sorted by the user's preferred
 * algorithm (hot, new, top, or controversial).
 *
 * Response includes the complete created subscription record with community
 * details, enabling the UI to immediately reflect the subscription state change
 * without requiring a separate fetch. The response provides confirmation of
 * subscription success, the subscription timestamp, and updated subscriber
 * count for the community.
 *
 * Error scenarios include attempting to subscribe to non-existent communities,
 * duplicate subscription attempts (returns existing subscription), subscribing
 * to archived communities (rejected with explanation), and private community
 * subscription requests (returns pending request status instead of completed
 * subscription).
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who is subscribing to the
 *   community
 * @param props.body Community subscription creation data including the target
 *   community identifier to subscribe to
 * @path /redditLike/member/users/:userId/subscriptions
 * @accessor api.functional.redditLike.member.users.subscriptions.subscribe
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function subscribe(
  connection: IConnection,
  props: subscribe.Props,
): Promise<subscribe.Response> {
  return true === connection.simulate
    ? subscribe.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...subscribe.METADATA,
          path: subscribe.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace subscribe {
  export type Props = {
    /** Unique identifier of the user who is subscribing to the community */
    userId: string & tags.Format<"uuid">;

    /**
     * Community subscription creation data including the target community
     * identifier to subscribe to
     */
    body: IRedditLikeUser.ISubscriptionCreate;
  };
  export type Body = IRedditLikeUser.ISubscriptionCreate;
  export type Response = IRedditLikeCommunitySubscription;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/users/:userId/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/member/users/${encodeURIComponent(props.userId ?? "null")}/subscriptions`;
  export const random = (): IRedditLikeCommunitySubscription =>
    typia.random<IRedditLikeCommunitySubscription>();
  export const simulate = (
    connection: IConnection,
    props: subscribe.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: subscribe.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Unsubscribe a user from a specific community.
 *
 * Remove a user's subscription to a community, allowing them to curate their
 * content feed by unsubscribing from communities they no longer wish to follow.
 * This operation deletes the corresponding record from the
 * reddit_like_community_subscriptions table, immediately removing posts from
 * that community from the user's personalized home feed.
 *
 * When a subscription is successfully removed, the system decrements the
 * community's subscriber_count by 1 to maintain accurate community metrics. The
 * unsubscribe action is immediate and does not require confirmation, providing
 * a frictionless user experience for managing community memberships.
 *
 * Security considerations include verifying that the authenticated user matches
 * the userId path parameter to prevent unauthorized subscription management.
 * Users can only manage their own subscriptions, not those of other users. The
 * operation validates that the subscription exists before attempting deletion
 * and handles cases where the user is not subscribed gracefully.
 *
 * This operation integrates with the personalized feed system defined in the
 * User Profiles and Feeds requirements, immediately affecting what content the
 * user sees in their home feed. The subscription removal is permanent until the
 * user chooses to re-subscribe to the community.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who is unsubscribing from
 *   the community
 * @param props.communityId Unique identifier of the community from which the
 *   user is unsubscribing
 * @path /redditLike/member/users/:userId/subscriptions/:communityId
 * @accessor api.functional.redditLike.member.users.subscriptions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the user who is unsubscribing from the community */
    userId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the community from which the user is
     * unsubscribing
     */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/member/users/:userId/subscriptions/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/users/${encodeURIComponent(props.userId ?? "null")}/subscriptions/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
