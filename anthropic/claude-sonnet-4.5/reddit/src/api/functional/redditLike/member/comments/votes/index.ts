import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommentVote } from "../../../../../structures/IRedditLikeCommentVote";
export * as me from "./me/index";

/**
 * Cast or modify a vote on a specific comment.
 *
 * Submit a vote on a specific comment identified by the comment ID path
 * parameter. This operation enables authenticated users to upvote (positive
 * endorsement) or downvote (negative signal) comments as part of the democratic
 * content curation system defined in the Voting System Requirements.
 *
 * The operation accepts a request body specifying the vote direction: upvote
 * (+1) or downvote (-1). When a user submits a vote, the system processes it
 * according to the vote state transition rules defined in the Voting System
 * specification. If the user has not previously voted on this comment, a new
 * vote record is created in the reddit_like_comment_votes table. If the user
 * has previously voted, the operation updates the existing vote record,
 * handling all vote change scenarios: upvote to downvote, downvote to upvote,
 * or vote removal.
 *
 * Vote processing includes several critical business rules enforced at the
 * application level. The system prevents self-voting by validating that the
 * authenticated user is not the comment author. The operation updates the
 * comment's vote_score field in the reddit_like_comments table, incrementing by
 * 1 for upvotes and decrementing by 1 for downvotes. Vote changes result in
 * score adjustments of +2 or -2 to account for both removing the previous vote
 * and applying the new vote.
 *
 * This operation integrates with the karma system defined in the Karma System
 * Requirements. When a comment receives a vote, the comment author's
 * comment_karma is updated in real-time, affecting their total karma score
 * displayed on their profile. The system records karma changes in the
 * reddit_like_karma_history table for audit trail and transparency.
 *
 * Anti-manipulation measures defined in the Voting System Requirements section
 * 8 are enforced during vote processing. The operation records the voter's IP
 * address and user agent in the reddit_like_comment_votes table for detecting
 * coordinated voting, multiple account abuse, and vote brigading patterns. The
 * system may apply vote weight adjustments based on account trust factors, with
 * new accounts or suspicious voting patterns receiving reduced vote impact.
 *
 * Security considerations include validating that the comment exists and is
 * accessible, preventing votes on deleted comments (where deleted_at is not
 * null in reddit_like_comments table), and enforcing rate limiting to prevent
 * vote manipulation. The operation completes within 2 seconds per performance
 * requirements, with optimistic UI updates providing immediate visual feedback
 * while background processing completes.
 *
 * The response includes the updated vote state, current vote score for the
 * comment, and confirmation of successful vote registration. This enables the
 * client application to immediately update the UI showing the new vote button
 * states and comment score without requiring a page refresh.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to vote on
 * @param props.body Vote direction and optional metadata for voting on the
 *   comment
 * @path /redditLike/member/comments/:commentId/votes
 * @accessor api.functional.redditLike.member.comments.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the comment to vote on */
    commentId: string & tags.Format<"uuid">;

    /** Vote direction and optional metadata for voting on the comment */
    body: IRedditLikeCommentVote.ICreate;
  };
  export type Body = IRedditLikeCommentVote.ICreate;
  export type Response = IRedditLikeCommentVote;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/comments/:commentId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes`;
  export const random = (): IRedditLikeCommentVote =>
    typia.random<IRedditLikeCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove the authenticated user's vote from a specific comment.
 *
 * Remove the authenticated user's vote (upvote or downvote) on a specific
 * comment, returning the vote state to neutral. This operation is part of the
 * democratic content curation system that allows users to change their voting
 * behavior on comments.
 *
 * When a user removes their vote, the comment's vote_score field is adjusted
 * accordingly: removing an upvote decreases the score by 1, while removing a
 * downvote increases the score by 1. The comment author's comment karma is also
 * adjusted to reflect the vote removal, following the karma calculation rules
 * defined in the karma system requirements.
 *
 * This operation integrates with the voting system defined in the Voting System
 * Requirements document. Per the vote change requirements, users can transition
 * between three vote states (upvoted, downvoted, neutral) at any time without
 * restrictions or cooldowns. Vote removal is accomplished by clicking the same
 * vote button that was previously activated.
 *
 * The operation requires authentication and validates that the user has an
 * existing vote record in the reddit_like_comment_votes table for the specified
 * comment. If no vote exists, the operation returns an error indicating there
 * is no vote to remove. The operation also enforces that users cannot remove
 * votes from deleted or archived comments.
 *
 * Security considerations include verifying the authenticated user's session is
 * valid and that they are the owner of the vote being removed. The operation
 * permanently removes the vote record from the database, as the
 * reddit_like_comment_votes table does not have a deleted_at field and only
 * supports hard deletion. This is the correct behavior for vote removal, as
 * votes should be completely removed rather than marked as deleted.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment whose vote is being
 *   removed
 * @path /redditLike/member/comments/:commentId/votes
 * @accessor api.functional.redditLike.member.comments.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the comment whose vote is being removed */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/member/comments/:commentId/votes",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
