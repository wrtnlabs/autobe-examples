import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerationAppeal } from "../../../../../../structures/IRedditLikeModerationAppeal";

/**
 * Escalate a community moderation appeal to platform administrators for
 * higher-level review.
 *
 * Escalate a community-level moderation appeal to platform administrators for
 * higher-level review. This operation enables users who have had their
 * community-level appeals denied by moderators to request a second review by
 * platform administrators, as defined in requirements R-APP-025 and R-APP-026.
 *
 * When a user escalates an appeal, the system updates the
 * reddit_like_moderation_appeals record by setting the is_escalated flag to
 * true and changing the status to route the appeal to the administrator review
 * queue. The escalation preserves the complete appeal history, including the
 * original community moderator's review and decision, ensuring administrators
 * have full context when reviewing the escalated appeal.
 *
 * Per requirement R-APP-027, the system limits users to one escalation per
 * moderation action, preventing repeated escalation attempts on the same
 * appeal. The operation validates that the appeal was previously reviewed and
 * denied at the community level before allowing escalation. Appeals of
 * platform-level suspensions cannot be escalated further as administrator
 * decisions are final per R-APP-024.
 *
 * The escalation process integrates with the moderation logging system defined
 * in reddit_like_moderation_logs, creating an audit trail entry documenting the
 * escalation action with timestamp, actor information, and appeal context.
 * Expected resolution timeframes for escalated appeals are 7-10 days per
 * R-APP-029, which is reflected in the expected_resolution_at timestamp
 * calculation.
 *
 * This operation requires authentication and verifies that the requesting user
 * is the original appellant. Only the member who submitted the appeal can
 * escalate it to administrators. The system enforces business rules ensuring
 * appeals are eligible for escalation based on their current status and prior
 * review outcomes.
 *
 * @param props.connection
 * @param props.appealId Unique identifier of the moderation appeal to escalate
 *   to administrators
 * @path /redditLike/member/moderation/appeals/:appealId/escalate
 * @accessor api.functional.redditLike.member.moderation.appeals.escalate.postByAppealid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByAppealid(
  connection: IConnection,
  props: postByAppealid.Props,
): Promise<postByAppealid.Response> {
  return true === connection.simulate
    ? postByAppealid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByAppealid.METADATA,
          path: postByAppealid.path(props),
          status: null,
        },
      );
}
export namespace postByAppealid {
  export type Props = {
    /**
     * Unique identifier of the moderation appeal to escalate to
     * administrators
     */
    appealId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeModerationAppeal;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/member/moderation/appeals/:appealId/escalate",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/moderation/appeals/${encodeURIComponent(props.appealId ?? "null")}/escalate`;
  export const random = (): IRedditLikeModerationAppeal =>
    typia.random<IRedditLikeModerationAppeal>();
  export const simulate = (
    connection: IConnection,
    props: postByAppealid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByAppealid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appealId")(() => typia.assert(props.appealId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Escalate a denied community moderation appeal to platform administrators for
 * review.
 *
 * Update an existing moderation appeal to escalate it from community-level
 * review to platform administrator review. This operation enables users who
 * have had their community-level appeals denied by moderators to request a
 * second review by platform administrators, as defined in requirements
 * R-APP-025 and R-APP-026.
 *
 * When a user escalates an appeal, this operation updates the existing
 * reddit_like_moderation_appeals record by setting the is_escalated boolean
 * flag to true and changing the status field to route the appeal to the
 * administrator review queue. The escalation preserves the complete appeal
 * history, including the original community moderator's review and decision,
 * ensuring administrators have full context when reviewing the escalated
 * appeal.
 *
 * Per requirement R-APP-27, the system limits users to one escalation per
 * moderation action, preventing repeated escalation attempts on the same
 * appeal. The operation validates that the appeal was previously reviewed and
 * denied at the community level (status = 'upheld') before allowing escalation.
 * Appeals of platform-level suspensions cannot be escalated further as
 * administrator decisions are final per R-APP-024.
 *
 * The escalation integrates with the moderation logging system defined in
 * reddit_like_moderation_logs, creating an audit trail entry documenting the
 * escalation action with timestamp, actor information (the appellant member),
 * and appeal context. Expected resolution timeframes for escalated appeals are
 * 7-10 days per R-APP-029, which is reflected in the expected_resolution_at
 * timestamp calculation when the escalation is processed.
 *
 * This operation requires member authentication and verifies that the
 * requesting user is the original appellant by checking that the authenticated
 * member's ID matches the appeal's appellant_member_id. Only the member who
 * submitted the appeal can escalate it to administrators. The system enforces
 * business rules ensuring appeals are eligible for escalation based on their
 * current status (must be 'upheld'/denied at community level) and appeal type
 * (community-level appeals only, not platform suspensions).
 *
 * Security considerations include validating appeal ownership to prevent users
 * from escalating other users' appeals, checking that the appeal hasn't already
 * been escalated (is_escalated = false), and ensuring the appeal is in an
 * appropriate state for escalation. The operation returns the updated appeal
 * record showing the new escalated status and routing to the administrator
 * review queue.
 *
 * @param props.connection
 * @param props.appealId Unique identifier of the moderation appeal to escalate
 *   to administrators
 * @path /redditLike/member/moderation/appeals/:appealId/escalate
 * @accessor api.functional.redditLike.member.moderation.appeals.escalate.putByAppealid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByAppealid(
  connection: IConnection,
  props: putByAppealid.Props,
): Promise<putByAppealid.Response> {
  return true === connection.simulate
    ? putByAppealid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByAppealid.METADATA,
          path: putByAppealid.path(props),
          status: null,
        },
      );
}
export namespace putByAppealid {
  export type Props = {
    /**
     * Unique identifier of the moderation appeal to escalate to
     * administrators
     */
    appealId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeModerationAppeal;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/member/moderation/appeals/:appealId/escalate",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/moderation/appeals/${encodeURIComponent(props.appealId ?? "null")}/escalate`;
  export const random = (): IRedditLikeModerationAppeal =>
    typia.random<IRedditLikeModerationAppeal>();
  export const simulate = (
    connection: IConnection,
    props: putByAppealid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByAppealid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appealId")(() => typia.assert(props.appealId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
