import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommentVote } from "../../../../../../structures/IRedditLikeCommentVote";

/**
 * Retrieve the authenticated user's vote status on a specific comment.
 *
 * Retrieve the authenticated user's current vote status on a specific comment,
 * returning information about whether they have upvoted (+1), downvoted (-1),
 * or not voted (null) on the comment. This operation supports the voting
 * system's user interface requirements by providing the data needed to display
 * correct button states.
 *
 * The operation queries the reddit_like_comment_votes table to find a vote
 * record matching both the authenticated user's member ID and the specified
 * comment ID. If a vote record exists, it returns the vote value and timestamp.
 * If no vote record exists, it indicates the user has not voted on this
 * comment.
 *
 * This operation is essential for maintaining accurate voting UI state across
 * the platform. When users view comments, the system must display whether they
 * have already voted to prevent confusion and enable vote changes. The vote
 * status information allows the frontend to highlight the appropriate vote
 * button (upvote or downvote) and enable the vote removal functionality.
 *
 * Per the voting system requirements, vote status is user-specific and
 * anonymous to other users. Only the individual user can see their own vote
 * status on content. This operation enforces that privacy by only returning the
 * authenticated user's vote information.
 *
 * The operation integrates with the comment display system defined in the
 * Comment System Requirements. When rendering comment threads, the system needs
 * to know the user's vote status for each comment to display appropriate visual
 * indicators (highlighted upvote button, highlighted downvote button, or
 * neutral state).
 *
 * Security considerations include verifying the authenticated user's session is
 * valid and ensuring the comment exists and is accessible. The operation works
 * with both active and deleted comments, as users may want to see their vote
 * history even on removed content.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment whose vote status is
 *   being retrieved
 * @path /redditLike/member/comments/:commentId/votes/me
 * @accessor api.functional.redditLike.member.comments.votes.me.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the comment whose vote status is being retrieved */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommentVote;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/member/comments/:commentId/votes/me",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes/me`;
  export const random = (): IRedditLikeCommentVote =>
    typia.random<IRedditLikeCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
