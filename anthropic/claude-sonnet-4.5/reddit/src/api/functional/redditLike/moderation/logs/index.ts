import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerationLog } from "../../../../structures/IRedditLikeModerationLog";
import { IPageIRedditLikeModerationLog } from "../../../../structures/IPageIRedditLikeModerationLog";

/**
 * Search and retrieve filtered moderation log entries with pagination and
 * advanced filtering.
 *
 * Retrieve a filtered and paginated list of moderation log entries from the
 * comprehensive audit trail system. This operation provides access to the
 * reddit_like_moderation_logs table, which records all moderation system
 * activities including report submissions, moderation actions, ban issuances,
 * appeal submissions, and appeal decisions.
 *
 * The moderation logs serve as a permanent, immutable audit trail for
 * accountability, transparency, and legal compliance per requirements R-LOG-001
 * through R-LOG-005. Each log entry captures complete context including the
 * actor who performed the action (member, moderator, or admin), the related
 * moderation entities (reports, actions, bans, suspensions, appeals), the
 * community context, event type, human-readable action description, and precise
 * timestamp with second precision.
 *
 * This operation supports comprehensive filtering and search capabilities to
 * help moderators and administrators efficiently find relevant log entries.
 * Filters include log type (report_submitted, action_taken, ban_issued, etc.),
 * actor role (member, moderator, admin), community context, time ranges, and
 * full-text search within action descriptions and metadata. The search
 * functionality uses the GIN trigram index on action_description for efficient
 * text matching.
 *
 * Access control is role-based: moderators can view logs only for communities
 * they moderate per requirement R-LOG-008, while administrators have access to
 * complete platform-wide moderation history per requirement R-LOG-009. The
 * system filters results based on the authenticated user's role and community
 * moderation assignments, ensuring proper data access boundaries.
 *
 * The operation returns paginated results with sorting options by timestamp
 * (newest first by default per R-LOG-010), log type, or community. Each log
 * entry includes comprehensive details about the moderation event, references
 * to related entities (with IDs for further lookup), and metadata context. The
 * pagination structure supports efficient browsing of large log datasets while
 * maintaining query performance through proper indexing on log_type,
 * created_at, actor IDs, and community_id.
 *
 * This operation integrates with the broader moderation system, providing
 * transparency into moderation decisions and enabling pattern analysis for
 * improving moderation effectiveness. The logs support moderator
 * accountability, user transparency (through public moderation logs per
 * R-LOG-015 through R-LOG-018), and administrative oversight of moderation
 * practices across the platform.
 *
 * @param props.connection
 * @param props.body Search criteria and filters for retrieving moderation log
 *   entries including log type, actor filters, community scope, time ranges,
 *   text search, and pagination parameters
 * @path /redditLike/moderation/logs
 * @accessor api.functional.redditLike.moderation.logs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and filters for retrieving moderation log entries
     * including log type, actor filters, community scope, time ranges, text
     * search, and pagination parameters
     */
    body: IRedditLikeModerationLog.IRequest;
  };
  export type Body = IRedditLikeModerationLog.IRequest;
  export type Response = IPageIRedditLikeModerationLog;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/moderation/logs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/moderation/logs";
  export const random = (): IPageIRedditLikeModerationLog =>
    typia.random<IPageIRedditLikeModerationLog>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
