import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikePostMetrics } from "../../../../structures/IRedditLikePostMetrics";

/**
 * Retrieve pre-calculated engagement metrics for a specific post.
 *
 * Retrieve comprehensive engagement metrics for a specific post from the
 * Reddit-like platform. This operation accesses the mv_reddit_like_post_metrics
 * materialized view which provides pre-calculated denormalized metrics
 * optimized for query performance without expensive real-time vote and comment
 * aggregation.
 *
 * The metrics include detailed voting statistics: vote_score (net upvotes minus
 * downvotes used for ranking algorithms), upvote_count (total positive votes
 * for popularity analysis), downvote_count (total negative votes for
 * controversy calculations), and derived upvote percentage (ratio of upvotes to
 * total votes). Additionally, the operation returns comment_count aggregated
 * from all comments and replies on the post, enabling fast feed displays
 * showing engagement levels.
 *
 * This endpoint is critical for content sorting algorithms defined in the
 * Content Sorting Algorithms specification. The vote_score feeds into Hot
 * algorithm time decay calculations and Top sorting rankings. The
 * upvote/downvote counts power the Controversial sorting algorithm which
 * identifies polarizing content with balanced voting patterns. The
 * comment_count provides engagement signals for content discovery and user
 * interest indication.
 *
 * The operation integrates with the Voting System where individual votes are
 * recorded in reddit_like_post_votes table, and the materialized view
 * aggregates these atomic vote records into summary statistics. The metrics are
 * refreshed periodically (indicated by last_calculated_at timestamp) to balance
 * data freshness with write performance on the normalized voting tables.
 *
 * Security considerations include public read access for metrics on posts in
 * public communities, while private community posts require membership
 * verification before exposing metrics. The operation respects community
 * privacy settings and post deletion status, returning appropriate errors for
 * inaccessible or deleted posts.
 *
 * Performance expectations are sub-second response times since metrics are
 * pre-calculated in the materialized view rather than computed on-demand. The
 * last_calculated_at timestamp indicates metric freshness, typically within
 * seconds to minutes of actual vote changes depending on view refresh
 * frequency. This architecture ensures fast feed rendering and sorting
 * algorithm execution even for posts with thousands of votes.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to retrieve metrics for
 * @path /redditLike/posts/:postId/metrics
 * @accessor api.functional.redditLike.posts.metrics.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the post to retrieve metrics for */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikePostMetrics;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/posts/:postId/metrics",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/posts/${encodeURIComponent(props.postId ?? "null")}/metrics`;
  export const random = (): IRedditLikePostMetrics =>
    typia.random<IRedditLikePostMetrics>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
