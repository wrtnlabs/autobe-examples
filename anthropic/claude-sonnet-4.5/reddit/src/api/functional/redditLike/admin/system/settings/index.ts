import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeSystemSetting } from "../../../../../structures/IRedditLikeSystemSetting";

/**
 * Retrieve a specific system setting by unique identifier.
 *
 * Retrieve detailed information about a single system setting configuration
 * parameter from the reddit_like_system_settings table. This operation returns
 * complete setting details including the setting key, value, description, value
 * type indicator, category classification, and public visibility flag.
 *
 * System settings control various platform behaviors such as maximum post
 * length limits, rate limiting thresholds for posting and commenting, feature
 * toggle flags, and other configurable system parameters. Each setting has a
 * unique identifier and a semantic key name used throughout the application to
 * retrieve configuration values.
 *
 * This endpoint is primarily used by platform administrators to inspect current
 * configuration values, understand setting purposes through descriptions, and
 * prepare for configuration updates. The value_type field indicates how to
 * deserialize the string value (string, int, double, boolean, json), enabling
 * proper type handling in application logic.
 *
 * Security considerations require that this operation be restricted to
 * administrator users only, as system settings may contain sensitive
 * configuration data affecting platform-wide behavior. The is_public field
 * indicates whether a setting can be safely exposed via public API, with
 * internal-only settings (like API keys or security parameters) kept
 * confidential.
 *
 * This operation integrates with system configuration management workflows and
 * may be used in conjunction with setting update operations to review current
 * values before modifications. Settings are categorized (content, moderation,
 * performance, features) to help administrators organize and locate related
 * configuration parameters efficiently.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target system setting
 * @path /redditLike/admin/system/settings/:id
 * @accessor api.functional.redditLike.admin.system.settings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target system setting */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeSystemSetting;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/admin/system/settings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/system/settings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRedditLikeSystemSetting =>
    typia.random<IRedditLikeSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing system configuration setting by ID.
 *
 * Update a system configuration setting in the reddit_like_system_settings
 * table. This operation allows platform administrators to modify system
 * parameters that control various aspects of platform behavior including
 * content limits, rate limiting rules, feature toggles, and other configurable
 * system settings.
 *
 * This operation validates that the provided setting ID exists in the system
 * before attempting the update. The value must conform to the data type
 * specified in the value_type field to ensure proper deserialization by the
 * application. Common value types include 'string', 'int', 'double', 'boolean',
 * and 'json' for complex values.
 *
 * Only administrators have permission to modify system settings as these
 * configurations directly impact platform functionality, security, and
 * performance. Changes to settings take effect immediately upon successful
 * update, though some settings may require application restart or cache
 * invalidation to fully apply.
 *
 * The operation updates the settings metadata including the description,
 * value_type, category classification, and public visibility flag. The
 * updated_at timestamp is automatically set to the current time to track when
 * the configuration was last modified, providing an audit trail for
 * configuration changes.
 *
 * Related operations include retrieving system settings to view current
 * configuration values before making updates, and creating new system settings
 * for expanding platform configuration capabilities.
 *
 * @param props.connection
 * @param props.id Unique identifier of the system setting to update
 * @param props.body Updated system setting configuration data including value,
 *   description, type, category, and visibility
 * @path /redditLike/admin/system/settings/:id
 * @accessor api.functional.redditLike.admin.system.settings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the system setting to update */
    id: string & tags.Format<"uuid">;

    /**
     * Updated system setting configuration data including value,
     * description, type, category, and visibility
     */
    body: IRedditLikeSystemSetting.IUpdate;
  };
  export type Body = IRedditLikeSystemSetting.IUpdate;
  export type Response = IRedditLikeSystemSetting;

  export const METADATA = {
    method: "PUT",
    path: "/redditLike/admin/system/settings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/admin/system/settings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRedditLikeSystemSetting =>
    typia.random<IRedditLikeSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a system configuration setting by ID.
 *
 * Permanently remove a system configuration setting from the
 * reddit_like_system_settings table. This operation completely deletes the
 * setting record from the database and cannot be undone, as the schema does not
 * support soft deletion for system settings.
 *
 * This operation is restricted to platform administrators only, as system
 * settings control critical platform functionality including content limits,
 * rate limiting rules, feature toggles, and other configurable aspects of the
 * system. Removing settings can have significant impact on platform behavior
 * and should only be performed when a configuration parameter is definitively
 * no longer needed.
 *
 * The operation validates that the specified setting ID exists before
 * attempting deletion. If the setting does not exist, the operation returns an
 * appropriate error response. Upon successful deletion, the setting is
 * immediately and permanently removed from the database, and all references to
 * this configuration are lost.
 *
 * Care should be taken when deleting system settings, as the application may
 * depend on certain configuration parameters to function correctly.
 * Administrators should verify that removing a setting will not break platform
 * functionality or cause runtime errors in components that reference the
 * setting.
 *
 * Before deleting a setting, consider whether disabling it (by changing its
 * value or is_public flag) would be more appropriate than permanent removal.
 * Settings that may be needed in the future should be disabled rather than
 * deleted to preserve configuration history and enable easy re-activation.
 *
 * Related operations include updating system settings to modify their values or
 * visibility, and retrieving settings to verify current configuration before
 * making deletion decisions.
 *
 * @param props.connection
 * @param props.id Unique identifier of the system setting to permanently delete
 * @path /redditLike/admin/system/settings/:id
 * @accessor api.functional.redditLike.admin.system.settings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the system setting to permanently delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/admin/system/settings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/system/settings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new system setting configuration parameter.
 *
 * Create a new configuration setting in the reddit_like_system_settings table
 * to control platform behavior and features. This operation accepts setting
 * details including the unique setting key, value, optional description, value
 * type indicator, category classification, and public visibility flag.
 *
 * System settings provide flexible runtime configuration without requiring code
 * changes or deployments. Each setting has a semantic key name (like
 * 'max_post_length' or 'rate_limit_posts_per_hour') that application code uses
 * to retrieve configuration values. The value is stored as a string with a
 * value_type field indicating the proper deserialization type (string, int,
 * double, boolean, json), enabling type-safe configuration handling.
 *
 * The category field helps organize related settings into logical groups such
 * as 'content', 'moderation', 'performance', or 'features', making it easier
 * for administrators to manage configurations in admin interfaces. The
 * is_public flag controls whether the setting can be exposed via public API
 * endpoints, with sensitive internal settings (API keys, security parameters)
 * marked as internal-only.
 *
 * This operation is restricted to administrator users only, as system settings
 * control critical platform behavior and may contain sensitive configuration
 * data. Administrators should provide clear, comprehensive descriptions for all
 * settings to help future administrators understand the purpose and impact of
 * each configuration parameter.
 *
 * The created setting is immediately available for use throughout the
 * application, with timestamp tracking for creation and future updates. This
 * operation integrates with platform configuration management and
 * administrative dashboards for system maintenance and tuning.
 *
 * @param props.connection
 * @param props.body System setting configuration data including key, value,
 *   type, and metadata
 * @path /redditLike/admin/system/settings
 * @accessor api.functional.redditLike.admin.system.settings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * System setting configuration data including key, value, type, and
     * metadata
     */
    body: IRedditLikeSystemSetting.ICreate;
  };
  export type Body = IRedditLikeSystemSetting.ICreate;
  export type Response = IRedditLikeSystemSetting;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/system/settings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/admin/system/settings";
  export const random = (): IRedditLikeSystemSetting =>
    typia.random<IRedditLikeSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
