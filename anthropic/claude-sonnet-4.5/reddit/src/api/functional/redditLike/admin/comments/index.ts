import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeComment } from "../../../../structures/IRedditLikeComment";
export * as replies from "./replies/index";
export * as votes from "./votes/index";

/**
 * Create a new comment or reply in a post discussion thread.
 *
 * Create a new comment on a post or reply to an existing comment, enabling
 * community discussion and engagement through threaded conversations. This
 * operation inserts a new record into the reddit_like_comments table and
 * supports the complete nested comment threading system defined in the business
 * requirements.
 *
 * This operation requires user authentication and validates that the
 * authenticated administrator is not banned from the community where the
 * content exists. The comment content must be between 1 and 10,000 characters
 * and is stored with markdown formatting support. When creating a reply to
 * another comment, the system validates the parent comment exists and enforces
 * the maximum nesting depth of 10 levels per business requirement section 4.4.
 *
 * The newly created comment is initialized with zero vote score, depth level
 * calculated from parent comment (0 for top-level comments), and edited flag
 * set to false. The system automatically increments the post's comment count
 * through the mv_reddit_like_post_metrics materialized view and makes the
 * comment immediately available for voting and further replies.
 *
 * Security considerations include content sanitization to prevent XSS attacks,
 * rate limiting to prevent spam (max 10 comments per minute per business
 * requirement section 11.2), and duplicate comment detection (rejecting
 * identical comments within 5 minutes per requirement section 11.2). URL
 * validation ensures only HTTP/HTTPS protocols are allowed in comment text
 * links, protecting users from malicious links.
 *
 * This operation integrates with the voting system by enabling immediate vote
 * capability on the new comment, the karma system by preparing the comment for
 * potential karma earning, and the content moderation system by making the
 * comment reportable if it violates rules. The comment appears in the author's
 * comment history on their profile and contributes to the overall discussion
 * thread structure.
 *
 * @param props.connection
 * @param props.body Comment creation data including content text, parent post,
 *   and optional parent comment for threaded replies
 * @path /redditLike/admin/comments
 * @accessor api.functional.redditLike.admin.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Comment creation data including content text, parent post, and
     * optional parent comment for threaded replies
     */
    body: IRedditLikeComment.ICreate;
  };
  export type Body = IRedditLikeComment.ICreate;
  export type Response = IRedditLikeComment;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/admin/comments";
  export const random = (): IRedditLikeComment =>
    typia.random<IRedditLikeComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a comment from a discussion for rule violations.
 *
 * Remove a specific comment from a discussion thread due to content policy
 * violations or community rule infractions. This operation is available to
 * community moderators within their assigned communities and to platform
 * administrators across all communities. The operation implements soft deletion
 * by setting the deleted_at timestamp on the reddit_like_comments record while
 * preserving all comment metadata and thread structure for discussion
 * continuity.
 *
 * When a comment is removed, the system creates detailed records in both
 * reddit_like_moderation_actions and reddit_like_moderation_logs tables to
 * maintain a comprehensive audit trail. The moderation action record captures
 * the removal type (community, platform, or spam), the reason category and
 * detailed explanation, and any internal notes for the moderation team. The
 * moderation log provides an immutable historical record of the removal event
 * including the moderator's identity, timestamp, and full context.
 *
 * Security and authorization are enforced rigorously. Moderators must have the
 * 'manage_comments' permission in the specific community where the comment
 * exists, validated through the reddit_like_community_moderators table and the
 * community association of the parent post in reddit_like_posts. The system
 * verifies that the moderator's permission set includes comment management
 * rights. Administrators bypass community-specific permission checks and can
 * remove comments platform-wide for policy enforcement. Regular members are
 * prevented from removing comments created by others.
 *
 * The removal process immediately hides the comment's content_text from public
 * view by filtering based on the deleted_at timestamp. The system replaces the
 * comment text with the placeholder '[removed by moderator]' when displaying
 * the thread to users. Critically, the comment's position in the thread
 * hierarchy is preserved to maintain conversation flow. All child replies to
 * the removed comment remain visible and properly nested beneath the
 * '[removed]' placeholder, ensuring that valuable discussion threads are not
 * fragmented by parent comment removals.
 *
 * This approach aligns with the Comment System requirements (section 5.5) which
 * specify that deleted comments with replies must preserve thread structure.
 * When a comment is removed, nested replies continue to display in their proper
 * hierarchical positions, maintaining the integrity of the conversation tree.
 * Users viewing the thread see the discussion flow even when intermediate
 * comments have been moderated, preventing confusion and preserving context for
 * remaining comments.
 *
 * Removal scope and type follow the same patterns as post removals.
 * Community-level removals hide comments from the specific community context.
 * Platform-level removals by administrators hide comments from all views due to
 * severe platform-wide policy violations. Spam removals trigger karma reversal
 * for the comment author, removing any karma points earned from the removed
 * comment according to anti-manipulation rules in the Karma System requirements
 * (section 9.2).
 *
 * The comment author receives a notification within 5 minutes of removal
 * explaining which comment was removed, the community it was removed from, the
 * stated reason citing specific rule violations, and information about how to
 * appeal the decision. The notification includes a link to the appeal
 * submission form, enabling users to exercise their right to contest moderation
 * decisions.
 *
 * This operation integrates seamlessly with the content reporting and
 * moderation workflow. Removals can be triggered either reactively (responding
 * to user-submitted reports in reddit_like_content_reports) or proactively by
 * moderators monitoring their communities. When removing a comment in response
 * to a report, the moderator includes the report_id in the request to link the
 * action to the triggering report, updating the report status to 'reviewed' and
 * enabling report resolution tracking.
 *
 * The operation fully supports the appeal process defined in the Content
 * Moderation and Reporting requirements (section 8). All removed comments and
 * their removal reasons are preserved in the moderation action records,
 * providing the necessary context for appeal review. Users appealing comment
 * removals reference the moderation action through the
 * reddit_like_moderation_appeals table, and reviewing moderators or
 * administrators have access to the complete removal context including original
 * comment text, removal reasoning, and any internal moderation notes.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to be removed
 * @param props.body Details about the comment removal including reason
 *   category, explanation text, removal scope, and optional report reference
 * @path /redditLike/admin/comments/:commentId/remove
 * @accessor api.functional.redditLike.admin.comments.remove
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function remove(
  connection: IConnection,
  props: remove.Props,
): Promise<void> {
  return true === connection.simulate
    ? remove.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...remove.METADATA,
          path: remove.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace remove {
  export type Props = {
    /** Unique identifier of the comment to be removed */
    commentId: string & tags.Format<"uuid">;

    /**
     * Details about the comment removal including reason category,
     * explanation text, removal scope, and optional report reference
     */
    body: IRedditLikeComment.IRemove;
  };
  export type Body = IRedditLikeComment.IRemove;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/comments/:commentId/remove",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/admin/comments/${encodeURIComponent(props.commentId ?? "null")}/remove`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: remove.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: remove.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore a soft-deleted comment to make it visible again.
 *
 * Restores a previously soft-deleted comment by clearing its deleted_at
 * timestamp, making the comment visible again in discussion threads. This
 * operation is essential for recovering comments that were deleted by mistake
 * or removed during moderation but later approved through appeals.
 *
 * When a comment is deleted in the platform, it undergoes soft deletion where
 * the deleted_at timestamp is set but the comment data remains in the
 * reddit_like_comments table. Soft deletion preserves the comment's position in
 * the thread hierarchy, all voting data, karma attribution, and nested reply
 * relationships while hiding the comment content from public view. The thread
 * structure remains intact with '[deleted]' placeholder shown to maintain
 * conversation context.
 *
 * This restoration endpoint reverses the soft deletion by clearing the
 * deleted_at field, immediately making the comment content visible again in its
 * original thread position. The comment appears exactly where it was before
 * deletion, maintaining all parent-child relationships in the nested comment
 * tree. All previously earned karma from the comment remains intact per
 * business requirements, and the comment's vote score is preserved.
 *
 * Authorization for comment restoration depends on the context: comment authors
 * can restore their own deleted comments within reasonable timeframes,
 * community moderators can restore comments removed as part of moderation
 * actions in their communities, and platform administrators can restore any
 * comment platform-wide. The operation validates that the requesting user has
 * appropriate permissions before executing the restoration.
 *
 * The restored comment retains all its original attributes including content
 * text, creation timestamp, vote score, depth level, and threading
 * relationships. Child replies that were preserved during deletion remain
 * connected to the restored parent comment. The comment immediately becomes
 * available for voting and further replies. The restored comment integrates
 * naturally into the existing conversation thread based on its original
 * creation time, not the restoration time.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the soft-deleted comment to
 *   restore
 * @path /redditLike/admin/comments/:commentId/restore
 * @accessor api.functional.redditLike.admin.comments.restore
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function restore(
  connection: IConnection,
  props: restore.Props,
): Promise<restore.Response> {
  return true === connection.simulate
    ? restore.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...restore.METADATA,
          path: restore.path(props),
          status: null,
        },
      );
}
export namespace restore {
  export type Props = {
    /** Unique identifier of the soft-deleted comment to restore */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeComment;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/comments/:commentId/restore",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/comments/${encodeURIComponent(props.commentId ?? "null")}/restore`;
  export const random = (): IRedditLikeComment =>
    typia.random<IRedditLikeComment>();
  export const simulate = (
    connection: IConnection,
    props: restore.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: restore.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
