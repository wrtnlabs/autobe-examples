import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommunityBan } from "../../../../../structures/IRedditLikeCommunityBan";

/**
 * Retrieve detailed information about a specific community ban (admin access).
 *
 * Retrieve comprehensive details of a specific community ban issued within any
 * community on the platform. This operation fetches complete ban information
 * including the banned member's identity, the moderator who issued the ban, the
 * reason for the ban, ban duration and expiration details, and current ban
 * status.
 *
 * This operation is used by platform administrators to review community bans
 * across any community for oversight purposes, appeal reviews, or investigation
 * of moderation patterns. Unlike the moderator endpoint, administrators can
 * access ban details for any community regardless of their moderator
 * assignments, reflecting their elevated platform-wide permissions.
 *
 * The operation integrates with the reddit_like_community_bans table from the
 * Prisma schema, which stores community-level bans with support for both
 * temporary and permanent bans. The table includes soft delete support through
 * the deleted_at field, allowing lifted bans to be preserved in audit history.
 *
 * Security considerations include ensuring only platform administrators can
 * access this endpoint, as it provides cross-community visibility into
 * moderation decisions. This elevated access enables administrators to identify
 * moderation abuse, review appeal requests, and ensure consistent application
 * of platform policies across communities.
 *
 * The response includes all ban metadata such as whether the ban is permanent
 * or temporary, the expiration date for temporary bans, whether the ban is
 * currently active, the complete ban reason provided by the issuing moderator,
 * and any internal notes. This comprehensive view enables administrators to
 * review moderation decisions and handle escalated appeals effectively.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the ban was
 *   issued
 * @param props.banId Unique identifier of the specific community ban to
 *   retrieve
 * @path /redditLike/admin/communities/:communityId/bans/:banId
 * @accessor api.functional.redditLike.admin.communities.bans.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the community where the ban was issued */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific community ban to retrieve */
    banId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikeCommunityBan;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/admin/communities/:communityId/bans/:banId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/bans/${encodeURIComponent(props.banId ?? "null")}`;
  export const random = (): IRedditLikeCommunityBan =>
    typia.random<IRedditLikeCommunityBan>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("banId")(() => typia.assert(props.banId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Lift a community ban and restore member access (admin override, soft delete).
 *
 * Lifts a community ban by setting the deleted_at timestamp to the current
 * time, marking the ban as inactive while preserving the complete ban record
 * for audit history. This soft delete approach maintains the ban record in the
 * reddit_like_community_bans table for moderation log purposes and historical
 * review, while immediately restoring the banned member's ability to post,
 * comment, and vote in the community.
 *
 * This endpoint is used by platform administrators to override community bans
 * as part of their elevated privileges. Administrators can lift bans in any
 * community regardless of moderator assignments, which is essential for
 * handling escalated appeals, correcting moderator errors, or intervening in
 * cases of moderation abuse. The soft delete pattern ensures that the platform
 * maintains a complete audit trail of all moderation actions including
 * administrator interventions.
 *
 * The operation integrates with the reddit_like_community_bans table from the
 * Prisma schema, which includes a deleted_at field specifically for soft
 * deletion. When the deleted_at timestamp is set, the ban is no longer enforced
 * for access control checks, but the record remains queryable by moderators and
 * administrators for historical review and audit purposes. The complete ban
 * history including issue date, reason, duration, and lift date is preserved.
 *
 * Security considerations include strict authorization validation ensuring only
 * platform administrators can access this endpoint. The operation verifies the
 * ban exists and belongs to the specified community before performing the soft
 * delete. After successful deletion, the system logs the ban removal action in
 * the reddit_like_moderation_logs audit trail with the administrator's
 * identity, and sends a notification to the previously banned member informing
 * them that their access has been restored by platform administration.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community where the ban was
 *   issued
 * @param props.banId Unique identifier of the community ban to lift
 * @path /redditLike/admin/communities/:communityId/bans/:banId
 * @accessor api.functional.redditLike.admin.communities.bans.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the community where the ban was issued */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the community ban to lift */
    banId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/admin/communities/:communityId/bans/:banId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/bans/${encodeURIComponent(props.banId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("banId")(() => typia.assert(props.banId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
