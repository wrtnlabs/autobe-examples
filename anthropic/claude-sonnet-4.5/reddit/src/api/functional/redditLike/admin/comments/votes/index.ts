import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeCommentVote } from "../../../../../structures/IRedditLikeCommentVote";

/**
 * Cast or modify a vote on a specific comment.
 *
 * Submit a vote on a specific comment identified by the comment ID path
 * parameter. This operation enables authenticated users to upvote (positive
 * endorsement) or downvote (negative signal) comments as part of the democratic
 * content curation system defined in the Voting System Requirements.
 *
 * The operation accepts a request body specifying the vote direction: upvote
 * (+1) or downvote (-1). When a user submits a vote, the system processes it
 * according to the vote state transition rules defined in the Voting System
 * specification. If the user has not previously voted on this comment, a new
 * vote record is created in the reddit_like_comment_votes table. If the user
 * has previously voted, the operation updates the existing vote record,
 * handling all vote change scenarios: upvote to downvote, downvote to upvote,
 * or vote removal.
 *
 * Vote processing includes several critical business rules enforced at the
 * application level. The system prevents self-voting by validating that the
 * authenticated user is not the comment author. The operation updates the
 * comment's vote_score field in the reddit_like_comments table, incrementing by
 * 1 for upvotes and decrementing by 1 for downvotes. Vote changes result in
 * score adjustments of +2 or -2 to account for both removing the previous vote
 * and applying the new vote.
 *
 * This operation integrates with the karma system defined in the Karma System
 * Requirements. When a comment receives a vote, the comment author's
 * comment_karma is updated in real-time, affecting their total karma score
 * displayed on their profile. The system records karma changes in the
 * reddit_like_karma_history table for audit trail and transparency.
 *
 * Anti-manipulation measures defined in the Voting System Requirements section
 * 8 are enforced during vote processing. The operation records the voter's IP
 * address and user agent in the reddit_like_comment_votes table for detecting
 * coordinated voting, multiple account abuse, and vote brigading patterns. The
 * system may apply vote weight adjustments based on account trust factors, with
 * new accounts or suspicious voting patterns receiving reduced vote impact.
 *
 * Security considerations include validating that the comment exists and is
 * accessible, preventing votes on deleted comments (where deleted_at is not
 * null in reddit_like_comments table), and enforcing rate limiting to prevent
 * vote manipulation. The operation completes within 2 seconds per performance
 * requirements, with optimistic UI updates providing immediate visual feedback
 * while background processing completes.
 *
 * The response includes the updated vote state, current vote score for the
 * comment, and confirmation of successful vote registration. This enables the
 * client application to immediately update the UI showing the new vote button
 * states and comment score without requiring a page refresh.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to vote on
 * @param props.body Vote direction and optional metadata for voting on the
 *   comment
 * @path /redditLike/admin/comments/:commentId/votes
 * @accessor api.functional.redditLike.admin.comments.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the comment to vote on */
    commentId: string & tags.Format<"uuid">;

    /** Vote direction and optional metadata for voting on the comment */
    body: IRedditLikeCommentVote.ICreate;
  };
  export type Body = IRedditLikeCommentVote.ICreate;
  export type Response = IRedditLikeCommentVote;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/comments/:commentId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/admin/comments/${encodeURIComponent(props.commentId ?? "null")}/votes`;
  export const random = (): IRedditLikeCommentVote =>
    typia.random<IRedditLikeCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
