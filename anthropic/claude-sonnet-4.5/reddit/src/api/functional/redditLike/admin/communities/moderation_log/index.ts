import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikeModerationLog } from "../../../../../structures/IRedditLikeModerationLog";
import { IPageIRedditLikeModerationLog } from "../../../../../structures/IPageIRedditLikeModerationLog";

/**
 * Search and retrieve moderation logs for a specific community.
 *
 * Retrieve a filtered, paginated list of moderation log entries for a specific
 * community, providing comprehensive audit trail access for moderators and
 * administrators. This operation returns all moderation system activities that
 * occurred within the specified community, including content report
 * submissions, moderator actions on posts and comments, community ban issuances
 * and lifts, appeal submissions and decisions, and report dismissals.
 *
 * The moderation log system serves as the permanent immutable historical record
 * of community governance and content moderation activities. It captures
 * complete context for every moderation event including who performed the
 * action (member reporting, moderator acting, or administrator deciding), what
 * was affected (posts, comments, users), why the action was taken (violation
 * categories, reasoning), and when it occurred (precise timestamps). This
 * transparency is essential for moderation accountability, dispute resolution,
 * and understanding community governance patterns over time.
 *
 * This operation integrates with the reddit_like_moderation_logs table as
 * defined in the Prisma schema, which maintains comprehensive audit trails with
 * foreign key references to all related moderation entities. The table stores
 * log type categorization, human-readable action descriptions, JSON metadata
 * for event-specific details, and IP addresses for security auditing. The
 * community_id foreign key enables efficient filtering of logs to specific
 * communities.
 *
 * Security and authorization are critical for this operation. Community
 * moderators can view logs only for communities they moderate, enabling them to
 * review their team's moderation activities, track report handling, and ensure
 * consistency in rule enforcement. Platform administrators have unrestricted
 * access to logs across all communities for oversight, appeal reviews, and
 * platform-wide moderation analytics.
 *
 * The operation supports advanced filtering capabilities to help moderators
 * efficiently navigate large log histories. Filters include log type
 * (report_submitted, action_taken, ban_issued, etc.), time ranges for
 * historical analysis, specific actor identification, and related entity
 * references (specific reports, actions, bans, or appeals). The request body
 * enables complex search queries with pagination to handle communities with
 * extensive moderation histories.
 *
 * Response data includes complete log entry details with all referenced
 * entities (actors, affected content, related reports/actions/bans/appeals)
 * providing full event context. The paginated structure ensures performant
 * delivery of log data even for highly active communities with thousands of
 * moderation events. This operation is fundamental to the public moderation log
 * feature per requirement R-LOG-015, enabling community members to review
 * moderation transparency while protecting sensitive internal notes and private
 * information.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community whose moderation
 *   logs are being retrieved
 * @param props.body Search criteria and pagination parameters for filtering
 *   moderation logs including log type, time ranges, actor filters, and related
 *   entity filters
 * @path /redditLike/admin/communities/:communityId/moderation-log
 * @accessor api.functional.redditLike.admin.communities.moderation_log.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the community whose moderation logs are being
     * retrieved
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for filtering moderation
     * logs including log type, time ranges, actor filters, and related
     * entity filters
     */
    body: IRedditLikeModerationLog.IRequest;
  };
  export type Body = IRedditLikeModerationLog.IRequest;
  export type Response = IPageIRedditLikeModerationLog;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/admin/communities/:communityId/moderation-log",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/redditLike/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderation-log`;
  export const random = (): IPageIRedditLikeModerationLog =>
    typia.random<IPageIRedditLikeModerationLog>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
