import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRedditLikePlatformSuspension } from "../../../../../structures/IRedditLikePlatformSuspension";
import { IPageIRedditLikePlatformSuspension } from "../../../../../structures/IPageIRedditLikePlatformSuspension";

/**
 * Issue a platform-wide suspension for a member user.
 *
 * Issue a platform-wide suspension that prevents a member from accessing the
 * entire Reddit-like community platform. This operation is restricted to
 * administrators only and represents the most severe moderation action
 * available, affecting the user's ability to perform any authenticated actions
 * across all communities.
 *
 * Platform suspensions are issued for serious violations of platform-wide
 * policies including repeated rule violations across multiple communities,
 * severe harassment, spam campaigns, hate speech, illegal content posting, or
 * ban evasion attempts. Unlike community-level bans which are scoped to
 * specific communities, platform suspensions deny all platform access and
 * prevent the user from logging in.
 *
 * The operation creates a new record in the reddit_like_platform_suspensions
 * table with references to the suspended member and the issuing administrator.
 * Per business requirements R-BAN-013, suspensions can be temporary (3 days, 7
 * days, 30 days) or permanent account termination. Temporary suspensions
 * automatically restore user access when the expiration date passes through
 * system automation.
 *
 * When a suspension is issued, the system sends an email notification to the
 * user's registered email address immediately per requirement R-BAN-020,
 * including the suspension type, duration, detailed reason, and information
 * about the appeal process per R-BAN-021. The notification includes a direct
 * link to the appeal submission form.
 *
 * All suspension actions are logged in the reddit_like_moderation_logs table
 * per requirement R-BAN-018, creating an immutable audit trail with the
 * administrator identity, suspension reason, timestamp, and IP address for
 * accountability and legal compliance. The suspension record stores both a
 * predefined reason category and detailed reason text for transparency.
 *
 * Suspended users attempting to log in will be denied access with a message
 * displaying the suspension reason and duration per requirement R-BAN-012. For
 * temporary suspensions, the message includes the expiration date. The system
 * enforces suspensions by validating user status during authentication
 * workflows and rejecting login attempts from suspended accounts.
 *
 * @param props.connection
 * @param props.body Suspension details including the member to suspend, reason
 *   category, detailed explanation, duration, and optional internal notes
 * @path /redditLike/admin/platform/suspensions
 * @accessor api.functional.redditLike.admin.platform.suspensions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Suspension details including the member to suspend, reason category,
     * detailed explanation, duration, and optional internal notes
     */
    body: IRedditLikePlatformSuspension.ICreate;
  };
  export type Body = IRedditLikePlatformSuspension.ICreate;
  export type Response = IRedditLikePlatformSuspension;

  export const METADATA = {
    method: "POST",
    path: "/redditLike/admin/platform/suspensions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/admin/platform/suspensions";
  export const random = (): IRedditLikePlatformSuspension =>
    typia.random<IRedditLikePlatformSuspension>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered platform suspensions with pagination.
 *
 * Retrieve a comprehensive, filtered, and paginated list of all platform-wide
 * suspensions issued by administrators. This operation provides advanced search
 * and filtering capabilities for monitoring platform safety, reviewing
 * suspension history, analyzing suspension patterns, and managing active
 * suspensions across the entire platform.
 *
 * The operation queries the reddit_like_platform_suspensions table with support
 * for multiple filter criteria including suspension status (active, expired,
 * lifted), permanence type (temporary or permanent), member identifiers,
 * issuing administrator, date ranges, and reason categories. Results can be
 * sorted by various fields including creation date, expiration date, and member
 * username for flexible data exploration.
 *
 * This search functionality serves multiple administrative use cases.
 * Administrators monitoring platform health can filter for active suspensions
 * to see currently banned users. Historical analysis requires filtering by date
 * ranges to understand suspension trends over time. When reviewing specific
 * cases, administrators can filter by member ID or username to see a user's
 * complete suspension history across all incidents.
 *
 * Pagination support is essential given the potential for thousands of
 * suspension records as the platform scales. The operation returns paginated
 * results with configurable page sizes, total count metadata, and navigation
 * information. This enables efficient browsing through large suspension
 * datasets without performance degradation.
 *
 * Security considerations include strict role-based access control ensuring
 * only administrators can access suspension data, which contains sensitive
 * information about user violations and platform policy enforcement. The
 * operation integrates with the authentication system to verify administrator
 * credentials before processing requests.
 *
 * The response includes comprehensive suspension information from the
 * reddit_like_platform_suspensions table including suspension reasons,
 * durations, status, related member details, and audit timestamps. For each
 * suspension, the system provides the member username, suspension category,
 * detailed reason text, permanence flag, expiration date (if applicable),
 * active status, issuing administrator, and creation timestamp.
 *
 * This operation supports the administrator dashboard and moderation oversight
 * requirements specified in the Content Moderation and Reporting document,
 * enabling administrators to fulfill their platform governance responsibilities
 * through efficient suspension data access and analysis.
 *
 * @param props.connection
 * @param props.body Search criteria including filters for status, permanence,
 *   date ranges, member information, and pagination parameters
 * @path /redditLike/admin/platform/suspensions
 * @accessor api.functional.redditLike.admin.platform.suspensions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria including filters for status, permanence, date
     * ranges, member information, and pagination parameters
     */
    body: IRedditLikePlatformSuspension.IRequest;
  };
  export type Body = IRedditLikePlatformSuspension.IRequest;
  export type Response = IPageIRedditLikePlatformSuspension;

  export const METADATA = {
    method: "PATCH",
    path: "/redditLike/admin/platform/suspensions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/redditLike/admin/platform/suspensions";
  export const random = (): IPageIRedditLikePlatformSuspension =>
    typia.random<IPageIRedditLikePlatformSuspension>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific platform suspension.
 *
 * Retrieve comprehensive details about a platform-wide user suspension
 * identified by its unique suspension identifier. This operation provides
 * administrators with complete visibility into suspension records, including
 * the suspended member's identity, the administrator who issued the suspension,
 * the suspension reason category and detailed explanation, whether the
 * suspension is temporary or permanent, the expiration date for temporary
 * suspensions, and the current active status.
 *
 * This endpoint is critical for administrative oversight and transparency in
 * the platform's moderation system. Administrators use this operation to review
 * suspension decisions before handling appeals, verify that suspensions were
 * issued correctly with appropriate reasoning, and gather context when users
 * contact support about their suspended accounts.
 *
 * The suspension information integrates with the
 * reddit_like_platform_suspensions table as defined in the Prisma schema. The
 * response includes all suspension metadata such as suspension reason category
 * (repeated_violations, harassment, spam, hate_speech, illegal_content,
 * ban_evasion, other), the detailed suspension reason text that was
 * communicated to the user, internal notes visible only to administrators for
 * team context, and timestamps tracking when the suspension was issued and last
 * modified.
 *
 * Security considerations include restricting this endpoint to administrator
 * access only, as suspension details contain sensitive moderation information
 * and internal notes. The endpoint enforces authorization to ensure only
 * platform administrators can view suspension records. Suspended users cannot
 * access their own suspension details through this endpoint - they receive
 * suspension information through email notifications per the moderation
 * requirements.
 *
 * Related operations include the platform suspension creation endpoint (POST
 * /platform/suspensions) which administrators use to issue new suspensions, the
 * suspension appeal review endpoint where administrators handle user appeals,
 * and the moderation logs endpoint which provides the complete audit trail of
 * all suspension-related actions.
 *
 * @param props.connection
 * @param props.suspensionId Unique identifier of the platform suspension to
 *   retrieve
 * @path /redditLike/admin/platform/suspensions/:suspensionId
 * @accessor api.functional.redditLike.admin.platform.suspensions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the platform suspension to retrieve */
    suspensionId: string & tags.Format<"uuid">;
  };
  export type Response = IRedditLikePlatformSuspension;

  export const METADATA = {
    method: "GET",
    path: "/redditLike/admin/platform/suspensions/:suspensionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/platform/suspensions/${encodeURIComponent(props.suspensionId ?? "null")}`;
  export const random = (): IRedditLikePlatformSuspension =>
    typia.random<IRedditLikePlatformSuspension>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("suspensionId")(() => typia.assert(props.suspensionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Lift a platform suspension and restore user access.
 *
 * Remove an active platform suspension by setting the soft delete timestamp and
 * deactivating the suspension record. This operation restores the suspended
 * member's full access to the platform, allowing them to log in and participate
 * in all communities again. The suspension record is preserved in the database
 * through soft deletion to maintain the complete moderation audit trail and
 * suspension history.
 *
 * This endpoint is exclusively available to platform administrators who have
 * the authority to lift platform-wide suspensions. Administrators use this
 * operation in several scenarios: when handling successful appeals where the
 * suspension is overturned, when correcting suspension errors or mistaken
 * identity cases, when reducing penalties as part of partial appeal acceptance,
 * or when implementing early release for users who have demonstrated
 * rehabilitation.
 *
 * The operation updates the reddit_like_platform_suspensions table as defined
 * in the Prisma schema. When a suspension is lifted, the system sets the
 * deleted_at field to the current timestamp (implementing the soft delete
 * pattern present in the schema), updates the is_active field to false to
 * disable the suspension, and records the updated_at timestamp. The suspension
 * record remains in the database for historical tracking, audit compliance, and
 * pattern analysis of repeat offenders.
 *
 * Security and authorization considerations include strict administrator-only
 * access enforcement, logging of all suspension lift actions in the
 * reddit_like_moderation_logs table for accountability, and notification
 * requirements that inform the previously suspended user via email that their
 * access has been restored. The operation validates that the suspension exists
 * and is currently active before attempting to lift it.
 *
 * Related operations include the suspension retrieval endpoint (GET
 * /platform/suspensions/{suspensionId}) for viewing suspension details before
 * lifting, the suspension creation endpoint (POST /platform/suspensions) for
 * issuing new suspensions, the appeal review endpoint where administrators
 * decide whether to lift suspensions based on user appeals, and the moderation
 * logs endpoint which tracks all suspension lifecycle events including issuance
 * and lifting.
 *
 * Important business rules enforced by this operation include that lifted
 * suspensions cannot be reactivated (a new suspension must be issued instead),
 * all existing user sessions are invalidated when a suspension is lifted to
 * force fresh authentication, and the user receives notification of the
 * restoration within the notification SLA timeframe.
 *
 * @param props.connection
 * @param props.suspensionId Unique identifier of the platform suspension to
 *   lift
 * @path /redditLike/admin/platform/suspensions/:suspensionId
 * @accessor api.functional.redditLike.admin.platform.suspensions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the platform suspension to lift */
    suspensionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/redditLike/admin/platform/suspensions/:suspensionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/redditLike/admin/platform/suspensions/${encodeURIComponent(props.suspensionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("suspensionId")(() => typia.assert(props.suspensionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
