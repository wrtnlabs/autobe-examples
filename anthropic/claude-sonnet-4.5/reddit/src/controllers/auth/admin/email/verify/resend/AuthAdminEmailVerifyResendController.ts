import { Controller } from "@nestjs/common";
import { TypedRoute } from "@nestia/core";
import typia from "typia";
import { postAuthAdminEmailVerifyResend } from "../../../../../../providers/postAuthAdminEmailVerifyResend";
import { AdminAuth } from "../../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../../decorators/payload/AdminPayload";

import { IRedditLikeAdmin } from "../../../../../../api/structures/IRedditLikeAdmin";

@Controller("/auth/admin/email/verify/resend")
export class AuthAdminEmailVerifyResendController {
  /**
   * Resend email verification link to administrator.
   *
   * Generates and sends a new email verification link to the authenticated
   * administrator's registered email address when the original verification
   * link has expired or was not received. This endpoint enables administrators
   * to retry email verification if they did not complete verification within
   * the original 24-hour window or if the verification email was lost or
   * missed.
   *
   * The operation validates the administrator's authentication status by
   * verifying their JWT access token is valid, confirms they have admin role
   * permissions, and retrieves their account information from
   * reddit_like_admins table through the reddit_like_users relationship. The
   * system then checks the current email verification status in the
   * email_verified field - if the email is already verified (email_verified is
   * true), the system displays a message 'Your email address is already
   * verified' and does not send a new verification email.
   *
   * For administrators with unverified emails (email_verified is false), the
   * system generates a new cryptographically secure verification token using
   * secure random number generation and creates a fresh verification record in
   * reddit_like_email_verifications. The new record includes the
   * reddit_like_user_id linking to the admin's account, the current email
   * address from the email field, the newly generated unique
   * verification_token, verification_type set to 'registration' (or
   * 'email_change' if this is for a pending email change), expires_at timestamp
   * set to 24 hours from the current time per authentication requirements,
   * verified_at initially null, and created_at timestamp.
   *
   * Before creating the new verification record, the system invalidates any
   * previous pending verification tokens for the same administrator by either
   * deleting old verification records with the same reddit_like_user_id where
   * verified_at is null, or by allowing them to remain but ensuring the new
   * token supersedes them. This prevents accumulation of unused verification
   * tokens and ensures only the most recent token is valid.
   *
   * The system sends a new verification email to the administrator's registered
   * email address (retrieved from the email field in reddit_like_users)
   * containing a unique verification link with the newly generated token
   * embedded, explanation that this is a new verification link replacing any
   * previous links, instructions to click the link within 24 hours to verify
   * the email, and information about requesting another new link if needed. The
   * email is sent within 5 minutes of the resend request.
   *
   * Upon successful verification email sending, the system displays a
   * confirmation message 'A new verification email has been sent to your email
   * address. Please check your inbox and click the verification link within 24
   * hours.' The operation returns a response indicating the email was sent
   * successfully, though it does not expose whether the email address actually
   * exists in the system for security reasons.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async resendVerificationEmail(
    @AdminAuth()
    admin: AdminPayload,
  ): Promise<IRedditLikeAdmin.IResendVerificationResponse> {
    try {
      return await postAuthAdminEmailVerifyResend({
        admin,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
