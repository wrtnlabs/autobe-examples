import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postRedditLikeModeratorCommunitiesCommunityIdModerators } from "../../../../../providers/postRedditLikeModeratorCommunitiesCommunityIdModerators";
import { ModeratorAuth } from "../../../../../decorators/ModeratorAuth";
import { ModeratorPayload } from "../../../../../decorators/payload/ModeratorPayload";
import { getRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId } from "../../../../../providers/getRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId";
import { putRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId } from "../../../../../providers/putRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId";
import { deleteRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId } from "../../../../../providers/deleteRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId";

import { IRedditLikeCommunityModerator } from "../../../../../api/structures/IRedditLikeCommunityModerator";

@Controller("/redditLike/moderator/communities/:communityId/moderators")
export class RedditlikeModeratorCommunitiesModeratorsController {
  /**
   * Assign a new moderator to a community with specified permissions.
   *
   * Assign a new moderator to manage a specific community by creating a
   * moderator assignment record with customizable permission grants. This
   * operation enables existing community moderators with 'manage_moderators'
   * permission to expand their moderation team by inviting additional
   * moderators from the member base.
   *
   * The operation implements the moderator invitation workflow defined in the
   * Community Management requirements document section 5.2. When a moderator
   * invites a new moderator, the system verifies the invited user is a
   * registered member, ensures they are not already a moderator of this
   * community, and validates that the community has not reached the maximum
   * limit of 25 moderators. The inviting moderator can customize which specific
   * permissions to grant, choosing from manage_posts, manage_comments,
   * manage_users, manage_settings, manage_moderators, and access_reports.
   *
   * This operation references the reddit_like_community_moderators table which
   * tracks the many-to-many relationship between moderators and communities.
   * Each assignment record includes the moderator being assigned, the community
   * they are managing, who assigned them (for seniority tracking), the
   * timestamp of assignment (for seniority-based removal rules), whether they
   * are the primary moderator (always false for invited moderators), and the
   * JSON or comma-separated list of granted permissions.
   *
   * The default permission set for newly invited moderators includes
   * 'manage_posts', 'manage_comments', and 'access_reports' as specified in the
   * requirements, though the inviting moderator can customize this set during
   * the invitation. Primary moderators (community creators) automatically
   * receive all permissions and have irrevocable status, but this operation is
   * for inviting additional moderators, not creating communities.
   *
   * Authorization for this operation requires the requesting user to be an
   * authenticated moderator with 'manage_moderators' permission in the target
   * community, or a platform administrator who can manage moderators in any
   * community. The operation validates these permissions before allowing
   * moderator assignment to maintain proper community governance hierarchy.
   *
   * @param connection
   * @param communityId Unique identifier of the community where the new
   *   moderator is being assigned
   * @param body Moderator assignment information including the user to be
   *   assigned and their permission set
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IRedditLikeCommunityModerator.ICreate,
  ): Promise<IRedditLikeCommunityModerator> {
    try {
      return await postRedditLikeModeratorCommunitiesCommunityIdModerators({
        moderator,
        communityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed information about a specific moderator assignment in a
   * community.
   *
   * This operation retrieves comprehensive information about a specific
   * moderator assignment within a community. The endpoint accesses the
   * reddit_like_community_moderators junction table which manages the
   * many-to-many relationship between communities and their assigned
   * moderators.
   *
   * The response includes critical moderator assignment details such as the
   * moderator's unique identifier, the timestamp when they were assigned to the
   * community (assigned_at), whether they hold primary moderator status
   * indicated by the is_primary boolean field (community creator with
   * irrevocable permissions), and their granted permission set stored in the
   * permissions field (manage_posts, manage_comments, manage_users,
   * manage_settings, manage_moderators, access_reports).
   *
   * This operation is essential for community management workflows, enabling
   * moderators and administrators to review the moderator team composition,
   * understand permission distributions, and verify moderator credentials. The
   * information helps in making informed decisions about moderator role
   * changes, permission adjustments, or moderator removals based on seniority
   * tracked via the assigned_at timestamp field from the Prisma schema.
   *
   * Security considerations include restricting access to this endpoint to
   * authenticated users with appropriate permissions - typically current
   * community moderators who need to view the moderator team, or administrators
   * who oversee all communities. The endpoint enforces community-specific
   * scope, ensuring moderators can only view moderator details for communities
   * they manage.
   *
   * The endpoint integrates with the user roles and authentication system
   * defined in the requirements, enforcing role-based access control. It also
   * connects to the community management workflows, supporting the moderator
   * assignment and hierarchy features specified in the community management
   * requirements document.
   *
   * @param connection
   * @param communityId Unique identifier of the community whose moderator
   *   assignment information is being retrieved
   * @param moderatorId Unique identifier of the specific moderator assignment
   *   record in the reddit_like_community_moderators table
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":moderatorId")
  public async at(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("moderatorId")
    moderatorId: string & tags.Format<"uuid">,
  ): Promise<IRedditLikeCommunityModerator> {
    try {
      return await getRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId(
        {
          moderator,
          communityId,
          moderatorId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update moderator assignment permissions and details for a specific
   * moderator in a community.
   *
   * This operation updates the moderator assignment record for a specific
   * moderator within a community, enabling management of moderator permissions
   * and assignment attributes. The endpoint modifies records in the
   * reddit_like_community_moderators junction table which tracks community
   * moderator assignments with fields including community_id, moderator_id,
   * assigned_by_moderator_id, assigned_at, is_primary, and permissions.
   *
   * The primary use case is adjusting the permissions field which stores the
   * granted permissions for a moderator within a community. Per the community
   * management requirements section 5.3, moderators can have granular
   * permissions including manage_posts, manage_comments, manage_users,
   * manage_settings, manage_moderators, and access_reports. This endpoint
   * allows the primary moderator or moderators with 'manage_moderators'
   * permission to customize which permissions each moderator possesses by
   * updating the permissions string field.
   *
   * Authorization for this operation is carefully controlled per requirements
   * section 5.3. Only the primary moderator (where is_primary=true) can modify
   * permissions for any moderator, or moderators with the 'manage_moderators'
   * permission can adjust permissions for moderators who were assigned after
   * them based on the assigned_at timestamp (seniority-based permission model).
   * The endpoint enforces these business rules by validating the requesting
   * user's moderator status and permission set before allowing updates.
   *
   * The update operation cannot modify certain immutable fields as defined in
   * the Prisma schema including the community_id, moderator_id, is_primary
   * flag, assigned_at timestamp, or assigned_by_moderator_id references. These
   * fields establish the foundational moderator relationship and must remain
   * stable for referential integrity. Only the permissions string can be
   * modified through this endpoint to adjust the moderator's granted
   * capabilities.
   *
   * Security considerations include verifying the requesting user is a
   * moderator of the specified community, has appropriate permission levels to
   * modify other moderators per the seniority rules, and is not attempting to
   * escalate their own permissions or modify the primary moderator's
   * irrevocable permissions. The operation logs all permission changes for
   * audit trail purposes in the moderation logging system.
   *
   * This endpoint integrates with the community management system defined in
   * requirements document 03-community-management.md, supporting the moderator
   * hierarchy and permission management features specified in sections 5.3 and
   * 5.4. It enables the distributed moderation model where communities manage
   * their own moderator teams within platform guidelines.
   *
   * @param connection
   * @param communityId Unique identifier of the community containing the
   *   moderator assignment to update
   * @param moderatorId Unique identifier of the specific moderator assignment
   *   record in the reddit_like_community_moderators table to update
   * @param body Updated moderator assignment data including modified
   *   permissions string and any other editable attributes
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":moderatorId")
  public async update(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("moderatorId")
    moderatorId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IRedditLikeCommunityModerator.IUpdate,
  ): Promise<IRedditLikeCommunityModerator> {
    try {
      return await putRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId(
        {
          moderator,
          communityId,
          moderatorId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Remove a moderator from a community.
   *
   * Removes a moderator assignment from a specific community, immediately
   * revoking all their moderator permissions for that community. This operation
   * implements the community governance model where moderators can be removed
   * by authorized users based on seniority and permission hierarchies.
   *
   * The operation enforces strict authorization rules defined in the community
   * management requirements. Only the primary moderator (community creator) has
   * irrevocable permissions and can remove any other moderator from the
   * community. Additionally, moderators with 'manage_moderators' permission can
   * remove moderators who were assigned after them, implementing a
   * seniority-based removal system.
   *
   * When a moderator is removed, the system immediately revokes all their
   * moderator permissions for the specified community. The removed moderator
   * receives a notification informing them of the removal. However, their
   * status as a regular community member is retained - they remain subscribed
   * to the community unless they choose to unsubscribe manually. This ensures
   * that moderator removal doesn't forcibly disconnect users from communities
   * they care about.
   *
   * This operation is permanent and cannot be undone directly. If a moderator
   * is removed by mistake, they must be re-invited through the standard
   * moderator invitation workflow. The removal is logged in the moderation
   * system for audit trail purposes.
   *
   * The operation validates that the requesting user has appropriate
   * permissions to remove the specified moderator from the community. It also
   * verifies that the community exists and that the target moderator is
   * currently assigned to that community before processing the removal.
   *
   * @param connection
   * @param communityId Unique identifier of the community from which the
   *   moderator will be removed
   * @param moderatorId Unique identifier of the moderator to be removed from
   *   the community
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":moderatorId")
  public async erase(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("moderatorId")
    moderatorId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteRedditLikeModeratorCommunitiesCommunityIdModeratorsModeratorId(
        {
          moderator,
          communityId,
          moderatorId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
