import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { getRedditLikeCommunitiesCommunityIdSubscriptions } from "../../../../providers/getRedditLikeCommunitiesCommunityIdSubscriptions";

import { IPageIRedditLikeMember } from "../../../../api/structures/IPageIRedditLikeMember";

@Controller("/redditLike/communities/:communityId/subscriptions")
export class RedditlikeCommunitiesSubscriptionsController {
  /**
   * Retrieve paginated list of members subscribed to a specific community.
   *
   * Fetches the complete subscriber list for a specified community, returning
   * member summary information ordered by subscription date. This operation
   * provides visibility into community membership composition and supports
   * analytics about community growth and member demographics.
   *
   * The operation queries the reddit_like_community_subscriptions junction
   * table to identify all active subscriptions for the specified community. For
   * each subscription record, the system joins with the reddit_like_users table
   * to retrieve member profile information including username, total karma
   * (calculated from post_karma and comment_karma fields in the unified user
   * table), account creation date, and the timestamp when they subscribed to
   * this specific community.
   *
   * Access control is enforced based on community privacy settings defined in
   * section 8 of the Community Management Requirements. For public communities,
   * this information is accessible to all users including guests. For private
   * communities, only approved members of that community and community
   * moderators can view the subscriber list. The system validates the
   * requesting user's access rights before returning subscription data.
   *
   * The response includes member summary information optimized for list
   * displays rather than complete member profiles. Each subscriber entry
   * contains their username (for identification and navigation to profile),
   * total karma score (as a trust and reputation indicator), account age (to
   * distinguish veteran members from new joiners), and subscription timestamp
   * (showing when they joined the community). This data enables communities to
   * understand their member base demographics and growth patterns.
   *
   * Pagination is implemented to handle communities with large subscriber
   * counts efficiently. The system returns subscribers in reverse chronological
   * order by default (most recent subscribers first), allowing communities to
   * see their newest members. Alternative sorting options may include
   * alphabetical by username or by member karma score to identify
   * high-reputation community members.
   *
   * The operation integrates with the subscription tracking system defined in
   * section 4.4 of the Community Management Requirements. The subscriber count
   * displayed on the community page is denormalized in the
   * reddit_like_communities table for performance, while this endpoint provides
   * the detailed member-level subscription data by querying the normalized
   * reddit_like_community_subscriptions junction table.
   *
   * Performance considerations ensure that even communities with hundreds of
   * thousands of subscribers can return the first page of results within 2
   * seconds. The system uses efficient database indexing on the (community_id,
   * subscribed_at) compound index to enable fast retrieval and sorting of
   * subscription records.
   *
   * @param connection
   * @param communityId Unique identifier of the community whose subscriber list
   *   is being retrieved
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async index(
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
  ): Promise<IPageIRedditLikeMember.ISummary> {
    try {
      return await getRedditLikeCommunitiesCommunityIdSubscriptions({
        communityId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
