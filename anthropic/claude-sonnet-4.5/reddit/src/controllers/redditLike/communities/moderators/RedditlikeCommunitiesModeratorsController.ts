import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getRedditLikeCommunitiesCommunityIdModerators } from "../../../../providers/getRedditLikeCommunitiesCommunityIdModerators";
import { postRedditLikeCommunitiesCommunityIdModerators } from "../../../../providers/postRedditLikeCommunitiesCommunityIdModerators";
import { ModeratorAuth } from "../../../../decorators/ModeratorAuth";
import { ModeratorPayload } from "../../../../decorators/payload/ModeratorPayload";

import { IPageIRedditLikeCommunityModerator } from "../../../../api/structures/IPageIRedditLikeCommunityModerator";
import { IRedditLikeCommunityModerator } from "../../../../api/structures/IRedditLikeCommunityModerator";

@Controller("/redditLike/communities/:communityId/moderators")
export class RedditlikeCommunitiesModeratorsController {
  /**
   * Retrieve list of moderators assigned to a specific community.
   *
   * Retrieve a comprehensive list of all moderators currently assigned to
   * manage a specific community. This operation returns detailed information
   * about each moderator including their username, assigned permissions,
   * assignment timestamp, and whether they are the primary moderator (community
   * creator).
   *
   * This endpoint serves multiple use cases: allowing community members to
   * understand who manages their community for transparency and accountability,
   * enabling moderators to view the current moderation team structure, and
   * helping administrators audit community governance. The response includes
   * permission details showing which specific moderation capabilities each
   * moderator has been granted (such as manage_posts, manage_comments,
   * manage_users, manage_settings, manage_moderators, and access_reports).
   *
   * The operation leverages the reddit_like_community_moderators junction table
   * which tracks the many-to-many relationship between moderators and
   * communities. Each moderator assignment includes granular permission
   * settings, with primary moderators (community creators) having irrevocable
   * full permissions. The assignment timestamp enables seniority-based
   * permission rules where moderators can only remove moderators added after
   * them.
   *
   * This is a public read operation that does not require authentication,
   * supporting the platform's transparency principles. Community members,
   * potential subscribers, and visitors can review the moderation team to
   * understand community governance before participating.
   *
   * @param connection
   * @param communityId Unique identifier of the target community whose
   *   moderators are being retrieved
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async index(
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
  ): Promise<IPageIRedditLikeCommunityModerator> {
    try {
      return await getRedditLikeCommunitiesCommunityIdModerators({
        communityId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Assign a new moderator to a community with specified permissions.
   *
   * Assign a new moderator to manage a specific community by creating a
   * moderator assignment record with customizable permission grants. This
   * operation enables existing community moderators with 'manage_moderators'
   * permission or platform administrators to expand the moderation team by
   * inviting additional moderators from the member base.
   *
   * The operation implements the moderator invitation workflow defined in the
   * Community Management requirements document section 5.2. When a moderator or
   * administrator invites a new moderator, the system verifies the invited user
   * is a registered member, ensures they are not already a moderator of this
   * community, and validates that the community has not reached the maximum
   * limit of 25 moderators. The inviting moderator can customize which specific
   * permissions to grant, choosing from manage_posts, manage_comments,
   * manage_users, manage_settings, manage_moderators, and access_reports.
   *
   * This operation references the reddit_like_community_moderators table which
   * tracks the many-to-many relationship between moderators and communities.
   * Each assignment record includes the moderator being assigned, the community
   * they are managing, who assigned them (for seniority tracking), the
   * timestamp of assignment (for seniority-based removal rules), whether they
   * are the primary moderator (always false for invited moderators), and the
   * JSON or comma-separated list of granted permissions.
   *
   * The default permission set for newly invited moderators includes
   * 'manage_posts', 'manage_comments', and 'access_reports' as specified in the
   * requirements, though the inviting moderator or administrator can customize
   * this set during the invitation. Primary moderators (community creators)
   * automatically receive all permissions and have irrevocable status, but this
   * operation is for inviting additional moderators, not creating communities.
   *
   * Authorization for this operation requires the requesting user to be either
   * an authenticated moderator with 'manage_moderators' permission in the
   * target community, or a platform administrator who can manage moderators in
   * any community. The operation validates these permissions before allowing
   * moderator assignment to maintain proper community governance hierarchy.
   * Both moderators and administrators use the same endpoint, with role-based
   * business logic applied in the implementation.
   *
   * @param connection
   * @param communityId Unique identifier of the community where the new
   *   moderator is being assigned
   * @param body Moderator assignment information including the user to be
   *   assigned and their permission set
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IRedditLikeCommunityModerator.ICreate,
  ): Promise<IRedditLikeCommunityModerator> {
    try {
      return await postRedditLikeCommunitiesCommunityIdModerators({
        moderator,
        communityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
