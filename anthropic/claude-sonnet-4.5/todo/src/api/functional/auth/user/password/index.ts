import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../../structures/ITodoListUser";

/**
 * Change authenticated user password and invalidate all sessions for
 * todo_list_users table.
 *
 * Allows authenticated users to securely change their account password with
 * comprehensive security measures.
 *
 * This operation enables users to update their password while maintaining
 * strict security controls. The system validates the current password before
 * allowing changes, ensures the new password meets strength requirements, and
 * implements security measures to protect the account including session
 * invalidation across all devices. The password change workflow references the
 * password_hash field in todo_list_users table and manages associated refresh
 * tokens.
 *
 * The password change workflow executes these steps: authenticate the user via
 * JWT token validation, verify the provided current password matches the stored
 * password_hash using bcrypt comparison, validate the new password meets
 * security requirements (minimum 8 characters, contains letters and numbers,
 * not commonly weak password), ensure new password differs from current
 * password to prevent reuse, hash the new password using bcrypt with minimum
 * cost factor 12, update the password_hash field in todo_list_users table,
 * update the updated_at timestamp, invalidate all existing refresh tokens for
 * this user by setting revoked_at timestamp in todo_list_refresh_tokens table,
 * generate new JWT tokens for the current session, send notification email to
 * the user's email address confirming the password change, and return success
 * confirmation with new authentication tokens.
 *
 * Security implementations include current password verification using bcrypt
 * constant-time comparison, new password strength validation enforcing minimum
 * 8 characters with letters and numbers, prevention of password reuse by
 * comparing new against current, secure bcrypt hashing with cost factor 12 for
 * the new password, session invalidation across all devices by revoking all
 * refresh tokens (forces re-login everywhere for security), rate limiting to
 * prevent password change abuse, comprehensive logging of password change
 * events for audit trail, notification email to alert user of password change
 * for security awareness, and protection against concurrent password change
 * attempts.
 *
 * The operation returns HTTP 401 with error code PASSWORD_INCORRECT when
 * current password verification fails, HTTP 400 with error code WEAK_PASSWORD
 * when new password doesn't meet requirements, HTTP 400 with error code
 * PASSWORD_REUSED when new password matches current password, HTTP 400 for
 * missing required fields, and HTTP 200 with new authentication tokens on
 * success.
 *
 * The response includes success confirmation message, new JWT access token for
 * immediate use, new refresh token to replace invalidated ones, and timestamp
 * of the password change. All other active sessions (on other devices) are
 * invalidated and require re-login, enhancing security when passwords are
 * changed.
 *
 * This operation is critical for account security management and integrates
 * with the authentication security requirements. It ensures that password
 * changes are a conscious, verified action by the account owner and prevents
 * unauthorized access if the account was compromised. Users should use this
 * operation whenever they suspect their password may have been exposed or as
 * part of regular security hygiene.
 *
 * @param props.connection
 * @param props.body Current password verification and new password for account
 *   update
 * @path /auth/user/password
 * @accessor api.functional.auth.user.password.changePassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function changePassword(
  connection: IConnection,
  props: changePassword.Props,
): Promise<changePassword.Response> {
  return true === connection.simulate
    ? changePassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...changePassword.METADATA,
          path: changePassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace changePassword {
  export type Props = {
    /** Current password verification and new password for account update */
    body: ITodoListUser.IChangePassword;
  };
  export type Body = ITodoListUser.IChangePassword;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "PUT",
    path: "/auth/user/password",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/password";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: changePassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: changePassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
