import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListPasswordResetRequest } from "../../../../structures/ITodoListPasswordResetRequest";
import { ITodoListPasswordResetResponse } from "../../../../structures/ITodoListPasswordResetResponse";
import { ITodoListPasswordResetConfirm } from "../../../../structures/ITodoListPasswordResetConfirm";
import { ITodoListPasswordResetConfirmResponse } from "../../../../structures/ITodoListPasswordResetConfirmResponse";

/**
 * Request password reset for a user account.
 *
 * Initiates the password reset workflow for users who have forgotten their
 * password and need to regain access to their account. This operation provides
 * a secure mechanism for users to reset their credentials without requiring
 * authentication.
 *
 * When a user submits their email address, the system validates that an account
 * exists with that email in the todo_list_users table. If the account exists
 * and is active (deleted_at is null), the system generates a unique,
 * time-limited password reset token and sends it to the user's registered email
 * address. The reset link expires after 1 hour for security purposes.
 *
 * Security considerations include rate limiting to prevent abuse (maximum 3
 * reset requests per email per hour), protection against email enumeration
 * attacks by returning the same success message regardless of whether the email
 * exists, and secure token generation using cryptographically strong random
 * values. The operation logs all password reset requests for security
 * monitoring.
 *
 * The password reset token is single-use and becomes invalid once used or after
 * expiration. If a user requests multiple password resets, only the most recent
 * token remains valid. This operation does not require authentication since
 * users who need password reset cannot authenticate.
 *
 * Related operations: This operation must be followed by POST
 * /auth/password-reset/confirm to complete the password reset process. Users
 * receive the reset token via email and use it in the confirmation endpoint.
 *
 * @param props.connection
 * @param props.body Email address of the user account requesting password reset
 * @path /todoList/auth/password-reset/request
 * @accessor api.functional.todoList.auth.password_reset.request
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function request(
  connection: IConnection,
  props: request.Props,
): Promise<request.Response> {
  return true === connection.simulate
    ? request.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...request.METADATA,
          path: request.path(),
          status: null,
        },
        props.body,
      );
}
export namespace request {
  export type Props = {
    /** Email address of the user account requesting password reset */
    body: ITodoListPasswordResetRequest;
  };
  export type Body = ITodoListPasswordResetRequest;
  export type Response = ITodoListPasswordResetResponse;

  export const METADATA = {
    method: "POST",
    path: "/todoList/auth/password-reset/request",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/auth/password-reset/request";
  export const random = (): ITodoListPasswordResetResponse =>
    typia.random<ITodoListPasswordResetResponse>();
  export const simulate = (
    connection: IConnection,
    props: request.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: request.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Confirm password reset and set new password for user account.
 *
 * Completes the password reset workflow by validating the reset token and
 * updating the user's password to a new secure value. This operation is the
 * second step in the password reset process, following the initial reset
 * request.
 *
 * When a user submits the password reset token (received via email) along with
 * their new password, the system validates several security requirements.
 * First, it verifies the reset token is valid, not expired (tokens expire after
 * 1 hour), and has not been previously used. Second, it validates the new
 * password meets security requirements: minimum 8 characters, containing at
 * least one uppercase letter, one lowercase letter, and one number.
 *
 * If validation succeeds, the system updates the password_hash field in the
 * todo_list_users table using bcrypt with a minimum cost factor of 10. The
 * system then invalidates all existing user sessions for security by deleting
 * all associated records from the todo_list_refresh_tokens table, forcing the
 * user to log in again with their new password on all devices.
 *
 * Security measures include: the reset token is immediately invalidated after
 * use (even if password update fails), all previous reset tokens for that user
 * are invalidated, and a confirmation email is sent to the user's registered
 * email address notifying them of the password change. The operation logs all
 * password reset completions for security auditing.
 *
 * Error scenarios include expired tokens, invalid tokens, tokens that have
 * already been used, and passwords that don't meet security requirements. Each
 * error returns specific guidance to help users complete the process
 * successfully.
 *
 * Related operations: This operation must be preceded by POST
 * /auth/password-reset/request which sends the reset token to the user's email.
 * After successful password reset, users must use POST /auth/login with their
 * new credentials.
 *
 * @param props.connection
 * @param props.body Password reset token and new password for account recovery
 * @path /todoList/auth/password-reset/confirm
 * @accessor api.functional.todoList.auth.password_reset.confirm
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function confirm(
  connection: IConnection,
  props: confirm.Props,
): Promise<confirm.Response> {
  return true === connection.simulate
    ? confirm.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...confirm.METADATA,
          path: confirm.path(),
          status: null,
        },
        props.body,
      );
}
export namespace confirm {
  export type Props = {
    /** Password reset token and new password for account recovery */
    body: ITodoListPasswordResetConfirm;
  };
  export type Body = ITodoListPasswordResetConfirm;
  export type Response = ITodoListPasswordResetConfirmResponse;

  export const METADATA = {
    method: "POST",
    path: "/todoList/auth/password-reset/confirm",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/auth/password-reset/confirm";
  export const random = (): ITodoListPasswordResetConfirmResponse =>
    typia.random<ITodoListPasswordResetConfirmResponse>();
  export const simulate = (
    connection: IConnection,
    props: confirm.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: confirm.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
