import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListAuth } from "../../../../structures/ITodoListAuth";

/**
 * Refresh JWT access token using a valid refresh token.
 *
 * This operation allows users to obtain a new JWT access token when their
 * current access token has expired, using their valid refresh token. This is a
 * critical part of the authentication flow that enables seamless user
 * experience by avoiding frequent re-authentication.
 *
 * The operation validates the provided refresh token against the
 * todo_list_refresh_tokens table in the Prisma schema. It verifies that the
 * token exists, has not been revoked (revoked_at is null), and has not expired
 * (expires_at is after current time). The refresh token value is compared
 * against the stored token_hash using secure hashing comparison.
 *
 * When validation succeeds, the system generates a new JWT access token with
 * 30-minute expiration containing the user's userId, email, and role claims.
 * Optionally, the system may implement refresh token rotation by issuing a new
 * refresh token and invalidating the old one for enhanced security.
 *
 * Security considerations include rate limiting to prevent token refresh abuse,
 * secure token transmission over HTTPS only, and proper token validation to
 * prevent unauthorized access. The operation maintains referential integrity
 * with the todo_list_users table through the todo_list_user_id foreign key
 * relationship.
 *
 * This operation is essential for maintaining user sessions as defined in the
 * authentication requirements. It supports the 30-minute access token
 * expiration policy while providing a 30-day refresh token validity period,
 * balancing security with user convenience.
 *
 * Related operations include user login (which issues the initial token pair)
 * and logout (which revokes refresh tokens). This operation must be called
 * before the refresh token expires to maintain continuous access.
 *
 * @param props.connection
 * @param props.body Refresh token credentials for obtaining a new access token
 * @path /todoList/auth/token/refresh
 * @accessor api.functional.todoList.auth.token.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  return true === connection.simulate
    ? refresh.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...refresh.METADATA,
          path: refresh.path(),
          status: null,
        },
        props.body,
      );
}
export namespace refresh {
  export type Props = {
    /** Refresh token credentials for obtaining a new access token */
    body: ITodoListAuth.IRefreshTokenRequest;
  };
  export type Body = ITodoListAuth.IRefreshTokenRequest;
  export type Response = ITodoListAuth.ITokenResponse;

  export const METADATA = {
    method: "POST",
    path: "/todoList/auth/token/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/auth/token/refresh";
  export const random = (): ITodoListAuth.ITokenResponse =>
    typia.random<ITodoListAuth.ITokenResponse>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
