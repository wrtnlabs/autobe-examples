import { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { IPageITodoListRefreshToken } from "../../../../../../structures/IPageITodoListRefreshToken";
import { ITodoListSessionRevocationResult } from "../../../../../../structures/ITodoListSessionRevocationResult";

/**
 * Retrieve all active refresh token sessions for the authenticated user.
 *
 * Retrieve a comprehensive list of all active refresh token sessions associated
 * with the currently authenticated user's account. This operation provides
 * users with visibility into where and when they are logged in across different
 * devices and browsers, supporting security monitoring and session management
 * capabilities.
 *
 * The operation queries the todo_list_refresh_tokens table to find all refresh
 * tokens belonging to the authenticated user where revoked_at is null and
 * expires_at is in the future. Each session record includes the token
 * identifier, creation timestamp, expiration timestamp, and any metadata that
 * helps users identify the device or location of the session.
 *
 * This functionality supports the security requirement (REQ-AUTH-027) that
 * allows users to view their active sessions. By providing this visibility,
 * users can identify unauthorized access attempts and take action by revoking
 * suspicious sessions. The operation is essential for maintaining account
 * security and user control over authentication state.
 *
 * The response includes session details such as when each session was created,
 * when it will expire, and potentially device/browser information if captured
 * during token issuance. Sessions are returned in reverse chronological order
 * (newest first) to help users quickly identify recent login activity.
 *
 * Only the authenticated user can access their own sessions - the operation
 * enforces strict authorization by filtering results based on the user ID
 * extracted from the JWT access token. This ensures complete data isolation
 * between users as required by the security and privacy specifications.
 *
 * @param props.connection
 * @path /todoList/user/auth/user/sessions
 * @accessor api.functional.todoList.user.auth.user.sessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageITodoListRefreshToken;

  export const METADATA = {
    method: "GET",
    path: "/todoList/user/auth/user/sessions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/auth/user/sessions";
  export const random = (): IPageITodoListRefreshToken =>
    typia.random<IPageITodoListRefreshToken>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Revoke all active sessions and force logout from all devices.
 *
 * Permanently revoke all active refresh token sessions for the currently
 * authenticated user, forcing logout across all devices and browsers where the
 * user is currently logged in. This operation provides a critical security
 * feature allowing users to terminate all their sessions simultaneously,
 * typically used when a user suspects their account may be compromised or when
 * they want to ensure they are logged out everywhere.
 *
 * The operation updates all records in the todo_list_refresh_tokens table where
 * todo_list_user_id matches the authenticated user and revoked_at is null,
 * setting revoked_at to the current timestamp. This makes all existing refresh
 * tokens invalid, preventing them from being used to obtain new access tokens
 * even if they have not yet reached their expiration time.
 *
 * This functionality implements the security requirement (REQ-AUTH-029) that
 * states 'WHEN a user requests logout from all devices, THE system SHALL
 * invalidate all refresh tokens associated with that user.' By revoking all
 * tokens, the system ensures that any device attempting to use an old refresh
 * token will be denied and required to perform a fresh login with email and
 * password credentials.
 *
 * The operation is particularly important for security scenarios such as
 * password changes (where all sessions should be invalidated), suspected
 * unauthorized access, or when a user loses a device. After this operation
 * completes, the user will need to log in again on all devices to establish new
 * authenticated sessions.
 *
 * The operation affects only the authenticated user's sessions and cannot
 * impact other users' tokens, maintaining strict data isolation. The operation
 * returns a confirmation of how many sessions were revoked, providing
 * transparency about the action taken.
 *
 * @param props.connection
 * @path /todoList/user/auth/user/sessions
 * @accessor api.functional.todoList.user.auth.user.sessions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(connection: IConnection): Promise<erase.Response> {
  return true === connection.simulate
    ? erase.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(),
          status: null,
        },
      );
}
export namespace erase {
  export type Response = ITodoListSessionRevocationResult;

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/user/auth/user/sessions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/auth/user/sessions";
  export const random = (): ITodoListSessionRevocationResult =>
    typia.random<ITodoListSessionRevocationResult>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
