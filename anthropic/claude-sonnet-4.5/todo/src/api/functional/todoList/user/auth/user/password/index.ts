import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../../../../structures/ITodoListUser";

/**
 * Change authenticated user's password with current password verification.
 *
 * Allows authenticated users to update their account password securely. This
 * operation requires both the current password and the new password to complete
 * the change. The current password verification step ensures that only the
 * legitimate account owner can modify the password, preventing unauthorized
 * changes if someone gains temporary access to an authenticated session.
 *
 * The password change workflow operates on the todo_list_users table by
 * updating the password_hash field with a new bcrypt hash of the provided
 * password. The system uses bcrypt with a minimum cost factor of 12 to ensure
 * strong cryptographic security. The new password must meet all security
 * requirements defined in the authentication specifications: minimum 8
 * characters, containing at least one uppercase letter, one lowercase letter,
 * one number, and one special character.
 *
 * Security measures implemented in this operation include: (1) Current password
 * verification against the stored password_hash to confirm the user knows the
 * existing password, (2) Validation that the new password meets all complexity
 * requirements, (3) Ensuring the new password is different from the current
 * password, (4) Automatic revocation of all existing refresh tokens in the
 * todo_list_refresh_tokens table by setting their revoked_at timestamps,
 * forcing the user to log in again on all devices.
 *
 * When all refresh tokens are revoked, the user will be immediately logged out
 * from all active sessions across all devices. This is a critical security
 * feature because if an account has been compromised, changing the password
 * ensures that any attacker's session is immediately terminated. The user will
 * need to log in again with their new password to obtain fresh access and
 * refresh tokens.
 *
 * The operation also updates the updated_at timestamp in the todo_list_users
 * table to reflect when the password was last changed. Additionally, the system
 * sends a confirmation email to the user's registered email address notifying
 * them of the successful password change. This email notification serves as a
 * security alert - if the user did not initiate the password change, they can
 * take immediate action to secure their account.
 *
 * Business rules enforced: The current password must match the stored
 * password_hash. The new password must meet all validation requirements
 * (length, complexity). The new password must be different from the current
 * password. All of these rules are defined in the Business Rules document under
 * password management requirements.
 *
 * Related operations: After successfully changing the password, the user should
 * use the login operation to re-authenticate with their new credentials. This
 * operation works in conjunction with the password reset flow for users who
 * have forgotten their password.
 *
 * @param props.connection
 * @param props.body Password change request containing current password for
 *   verification and new password that meets security requirements
 * @path /todoList/user/auth/user/password
 * @accessor api.functional.todoList.user.auth.user.password.changePassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function changePassword(
  connection: IConnection,
  props: changePassword.Props,
): Promise<changePassword.Response> {
  return true === connection.simulate
    ? changePassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...changePassword.METADATA,
          path: changePassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace changePassword {
  export type Props = {
    /**
     * Password change request containing current password for verification
     * and new password that meets security requirements
     */
    body: ITodoListUser.IChangePassword;
  };
  export type Body = ITodoListUser.IChangePassword;
  export type Response = ITodoListUser.IPasswordChangeResponse;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/user/auth/user/password",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/auth/user/password";
  export const random = (): ITodoListUser.IPasswordChangeResponse =>
    typia.random<ITodoListUser.IPasswordChangeResponse>();
  export const simulate = (
    connection: IConnection,
    props: changePassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: changePassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
