import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodo } from "../../../../structures/ITodoListTodo";
import { IPageITodoListTodo } from "../../../../structures/IPageITodoListTodo";

/**
 * Create a new todo item for the authenticated user.
 *
 * Create a new todo item and add it to the authenticated user's personal todo
 * list. This operation is the primary method for users to capture and record
 * new tasks they need to complete.
 *
 * The operation accepts a todo title (required) and an optional description in
 * the request body. The title must be between 1 and 200 characters and contain
 * at least one non-whitespace character as per business validation rules
 * defined in the requirements. The description is optional but if provided must
 * not exceed 2000 characters.
 *
 * When a todo is successfully created, the system automatically performs
 * several operations: generates a unique UUID identifier for the todo, assigns
 * the currently authenticated user (extracted from the JWT token) as the owner
 * by setting the todo_list_user_id field, sets the completion status to false
 * (incomplete) by default, and records both the creation timestamp and initial
 * update timestamp with the current date and time.
 *
 * The operation enforces strict ownership and data isolation. Each todo is
 * exclusively associated with the user who created it, and the
 * todo_list_user_id field in the todo_list_todos table maintains this
 * relationship through a foreign key reference to todo_list_users.id. The
 * relationship is configured with CASCADE delete, meaning if a user account is
 * deleted, all their todos are automatically removed to maintain referential
 * integrity.
 *
 * Validation occurs before todo creation. If the title is empty, contains only
 * whitespace, or exceeds 200 characters, the system rejects the request with a
 * 400 Bad Request error and returns a clear validation error message.
 * Similarly, if the description exceeds 2000 characters, the request is
 * rejected with appropriate error feedback.
 *
 * Security measures include requiring valid JWT authentication before
 * processing the request (users must be logged in), extracting the user ID from
 * the validated JWT token payload to ensure correct ownership assignment, and
 * preventing unauthenticated guests from creating todos (returns 401
 * Unauthorized).
 *
 * Performance expectations require the operation to complete within 500
 * milliseconds from request receipt to response delivery as defined in the
 * performance requirements document. The system provides immediate feedback by
 * returning the complete newly created todo object including the
 * system-generated ID and timestamps.
 *
 * This operation is fundamental to the user workflow. After successful
 * registration or login, creating the first todo is typically the user's
 * initial interaction with the core functionality. The operation is designed to
 * be fast and simple, allowing users to quickly capture tasks as they arise
 * throughout their day without friction or complexity.
 *
 * @param props.connection
 * @param props.body Todo creation data including required title and optional
 *   description
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Todo creation data including required title and optional description */
    body: ITodoListTodo.ICreate;
  };
  export type Body = ITodoListTodo.ICreate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated list of user's todos from
 * todo_list_todos table.
 *
 * Retrieve a filtered and paginated list of todo items belonging to the
 * authenticated user. This operation provides advanced search and filtering
 * capabilities for the user's personal todo list, operating on the
 * todo_list_todos table with strict user isolation.
 *
 * The operation supports comprehensive filtering and search functionality to
 * help users find specific todos or view subsets of their task list. Users can
 * filter by completion status to view only incomplete or completed tasks,
 * search within todo titles and descriptions using text matching, and sort
 * results by various fields including creation date, update date, title, or
 * completion status. Pagination enables efficient handling of large todo lists,
 * returning results in manageable pages.
 *
 * Security considerations include strict enforcement of data isolation - the
 * system automatically filters todos to include only those where
 * todo_list_user_id matches the authenticated user's ID from the JWT token.
 * Users cannot access or search todos belonging to other users under any
 * circumstances. Rate limiting prevents abuse of search operations, and all
 * query parameters are validated to prevent injection attacks.
 *
 * This operation integrates with the todo_list_todos table as defined in the
 * Prisma schema, utilizing indexes on todo_list_user_id, created_at, completed,
 * and deleted_at fields for optimal query performance. The operation excludes
 * soft-deleted todos by filtering where deleted_at is null, ensuring users only
 * see their active todo items.
 *
 * The response includes todo summary information optimized for list displays:
 * id, title, description, completion status, creation timestamp, and last
 * update timestamp. Each response also includes pagination metadata showing
 * total count, current page, page size, and total pages to support client-side
 * pagination controls.
 *
 * Validation rules ensure search parameters are within acceptable ranges: page
 * numbers must be positive integers, page size is limited to prevent excessive
 * data retrieval (typically 50-100 items per page), sort fields must be valid
 * todo properties, and search text length is constrained to prevent performance
 * issues. The system provides clear error messages when validation fails.
 *
 * Expected behavior: Successful requests return a paginated list of todos
 * matching the search criteria, sorted according to the specified order
 * (defaulting to newest first by created_at). Empty result sets return
 * successfully with an empty data array and pagination metadata. Invalid search
 * parameters return validation errors with specific guidance on correcting the
 * request.
 *
 * @param props.connection
 * @param props.body Search criteria including filters, pagination, and sorting
 *   options for todo list retrieval
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria including filters, pagination, and sorting options
     * for todo list retrieval
     */
    body: ITodoListTodo.IRequest;
  };
  export type Body = ITodoListTodo.IRequest;
  export type Response = IPageITodoListTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): IPageITodoListTodo.ISummary =>
    typia.random<IPageITodoListTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific todo item.
 *
 * Retrieve the complete details of a single todo item by its unique identifier.
 * This operation returns all properties of the specified todo including the
 * title, optional description, completion status, creation timestamp, and last
 * modification timestamp.
 *
 * The operation enforces strict data isolation to ensure users can only access
 * their own todo items. When a user requests a todo by ID, the system verifies
 * that the authenticated user is the owner of the requested todo. If the user
 * attempts to access a todo owned by another user, the request is denied with a
 * 403 Forbidden error.
 *
 * This endpoint is commonly used after viewing the todo list when a user wants
 * to see full details of a specific task, or when the user interface needs to
 * display detailed todo information for editing or review purposes. The
 * operation is designed to respond quickly, typically within 300 milliseconds
 * as per performance requirements.
 *
 * Security considerations include verifying the JWT authentication token before
 * processing the request and ensuring the todo belongs to the authenticated
 * user. The operation will return appropriate error responses if the todo does
 * not exist (404 Not Found) or if the user lacks permission to access it (403
 * Forbidden).
 *
 * The response includes all todo fields as defined in the todo_list_todos
 * table: unique identifier, title (1-200 characters), optional description (up
 * to 2000 characters), completion status (boolean), creation timestamp, and
 * last updated timestamp. The operation supports the core user workflow of
 * reviewing task details and provides the foundation for subsequent edit or
 * status update operations.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo item to retrieve
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the todo item to retrieve */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing todo item with new title, description, or completion
 * status.
 *
 * Update an existing todo item in the user's personal task list. This operation
 * allows authenticated users to modify the title, description, and completion
 * status of their own todo items. The operation enforces strict ownership
 * verification - users can only update todos they created, ensuring complete
 * data isolation between different user accounts.
 *
 * The update process validates all input data according to business rules
 * defined in the requirements. The title must be between 1 and 200 characters
 * and contain at least one non-whitespace character. The description, when
 * provided, must not exceed 2000 characters. The completion status must be a
 * valid boolean value (true for completed, false for incomplete).
 *
 * When a todo is successfully updated, the system automatically updates the
 * updated_at timestamp to record when the modification occurred. The original
 * creation timestamp (created_at) remains unchanged, preserving the historical
 * record of when the todo was first created. This operation supports partial
 * updates - only the fields included in the request body will be modified,
 * while other fields retain their existing values.
 *
 * The operation returns the complete updated todo item upon success, including
 * all current field values and system-generated timestamps. If the specified
 * todo does not exist or belongs to another user, the operation returns an
 * appropriate error response. If the provided data fails validation (empty
 * title, title too long, description too long), the operation rejects the
 * request and returns detailed validation error information.
 *
 * This update operation is essential for the daily todo management workflow,
 * enabling users to refine task details, correct typos, add context through
 * descriptions, and manage their tasks effectively throughout their lifecycle.
 * The operation maintains data integrity by preventing cross-user data access
 * and enforcing all business validation rules defined in the requirements
 * documentation.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo item to update
 * @param props.body Updated todo information including title, description, and
 *   completion status
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the todo item to update */
    todoId: string & tags.Format<"uuid">;

    /**
     * Updated todo information including title, description, and completion
     * status
     */
    body: ITodoListTodo.IUpdate;
  };
  export type Body = ITodoListTodo.IUpdate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a todo item from the user's task list.
 *
 * Delete a todo item from the authenticated user's personal task list. This
 * operation allows users to remove todos they no longer need, whether completed
 * tasks they want to clear from their list or tasks that have become obsolete
 * or irrelevant. The operation implements soft delete functionality by setting
 * the deleted_at timestamp on the todo record, marking it as deleted while
 * preserving the data in the database for referential integrity and potential
 * recovery processes.
 *
 * The deletion process enforces strict ownership verification - users can only
 * delete todos they created. The system validates that the specified todo
 * exists and belongs to the authenticated user before proceeding with deletion.
 * If the todo does not exist or belongs to another user, the operation returns
 * an appropriate error response denying the deletion request.
 *
 * As per the Prisma schema, this table includes a deleted_at field, indicating
 * soft delete implementation. When a todo is deleted, the system sets the
 * deleted_at timestamp to the current date and time, marking the todo as
 * deleted. The todo is then excluded from normal query results and user views,
 * effectively removing it from the user's active todo list. However, the data
 * remains in the database to support data lifecycle management and maintain
 * referential integrity.
 *
 * The operation returns a success confirmation when the deletion completes
 * successfully. Deleted todos are immediately removed from the user's todo list
 * view and cannot be accessed through normal todo retrieval operations. Users
 * should be aware that deletion is permanent from their perspective - once
 * deleted, todos cannot be easily recovered through the user interface (though
 * the data is retained in the database with the deleted_at timestamp).
 *
 * This delete operation is essential for maintaining a clean, manageable todo
 * list. It enables users to remove completed tasks to reduce clutter, eliminate
 * outdated or cancelled tasks, and keep their task list focused on current,
 * actionable items. The soft delete approach supports data management
 * requirements while providing a clean user experience where deleted items
 * disappear from view immediately.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the todo item to delete
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the todo item to delete */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
