import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postDiscussionBoardMemberUsersUserIdFavorites } from "../../../../../providers/postDiscussionBoardMemberUsersUserIdFavorites";
import { MemberAuth } from "../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../decorators/payload/MemberPayload";
import { patchDiscussionBoardMemberUsersUserIdFavorites } from "../../../../../providers/patchDiscussionBoardMemberUsersUserIdFavorites";
import { deleteDiscussionBoardMemberUsersUserIdFavoritesFavoriteId } from "../../../../../providers/deleteDiscussionBoardMemberUsersUserIdFavoritesFavoriteId";

import { IDiscussionBoardFavorite } from "../../../../../api/structures/IDiscussionBoardFavorite";
import { IPageIDiscussionBoardTopic } from "../../../../../api/structures/IPageIDiscussionBoardTopic";

@Controller("/discussionBoard/member/users/:userId/favorites")
export class DiscussionboardMemberUsersFavoritesController {
  /**
   * Add a discussion topic to a user's favorites/bookmarks collection.
   *
   * Create a new favorite/bookmark record for a specific user on a discussion
   * topic. This operation allows members to save important or interesting
   * discussions on economic and political subjects for easy access and future
   * reference.
   *
   * The operation creates a record in the discussion_board_favorites table,
   * establishing a relationship between the user (discussion_board_member_id)
   * and a discussion topic (discussion_board_topic_id). Each favorite record
   * captures when the bookmark was created, enabling chronological organization
   * of saved content.
   *
   * Security considerations require verifying that the authenticated user
   * matches the userId in the path parameter, preventing users from creating
   * favorites on behalf of other users. The operation validates that the
   * requesting user is a registered, authenticated member with active account
   * status.
   *
   * The operation validates that the target discussion topic exists in the
   * discussion_board_topics table and is accessible to the user (not deleted,
   * not restricted by permissions). It also enforces the unique constraint that
   * prevents duplicate favorites - users cannot favorite the same topic
   * multiple times.
   *
   * The request body contains the topic_id of the discussion to be favorited.
   * The operation performs referential integrity validation to ensure the
   * topic_id references a valid, existing discussion topic. If the topic does
   * not exist or has been deleted, the operation returns an appropriate error.
   *
   * Business rules from the requirements allow users to maintain unlimited
   * favorites, though the platform may implement soft limits in the future. The
   * operation supports soft deletion via the deleted_at timestamp field,
   * allowing recovery of accidentally removed bookmarks within a recovery
   * window.
   *
   * The response returns the created favorite record including the unique
   * favorite ID, topic information, and creation timestamp. This enables the
   * client to immediately update the UI to reflect the favorited state and add
   * the topic to the user's favorites collection.
   *
   * This operation integrates with the engagement system by recording user
   * interest in specific topics. Favorited topics may receive special treatment
   * in personalized recommendations and notification preferences, allowing
   * users to track updates on discussions they've explicitly bookmarked.
   *
   * @param connection
   * @param userId Unique identifier of the user who is favoriting the
   *   discussion topic
   * @param body Information about the discussion topic to be added to user's
   *   favorites, including the topic identifier
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IDiscussionBoardFavorite.ICreate,
  ): Promise<IDiscussionBoardFavorite> {
    try {
      return await postDiscussionBoardMemberUsersUserIdFavorites({
        member,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a filtered, paginated list of discussion topics favorited by a
   * specific user.
   *
   * Retrieve a comprehensive, filtered, and paginated list of discussion topics
   * that a user has bookmarked or favorited for later reference. This operation
   * provides members with powerful tools to organize and rediscover their saved
   * economic and political discussions.
   *
   * The operation queries the discussion_board_favorites table, joining with
   * discussion_board_topics to return complete topic information including
   * title, content preview, category, tags, vote scores, reply counts, and
   * author information. This enables users to maintain a personal library of
   * valuable discussions they want to revisit.
   *
   * Security considerations include verifying that the requesting user has
   * permission to view the specified user's favorites. By default, favorites
   * are private (visible only to the owner), but users can optionally make
   * their favorites public through privacy settings defined in the
   * discussion_board_members table. The operation must respect the
   * activity_visibility field when determining access permissions.
   *
   * The operation supports comprehensive filtering options including search by
   * topic title or content, filtering by category or tags, date range filtering
   * (when favorited), and filtering by topic status (active, archived). This
   * helps users efficiently locate specific favorited discussions within large
   * bookmark collections.
   *
   * Sorting capabilities include ordering by date favorited (newest first or
   * oldest first), topic creation date, recent activity on the topic, vote
   * score, or reply count. This flexibility allows users to organize their
   * favorites based on different discovery and research needs.
   *
   * Pagination is essential for users with extensive favorite collections, with
   * configurable page sizes. The response includes pagination metadata (total
   * count, page number, page size) to support client-side pagination controls.
   *
   * This operation integrates with the voting and engagement system by
   * including current vote scores and engagement metrics for each favorited
   * topic. It also integrates with the discussion management system to provide
   * complete topic metadata including category assignment, tag associations,
   * and current topic status.
   *
   * @param connection
   * @param userId Unique identifier of the user whose favorited topics are
   *   being retrieved
   * @param body Search criteria, filtering options, sorting preferences, and
   *   pagination parameters for retrieving user's favorited discussions
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IDiscussionBoardFavorite.IRequest,
  ): Promise<IPageIDiscussionBoardTopic.ISummary> {
    try {
      return await patchDiscussionBoardMemberUsersUserIdFavorites({
        member,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Remove a bookmarked discussion from user's favorites collection.
   *
   * This operation allows authenticated users to remove a previously bookmarked
   * discussion topic from their favorites collection. When a user unfavorites a
   * topic, the favorite record is soft deleted from the
   * discussion_board_favorites table, marking it with a deleted_at timestamp
   * while preserving the record for potential recovery during the 30-day
   * recovery window as specified in the platform policy.
   *
   * The operation validates that the favorite record exists, belongs to the
   * authenticated user, and has not already been deleted. Users can only delete
   * their own favorites - attempting to delete another user's favorite will
   * result in a permission error. The favoriteId parameter must reference a
   * valid favorite record in the discussion_board_favorites table that is
   * currently active (deleted_at is null).
   *
   * Security considerations include verifying that the authenticated user's ID
   * matches the userId path parameter to prevent unauthorized deletion of other
   * users' favorites. The operation respects the soft deletion pattern, setting
   * the deleted_at timestamp rather than permanently removing the record from
   * the database. This soft delete approach supports the platform's 30-day
   * recovery window and maintains data integrity for audit purposes.
   *
   * This operation is the inverse of creating a favorite and works in
   * conjunction with the GET or PATCH endpoints that list favorited
   * discussions. After successful deletion, the removed topic will no longer
   * appear in the user's favorites list but can be favorited again if desired,
   * as the system filters out records with non-null deleted_at timestamps in
   * normal queries.
   *
   * Upon successful deletion, the operation returns no response body, following
   * REST conventions for DELETE operations. The client should update the UI to
   * reflect the removal of the bookmarked topic from the favorites collection.
   * If the favorite record does not exist or has already been deleted, the
   * operation should return an appropriate error response.
   *
   * @param connection
   * @param userId Unique identifier of the user whose favorite is being removed
   * @param favoriteId Unique identifier of the favorite record to be removed
   *   from the user's collection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":favoriteId")
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedParam("favoriteId")
    favoriteId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteDiscussionBoardMemberUsersUserIdFavoritesFavoriteId({
        member,
        userId,
        favoriteId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
