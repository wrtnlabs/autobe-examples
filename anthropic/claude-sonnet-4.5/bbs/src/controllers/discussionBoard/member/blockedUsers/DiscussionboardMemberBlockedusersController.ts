import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { deleteDiscussionBoardMemberBlockedUsersBlockedUserId } from "../../../../providers/deleteDiscussionBoardMemberBlockedUsersBlockedUserId";
import { MemberAuth } from "../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../decorators/payload/MemberPayload";

@Controller("/discussionBoard/member/blockedUsers/:blockedUserId")
export class DiscussionboardMemberBlockedusersController {
  /**
   * Remove a user blocking relationship to unblock a previously blocked user.
   *
   * Removes an existing user blocking relationship by performing a soft delete
   * on the discussion_board_blocked_users record, allowing the authenticated
   * user to once again see content from and receive notifications from the
   * previously blocked user. This operation sets the deleted_at timestamp to
   * preserve the block history for audit purposes while immediately restoring
   * content visibility.
   *
   * When a user unblocks another user, the system marks the blocking
   * relationship as deleted by setting the deleted_at timestamp on the
   * discussion_board_blocked_users record. This soft deletion approach
   * preserves the historical record of the blocking relationship for audit
   * trail and analytics purposes while immediately changing the user's
   * experience. The previously blocked user's topics, replies, and other
   * content become visible again throughout the platform, and the user who
   * performed the unblock will resume receiving notifications from the
   * previously blocked user according to their notification preference
   * settings.
   *
   * The operation uses the authenticated user's ID from the JWT token as the
   * blocker_id when querying for the block record, eliminating the need for a
   * userId path parameter and preventing authorization bypass vulnerabilities.
   * The system validates that an active (non-deleted) blocking relationship
   * exists between the authenticated user and the specified blocked user before
   * attempting the soft delete. If no active block relationship exists, the
   * operation returns an error indicating the block was not found.
   *
   * This operation is part of the user privacy and interaction control features
   * defined in the User Profiles and Preferences requirements. Users can manage
   * their blocked users list through their profile settings, with a maximum of
   * 100 blocked users per account. The business rules enforce a limit of 3
   * block/unblock cycles per user pair per day to prevent abuse of the blocking
   * system. Soft-deleted block records are retained for 30 days to support
   * recovery in case of accidental unblock or for audit purposes, after which
   * they may be permanently removed during database cleanup operations.
   *
   * Security considerations include verifying the authenticated user's identity
   * through JWT token validation and ensuring users cannot manipulate other
   * users' blocking relationships. The operation enforces role-based access
   * control where only the blocker themselves can remove their own blocks. The
   * system checks that the deleted_at field is currently null (indicating an
   * active block) before performing the soft delete to prevent duplicate
   * operations.
   *
   * After successful soft delete, users may immediately see the previously
   * blocked user's content in discussion threads and search results. The change
   * takes effect instantly without requiring page refresh for real-time
   * interfaces, though cached content may take a few moments to update. The
   * discussion_board_blocked_users record remains in the database with
   * deleted_at set to the current timestamp, supporting audit queries and
   * preventing complete loss of blocking history.
   *
   * @param connection
   * @param blockedUserId Unique identifier of the user who is being unblocked
   *   (the blocked user)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("blockedUserId")
    blockedUserId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteDiscussionBoardMemberBlockedUsersBlockedUserId({
        member,
        blockedUserId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
