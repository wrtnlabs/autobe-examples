import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthModeratorJoin } from "../../../providers/postAuthModeratorJoin";
import { postAuthModeratorLogin } from "../../../providers/postAuthModeratorLogin";
import { postAuthModeratorRefresh } from "../../../providers/postAuthModeratorRefresh";

import { IDiscussionBoardModerator } from "../../../api/structures/IDiscussionBoardModerator";

@Controller("/auth/moderator")
export class AuthModeratorController {
  /**
   * Register new moderator account and receive JWT tokens.
   *
   * Creates a new moderator account in the discussion_board_moderators table
   * after validating registration inputs against business rules. The
   * registration requires unique username (3-30 characters, alphanumeric with
   * hyphens/underscores), unique email address (valid format), and secure
   * password meeting complexity requirements (minimum 8 characters with
   * uppercase, lowercase, number, special character). The system hashes the
   * password using bcrypt with cost factor 12 before storage, ensuring
   * passwords are never stored in plain text.
   *
   * Upon successful registration, the operation generates JWT authentication
   * tokens following the platform's token strategy. An access token with
   * 30-minute expiration is created for immediate API authentication, along
   * with a refresh token (7-30 day expiration) for obtaining new access tokens
   * without re-authentication. Both tokens include the moderator's user ID,
   * username, email, role designation, and granted permissions in the JWT
   * payload.
   *
   * The operation sets initial account status to 'pending_verification' until
   * email verification completes, and email_verified to false. The
   * appointed_by_admin_id references the administrator who initiated the
   * moderator appointment. The system records the appointment timestamp, device
   * information, and sets is_active to true for immediate moderation queue
   * access.
   *
   * This operation integrates with the authentication system defined in the
   * User Roles and Authentication document, implementing role-based access
   * control for moderators who inherit all member permissions plus moderation
   * capabilities including content review, warning issuance, and temporary
   * suspensions. Registration data is validated according to Business Rules and
   * Validation requirements, and all security measures from Performance and
   * Security requirements are enforced.
   *
   * The response includes the complete moderator profile with role information,
   * permission grants, and token credentials required for subsequent
   * authenticated API operations. This operation is essential for moderator
   * onboarding and represents the entry point for trusted community members to
   * access moderation tools and maintain discourse standards across economic
   * and political discussions.
   *
   * @param connection
   * @param body Registration information including appointed administrator
   *   reference, unique username, verified email address, secure password
   *   meeting complexity requirements, optional display name and bio, and
   *   account configuration
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IDiscussionBoardModerator.ICreate,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await postAuthModeratorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate moderator credentials and issue JWT tokens.
   *
   * Validates moderator login credentials against the
   * discussion_board_moderators table and issues JWT authentication tokens upon
   * successful verification. The operation accepts either email address or
   * username along with the password, retrieves the moderator account, and
   * performs comprehensive validation checks before granting access.
   *
   * The authentication process verifies multiple account state conditions from
   * the Prisma schema: confirms the account exists in the moderators table,
   * validates email_verified is true (required for moderation duties per
   * schema), compares the submitted password against the stored password_hash
   * using bcrypt constant-time comparison, checks account_status is 'active'
   * (not suspended or deactivated), and ensures is_active is true (moderator
   * privileges are enabled). Any failed validation results in authentication
   * denial with appropriate error messaging.
   *
   * Upon successful credential validation, the system generates JWT tokens
   * following the platform's authentication strategy defined in the User Roles
   * and Authentication document. An access token with 30-minute expiration is
   * created containing the moderator's user ID, username, email, role
   * designation ('moderator'), and specific permissions array in the JWT
   * payload. A refresh token with 7-30 day expiration (extended for 'Remember
   * Me' functionality) is generated for obtaining new access tokens without
   * re-authentication.
   *
   * The operation creates a new session record in discussion_board_sessions
   * table with the access_token_hash, device_type, browser_info, ip_address,
   * approximate location, and activity timestamps. A corresponding refresh
   * token record is created in discussion_board_refresh_tokens linked to the
   * session. The login attempt is logged in discussion_board_login_history with
   * success status, device information, and timestamp for security audit
   * trail.
   *
   * Security measures are enforced per Performance and Security requirements:
   * failed login attempts are tracked and trigger progressive protections
   * including CAPTCHA after 3 failures and 15-minute account lockout after 5
   * failures within 15 minutes. The system logs all authentication events in
   * discussion_board_security_logs for monitoring suspicious patterns like
   * brute force attacks or credential stuffing attempts.
   *
   * This operation is essential for moderator access to the moderation queue,
   * content review tools, warning issuance capabilities, and user suspension
   * features. Successful login enables moderators to perform their duties
   * maintaining civil discourse standards across economic and political
   * discussions as specified in the Moderation System requirements.
   *
   * @param connection
   * @param body Login credentials containing email address or username and
   *   password for authentication, with optional 'remember me' flag for
   *   extended refresh token expiration
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IDiscussionBoardModerator.ILogin,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await postAuthModeratorLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh access token using valid refresh token.
   *
   * Validates the provided refresh token and issues a new access token to
   * maintain moderator session continuity without requiring credential
   * re-entry. This operation is essential for user experience during extended
   * moderation sessions, allowing seamless access token renewal when the
   * 30-minute access token expires while the moderator is actively reviewing
   * content in the moderation queue.
   *
   * The refresh process performs comprehensive validation against the
   * discussion_board_refresh_tokens table in the Prisma schema. The system
   * verifies the submitted refresh_token_hash matches a stored token, confirms
   * the token expires_at timestamp has not passed, validates is_revoked is
   * false (token has not been invalidated), and retrieves the associated
   * session from discussion_board_sessions via the discussion_board_session_id
   * foreign key relationship. The session's is_active status must be true, and
   * the session must not have been revoked (revoked_at is null).
   *
   * Through the session relationship, the system accesses the moderator account
   * from discussion_board_moderators table and validates account state:
   * account_status must be 'active' (not suspended or deactivated), is_active
   * must be true (moderator privileges enabled), and email_verified must be
   * true. If the moderator account has been suspended, banned, or had
   * privileges revoked since the refresh token was issued, the refresh
   * operation fails and requires fresh authentication.
   *
   * Upon successful validation, the system generates a new JWT access token
   * with 30-minute expiration containing the moderator's current user ID,
   * username, email, role designation ('moderator'), and up-to-date permissions
   * array reflecting any permission changes since original login. The new
   * access token enables continued API authentication for moderation
   * operations.
   *
   * The operation may implement refresh token rotation as a security best
   * practice: generating a new refresh token with extended expiration, marking
   * the old refresh token as revoked by setting is_revoked to true and
   * recording revoked_at timestamp, and returning both new access and refresh
   * tokens. This rotation strategy limits the window of vulnerability if a
   * refresh token is compromised.
   *
   * The refresh operation updates the session's last_activity_at timestamp in
   * discussion_board_sessions to track active moderation sessions. If the
   * moderator account has last_activity_at tracking, this is also updated to
   * reflect continued platform engagement. All token refresh events are logged
   * in discussion_board_security_logs with event_type 'token_refreshed' for
   * security monitoring and audit compliance.
   *
   * This operation integrates with the JWT token management strategy defined in
   * the User Roles and Authentication document, supporting the stateless
   * authentication architecture while enabling long-lived sessions through
   * refresh token mechanics. It prevents the poor user experience of frequent
   * login prompts during active moderation work while maintaining security
   * through short-lived access tokens and revocable refresh tokens.
   *
   * @param connection
   * @param body Refresh token request containing the current valid refresh
   *   token to be exchanged for a new access token
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IDiscussionBoardModerator.IRefresh,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await postAuthModeratorRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
