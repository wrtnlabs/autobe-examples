import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAdministrator } from "../../../structures/IDiscussionBoardAdministrator";
export * as password from "./password/index";

/**
 * Register a new administrator account with platform control privileges.
 *
 * Creates a new administrator account with full platform control and
 * administrative privileges. This operation is the entry point for onboarding
 * new administrative staff who will manage the discussion board platform.
 *
 * The registration process collects essential administrator credentials
 * including username (3-30 characters, alphanumeric with hyphens and
 * underscores), email address (must be unique and verifiable), and password
 * meeting security requirements (minimum 8 characters with uppercase,
 * lowercase, number, and special character). The username and email fields
 * reference the discussion_board_administrators table schema which defines
 * these as unique fields requiring verification.
 *
 * Upon successful registration, the system creates a new administrator record
 * in the discussion_board_administrators table with account_status set to
 * 'pending_verification' initially, and email_verified set to false. A
 * verification email is sent to the provided email address containing a
 * time-limited verification token. The administrator must verify their email
 * before gaining full access to administrative functions.
 *
 * Security considerations for administrator registration include enhanced
 * password requirements, potential IP whitelisting for administrator
 * registration endpoints, and audit logging of all administrator account
 * creation events in the discussion_board_audit_logs and
 * discussion_board_security_logs tables. Administrator registration is a
 * high-sensitivity operation that should be restricted or require approval from
 * existing super administrators in production environments.
 *
 * The response includes JWT tokens (access token and refresh token) following
 * the authentication token structure defined in the discussion_board_sessions
 * and discussion_board_refresh_tokens tables. The access token expires after 30
 * minutes and the refresh token expires after 7-30 days depending on 'Remember
 * Me' preferences. These tokens enable the newly registered administrator to
 * authenticate for subsequent administrative operations once email verification
 * is complete.
 *
 * @param props.connection
 * @param props.body Administrator registration credentials including unique
 *   username, verified email address, and secure password meeting complexity
 *   requirements
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/join
 * @accessor api.functional.auth.administrator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Administrator registration credentials including unique username,
     * verified email address, and secure password meeting complexity
     * requirements
     */
    body: IDiscussionBoardAdministrator.ICreate;
  };
  export type Body = IDiscussionBoardAdministrator.ICreate;
  export type Response = IDiscussionBoardAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/join";
  export const random = (): IDiscussionBoardAdministrator.IAuthorized =>
    typia.random<IDiscussionBoardAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate administrator and issue access tokens.
 *
 * Authenticates an existing administrator account by validating credentials and
 * issuing JWT access and refresh tokens for administrative session management.
 *
 * The login process accepts either the administrator's unique email address or
 * username along with their password. The system retrieves the administrator
 * record from the discussion_board_administrators table, verifies the account
 * exists and has account_status set to 'active', checks that email_verified is
 * true, and validates the submitted password against the stored password_hash
 * using bcrypt comparison with minimum cost factor 12.
 *
 * Security measures include comprehensive logging of all login attempts in the
 * discussion_board_login_history table with fields capturing email_attempted,
 * is_successful status, failure_reason for failed attempts, ip_address,
 * device_type, browser_info, and location for security analysis. The system
 * implements account lockout protection: after 5 consecutive failed login
 * attempts within 15 minutes, the account is temporarily locked for 30 minutes
 * and the administrator receives an email notification about the lockout
 * event.
 *
 * Upon successful authentication, the system generates a new session record in
 * the discussion_board_sessions table with discussion_board_administrator_id
 * referencing the authenticated administrator, access_token_hash containing the
 * hashed JWT access token, device_type, browser_info, ip_address, and location
 * extracted from the request context. The session expires_at timestamp is set
 * to 30 minutes from issuance for the access token. Simultaneously, a refresh
 * token record is created in discussion_board_refresh_tokens with the session
 * reference, refresh_token_hash, and expires_at set to 7-30 days based on
 * Remember Me preference.
 *
 * The response contains the JWT tokens following the
 * IDiscussionBoardAdministrator.IAuthorized format, enabling the administrator
 * to access protected administrative endpoints including user management,
 * moderator appointment via the discussion_board_moderators table, category
 * management in discussion_board_categories, system configuration, moderation
 * oversight through discussion_board_moderation_actions, and comprehensive
 * audit log access across discussion_board_audit_logs,
 * discussion_board_security_logs, and discussion_board_moderation_audit_logs
 * tables.
 *
 * @param props.connection
 * @param props.body Administrator login credentials containing email or
 *   username and password for authentication
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/login
 * @accessor api.functional.auth.administrator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Administrator login credentials containing email or username and
     * password for authentication
     */
    body: IDiscussionBoardAdministrator.ILogin;
  };
  export type Body = IDiscussionBoardAdministrator.ILogin;
  export type Response = IDiscussionBoardAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/login";
  export const random = (): IDiscussionBoardAdministrator.IAuthorized =>
    typia.random<IDiscussionBoardAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh administrator access token using valid refresh token.
 *
 * Renews the administrator's access token using a valid refresh token,
 * extending the authenticated session without requiring credential re-entry.
 *
 * The token refresh process accepts the current refresh token (typically stored
 * in httpOnly cookie or secure storage) and validates it against the
 * discussion_board_refresh_tokens table. The system verifies the
 * refresh_token_hash matches an existing record, checks that is_revoked is
 * false, confirms the expires_at timestamp has not passed (standard expiration
 * is 7-30 days based on Remember Me preference), and validates the associated
 * session in discussion_board_sessions is still active with is_active set to
 * true.
 *
 * The system retrieves the administrator account via the session's
 * discussion_board_administrator_id foreign key, verifies the account_status is
 * 'active' in the discussion_board_administrators table, and confirms the
 * account has not been suspended or banned. Any account status changes
 * (suspension, ban, role revocation) invalidate all existing tokens and prevent
 * refresh token usage.
 *
 * Upon successful validation, the system generates a new JWT access token with
 * expires_at set to 30 minutes from issuance, updates the session's
 * last_activity_at timestamp in discussion_board_sessions to reflect ongoing
 * administrator activity, and optionally implements refresh token rotation by
 * generating a new refresh token and marking the old one as is_revoked true for
 * enhanced security.
 *
 * The response returns fresh JWT tokens in the
 * IDiscussionBoardAdministrator.IAuthorized format containing the new access
 * token and optionally a new refresh token if rotation is enabled. This
 * mechanism enables administrators to maintain long-running authenticated
 * sessions for administrative tasks without security degradation, while the
 * relatively short access token lifetime (30 minutes) limits the window of
 * vulnerability if a token is compromised.
 *
 * Security considerations include comprehensive logging of token refresh events
 * in discussion_board_security_logs with event_type 'token_refresh', tracking
 * ip_address and user_agent for anomaly detection, and implementing refresh
 * token rotation policies that invalidate old refresh tokens after successful
 * refresh operations to prevent token replay attacks.
 *
 * @param props.connection
 * @param props.body Refresh token request containing the current valid refresh
 *   token for generating a new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/refresh
 * @accessor api.functional.auth.administrator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing the current valid refresh token for
     * generating a new access token
     */
    body: IDiscussionBoardAdministrator.IRefresh;
  };
  export type Body = IDiscussionBoardAdministrator.IRefresh;
  export type Response = IDiscussionBoardAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/refresh";
  export const random = (): IDiscussionBoardAdministrator.IAuthorized =>
    typia.random<IDiscussionBoardAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
