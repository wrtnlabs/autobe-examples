import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardModerator } from "../../../structures/IDiscussionBoardModerator";

/**
 * Register new moderator account and receive JWT tokens.
 *
 * Creates a new moderator account in the discussion_board_moderators table
 * after validating registration inputs against business rules. The registration
 * requires unique username (3-30 characters, alphanumeric with
 * hyphens/underscores), unique email address (valid format), and secure
 * password meeting complexity requirements (minimum 8 characters with
 * uppercase, lowercase, number, special character). The system hashes the
 * password using bcrypt with cost factor 12 before storage, ensuring passwords
 * are never stored in plain text.
 *
 * Upon successful registration, the operation generates JWT authentication
 * tokens following the platform's token strategy. An access token with
 * 30-minute expiration is created for immediate API authentication, along with
 * a refresh token (7-30 day expiration) for obtaining new access tokens without
 * re-authentication. Both tokens include the moderator's user ID, username,
 * email, role designation, and granted permissions in the JWT payload.
 *
 * The operation sets initial account status to 'pending_verification' until
 * email verification completes, and email_verified to false. The
 * appointed_by_admin_id references the administrator who initiated the
 * moderator appointment. The system records the appointment timestamp, device
 * information, and sets is_active to true for immediate moderation queue
 * access.
 *
 * This operation integrates with the authentication system defined in the User
 * Roles and Authentication document, implementing role-based access control for
 * moderators who inherit all member permissions plus moderation capabilities
 * including content review, warning issuance, and temporary suspensions.
 * Registration data is validated according to Business Rules and Validation
 * requirements, and all security measures from Performance and Security
 * requirements are enforced.
 *
 * The response includes the complete moderator profile with role information,
 * permission grants, and token credentials required for subsequent
 * authenticated API operations. This operation is essential for moderator
 * onboarding and represents the entry point for trusted community members to
 * access moderation tools and maintain discourse standards across economic and
 * political discussions.
 *
 * @param props.connection
 * @param props.body Registration information including appointed administrator
 *   reference, unique username, verified email address, secure password meeting
 *   complexity requirements, optional display name and bio, and account
 *   configuration
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration information including appointed administrator reference,
     * unique username, verified email address, secure password meeting
     * complexity requirements, optional display name and bio, and account
     * configuration
     */
    body: IDiscussionBoardModerator.ICreate;
  };
  export type Body = IDiscussionBoardModerator.ICreate;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate moderator credentials and issue JWT tokens.
 *
 * Validates moderator login credentials against the discussion_board_moderators
 * table and issues JWT authentication tokens upon successful verification. The
 * operation accepts either email address or username along with the password,
 * retrieves the moderator account, and performs comprehensive validation checks
 * before granting access.
 *
 * The authentication process verifies multiple account state conditions from
 * the Prisma schema: confirms the account exists in the moderators table,
 * validates email_verified is true (required for moderation duties per schema),
 * compares the submitted password against the stored password_hash using bcrypt
 * constant-time comparison, checks account_status is 'active' (not suspended or
 * deactivated), and ensures is_active is true (moderator privileges are
 * enabled). Any failed validation results in authentication denial with
 * appropriate error messaging.
 *
 * Upon successful credential validation, the system generates JWT tokens
 * following the platform's authentication strategy defined in the User Roles
 * and Authentication document. An access token with 30-minute expiration is
 * created containing the moderator's user ID, username, email, role designation
 * ('moderator'), and specific permissions array in the JWT payload. A refresh
 * token with 7-30 day expiration (extended for 'Remember Me' functionality) is
 * generated for obtaining new access tokens without re-authentication.
 *
 * The operation creates a new session record in discussion_board_sessions table
 * with the access_token_hash, device_type, browser_info, ip_address,
 * approximate location, and activity timestamps. A corresponding refresh token
 * record is created in discussion_board_refresh_tokens linked to the session.
 * The login attempt is logged in discussion_board_login_history with success
 * status, device information, and timestamp for security audit trail.
 *
 * Security measures are enforced per Performance and Security requirements:
 * failed login attempts are tracked and trigger progressive protections
 * including CAPTCHA after 3 failures and 15-minute account lockout after 5
 * failures within 15 minutes. The system logs all authentication events in
 * discussion_board_security_logs for monitoring suspicious patterns like brute
 * force attacks or credential stuffing attempts.
 *
 * This operation is essential for moderator access to the moderation queue,
 * content review tools, warning issuance capabilities, and user suspension
 * features. Successful login enables moderators to perform their duties
 * maintaining civil discourse standards across economic and political
 * discussions as specified in the Moderation System requirements.
 *
 * @param props.connection
 * @param props.body Login credentials containing email address or username and
 *   password for authentication, with optional 'remember me' flag for extended
 *   refresh token expiration
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login credentials containing email address or username and password
     * for authentication, with optional 'remember me' flag for extended
     * refresh token expiration
     */
    body: IDiscussionBoardModerator.ILogin;
  };
  export type Body = IDiscussionBoardModerator.ILogin;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access token using valid refresh token.
 *
 * Validates the provided refresh token and issues a new access token to
 * maintain moderator session continuity without requiring credential re-entry.
 * This operation is essential for user experience during extended moderation
 * sessions, allowing seamless access token renewal when the 30-minute access
 * token expires while the moderator is actively reviewing content in the
 * moderation queue.
 *
 * The refresh process performs comprehensive validation against the
 * discussion_board_refresh_tokens table in the Prisma schema. The system
 * verifies the submitted refresh_token_hash matches a stored token, confirms
 * the token expires_at timestamp has not passed, validates is_revoked is false
 * (token has not been invalidated), and retrieves the associated session from
 * discussion_board_sessions via the discussion_board_session_id foreign key
 * relationship. The session's is_active status must be true, and the session
 * must not have been revoked (revoked_at is null).
 *
 * Through the session relationship, the system accesses the moderator account
 * from discussion_board_moderators table and validates account state:
 * account_status must be 'active' (not suspended or deactivated), is_active
 * must be true (moderator privileges enabled), and email_verified must be true.
 * If the moderator account has been suspended, banned, or had privileges
 * revoked since the refresh token was issued, the refresh operation fails and
 * requires fresh authentication.
 *
 * Upon successful validation, the system generates a new JWT access token with
 * 30-minute expiration containing the moderator's current user ID, username,
 * email, role designation ('moderator'), and up-to-date permissions array
 * reflecting any permission changes since original login. The new access token
 * enables continued API authentication for moderation operations.
 *
 * The operation may implement refresh token rotation as a security best
 * practice: generating a new refresh token with extended expiration, marking
 * the old refresh token as revoked by setting is_revoked to true and recording
 * revoked_at timestamp, and returning both new access and refresh tokens. This
 * rotation strategy limits the window of vulnerability if a refresh token is
 * compromised.
 *
 * The refresh operation updates the session's last_activity_at timestamp in
 * discussion_board_sessions to track active moderation sessions. If the
 * moderator account has last_activity_at tracking, this is also updated to
 * reflect continued platform engagement. All token refresh events are logged in
 * discussion_board_security_logs with event_type 'token_refreshed' for security
 * monitoring and audit compliance.
 *
 * This operation integrates with the JWT token management strategy defined in
 * the User Roles and Authentication document, supporting the stateless
 * authentication architecture while enabling long-lived sessions through
 * refresh token mechanics. It prevents the poor user experience of frequent
 * login prompts during active moderation work while maintaining security
 * through short-lived access tokens and revocable refresh tokens.
 *
 * @param props.connection
 * @param props.body Refresh token request containing the current valid refresh
 *   token to be exchanged for a new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing the current valid refresh token to
     * be exchanged for a new access token
     */
    body: IDiscussionBoardModerator.IRefresh;
  };
  export type Body = IDiscussionBoardModerator.IRefresh;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
