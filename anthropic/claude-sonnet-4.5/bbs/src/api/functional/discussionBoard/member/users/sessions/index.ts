import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardSession } from "../../../../../structures/IDiscussionBoardSession";
import { IPageIDiscussionBoardSession } from "../../../../../structures/IPageIDiscussionBoardSession";

/**
 * Retrieve and filter active sessions for a specific user account.
 *
 * This operation retrieves a comprehensive, filtered, and paginated list of
 * active sessions for a specified user from the discussion_board_sessions
 * table. Sessions represent active login instances across different devices and
 * browsers, providing users with visibility into where their account is
 * currently authenticated.
 *
 * The operation supports advanced filtering capabilities to help users find
 * specific sessions based on various criteria including device type (Desktop,
 * Mobile, Tablet), browser information (Chrome, Firefox, Safari, etc.),
 * approximate geographic location, IP address patterns, login timestamp ranges,
 * and last activity timeframe. Users can search for sessions that meet multiple
 * filter criteria simultaneously to identify specific login instances or detect
 * suspicious activity.
 *
 * Each session record in the response includes comprehensive metadata to help
 * users identify and assess their login instances. This includes the device
 * type extracted from the user agent string, browser name and version
 * information, the IP address from which the session was created, an
 * approximate geographic location based on IP geolocation (city-level
 * precision), the timestamp when the user logged in to create this session, the
 * timestamp of the most recent activity in this session, the session's
 * expiration timestamp, and whether the session is currently active or has been
 * revoked.
 *
 * Security considerations are paramount in this operation. Users should only be
 * able to access their own session data unless they have administrator
 * privileges. The operation enforces strict authorization checks to ensure
 * users cannot view another user's active sessions without proper permissions.
 * Session data is sensitive as it reveals user behavior patterns, device usage,
 * and location information. The response should present session data in a
 * user-friendly format that makes it easy to identify unfamiliar or suspicious
 * sessions.
 *
 * The operation integrates with the multi-device session management
 * functionality defined in the User Roles and Authentication document. It
 * provides the data foundation for features like "view active sessions,"
 * "revoke this session," and "revoke all other sessions." Users can use this
 * information to make informed decisions about session management and account
 * security.
 *
 * Pagination is essential given that active users may have numerous historical
 * session records. The response should include pagination metadata indicating
 * the current page, total number of sessions matching the filters, and page
 * size. Sorting options allow users to organize sessions by most recent
 * activity, login timestamp, or other relevant criteria to quickly identify the
 * sessions they're looking for.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose sessions are being
 *   retrieved
 * @param props.body Filter criteria and pagination parameters for retrieving
 *   user sessions including device type, location, activity timeframe, and
 *   sorting preferences
 * @path /discussionBoard/member/users/:userId/sessions
 * @accessor api.functional.discussionBoard.member.users.sessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the user whose sessions are being retrieved */
    userId: string & tags.Format<"uuid">;

    /**
     * Filter criteria and pagination parameters for retrieving user
     * sessions including device type, location, activity timeframe, and
     * sorting preferences
     */
    body: IDiscussionBoardSession.IRequest;
  };
  export type Body = IDiscussionBoardSession.IRequest;
  export type Response = IPageIDiscussionBoardSession;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/users/:userId/sessions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/sessions`;
  export const random = (): IPageIDiscussionBoardSession =>
    typia.random<IPageIDiscussionBoardSession>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke a specific user session to terminate access from a particular device.
 *
 * This operation enables authenticated users to revoke a specific active
 * session, effectively logging out from a particular device or browser. This
 * functionality is essential for the multi-device session management system
 * described in the User Roles and Authentication requirements, where users need
 * the ability to view all their active sessions and selectively terminate
 * sessions they no longer wish to keep active.
 *
 * When a session is revoked through this operation, the system immediately
 * invalidates all associated JWT tokens (both access and refresh tokens) for
 * that session, preventing any further authenticated requests using those
 * tokens. The session record is permanently removed from the
 * discussion_board_sessions table since the schema does not include a
 * deleted_at column for soft deletion. The associated refresh token in the
 * discussion_board_refresh_tokens table is also removed through the cascade
 * delete relationship.
 *
 * This operation is particularly important for security scenarios such as when
 * a user suspects unauthorized access, wants to log out from a device they no
 * longer have physical access to, or simply wants to terminate sessions on
 * devices they are no longer using. The operation provides users with granular
 * control over their active sessions across multiple devices.
 *
 * The operation validates that the requesting user is either the owner of the
 * session being revoked or has administrative privileges. Users can only revoke
 * their own sessions unless they are administrators. The session must exist and
 * be associated with the specified user ID before revocation can proceed.
 *
 * After successful revocation, the affected device will be immediately logged
 * out upon its next authenticated request, as the JWT tokens will no longer be
 * valid. The operation logs the session termination in the security audit trail
 * for accountability and security monitoring purposes.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who owns the session
 * @param props.sessionId Unique identifier of the specific session to revoke
 * @path /discussionBoard/member/users/:userId/sessions/:sessionId
 * @accessor api.functional.discussionBoard.member.users.sessions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the user who owns the session */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific session to revoke */
    sessionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/users/:userId/sessions/:sessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/sessions/${encodeURIComponent(props.sessionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("sessionId")(() => typia.assert(props.sessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
