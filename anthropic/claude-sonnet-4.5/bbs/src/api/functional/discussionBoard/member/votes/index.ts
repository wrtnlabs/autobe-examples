import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardVote } from "../../../../structures/IDiscussionBoardVote";

/**
 * Cast a vote (upvote or downvote) on discussion board content.
 *
 * Create a new vote on a discussion topic or reply, recording the member's
 * assessment of content quality. This operation is fundamental to the
 * platform's community-driven content curation system, enabling members to
 * collectively surface high-quality economic and political discussions while
 * discouraging low-quality contributions.
 *
 * The voting operation validates several business rules before accepting the
 * vote. First, the system verifies that the user has sufficient reputation
 * points - upvoting requires a minimum of 10 reputation points, while
 * downvoting requires 50 reputation points to prevent abuse. Second, the system
 * ensures users cannot vote on their own content (self-voting is prohibited).
 * Third, the system enforces that each user can cast only one vote per content
 * item, though votes can be changed or removed within a 5-minute window after
 * casting.
 *
 * When a vote is successfully cast, the system records the vote in the
 * discussion_board_votes table with the member ID, votable type (topic or
 * reply), votable ID, and vote type (upvote or downvote). The vote immediately
 * affects the content's net score (upvotes minus downvotes) which influences
 * content ranking in the Hot, Top, and Controversial sorting algorithms.
 * Additionally, the author of the voted content receives reputation points: +5
 * for topic upvotes, +2 for reply upvotes, -2 for topic downvotes, and -1 for
 * reply downvotes.
 *
 * The voting system integrates with the notification system, potentially
 * triggering vote milestone notifications when content reaches 10, 25, 50, 100,
 * or higher vote thresholds. Vote data also feeds into user reputation
 * calculations tracked in the discussion_board_user_reputation table, enabling
 * reputation-based privilege unlocking and leaderboard features.
 *
 * Security considerations include rate limiting (maximum 200 votes per hour per
 * user) and suspicious pattern detection to prevent vote manipulation, vote
 * rings, and coordinated voting attacks. The system logs vote patterns and may
 * flag suspicious activity for moderator review. Suspended or banned users are
 * prevented from casting votes during their restriction period.
 *
 * This operation is essential for maintaining content quality on the platform,
 * as it allows the community to collectively identify valuable economic and
 * political discourse while suppressing spam, misinformation, and low-effort
 * content.
 *
 * @param props.connection
 * @param props.body Vote casting information including the content being voted
 *   on and vote direction
 * @path /discussionBoard/member/votes
 * @accessor api.functional.discussionBoard.member.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Vote casting information including the content being voted on and
     * vote direction
     */
    body: IDiscussionBoardVote.ICreate;
  };
  export type Body = IDiscussionBoardVote.ICreate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/member/votes";
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update or remove an existing vote on discussion board content.
 *
 * Modify an existing vote record to change vote direction (upvote to downvote
 * or vice versa) or remove the vote entirely. This operation provides users
 * with flexibility to reconsider their content assessment and correct
 * accidental votes, supporting the platform's goal of accurate community-driven
 * content curation.
 *
 * The vote update operation enforces a critical time-based business rule: votes
 * can only be changed or removed within 5 minutes of the original vote casting.
 * After this window expires, votes are locked and cannot be modified to
 * maintain content score stability and prevent strategic vote manipulation.
 * This 5-minute grace period balances user flexibility with content integrity
 * requirements.
 *
 * When a user updates their vote, the system validates several conditions.
 * First, the system verifies that the vote record exists and belongs to the
 * authenticated user - users cannot modify votes cast by others. Second, the
 * system checks that the vote is still within the 5-minute modification window
 * by comparing the current timestamp with the vote's created_at timestamp from
 * the discussion_board_votes table. Third, the system ensures the user still
 * has permission to vote (account not suspended, sufficient reputation points
 * maintained).
 *
 * Vote modifications trigger immediate recalculations throughout the platform.
 * When a vote changes from upvote to downvote, the content's net score
 * decreases by 2 points (removing +1 and adding -1). The author's reputation in
 * the discussion_board_user_reputation table is adjusted accordingly, reversing
 * the original reputation bonus and applying the new reputation change. If a
 * vote is removed entirely (changed to null or neutral), the system removes the
 * vote record and recalculates scores without that vote's contribution.
 *
 * The operation integrates with the content ranking system, causing immediate
 * updates to Hot, Top, and Controversial sorting algorithms. Vote changes may
 * also affect whether content has reached vote milestone thresholds,
 * potentially triggering or revoking vote milestone notifications sent through
 * the discussion_board_notifications table.
 *
 * Security and anti-gaming measures apply to vote updates just as they do to
 * initial vote casting. The system tracks vote change patterns and may flag
 * users who repeatedly change votes in suspicious patterns (such as
 * coordinating with vote rings or attempting to manipulate trending
 * algorithms). Vote update actions are logged in the
 * discussion_board_audit_logs table for fraud detection and pattern analysis.
 *
 * Users attempting to modify votes after the 5-minute window receive a clear
 * error message explaining the time restriction and encouraging them to leave
 * their original vote in place or engage through replies instead. This helps
 * users understand platform rules while maintaining content score integrity
 * essential for fair community-driven content curation.
 *
 * @param props.connection
 * @param props.voteId Unique identifier of the vote record to update
 * @param props.body Updated vote information including new vote direction or
 *   removal flag
 * @path /discussionBoard/member/votes/:voteId
 * @accessor api.functional.discussionBoard.member.votes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the vote record to update */
    voteId: string & tags.Format<"uuid">;

    /** Updated vote information including new vote direction or removal flag */
    body: IDiscussionBoardVote.IUpdate;
  };
  export type Body = IDiscussionBoardVote.IUpdate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a member's vote from discussion content within the 5-minute change
 * window.
 *
 * This operation enables authenticated members to remove their previously cast
 * votes from discussion topics or replies. Vote removal is a critical component
 * of the voting and engagement system, providing users with the flexibility to
 * retract their voting decisions within a limited time window.
 *
 * When a member successfully removes a vote, several cascading effects occur
 * throughout the system. First, the vote record is permanently deleted from the
 * discussion_board_votes table. Second, the content's net vote score is
 * recalculated immediately - if an upvote is removed, the score decrements by
 * 1; if a downvote is removed, the score increments by 1. Third, the content
 * author's reputation is adjusted to reverse the reputation points that were
 * originally awarded or deducted when the vote was cast. This ensures
 * reputation accurately reflects current community assessment rather than
 * historical voting patterns.
 *
 * Security and business rule enforcement are paramount in this operation. The
 * system validates that the authenticated member is indeed the owner of the
 * vote being removed - users cannot remove other users' votes. The operation
 * checks that the vote exists and has not already been deleted (soft delete
 * check via deleted_at column). Most critically, the operation enforces the
 * 5-minute vote change window defined in business rules: votes can only be
 * removed within 5 minutes of being cast. After this window expires, votes are
 * locked permanently and cannot be changed or removed. This time constraint
 * prevents vote manipulation and ensures voting stability for content ranking
 * algorithms.
 *
 * The operation integrates with multiple platform systems. It affects the
 * voting and engagement system by modifying vote counts and rankings. It
 * triggers reputation recalculation in the user reputation system, potentially
 * affecting privilege unlocking if the reputation change crosses thresholds. It
 * may trigger notifications if the vote removal causes the content to fall
 * below a previously reached milestone. The operation respects the soft delete
 * pattern used throughout the platform, checking the deleted_at column to
 * ensure votes marked as deleted cannot be removed again.
 *
 * Error scenarios are handled gracefully with clear user feedback. If the vote
 * does not exist or does not belong to the requesting user, the operation
 * returns a 404 Not Found or 403 Forbidden error. If the 5-minute change window
 * has expired, the operation returns a 400 Bad Request with a message
 * explaining that votes can only be removed within 5 minutes of casting. If the
 * content associated with the vote has been deleted, the operation may also
 * reject the removal request. All validation occurs server-side to prevent
 * security vulnerabilities.
 *
 * This operation supports the platform's philosophy of empowering users to
 * control their engagement while maintaining voting integrity through
 * time-based restrictions. It balances user flexibility (allowing quick vote
 * retraction) with system stability (preventing long-term vote manipulation).
 *
 * @param props.connection
 * @param props.voteId Unique identifier of the vote to be removed
 * @path /discussionBoard/member/votes/:voteId
 * @accessor api.functional.discussionBoard.member.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the vote to be removed */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
