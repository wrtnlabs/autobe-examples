import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardNotification } from "../../../../../structures/IDiscussionBoardNotification";
import { IPageIDiscussionBoardNotification } from "../../../../../structures/IPageIDiscussionBoardNotification";

/**
 * Search and retrieve a filtered, paginated list of user notifications.
 *
 * Retrieve a comprehensive, filtered, and paginated list of notifications for a
 * specific user from the discussion board notification system. This operation
 * provides advanced search and filtering capabilities for users to manage their
 * notification history, find specific types of notifications, and review
 * activity alerts across the platform.
 *
 * The operation supports filtering by notification type (reply_to_topic,
 * reply_to_comment, mention, vote_milestone, moderation_action,
 * system_announcement, watched_topic_update, welcome), read status (read,
 * unread, all), delivery channel (in-app, email), and date ranges. Users can
 * search for notifications related to specific topics, replies, or triggering
 * users, enabling efficient notification management and historical review.
 *
 * This endpoint integrates with the discussion_board_notifications table as
 * defined in the Prisma schema, accessing all notification fields including
 * triggering users (members, moderators, administrators), related content
 * (topics, replies, moderation actions), delivery status, and read tracking.
 * The operation respects user privacy by only returning notifications that
 * belong to the authenticated user identified by the userId path parameter.
 *
 * Security considerations include verifying that the authenticated user matches
 * the userId path parameter to prevent unauthorized access to other users'
 * notifications. The operation enforces ownership validation ensuring users can
 * only access their own notification data. Rate limiting may be applied to
 * prevent excessive notification queries, though typical user notification
 * browsing patterns should fall well within acceptable limits.
 *
 * The response includes paginated notification summaries optimized for
 * notification center display, including notification type indicators,
 * triggering user information, content previews, timestamps, read status, and
 * deep links to related content. The operation supports sorting by creation
 * date (newest first by default), notification type, or read status to help
 * users organize their notification feed according to their preferences.
 *
 * This operation is essential for the notification management user experience,
 * allowing users to review their notification history, identify unread
 * notifications, filter by activity type, and efficiently navigate to content
 * that requires their attention. It complements the real-time notification
 * delivery system by providing historical access and advanced management
 * capabilities beyond the basic notification center view.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose notifications are
 *   being retrieved
 * @param props.body Search criteria and pagination parameters for filtering
 *   user notifications including notification type, read status, date ranges,
 *   and sorting preferences
 * @path /discussionBoard/member/users/:userId/notifications
 * @accessor api.functional.discussionBoard.member.users.notifications.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the user whose notifications are being retrieved */
    userId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for filtering user
     * notifications including notification type, read status, date ranges,
     * and sorting preferences
     */
    body: IDiscussionBoardNotification.IRequest;
  };
  export type Body = IDiscussionBoardNotification.IRequest;
  export type Response = IPageIDiscussionBoardNotification.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/users/:userId/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/notifications`;
  export const random = (): IPageIDiscussionBoardNotification.ISummary =>
    typia.random<IPageIDiscussionBoardNotification.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific user notification by ID.
 *
 * Retrieve comprehensive details for a single notification record identified by
 * notificationId belonging to the user identified by userId. This operation
 * provides complete notification information including notification type,
 * triggering event details, related content references, delivery channel
 * status, and read tracking metadata.
 *
 * The operation accesses the discussion_board_notifications table as defined in
 * the Prisma schema, returning full notification data including all foreign key
 * references to triggering users (members, moderators, administrators), related
 * discussion content (topics, replies), associated moderation actions, and
 * complete delivery status tracking for both in-app and email channels.
 *
 * When a notification is retrieved, the system returns detailed information
 * about what triggered the notification, who performed the triggering action,
 * what content is involved, and the notification's current state (read/unread,
 * seen/unseen, delivery status). This enables rich notification display in user
 * interfaces showing full context and allowing users to understand exactly what
 * activity occurred and navigate directly to relevant content.
 *
 * Security validation ensures that the authenticated user matches the userId
 * path parameter and that the requested notification actually belongs to that
 * user. The operation prevents users from accessing notifications belonging to
 * other users by validating the notification's user_id field against the
 * authenticated user's identity before returning data. If the notification does
 * not belong to the authenticated user or does not exist, appropriate error
 * responses are returned.
 *
 * This operation is typically used when a user clicks on a notification in
 * their notification center to view full details, or when the system needs to
 * mark a notification as read after user interaction. It may automatically
 * update the is_read and read_at fields when accessed, depending on business
 * logic implementation, though this read-tracking behavior is handled by
 * backend application logic rather than specified in the API operation itself.
 *
 * The detailed notification information enables the user interface to display
 * rich notification cards showing the triggering user's profile information,
 * preview of related content, action timestamps, and contextual navigation
 * options. For moderation action notifications, this includes the full
 * moderation reason and appeal process information. For reply notifications,
 * this includes the reply preview and direct link to the conversation thread.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who owns this notification
 * @param props.notificationId Unique identifier of the specific notification to
 *   retrieve
 * @path /discussionBoard/member/users/:userId/notifications/:notificationId
 * @accessor api.functional.discussionBoard.member.users.notifications.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the user who owns this notification */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific notification to retrieve */
    notificationId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardNotification;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/users/:userId/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IDiscussionBoardNotification =>
    typia.random<IDiscussionBoardNotification>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update notification read status for a specific user notification.
 *
 * Updates the read status of a specific notification in the user's notification
 * center. This operation allows users to mark individual notifications as read,
 * which updates both the is_read boolean flag and sets the read_at timestamp in
 * the discussion_board_notifications table.
 *
 * The operation validates that the notification belongs to the specified user
 * before processing the update. This ensures users can only modify their own
 * notifications and cannot manipulate other users' notification states. The
 * system checks that the userId parameter matches the user_id field in the
 * notification record.
 *
 * When a notification is marked as read, the is_read field is set to true and
 * the read_at timestamp is set to the current time. This data is used
 * throughout the platform to display unread notification counts in the
 * notification center badge, filter notifications by read/unread status, and
 * track user engagement with notifications.
 *
 * The operation supports updating other notification properties beyond read
 * status, such as is_seen (whether user viewed the notification in the list
 * without clicking), allowing flexible notification state management. This
 * enables the platform to distinguish between notifications that were merely
 * displayed versus those the user actively engaged with.
 *
 * This operation integrates with the notification system defined in the
 * requirements, which specifies that notifications must track read/unread
 * status, support user interaction through the notification center, and update
 * badge counts in real-time as users mark notifications as read. The response
 * confirms the update and returns the updated notification state for immediate
 * UI reflection.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who owns the notification
 * @param props.notificationId Unique identifier of the notification to update
 * @param props.body Updated notification properties including read status and
 *   seen status
 * @path /discussionBoard/member/users/:userId/notifications/:notificationId
 * @accessor api.functional.discussionBoard.member.users.notifications.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the user who owns the notification */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the notification to update */
    notificationId: string & tags.Format<"uuid">;

    /** Updated notification properties including read status and seen status */
    body: IDiscussionBoardNotification.IUpdate;
  };
  export type Body = IDiscussionBoardNotification.IUpdate;
  export type Response = IDiscussionBoardNotification;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/users/:userId/notifications/:notificationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IDiscussionBoardNotification =>
    typia.random<IDiscussionBoardNotification>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a specific notification from user's notification history.
 *
 * Removes a specific notification from the user's notification center by
 * marking it as deleted. This operation sets the deleted_at timestamp in the
 * discussion_board_notifications table, implementing a soft deletion pattern
 * that preserves notification data for audit purposes while hiding it from the
 * user's view.
 *
 * The operation first validates that the notification belongs to the specified
 * user by checking that the userId parameter matches the user_id field in the
 * notification record. This security check ensures users can only delete their
 * own notifications and cannot manipulate other users' notification histories.
 *
 * According to the Prisma schema, the discussion_board_notifications table
 * includes a deleted_at field, indicating this operation performs soft deletion
 * rather than permanent removal. The soft-deleted notification is immediately
 * hidden from the user's notification center and no longer appears in their
 * notification list or contributes to the unread notification count badge.
 * However, the record is retained in the database for the 90-day retention
 * period specified in the notification system requirements.
 *
 * This deletion capability supports the notification management features
 * outlined in the requirements, which specify that users should be able to
 * delete individual notifications and perform bulk deletion of read
 * notifications. The operation provides users with control over their
 * notification history, allowing them to maintain a clean, relevant
 * notification center by removing outdated or unnecessary alerts.
 *
 * After successful deletion, the notification is immediately removed from all
 * user-facing interfaces including the notification center dropdown,
 * notification history page, and unread count calculations. The system
 * recalculates the notification badge count to reflect the removal.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who owns the notification
 * @param props.notificationId Unique identifier of the notification to delete
 * @path /discussionBoard/member/users/:userId/notifications/:notificationId
 * @accessor api.functional.discussionBoard.member.users.notifications.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the user who owns the notification */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the notification to delete */
    notificationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/users/:userId/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
