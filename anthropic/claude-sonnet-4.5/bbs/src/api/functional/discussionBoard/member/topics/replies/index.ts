import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardReply } from "../../../../../structures/IDiscussionBoardReply";

/**
 * Create a new reply to a discussion topic or nested reply within the topic.
 *
 * Create a new reply to an existing discussion topic, enabling members to
 * participate in threaded conversations on economic and political subjects.
 * This operation supports both top-level replies directly to the main topic and
 * nested replies responding to other members' comments, maintaining the
 * conversation hierarchy that facilitates organized, contextual discussions.
 *
 * The operation creates records in the discussion_board_replies table as
 * defined in the Prisma schema, which supports threaded conversations up to 10
 * levels deep through parent-child relationships. Reply content must be between
 * 1 and 10,000 characters in length with Markdown formatting support for rich
 * text expression. The system automatically calculates the depth_level based on
 * the parent reply's depth to enforce the 10-level threading constraint defined
 * in the discussion management requirements.
 *
 * Security and authorization considerations require that only authenticated
 * members (not guests) can post replies, and the user's account must be in good
 * standing (not suspended or banned). The operation validates that the target
 * topic exists, belongs to the specified topicId parameter, and is in an active
 * state that permits new replies. Locked topics prevent new replies except from
 * administrators, and archived topics are read-only. The system enforces rate
 * limiting rules of maximum 30 replies per hour and 200 replies per day per
 * user to prevent spam, with additional cooldown periods if users post more
 * than 3 replies to the same topic within 5 minutes.
 *
 * The request body includes the reply content, optional parent_reply_id for
 * nested replies, and any formatting preferences. When a reply is successfully
 * created, the system increments the parent topic's reply_count, updates the
 * topic's last_activity timestamp, and triggers notifications to relevant users
 * (topic author for top-level replies, parent reply author for nested replies,
 * or users mentioned with @username syntax). The response returns the complete
 * newly created reply object including its assigned unique identifier, depth
 * level, creation timestamp, and author information.
 *
 * This operation integrates closely with the notification system documented in
 * the notification requirements, triggering reply_to_topic or reply_to_comment
 * notifications based on whether the reply is top-level or nested. It also
 * respects user blocking relationships, preventing blocked users from seeing
 * each other's replies in the thread display. Validation rules from the
 * business rules document ensure content quality, prevent duplicate
 * submissions, and maintain civil discourse standards for economic and
 * political discussions.
 *
 * Related operations that users typically combine with reply creation include
 * viewing the parent topic to understand discussion context (GET
 * /topics/{topicId}), retrieving the full reply thread for reference (GET
 * /topics/{topicId}/replies), and editing the newly created reply within the
 * allowed time window if corrections are needed (PUT
 * /topics/{topicId}/replies/{replyId}). The threading structure enables complex
 * multi-party discussions while maintaining clear conversation flow and
 * context.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the discussion topic to which the
 *   reply is being posted
 * @param props.body Reply content and threading information for creating a new
 *   discussion reply
 * @path /discussionBoard/member/topics/:topicId/replies
 * @accessor api.functional.discussionBoard.member.topics.replies.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the discussion topic to which the reply is being
     * posted
     */
    topicId: string & tags.Format<"uuid">;

    /**
     * Reply content and threading information for creating a new discussion
     * reply
     */
    body: IDiscussionBoardReply.ICreate;
  };
  export type Body = IDiscussionBoardReply.ICreate;
  export type Response = IDiscussionBoardReply;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/topics/:topicId/replies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/topics/${encodeURIComponent(props.topicId ?? "null")}/replies`;
  export const random = (): IDiscussionBoardReply =>
    typia.random<IDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a reply's content within allowed edit time window.
 *
 * Updates the content of an existing reply to a discussion topic, subject to
 * time-based editing restrictions and permission validation. This operation
 * allows members to modify their own reply content within specific time
 * constraints that vary based on user reputation: standard members can edit
 * replies within 1 hour of posting, while members with 100+ reputation points
 * have a 24-hour edit window. Moderators and administrators can edit any reply
 * at any time without time restrictions.
 *
 * The operation validates multiple business rules before allowing the update:
 * it verifies the reply exists and belongs to the specified topic, confirms the
 * requesting user is either the original author or has moderator/administrator
 * privileges, checks that the edit is within the allowed time window based on
 * the user's reputation score and role, and ensures the topic is not locked
 * (which would prevent all editing except by administrators). Content
 * validation applies the same rules as reply creation, including length
 * constraints (1-10,000 characters), URL limits (maximum 5 URLs, flagged for
 * review if exceeded), duplicate detection (rejecting identical content to
 * previous replies by same user in same topic), and content quality checks
 * (profanity filtering, spam pattern detection, prohibited content screening).
 *
 * When a reply is successfully updated, the system records the edit in the
 * discussion_board_edit_history table, capturing the previous content, new
 * content, optional edit reason, editor identity, and modification timestamp.
 * This creates a comprehensive audit trail for transparency in discussions. The
 * reply's updated_at timestamp is refreshed, and an 'Edited' indicator is
 * displayed next to the reply showing when it was last modified. The parent
 * topic's updated_at timestamp is also refreshed to reflect recent activity.
 *
 * Security and authorization considerations include validating the JWT token to
 * confirm user identity, enforcing role-based permissions (members can only
 * edit their own replies unless they have moderator/administrator roles),
 * checking that the user account is not suspended or banned (suspended users
 * cannot edit content), and respecting topic lock status (locked topics prevent
 * editing except by administrators). The operation returns appropriate error
 * responses for various failure scenarios: 404 if the topic or reply doesn't
 * exist, 403 if the user lacks permission to edit the reply, 400 if the edit
 * window has expired or content validation fails, and 423 if the topic is
 * locked and user is not an administrator.
 *
 * This operation integrates with the reputation system to determine edit window
 * duration, the moderation system to respect content locks and user
 * suspensions, the validation system to enforce content quality rules, and the
 * edit history system to maintain transparency and auditability of content
 * modifications.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the discussion topic containing the
 *   reply
 * @param props.replyId Unique identifier of the reply to update
 * @param props.body Updated reply content and optional edit reason
 * @path /discussionBoard/member/topics/:topicId/replies/:replyId
 * @accessor api.functional.discussionBoard.member.topics.replies.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the discussion topic containing the reply */
    topicId: string & tags.Format<"uuid">;

    /** Unique identifier of the reply to update */
    replyId: string & tags.Format<"uuid">;

    /** Updated reply content and optional edit reason */
    body: IDiscussionBoardReply.IUpdate;
  };
  export type Body = IDiscussionBoardReply.IUpdate;
  export type Response = IDiscussionBoardReply;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/topics/:topicId/replies/:replyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/topics/${encodeURIComponent(props.topicId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardReply =>
    typia.random<IDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.param("replyId")(() => typia.assert(props.replyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Mark a reply as deleted with soft delete to support recovery.
 *
 * Marks a reply as deleted by setting the deleted_at timestamp, supporting a
 * 30-day recovery window consistent with platform data retention policies. This
 * operation allows members to delete their own replies within 1 hour of posting
 * if the reply has no child replies, while moderators and administrators can
 * delete any reply at any time without time restrictions. The operation uses
 * soft delete to preserve data for potential recovery and maintain audit trail
 * integrity.
 *
 * The operation validates multiple conditions before allowing deletion: it
 * verifies the reply exists and belongs to the specified topic, confirms the
 * requesting user is either the original author within the deletion time window
 * or has moderator/administrator privileges, checks that the topic is not
 * locked (which would prevent deletion except by administrators), and examines
 * whether the reply has any child replies that depend on it for thread
 * structure.
 *
 * Deletion behavior uses soft delete in both scenarios by setting the
 * deleted_at field to the current timestamp. If the reply has NO child replies,
 * the system sets the deleted_at timestamp, decrements the parent topic's
 * reply_count, updates the topic's updated_at timestamp, creates an audit log
 * entry recording the deletion, and hides the reply from normal user views
 * while preserving it in the database. If the reply HAS child replies, the
 * system sets the deleted_at timestamp to mark deletion, replaces the content
 * field with '[deleted]' placeholder text to maintain readability, maintains
 * the reply's position in the thread hierarchy, preserves all child replies in
 * their original structure, and ensures conversation flow remains
 * understandable. After 30 days, permanently deleted records may be purged from
 * the database as part of data retention policies.
 *
 * Time-based restrictions apply to member deletions: members can only delete
 * their own replies within 1 hour of posting, after which the deletion option
 * is removed to maintain discussion continuity and prevent retroactive content
 * removal that could confuse ongoing conversations. Members with 100+
 * reputation points do not receive an extended deletion windowâ€”the 1-hour limit
 * applies universally to all members regardless of reputation. However,
 * moderators and administrators can delete any reply at any time as part of
 * their content management responsibilities, and their deletions are logged in
 * the moderation audit trail.
 *
 * When a reply is successfully deleted, the system sets the deleted_at
 * timestamp, updates the parent topic's metadata to reflect the removed
 * content, triggers a notification to the reply author if deletion was
 * performed by a moderator (not for self-deletions), records the deletion in
 * the audit trail with actor identity and timestamp, and returns a success
 * confirmation. For moderator deletions, the action is logged in
 * discussion_board_moderation_actions table with deletion reason and content
 * snapshot.
 *
 * Security and authorization considerations include validating the JWT token to
 * confirm user identity, enforcing role-based permissions (members can only
 * delete their own replies within time window, moderators and administrators
 * can delete any reply), checking that the user account is not suspended or
 * banned, and respecting topic lock status (locked topics prevent deletion
 * except by administrators). The operation returns appropriate error responses
 * for various failure scenarios: 404 if the topic or reply doesn't exist, 403
 * if the user lacks permission to delete the reply, 400 if the deletion time
 * window has expired for member self-deletion, and 423 if the topic is locked
 * and user is not an administrator.
 *
 * This operation integrates with the discussion management system to maintain
 * reply counts and thread structure, the moderation system to log moderator
 * deletions and respect content locks, the audit system to record all deletion
 * events with actor and timestamp, and the notification system to alert users
 * when their content is removed by moderators.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the discussion topic containing the
 *   reply
 * @param props.replyId Unique identifier of the reply to delete
 * @path /discussionBoard/member/topics/:topicId/replies/:replyId
 * @accessor api.functional.discussionBoard.member.topics.replies.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the discussion topic containing the reply */
    topicId: string & tags.Format<"uuid">;

    /** Unique identifier of the reply to delete */
    replyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/topics/:topicId/replies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/topics/${encodeURIComponent(props.topicId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
