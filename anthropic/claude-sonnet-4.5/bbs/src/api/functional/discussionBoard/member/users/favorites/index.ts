import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardFavorite } from "../../../../../structures/IDiscussionBoardFavorite";
import { IPageIDiscussionBoardTopic } from "../../../../../structures/IPageIDiscussionBoardTopic";

/**
 * Add a discussion topic to a user's favorites/bookmarks collection.
 *
 * Create a new favorite/bookmark record for a specific user on a discussion
 * topic. This operation allows members to save important or interesting
 * discussions on economic and political subjects for easy access and future
 * reference.
 *
 * The operation creates a record in the discussion_board_favorites table,
 * establishing a relationship between the user (discussion_board_member_id) and
 * a discussion topic (discussion_board_topic_id). Each favorite record captures
 * when the bookmark was created, enabling chronological organization of saved
 * content.
 *
 * Security considerations require verifying that the authenticated user matches
 * the userId in the path parameter, preventing users from creating favorites on
 * behalf of other users. The operation validates that the requesting user is a
 * registered, authenticated member with active account status.
 *
 * The operation validates that the target discussion topic exists in the
 * discussion_board_topics table and is accessible to the user (not deleted, not
 * restricted by permissions). It also enforces the unique constraint that
 * prevents duplicate favorites - users cannot favorite the same topic multiple
 * times.
 *
 * The request body contains the topic_id of the discussion to be favorited. The
 * operation performs referential integrity validation to ensure the topic_id
 * references a valid, existing discussion topic. If the topic does not exist or
 * has been deleted, the operation returns an appropriate error.
 *
 * Business rules from the requirements allow users to maintain unlimited
 * favorites, though the platform may implement soft limits in the future. The
 * operation supports soft deletion via the deleted_at timestamp field, allowing
 * recovery of accidentally removed bookmarks within a recovery window.
 *
 * The response returns the created favorite record including the unique
 * favorite ID, topic information, and creation timestamp. This enables the
 * client to immediately update the UI to reflect the favorited state and add
 * the topic to the user's favorites collection.
 *
 * This operation integrates with the engagement system by recording user
 * interest in specific topics. Favorited topics may receive special treatment
 * in personalized recommendations and notification preferences, allowing users
 * to track updates on discussions they've explicitly bookmarked.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who is favoriting the
 *   discussion topic
 * @param props.body Information about the discussion topic to be added to
 *   user's favorites, including the topic identifier
 * @path /discussionBoard/member/users/:userId/favorites
 * @accessor api.functional.discussionBoard.member.users.favorites.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the user who is favoriting the discussion topic */
    userId: string & tags.Format<"uuid">;

    /**
     * Information about the discussion topic to be added to user's
     * favorites, including the topic identifier
     */
    body: IDiscussionBoardFavorite.ICreate;
  };
  export type Body = IDiscussionBoardFavorite.ICreate;
  export type Response = IDiscussionBoardFavorite;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/users/:userId/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/favorites`;
  export const random = (): IDiscussionBoardFavorite =>
    typia.random<IDiscussionBoardFavorite>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of discussion topics favorited by a
 * specific user.
 *
 * Retrieve a comprehensive, filtered, and paginated list of discussion topics
 * that a user has bookmarked or favorited for later reference. This operation
 * provides members with powerful tools to organize and rediscover their saved
 * economic and political discussions.
 *
 * The operation queries the discussion_board_favorites table, joining with
 * discussion_board_topics to return complete topic information including title,
 * content preview, category, tags, vote scores, reply counts, and author
 * information. This enables users to maintain a personal library of valuable
 * discussions they want to revisit.
 *
 * Security considerations include verifying that the requesting user has
 * permission to view the specified user's favorites. By default, favorites are
 * private (visible only to the owner), but users can optionally make their
 * favorites public through privacy settings defined in the
 * discussion_board_members table. The operation must respect the
 * activity_visibility field when determining access permissions.
 *
 * The operation supports comprehensive filtering options including search by
 * topic title or content, filtering by category or tags, date range filtering
 * (when favorited), and filtering by topic status (active, archived). This
 * helps users efficiently locate specific favorited discussions within large
 * bookmark collections.
 *
 * Sorting capabilities include ordering by date favorited (newest first or
 * oldest first), topic creation date, recent activity on the topic, vote score,
 * or reply count. This flexibility allows users to organize their favorites
 * based on different discovery and research needs.
 *
 * Pagination is essential for users with extensive favorite collections, with
 * configurable page sizes. The response includes pagination metadata (total
 * count, page number, page size) to support client-side pagination controls.
 *
 * This operation integrates with the voting and engagement system by including
 * current vote scores and engagement metrics for each favorited topic. It also
 * integrates with the discussion management system to provide complete topic
 * metadata including category assignment, tag associations, and current topic
 * status.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose favorited topics are
 *   being retrieved
 * @param props.body Search criteria, filtering options, sorting preferences,
 *   and pagination parameters for retrieving user's favorited discussions
 * @path /discussionBoard/member/users/:userId/favorites
 * @accessor api.functional.discussionBoard.member.users.favorites.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the user whose favorited topics are being
     * retrieved
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Search criteria, filtering options, sorting preferences, and
     * pagination parameters for retrieving user's favorited discussions
     */
    body: IDiscussionBoardFavorite.IRequest;
  };
  export type Body = IDiscussionBoardFavorite.IRequest;
  export type Response = IPageIDiscussionBoardTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/users/:userId/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/favorites`;
  export const random = (): IPageIDiscussionBoardTopic.ISummary =>
    typia.random<IPageIDiscussionBoardTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a bookmarked discussion from user's favorites collection.
 *
 * This operation allows authenticated users to remove a previously bookmarked
 * discussion topic from their favorites collection. When a user unfavorites a
 * topic, the favorite record is soft deleted from the
 * discussion_board_favorites table, marking it with a deleted_at timestamp
 * while preserving the record for potential recovery during the 30-day recovery
 * window as specified in the platform policy.
 *
 * The operation validates that the favorite record exists, belongs to the
 * authenticated user, and has not already been deleted. Users can only delete
 * their own favorites - attempting to delete another user's favorite will
 * result in a permission error. The favoriteId parameter must reference a valid
 * favorite record in the discussion_board_favorites table that is currently
 * active (deleted_at is null).
 *
 * Security considerations include verifying that the authenticated user's ID
 * matches the userId path parameter to prevent unauthorized deletion of other
 * users' favorites. The operation respects the soft deletion pattern, setting
 * the deleted_at timestamp rather than permanently removing the record from the
 * database. This soft delete approach supports the platform's 30-day recovery
 * window and maintains data integrity for audit purposes.
 *
 * This operation is the inverse of creating a favorite and works in conjunction
 * with the GET or PATCH endpoints that list favorited discussions. After
 * successful deletion, the removed topic will no longer appear in the user's
 * favorites list but can be favorited again if desired, as the system filters
 * out records with non-null deleted_at timestamps in normal queries.
 *
 * Upon successful deletion, the operation returns no response body, following
 * REST conventions for DELETE operations. The client should update the UI to
 * reflect the removal of the bookmarked topic from the favorites collection. If
 * the favorite record does not exist or has already been deleted, the operation
 * should return an appropriate error response.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose favorite is being
 *   removed
 * @param props.favoriteId Unique identifier of the favorite record to be
 *   removed from the user's collection
 * @path /discussionBoard/member/users/:userId/favorites/:favoriteId
 * @accessor api.functional.discussionBoard.member.users.favorites.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the user whose favorite is being removed */
    userId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the favorite record to be removed from the
     * user's collection
     */
    favoriteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/users/:userId/favorites/:favoriteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/favorites/${encodeURIComponent(props.favoriteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
