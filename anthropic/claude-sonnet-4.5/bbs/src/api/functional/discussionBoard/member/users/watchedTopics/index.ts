import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardWatchedTopic } from "../../../../../structures/IDiscussionBoardWatchedTopic";
import { IPageIDiscussionBoardWatchedTopic } from "../../../../../structures/IPageIDiscussionBoardWatchedTopic";

/**
 * Add a discussion topic to the user's watched topics list for activity
 * notifications.
 *
 * Create a new watch relationship that adds a discussion topic to the specified
 * user's watched topics list. When users watch topics, they receive
 * notifications about new activity including new replies, vote milestones, and
 * other significant events based on their configured notification preferences.
 *
 * This operation creates a record in the discussion_board_watched_topics table
 * establishing the many-to-many relationship between the user
 * (discussion_board_member_id) and the topic (discussion_board_topic_id). The
 * operation initializes the last_read_at timestamp to the current time,
 * indicating that the user has read all content up to this point, and future
 * notifications will only be triggered by new activity occurring after this
 * timestamp.
 *
 * The watch topic feature serves multiple business purposes. First, it enables
 * users to track ongoing discussions they're interested in without manually
 * checking for updates. Second, it drives user engagement by delivering timely
 * notifications when watched topics receive new replies or activity. Third, it
 * supports the personalized recommendation system by identifying topics the
 * user explicitly cares about, which informs content recommendation
 * algorithms.
 *
 * The operation validates several business rules before creating the watch
 * relationship. It verifies that the specified topic exists in the
 * discussion_board_topics table and is in an active state (not deleted, not
 * archived). It confirms the user has permission to view the topic based on
 * topic visibility rules and their role permissions. It checks that the user is
 * not already watching this topic to prevent duplicate watch records. It
 * enforces the business rule that users cannot watch their own topics (to
 * prevent self-notification scenarios).
 *
 * Security considerations include authenticating the requesting user and
 * validating they have permission to modify the specified user's watched
 * topics. Users can only add topics to their own watch list unless they have
 * administrator privileges. The operation respects content access controls,
 * ensuring users can only watch topics they have permission to view based on
 * their role and any content visibility restrictions.
 *
 * The operation integrates with the notification system defined in the
 * Notification System requirements document. After successfully adding a topic
 * to the watch list, future notifications will be triggered according to the
 * user's notification preferences in discussion_board_notification_preferences.
 * Notification batching, quiet hours, and digest frequency settings all apply
 * to watched topic notifications as specified in the requirements.
 *
 * Related API operations include PATCH /users/{userId}/watchedTopics to
 * retrieve the user's complete watched topics list, DELETE
 * /users/{userId}/watchedTopics/{topicId} to remove topics from the watch list
 * (unwatch), and PUT /users/{userId}/watchedTopics/{topicId}/read to update the
 * last_read_at timestamp when the user views a watched topic to prevent
 * notifications for already-seen content.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user who is adding a topic to
 *   their watch list
 * @param props.body Information about the discussion topic to add to the user's
 *   watch list
 * @path /discussionBoard/member/users/:userId/watchedTopics
 * @accessor api.functional.discussionBoard.member.users.watchedTopics.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the user who is adding a topic to their watch
     * list
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Information about the discussion topic to add to the user's watch
     * list
     */
    body: IDiscussionBoardWatchedTopic.ICreate;
  };
  export type Body = IDiscussionBoardWatchedTopic.ICreate;
  export type Response = IDiscussionBoardWatchedTopic;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/users/:userId/watchedTopics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/watchedTopics`;
  export const random = (): IDiscussionBoardWatchedTopic =>
    typia.random<IDiscussionBoardWatchedTopic>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of discussion topics watched by a
 * specific user.
 *
 * Retrieve a comprehensive, filtered, and paginated list of all discussion
 * topics that the specified user is currently watching. This operation provides
 * users with full visibility into their watched topics, allowing them to manage
 * which discussions they're tracking for updates and notifications.
 *
 * The operation accesses the discussion_board_watched_topics table which
 * maintains the many-to-many relationship between users and the topics they
 * follow. Each watched topic record includes the last_read_at timestamp,
 * enabling the system to identify which topics have new activity since the user
 * last viewed them. This allows the API to return unread indicators and sort by
 * topics with new activity.
 *
 * Users can watch topics to receive notifications when new replies are posted,
 * when discussions reach vote milestones, or when other significant activity
 * occurs. This operation supports the watched topic notification workflow
 * described in the Notification System requirements, allowing users to review
 * all topics they're monitoring in one centralized view.
 *
 * The operation supports comprehensive filtering options including
 * category-based filtering (Economics, Politics, etc.), activity status (topics
 * with new activity vs. fully read), date ranges for when topics were added to
 * watch list, and text search across watched topic titles and content. Sorting
 * options include most recent activity, newest watched topics first,
 * alphabetical by title, and topics with unread activity prioritized.
 *
 * Security considerations include validating that the requesting user has
 * permission to access the specified user's watched topics list. Users can only
 * retrieve their own watched topics list unless they have moderator or
 * administrator privileges. The operation respects privacy settings and only
 * returns topics the user has permission to view based on topic visibility
 * rules and content access controls.
 *
 * This operation integrates with the discussion management system to retrieve
 * full topic details including title, category, author, creation date, reply
 * count, vote score, and last activity timestamp. It also incorporates the
 * last_read_at timestamp from the watched_topics relationship to calculate and
 * display unread indicators, showing users which watched topics have new
 * activity requiring their attention.
 *
 * Related API operations include POST /users/{userId}/watchedTopics to add new
 * topics to the watch list, DELETE /users/{userId}/watchedTopics/{topicId} to
 * remove topics from watch list, and PATCH
 * /users/{userId}/watchedTopics/{topicId} to update last_read_at timestamp when
 * user views a watched topic.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose watched topics are
 *   being retrieved
 * @param props.body Filtering, pagination, and sorting parameters for the
 *   watched topics list query
 * @path /discussionBoard/member/users/:userId/watchedTopics
 * @accessor api.functional.discussionBoard.member.users.watchedTopics.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the user whose watched topics are being
     * retrieved
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Filtering, pagination, and sorting parameters for the watched topics
     * list query
     */
    body: IDiscussionBoardWatchedTopic.IRequest;
  };
  export type Body = IDiscussionBoardWatchedTopic.IRequest;
  export type Response = IPageIDiscussionBoardWatchedTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/users/:userId/watchedTopics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/watchedTopics`;
  export const random = (): IPageIDiscussionBoardWatchedTopic.ISummary =>
    typia.random<IPageIDiscussionBoardWatchedTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update watched topic subscription settings and tracking information.
 *
 * Update an existing watched topic subscription for a member, modifying watch
 * preferences and activity tracking metadata. This operation allows users to
 * update their watch relationship for a discussion topic they are monitoring
 * for new replies, votes, and other activity updates.
 *
 * The watched topics feature enables members to explicitly track discussions of
 * interest and receive notifications when new activity occurs based on their
 * configured notification preferences. Each watched topic record maintains a
 * last_read_at timestamp that tracks when the user last viewed the topic,
 * enabling the system to determine if new activity has occurred since their
 * last visit and display appropriate unread indicators in the user interface.
 *
 * This operation supports updating the last_read_at timestamp to mark the topic
 * as recently viewed, which is the primary use case for this endpoint. When a
 * user views a watched topic, the client application calls this endpoint to
 * update the last_read_at field, ensuring accurate tracking of which activity
 * is new versus already seen. This timestamp is essential for notification
 * batching logic and unread badge calculations.
 *
 * Security considerations include verifying that the authenticated user owns
 * the watched topic subscription they are attempting to modify. Users can only
 * update their own watched topic records, not those belonging to other users.
 * The system validates that the watch relationship exists and belongs to the
 * requesting user before allowing any modifications.
 *
 * This operation integrates with the notification system to ensure that watch
 * preference changes immediately affect future notification generation. If a
 * user updates their watch settings to disable notifications, the system
 * respects this preference for subsequent activity on the watched topic.
 *
 * The operation validates that the watched topic subscription exists and is
 * active (not soft-deleted). If the watch relationship has been removed or the
 * underlying topic has been deleted, the update operation fails with an
 * appropriate error message directing the user to re-watch the topic if
 * desired.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the member who owns the watched
 *   topic subscription
 * @param props.watchedTopicId Unique identifier of the watched topic
 *   subscription to update
 * @param props.body Update data for the watched topic subscription including
 *   last read timestamp and watch status
 * @path /discussionBoard/member/users/:userId/watchedTopics/:watchedTopicId
 * @accessor api.functional.discussionBoard.member.users.watchedTopics.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the member who owns the watched topic
     * subscription
     */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the watched topic subscription to update */
    watchedTopicId: string & tags.Format<"uuid">;

    /**
     * Update data for the watched topic subscription including last read
     * timestamp and watch status
     */
    body: IDiscussionBoardWatchedTopic.IUpdate;
  };
  export type Body = IDiscussionBoardWatchedTopic.IUpdate;
  export type Response = IDiscussionBoardWatchedTopic;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/users/:userId/watchedTopics/:watchedTopicId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/watchedTopics/${encodeURIComponent(props.watchedTopicId ?? "null")}`;
  export const random = (): IDiscussionBoardWatchedTopic =>
    typia.random<IDiscussionBoardWatchedTopic>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("watchedTopicId")(() => typia.assert(props.watchedTopicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete watched topic subscription to stop monitoring a discussion.
 *
 * Soft delete an existing watched topic subscription for a member by setting
 * the deleted_at timestamp, marking the watch relationship as deleted while
 * preserving the record for potential recovery and analytics. This operation
 * allows users to unwatch discussion topics they no longer wish to monitor,
 * cleaning up their watched topics list and reducing notification volume.
 *
 * The watched topics feature enables members to explicitly track discussions of
 * interest and receive notifications when new replies, votes, or other activity
 * occurs. When a user no longer finds a topic relevant or wishes to reduce
 * their notification volume, they can unwatch the topic through this operation.
 * Unwatching a topic immediately stops all future notifications about that
 * topic's activity, respecting the user's preference to disengage from that
 * particular discussion.
 *
 * This operation performs a soft delete on the watched topic subscription by
 * setting the deleted_at timestamp in the discussion_board_watched_topics
 * table. The Prisma schema includes a deleted_at field specifically to support
 * recovery of accidentally removed watch subscriptions. Soft deletion preserves
 * the watch history for analytics purposes while hiding the relationship from
 * active user interfaces and stopping notification generation.
 *
 * Security considerations include strict ownership validation to ensure users
 * can only unwatch their own topic subscriptions, not those belonging to other
 * users. The system verifies that the authenticated user's ID matches the
 * user_id associated with the watched topic record before allowing deletion.
 * This prevents unauthorized manipulation of other users' watch lists.
 *
 * The operation validates that the watched topic subscription exists and is
 * currently active (deleted_at is null) before proceeding with soft deletion.
 * If the subscription has already been deleted or does not exist, the operation
 * returns an appropriate error message. Users cannot delete watch subscriptions
 * that belong to other users, even if they know the watched topic ID.
 *
 * After successful soft deletion, the watched topic is immediately removed from
 * the user's watched topics list in the user interface. Any pending
 * notifications for this topic that have not yet been delivered are cancelled
 * or filtered to exclude this topic. The user will not receive any future
 * notifications about activity on this topic unless they explicitly watch it
 * again by creating a new watch subscription.
 *
 * This operation integrates with the notification system by triggering cleanup
 * of pending batched notifications that referenced this watched topic. If the
 * user had notifications queued in an hourly or daily digest mentioning this
 * topic, those notifications are filtered out to respect the user's decision to
 * unwatch.
 *
 * The soft deletion approach means that if a user accidentally unwatches a
 * topic, administrators or the system can potentially restore the subscription
 * within the 30-day recovery window defined in platform policies. The record
 * remains in the database with deleted_at timestamp set, preserving the watch
 * history for analytics and audit purposes while excluding it from active user
 * queries and notification generation logic.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the member who owns the watched
 *   topic subscription to delete
 * @param props.watchedTopicId Unique identifier of the watched topic
 *   subscription to remove
 * @path /discussionBoard/member/users/:userId/watchedTopics/:watchedTopicId
 * @accessor api.functional.discussionBoard.member.users.watchedTopics.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the member who owns the watched topic
     * subscription to delete
     */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the watched topic subscription to remove */
    watchedTopicId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/users/:userId/watchedTopics/:watchedTopicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/users/${encodeURIComponent(props.userId ?? "null")}/watchedTopics/${encodeURIComponent(props.watchedTopicId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("watchedTopicId")(() => typia.assert(props.watchedTopicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
