import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardSession } from "../../../../../structures/IDiscussionBoardSession";
import { IPageIDiscussionBoardSession } from "../../../../../structures/IPageIDiscussionBoardSession";

/**
 * Retrieve and filter active sessions for any user account (administrator
 * access).
 *
 * This operation retrieves a comprehensive, filtered, and paginated list of
 * active sessions for any specified user from the discussion_board_sessions
 * table. Unlike the member-scoped session retrieval, this administrator
 * operation can access session data for any user on the platform to support
 * security investigations, user support requests, and account monitoring.
 *
 * The operation supports advanced filtering capabilities to help administrators
 * find specific sessions based on various criteria including device type
 * (Desktop, Mobile, Tablet), browser information (Chrome, Firefox, Safari,
 * etc.), approximate geographic location, IP address patterns, login timestamp
 * ranges, and last activity timeframe. Administrators can search for sessions
 * that meet multiple filter criteria simultaneously to identify suspicious
 * login patterns, unusual device usage, or potential account compromises.
 *
 * Each session record in the response includes comprehensive metadata essential
 * for security assessment. This includes the device type extracted from the
 * user agent string, browser name and version information, the IP address from
 * which the session was created, an approximate geographic location based on IP
 * geolocation (city-level precision), the timestamp when the user logged in to
 * create this session, the timestamp of the most recent activity in this
 * session, the session's expiration timestamp, and whether the session is
 * currently active or has been revoked.
 *
 * Security considerations are critical for this administrative operation. Only
 * users with administrator privileges can access this endpoint, as it provides
 * visibility into any user's session data. This access is necessary for
 * legitimate security investigations (detecting account takeovers,
 * investigating suspicious activity patterns) and user support (helping users
 * who report unauthorized access). However, the sensitive nature of session
 * data requires that administrator access is logged in security audit trails.
 *
 * The operation integrates with the multi-device session management
 * functionality and administrator security tools defined in the User Roles and
 * Authentication document. Administrators can use this data to assist users
 * with session management issues, investigate security incidents, identify
 * patterns of abuse or unauthorized access, and take appropriate action such as
 * revoking suspicious sessions or implementing additional security measures for
 * compromised accounts.
 *
 * Pagination is essential given that users may have numerous historical session
 * records, and administrators may be reviewing session data across multiple
 * users. The response should include pagination metadata indicating the current
 * page, total number of sessions matching the filters, and page size. Sorting
 * options allow administrators to organize sessions by most recent activity,
 * login timestamp, or other criteria to quickly identify relevant sessions for
 * their investigation or support task.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose sessions are being
 *   retrieved by the administrator
 * @param props.body Filter criteria and pagination parameters for retrieving
 *   user sessions including device type, location, activity timeframe, and
 *   sorting preferences
 * @path /discussionBoard/administrator/users/:userId/sessions
 * @accessor api.functional.discussionBoard.administrator.users.sessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the user whose sessions are being retrieved by
     * the administrator
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Filter criteria and pagination parameters for retrieving user
     * sessions including device type, location, activity timeframe, and
     * sorting preferences
     */
    body: IDiscussionBoardSession.IRequest;
  };
  export type Body = IDiscussionBoardSession.IRequest;
  export type Response = IPageIDiscussionBoardSession;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/administrator/users/:userId/sessions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/administrator/users/${encodeURIComponent(props.userId ?? "null")}/sessions`;
  export const random = (): IPageIDiscussionBoardSession =>
    typia.random<IPageIDiscussionBoardSession>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
