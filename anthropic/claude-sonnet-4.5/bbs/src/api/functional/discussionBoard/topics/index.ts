import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardTopic } from "../../../structures/IDiscussionBoardTopic";
import { IPageIDiscussionBoardTopic } from "../../../structures/IPageIDiscussionBoardTopic";
import { IPageIDiscussionBoardEditHistory } from "../../../structures/IPageIDiscussionBoardEditHistory";
export * as replies from "./replies/index";

/**
 * Retrieve filtered and paginated list of discussion topics with advanced
 * search capabilities.
 *
 * Retrieve a comprehensive, filtered, and paginated list of discussion topics
 * from the economic and political discussion board platform. This operation
 * provides the primary mechanism for content discovery, allowing users to
 * search, filter, sort, and browse discussions based on multiple criteria
 * including keywords, categories, tags, vote scores, date ranges, author, and
 * topic status.
 *
 * The operation implements complex search and filtering functionality that goes
 * beyond simple GET parameters, justifying the PATCH method for the request
 * body. Users can combine multiple filters simultaneously to find highly
 * specific discussions on economic and political topics. For example, users
 * might search for "inflation policy" within the Economics category, tagged
 * with "monetary-policy", created in the last 30 days, with at least 10 votes,
 * sorted by recent activity.
 *
 * This operation integrates with the discussion_board_topics table as defined
 * in the Prisma schema, accessing fields including title, body, status,
 * view_count, reply_count, is_pinned, created_at, and updated_at. It also joins
 * with discussion_board_categories for category filtering,
 * discussion_board_topic_tags and discussion_board_tags for tag-based
 * filtering, and discussion_board_members for author information.
 *
 * The search functionality implements full-text search across topic titles and
 * body content using PostgreSQL's trigram indexing capabilities (as indicated
 * by the gin_trgm_ops indexes in the schema). This enables efficient fuzzy
 * matching and relevance-based ranking of search results. The operation
 * enforces rate limiting of 30 searches per minute per user as specified in the
 * business rules to prevent system abuse.
 *
 * Security considerations include appropriate filtering based on topic status
 * and deleted_at timestamps. Deleted topics (deleted_at IS NOT NULL) are
 * excluded from results for regular users but may be visible to moderators and
 * administrators based on their roles. Topics with status 'active' are shown
 * normally, while 'locked' and 'archived' topics are included with appropriate
 * status indicators.
 *
 * The response includes paginated results with topic summary information
 * optimized for list displays. Each topic in the results includes essential
 * metadata: title, author username, category name, creation date, reply count,
 * view count, vote score, tags, and last activity timestamp. The pagination
 * structure follows the platform standard of 25 topics per page as defined in
 * the Discussion Management requirements.
 *
 * Related API operations that might be used together with this endpoint include
 * GET /discussionBoard/topics/{topicId} for viewing individual topic details
 * after discovering them through this search operation. Users typically first
 * execute this search/filter operation to get a list of relevant topics, then
 * navigate to specific topics for detailed reading.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, and pagination parameters for
 *   retrieving discussion topics
 * @path /discussionBoard/topics
 * @accessor api.functional.discussionBoard.topics.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, and pagination parameters for retrieving
     * discussion topics
     */
    body: IDiscussionBoardTopic.IRequest;
  };
  export type Body = IDiscussionBoardTopic.IRequest;
  export type Response = IPageIDiscussionBoardTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/topics";
  export const random = (): IPageIDiscussionBoardTopic.ISummary =>
    typia.random<IPageIDiscussionBoardTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific discussion topic by ID.
 *
 * Retrieve complete detailed information for a specific discussion topic
 * identified by the topicId path parameter. This operation provides the full
 * topic view that users access when they click on a topic from search results,
 * category listings, or direct links. The operation returns comprehensive topic
 * data including the complete title and body content, author details, category
 * assignment, associated tags, engagement metrics (votes, views, replies), and
 * current topic status.
 *
 * This operation integrates directly with the discussion_board_topics table
 * from the Prisma schema, accessing all fields including id, title, body,
 * status, view_count, reply_count, is_pinned, created_at, updated_at, and
 * deleted_at. The operation joins with discussion_board_categories to retrieve
 * the full category information, discussion_board_members to get author
 * details, and discussion_board_topic_tags to fetch all associated tags for the
 * topic.
 *
 * Security and visibility considerations are critical for this operation. The
 * system validates that the requested topic exists and has not been
 * soft-deleted. Topics where deleted_at IS NOT NULL are excluded from regular
 * user access and return 404 Not Found, while moderators and administrators can
 * view deleted topics with appropriate indicators. Topics with status 'locked'
 * or 'archived' remain visible to all users but display status badges and have
 * restricted interaction capabilities.
 *
 * The operation implements view count tracking per the business requirements:
 * when any user views a topic, the system automatically increments the
 * view_count field in the discussion_board_topics table as a side effect of
 * this GET operation. The system counts only one view per user per 24-hour
 * period to prevent artificial inflation. This tracking is handled internally
 * by the backend service logic and does not require a separate API operation.
 *
 * The detailed topic response includes author information from the
 * discussion_board_members table such as username, display_name, avatar_url,
 * and account_status. This allows users to see who created the topic and access
 * their profile for more context about the author's contribution history and
 * expertise.
 *
 * Category information is fully expanded in the response, including the
 * category name, slug, description, and parent category if applicable (for
 * hierarchical category structures like Economics > Macroeconomics). This
 * provides users with complete context about how the topic is organized within
 * the platform's taxonomy.
 *
 * All associated tags are retrieved through the discussion_board_topic_tags
 * junction table and included in the response. Tags help users understand the
 * topic's specific focus areas and enable tag-based discovery of related
 * discussions. The response includes tag names and may include tag descriptions
 * where available.
 *
 * Engagement metrics included in the response provide social proof and indicate
 * discussion activity levels: view_count shows how many users have viewed the
 * topic, reply_count indicates the level of discussion activity, and vote
 * scores (calculated from related voting data) show community reception. The
 * is_pinned field indicates whether moderators have featured this topic as
 * particularly important or high-quality.
 *
 * Temporal information helps users understand topic timeline: created_at shows
 * when the topic was first posted, updated_at reflects the last modification
 * (either topic edit or new reply), enabling sorting by recent activity. If the
 * topic has been edited, the response may include an edited indicator based on
 * data from the discussion_board_edit_history table.
 *
 * This operation must be executed before users can interact with a topic
 * through replies, votes, or other engagement mechanisms. It provides the
 * foundation for all topic-specific operations including operations for posting
 * replies, voting, and bookmarking the topic.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the discussion topic to retrieve
 * @path /discussionBoard/topics/:topicId
 * @accessor api.functional.discussionBoard.topics.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the discussion topic to retrieve */
    topicId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardTopic;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IDiscussionBoardTopic =>
    typia.random<IDiscussionBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve paginated edit history for a specific discussion topic.
 *
 * Retrieve the complete edit history for a specific discussion topic, providing
 * transparency into content modifications over time. This operation queries the
 * discussion_board_edit_history table filtering for entity_type='topic' and
 * entity_id matching the specified topicId parameter.
 *
 * The edit history serves multiple critical purposes in maintaining platform
 * integrity and user trust. For economic and political discussions where
 * accuracy and context matter significantly, users need visibility into how
 * discussion topics have evolved. Each edit record captures a snapshot of the
 * content before and after modification, the editor's identity, the timestamp,
 * and optionally the reason for the edit.
 *
 * This operation supports pagination and filtering capabilities through the
 * request body, allowing users to navigate through extensive edit histories
 * efficiently. Users can filter by date ranges to see recent modifications or
 * historical changes, sort by edit timestamp to understand content evolution
 * chronologically, and search within edit history to find specific
 * modifications.
 *
 * Security considerations include verifying that the topic exists and is
 * accessible to the requesting user based on their role and the topic's
 * visibility settings. While edit history is generally public for transparency,
 * deleted or hidden topics may have restricted edit history access limited to
 * moderators and administrators. The operation respects content visibility
 * rules defined in the discussion management system.
 *
 * The response includes comprehensive edit information: previous content state,
 * new content state, editor information (username and role), edit timestamp,
 * optional edit reason, and metadata about the edit context. This level of
 * detail enables users to understand exactly how and why content changed,
 * supporting informed discussion participation and content verification.
 *
 * Related operations that work together with this endpoint include GET
 * /topics/{topicId} to view the current topic state, and PATCH /topics to
 * search for topics that might have interesting edit histories. The edit
 * history complements the main discussion viewing experience by providing the
 * temporal dimension of content evolution.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the discussion topic whose edit
 *   history is being retrieved
 * @param props.body Pagination, filtering, and sorting parameters for
 *   retrieving topic edit history
 * @path /discussionBoard/topics/:topicId/editHistory
 * @accessor api.functional.discussionBoard.topics.editHistory
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function editHistory(
  connection: IConnection,
  props: editHistory.Props,
): Promise<editHistory.Response> {
  return true === connection.simulate
    ? editHistory.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...editHistory.METADATA,
          path: editHistory.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace editHistory {
  export type Props = {
    /**
     * Unique identifier of the discussion topic whose edit history is being
     * retrieved
     */
    topicId: string & tags.Format<"uuid">;

    /**
     * Pagination, filtering, and sorting parameters for retrieving topic
     * edit history
     */
    body: IDiscussionBoardTopic.IEditHistoryRequest;
  };
  export type Body = IDiscussionBoardTopic.IEditHistoryRequest;
  export type Response = IPageIDiscussionBoardEditHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/topics/:topicId/editHistory",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/topics/${encodeURIComponent(props.topicId ?? "null")}/editHistory`;
  export const random = (): IPageIDiscussionBoardEditHistory =>
    typia.random<IPageIDiscussionBoardEditHistory>();
  export const simulate = (
    connection: IConnection,
    props: editHistory.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: editHistory.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
