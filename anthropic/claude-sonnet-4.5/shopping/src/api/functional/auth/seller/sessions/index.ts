import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSeller } from "../../../../structures/IShoppingMallSeller";

/**
 * Retrieve all active seller authentication sessions.
 *
 * Returns a comprehensive list of all current authentication sessions for the
 * authenticated seller, enabling security monitoring and multi-device session
 * management. This endpoint provides transparency into where and how the
 * seller's account is currently accessed, supporting security best practices by
 * allowing sellers to identify and revoke suspicious or unauthorized sessions.
 *
 * Authentication validation extracts the seller ID from the JWT access token
 * claims (sub or userId claim containing the seller's unique identifier) and
 * verifies the authenticated user has seller role. The endpoint queries the
 * shopping_mall_sessions table for all records where seller_id equals the
 * authenticated seller's ID, user_type equals 'seller', and is_revoked is false
 * (only active, non-revoked sessions are returned).
 *
 * Session information retrieval fetches comprehensive metadata for each active
 * session including device identification details (device_type indicating
 * mobile, tablet, or desktop; device_name providing user-friendly description
 * like 'Chrome on Windows' or 'Safari on iPhone'; browser_name identifying
 * Chrome, Firefox, Safari, Edge; operating_system showing Windows, macOS, iOS,
 * Android, Linux), location data (ip_address for technical reference,
 * approximate_location providing city and country derived from IP geolocation
 * such as 'New York, US' or 'London, UK'), and temporal information (created_at
 * showing when the session was established via login, last_activity_at
 * indicating most recent authenticated request or token refresh,
 * refresh_token_expires_at showing when the session will automatically
 * expire).
 *
 * Current session identification determines which session in the list
 * corresponds to the request being processed by comparing the refresh token
 * used in the current request (extracted from Authorization header or session
 * cookie) against the refresh_token field of each session record. The matching
 * session is flagged with is_current_session indicator in the response,
 * preventing sellers from accidentally revoking their own active session and
 * providing context for session management decisions.
 *
 * Session security analysis calculates session age (current_time - created_at),
 * inactivity duration (current_time - last_activity_at), and remaining token
 * lifetime (refresh_token_expires_at - current_time) for each session. Sessions
 * approaching expiration (within 7 days of refresh_token_expires_at) are
 * flagged with expiring_soon indicator, prompting sellers to maintain activity
 * to preserve the session or prepare for re-authentication.
 *
 * Sorting and organization presents sessions ordered by last_activity_at
 * descending, showing the most recently active sessions first. This prioritizes
 * currently-in-use sessions at the top of the list while relegating dormant or
 * forgotten sessions to the bottom. The response groups sessions by device type
 * (mobile sessions, tablet sessions, desktop sessions) for easier visual
 * scanning when sellers have many active sessions.
 *
 * Security indicators highlight suspicious patterns such as sessions from
 * unusual locations (compared to seller's typical login locations stored in
 * login history), sessions from IP addresses flagged in security databases,
 * concurrent sessions from geographically distant locations (physically
 * impossible without VPN or credential sharing), and new device logins that
 * occurred recently (within last 24 hours, flagged for seller awareness).
 *
 * The response provides actionable session management by including each
 * session's unique ID, enabling sellers to invoke the session revocation
 * endpoint for specific sessions they want to terminate. The list also
 * indicates which sessions are close to expiration (within 7 days) so sellers
 * can proactively refresh tokens or prepare for re-authentication.
 *
 * This endpoint integrates with the platform's security monitoring by logging
 * session list access (who viewed their sessions and when) and potentially
 * triggering security alerts if unusual access patterns are detected (e.g.,
 * session list checked immediately before password change from unfamiliar
 * location could indicate account compromise investigation).
 *
 * @param props.connection
 * @path /auth/seller/sessions
 * @accessor api.functional.auth.seller.sessions.listActiveSessions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function listActiveSessions(
  connection: IConnection,
): Promise<listActiveSessions.Response> {
  return true === connection.simulate
    ? listActiveSessions.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...listActiveSessions.METADATA,
          path: listActiveSessions.path(),
          status: null,
        },
      );
}
export namespace listActiveSessions {
  export type Response = IShoppingMallSeller.ISessionList;

  export const METADATA = {
    method: "GET",
    path: "/auth/seller/sessions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/sessions";
  export const random = (): IShoppingMallSeller.ISessionList =>
    typia.random<IShoppingMallSeller.ISessionList>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Revoke specific seller authentication session.
 *
 * Terminates a specific authentication session by invalidating its refresh
 * token, forcing re-login on the associated device or browser. This endpoint
 * provides sellers with granular session management capabilities, enabling
 * remote logout from specific devices for security purposes such as terminating
 * sessions on lost devices, public computers, or suspicious login locations.
 *
 * Authentication and ownership validation extracts the seller ID from the JWT
 * access token claims and verifies the authenticated user has seller role. The
 * endpoint receives the sessionId path parameter (UUID from
 * shopping_mall_sessions.id field) and queries the shopping_mall_sessions table
 * to verify the session exists where id equals sessionId, seller_id equals the
 * authenticated seller's ID, and user_type equals 'seller'. If the session is
 * not found or belongs to a different seller, the endpoint returns error
 * 'Session not found or you do not have permission to revoke it' to prevent
 * unauthorized session manipulation.
 *
 * Current session protection prevents sellers from accidentally locking
 * themselves out by revoking their own active session. The system identifies
 * the current session by comparing the sessionId parameter against the session
 * ID associated with the current request's authentication token (determined by
 * matching the refresh token in the request against refresh_token field in
 * shopping_mall_sessions, or by extracting session ID from JWT token claims if
 * embedded). If sessionId matches the current session, the endpoint returns
 * error 'Cannot revoke your current active session. Please use the logout
 * endpoint to end your current session' and blocks the revocation to maintain
 * seller access.
 *
 * Session revocation updates execute an atomic database transaction on the
 * shopping_mall_sessions table, setting is_revoked to true and revoked_at to
 * the current timestamp for the session where id equals sessionId. This
 * immediately invalidates the session - any subsequent token refresh attempts
 * using that session's refresh_token will fail with authentication error, and
 * any active access tokens from that session will become invalid on next
 * validation (access tokens are short-lived, 30-minute expiration, so impact is
 * near-immediate).
 *
 * Revoked session cannot be reactivated - session revocation is permanent and
 * irreversible. The seller must log in again on the affected device to create a
 * new session with fresh tokens. The revoked session data is retained in the
 * database for security audit trail purposes with is_revoked marker clearly
 * indicating the session termination.
 *
 * Security notification email is sent to the seller's registered email address
 * confirming the session revocation, including details about the revoked
 * session (device_name like 'Chrome on Windows', approximate_location like 'New
 * York, US', created_at showing when that session was originally established,
 * ip_address for technical reference). The notification also includes advisory
 * 'If you did not initiate this action, your account may be compromised. Please
 * change your password immediately' to alert the seller of potential
 * unauthorized access.
 *
 * Device and location information in the notification helps the seller verify
 * the revocation was legitimate (e.g., 'Yes, I revoked my old work laptop
 * session from New York' vs. 'I never logged in from Russia, this is
 * suspicious'). The notification is sent asynchronously within 5 minutes of
 * revocation.
 *
 * The endpoint returns a success confirmation message 'Session revoked
 * successfully. The device will be logged out shortly' along with the revoked
 * session's device information for seller confirmation. No tokens are issued or
 * modified for the current session - only the target session identified by
 * sessionId is affected.
 *
 * This operation integrates with the session security monitoring system,
 * logging all revocation events with timestamp, initiating seller, revoked
 * session details, and IP address from which revocation was requested. Patterns
 * of frequent session revocations may indicate security issues or account
 * sharing, triggering security alerts for admin investigation.
 *
 * @param props.connection
 * @param props.sessionId Unique identifier of the session to revoke
 * @path /auth/seller/sessions/:sessionId
 * @accessor api.functional.auth.seller.sessions.revokeSession
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function revokeSession(
  connection: IConnection,
  props: revokeSession.Props,
): Promise<revokeSession.Response> {
  return true === connection.simulate
    ? revokeSession.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...revokeSession.METADATA,
          path: revokeSession.path(props),
          status: null,
        },
      );
}
export namespace revokeSession {
  export type Props = {
    /** Unique identifier of the session to revoke */
    sessionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSeller.ISessionRevokeResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/auth/seller/sessions/:sessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/auth/seller/sessions/${encodeURIComponent(props.sessionId ?? "null")}`;
  export const random = (): IShoppingMallSeller.ISessionRevokeResponse =>
    typia.random<IShoppingMallSeller.ISessionRevokeResponse>();
  export const simulate = (
    connection: IConnection,
    props: revokeSession.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: revokeSession.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sessionId")(() => typia.assert(props.sessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
