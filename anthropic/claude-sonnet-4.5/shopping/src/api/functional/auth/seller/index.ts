import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSeller } from "../../../structures/IShoppingMallSeller";
export * as password from "./password/index";
export * as verification from "./verification/index";
export * as sessions from "./sessions/index";

/**
 * Register new seller account and issue authentication tokens.
 *
 * Creates a new seller account in the shopping_mall_sellers table with
 * comprehensive business information required for vendor onboarding and
 * marketplace participation. This endpoint handles the complete seller
 * registration workflow including business entity verification data collection,
 * authentication credential setup, and initial JWT token issuance for immediate
 * platform access.
 *
 * The registration process collects essential business information including
 * business_name (publicly displayed store name), business_type (individual,
 * LLC, corporation, partnership), contact_person_name (primary contact), email
 * (unique authentication identifier), phone (business contact number),
 * business_address (physical location for verification), tax_id (for tax
 * reporting and payout processing), and optional banking details
 * (bank_account_number, bank_routing_number, bank_account_holder_name) for
 * future payout configuration.
 *
 * Upon successful registration, the system creates a seller record with
 * account_status set to 'pending_approval' and email_verified set to false,
 * requiring subsequent email verification and administrator approval before
 * full platform access is granted. The operation generates a unique
 * email_verification_token (expires in 24 hours) and sets
 * email_verification_sent_at timestamp for verification workflow tracking.
 *
 * Security measures include password hashing using bcrypt or Argon2 (stored in
 * password_hash field), initialization of failed login attempt tracking
 * (failed_login_attempts set to 0, failed_login_window_start_at set to null),
 * and account lockout prevention fields (account_locked_until set to null). The
 * password_changed_at timestamp is set to the current time, and
 * password_history is initialized as empty JSON array for future password
 * rotation enforcement.
 *
 * The endpoint immediately issues JWT authentication tokens (access token with
 * 30-minute expiration and refresh token with 30-day expiration) enabling the
 * seller to access their account dashboard and view application status, though
 * product management and order fulfillment capabilities remain restricted until
 * account approval. The commission_rate is set to the platform default
 * (typically 0.10 for 10%), and optional store customization fields
 * (store_url_slug, store_description, store_logo_url, store_banner_url) can be
 * provided or configured later.
 *
 * This operation integrates with the email notification system to send
 * verification emails, the session management system to create initial
 * authentication sessions, and the admin notification system to alert
 * administrators of new seller applications requiring review. The created_at
 * and updated_at timestamps are set to the current time for audit trail
 * establishment.
 *
 * @param props.connection
 * @param props.body Seller registration information including business details,
 *   contact information, and authentication credentials
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/join
 * @accessor api.functional.auth.seller.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Seller registration information including business details, contact
     * information, and authentication credentials
     */
    body: IShoppingMallSeller.ICreate;
  };
  export type Body = IShoppingMallSeller.ICreate;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/join";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate seller and issue access tokens.
 *
 * Validates seller login credentials (email and password) and issues JWT
 * authentication tokens for platform access. This endpoint performs
 * multi-layered authentication validation to ensure secure seller access to
 * product management, inventory controls, order fulfillment, and analytics
 * features.
 *
 * The authentication process validates the seller exists in the
 * shopping_mall_sellers table by querying with the provided email address (must
 * match exactly, case-insensitive comparison). The endpoint verifies the
 * account_status field is set to 'active' - accounts with 'pending_approval',
 * 'suspended', 'banned', or 'on_hold' status are denied access with specific
 * error messages indicating the account state and required actions.
 *
 * Email verification is enforced by checking the email_verified field is true.
 * Sellers who have registered but not verified their email (email_verified =
 * false) cannot authenticate and receive a prompt to complete email
 * verification using the verification link sent to their registered email
 * address. The system allows requesting a new verification email if the
 * original email_verification_token has expired (24-hour expiration from
 * email_verification_sent_at timestamp).
 *
 * Password validation compares the provided password against the stored
 * password_hash using bcrypt or Argon2 verification. The system implements
 * account lockout protection by checking if account_locked_until timestamp is
 * set and has not passed - locked accounts display the remaining lockout
 * duration and suggest password reset or waiting for automatic unlock (30
 * minutes from lock time).
 *
 * Failed authentication attempts are tracked using failed_login_attempts
 * counter and failed_login_window_start_at timestamp. The system increments
 * failed_login_attempts on invalid password and checks if 5 failures occurred
 * within the 15-minute window defined by failed_login_window_start_at. Upon
 * reaching 5 failures, the account_locked_until field is set to 30 minutes from
 * current time, account is locked, and the seller receives notification email
 * about the security lockout.
 *
 * Successful authentication resets security counters (failed_login_attempts to
 * 0, failed_login_window_start_at to null, account_locked_until to null),
 * generates new JWT access token (30-minute expiration) and refresh token
 * (30-day expiration), creates a session record in shopping_mall_sessions table
 * with device information and IP address tracking, and returns the complete
 * seller profile along with authentication tokens.
 *
 * The response includes seller account details (id, email, business_name,
 * account_status, store information), authentication tokens for API access, and
 * session metadata. The seller can immediately access their dashboard, manage
 * products and inventory, view and process orders, respond to reviews, and
 * access sales analytics using the provided tokens.
 *
 * @param props.connection
 * @param props.body Seller login credentials containing email and password for
 *   authentication
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/login
 * @accessor api.functional.auth.seller.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Seller login credentials containing email and password for
     * authentication
     */
    body: IShoppingMallSeller.ILogin;
  };
  export type Body = IShoppingMallSeller.ILogin;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/login";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh seller access tokens using valid refresh token.
 *
 * Renews JWT access tokens for sellers using a valid refresh token, enabling
 * session extension without re-authentication. This endpoint is critical for
 * maintaining continuous seller access to the platform when access tokens
 * expire (30-minute lifetime), providing seamless user experience for ongoing
 * product management, inventory updates, and order fulfillment activities.
 *
 * The token refresh process validates the provided refresh token by querying
 * the shopping_mall_sessions table where refresh_token matches the provided
 * token, user_type equals 'seller', and seller_id is not null. The system
 * performs comprehensive validation checks including verifying
 * refresh_token_expires_at timestamp has not passed (30-day token lifetime),
 * confirming is_revoked field is false (session not manually terminated), and
 * validating the associated seller account exists and is active in
 * shopping_mall_sellers table.
 *
 * Session activity tracking updates the last_activity_at timestamp to the
 * current time, maintaining the session as active and preventing automatic
 * expiration due to the 30-day inactivity threshold. The system checks if
 * sessions have been inactive for 30 days by comparing current time against
 * last_activity_at, automatically expiring and revoking stale sessions.
 *
 * Token renewal logic generates a new JWT access token with fresh 30-minute
 * expiration containing seller authentication claims (seller ID, email, role,
 * permissions). The existing refresh token is maintained unless it is within 7
 * days of expiration (refresh_token_expires_at - current_time < 7 days), in
 * which case a new refresh token is generated with extended 30-day lifetime and
 * the session record is updated with the new refresh_token value and
 * refresh_token_expires_at timestamp.
 *
 * The endpoint returns the complete seller profile information (id, email,
 * business_name, account_status, email_verified, store_url_slug,
 * store_description, commission_rate, and other seller-specific fields from
 * shopping_mall_sellers table) along with the new access token and refresh
 * token (if renewed). This enables the seller application to update stored
 * credentials and continue authenticated operations without interruption.
 *
 * Security features include automatic session revocation detection (is_revoked
 * = true returns authentication error), device and location tracking through
 * existing session metadata (ip_address, user_agent, device_type, browser_name,
 * operating_system, approximate_location fields), and comprehensive audit
 * logging of token refresh operations for security monitoring and fraud
 * detection.
 *
 * @param props.connection
 * @param props.body Refresh token for generating new access tokens
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/refresh
 * @accessor api.functional.auth.seller.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for generating new access tokens */
    body: IShoppingMallSeller.IRefresh;
  };
  export type Body = IShoppingMallSeller.IRefresh;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/refresh";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout seller from current session.
 *
 * Terminates the seller's current authentication session by revoking the
 * refresh token and invalidating access, requiring fresh login for subsequent
 * platform access. This endpoint provides sellers with immediate logout
 * functionality to end their work session securely, clear authentication state,
 * and ensure their account credentials are not accessible from the current
 * device or browser.
 *
 * Session identification determines the current session by extracting the
 * refresh token from the request (typically sent in Authorization header as
 * Bearer token or in httpOnly session cookie). The system queries the
 * shopping_mall_sessions table for the record where refresh_token equals the
 * provided token, user_type equals 'seller', and seller_id equals the
 * authenticated seller's ID (from JWT access token claims). If the session is
 * not found or already revoked (is_revoked = true), the endpoint returns error
 * 'Session not found or already logged out'.
 *
 * Authentication validation verifies the seller is authenticated with a valid
 * JWT access token before processing logout. While logout conceptually ends
 * authentication, the request itself must be authenticated to prevent
 * unauthorized session termination. The seller ID from the access token must
 * match the seller_id associated with the refresh token's session to ensure
 * sellers can only log out their own sessions.
 *
 * Session revocation executes an atomic database update on the
 * shopping_mall_sessions table, setting is_revoked to true and revoked_at to
 * the current timestamp for the session where refresh_token matches the
 * request's refresh token. This immediately invalidates the session - the
 * refresh token can no longer be used to generate new access tokens, and the
 * seller is effectively logged out. The last_activity_at timestamp is updated
 * to the current time as the final activity of the session.
 *
 * Token invalidation guidance instructs the client application to immediately
 * discard all stored authentication credentials including the access token
 * (stored in memory, localStorage, or sessionStorage), the refresh token
 * (stored in httpOnly cookie or secure storage), and any cached seller profile
 * data. The response confirms 'Logged out successfully. Please remove all
 * stored tokens' to ensure client-side cleanup.
 *
 * Current access token remains technically valid until its natural expiration
 * (30 minutes from issuance) since JWT tokens are stateless and cannot be
 * immediately invalidated server-side without token blacklisting
 * infrastructure. However, the revoked refresh token prevents generation of new
 * access tokens, so the seller's session effectively ends within 30 minutes
 * maximum (when current access token expires). For immediate access revocation,
 * the platform may implement optional access token blacklisting checked on each
 * authenticated request.
 *
 * Security audit logging records the logout event with comprehensive details
 * including the seller's ID, email, session metadata (device_name,
 * browser_name, operating_system, approximate_location, ip_address), logout
 * timestamp, and session lifetime (created_at to revoked_at duration). This
 * audit trail supports security monitoring and investigation of unusual account
 * activity.
 *
 * Anomalous logout detection identifies logout events from unusual locations or
 * devices that differ from the seller's typical login patterns. If logout
 * occurs from an IP address or location inconsistent with the seller's
 * historical logins, the system sends a security notification email to the
 * seller's registered email address alerting them that a logout occurred from
 * an unfamiliar location (e.g., 'Your account was logged out from Paris, France
 * on Chrome/Windows at 2025-10-13 14:30 UTC'). This notification helps sellers
 * detect potential account compromise where an attacker gained access and then
 * logged out to cover tracks.
 *
 * Multi-session awareness does not affect other active sessions - logout only
 * revokes the specific session associated with the provided refresh token.
 * Sellers logged in on other devices or browsers remain authenticated with
 * their respective sessions until those sessions are individually logged out or
 * revoked. To log out from all devices simultaneously, sellers should use a
 * 'logout from all devices' endpoint (if available) or manually revoke all
 * sessions via the session management interface.
 *
 * The endpoint returns a minimal success response with confirmation message and
 * no sensitive data, as the seller is being logged out and should not continue
 * using authentication credentials. Client applications should redirect to
 * login page or public homepage after successful logout.
 *
 * @param props.connection
 * @path /auth/seller/logout
 * @accessor api.functional.auth.seller.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export type Response = IShoppingMallSeller.ILogoutResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/logout";
  export const random = (): IShoppingMallSeller.ILogoutResponse =>
    typia.random<IShoppingMallSeller.ILogoutResponse>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
