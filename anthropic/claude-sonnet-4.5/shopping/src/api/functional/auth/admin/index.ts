import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdmin } from "../../../structures/IShoppingMallAdmin";
export * as password from "./password/index";
export * as sessions from "./sessions/index";

/**
 * Create new admin account (admin role creation via existing admin).
 *
 * Creates a new admin account through an existing authenticated administrator.
 * This endpoint implements the admin account creation workflow as specified in
 * the business requirements, where admin accounts cannot be self-registered and
 * must be created by existing admins to maintain security and accountability.
 *
 * The operation requires the requesting admin to be authenticated with a valid
 * JWT token. The system extracts the creator admin's ID from the token and
 * populates the created_by_admin_id field to establish the audit trail. This
 * creates a self-referential relationship in the shopping_mall_admins table,
 * tracking which admin created each new admin account.
 *
 * The new admin account is initialized with email_verified set to false,
 * requiring the new admin to verify their email before accessing the platform.
 * An email_verification_token is generated and sent to the provided email
 * address. The verification link expires after 24 hours, and the new admin can
 * request a new verification email if needed with rate limiting (1 per 5
 * minutes).
 *
 * Password security is enforced according to platform standards: minimum 8
 * characters, at least one uppercase letter, one lowercase letter, one number,
 * and one special character. The password is hashed using bcrypt or Argon2
 * before storage. The password_history field is initialized as an empty JSON
 * array to track future password changes (last 5 passwords stored to prevent
 * reuse).
 *
 * Role-based permissions are assigned through the role_level field, supporting
 * hierarchical admin roles: super_admin (full platform access, can create other
 * admins), order_manager (order and refund management only), content_moderator
 * (product and review moderation only), and support_admin (customer service and
 * basic operations). The is_active flag is set to true by default, allowing the
 * new admin to log in after email verification.
 *
 * Multi-factor authentication (mfa_enabled) is set to false initially but
 * should be required for super_admin roles as per security requirements. The
 * mfa_secret field remains null until the admin enables MFA. Failed login
 * attempt tracking fields (failed_login_attempts, failed_login_window_start_at,
 * account_locked_until) are initialized to zero/null to begin tracking login
 * security from the first login attempt.
 *
 * Upon successful account creation, the system issues JWT access and refresh
 * tokens following the standard authentication flow, allowing the creating
 * admin to continue their session. The response includes the complete admin
 * profile information and authentication tokens, enabling immediate integration
 * into admin workflows.
 *
 * @param props.connection
 * @param props.body New admin account registration information including email,
 *   password, full name, and role level
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * New admin account registration information including email, password,
     * full name, and role level
     */
    body: IShoppingMallAdmin.ICreate;
  };
  export type Body = IShoppingMallAdmin.ICreate;
  export type Response = IShoppingMallAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): IShoppingMallAdmin.IAuthorized =>
    typia.random<IShoppingMallAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin login authentication with credential validation and JWT token issuance.
 *
 * Authenticates an existing admin user with email and password credentials and
 * issues JWT tokens for API access. This endpoint implements the admin login
 * workflow with comprehensive security measures including account verification,
 * lockout protection, and MFA support.
 *
 * The authentication process begins by validating the provided email format and
 * checking if an admin account exists with that email in the
 * shopping_mall_admins table. If no account is found, a generic error is
 * returned to prevent email enumeration attacks: 'Invalid email or password'.
 *
 * Once the account is located, the system performs several security checks
 * before password verification. First, it verifies the account_status is
 * 'active' - suspended or inactive admin accounts cannot log in. Second, it
 * checks the email_verified flag is true, ensuring the admin has completed
 * email verification. Unverified admin accounts receive an error: 'Please
 * verify your email address before logging in'.
 *
 * The system then checks if the account is currently locked due to previous
 * failed login attempts by examining the account_locked_until timestamp. If the
 * current time is before the lockout expiration, login is denied with the
 * error: 'Your account has been locked due to multiple failed login attempts.
 * Please try again in X minutes or reset your password'.
 *
 * If all preliminary checks pass, the system verifies the password by comparing
 * the provided password against the stored password_hash using bcrypt. If the
 * password is incorrect, the system increments the failed_login_attempts
 * counter and updates the failed_login_window_start_at timestamp if this is the
 * first failure in a new 15-minute window. After the 5th failed attempt within
 * a 15-minute window, the account_locked_until field is set to 30 minutes from
 * the current time, locking the account. A security notification email is sent
 * to the admin's email address.
 *
 * Upon successful password verification, the system resets
 * failed_login_attempts to zero and clears the failed_login_window_start_at
 * timestamp. The last_login_at timestamp is updated to the current time, and
 * last_login_ip is set to the client's IP address for security monitoring.
 *
 * If mfa_enabled is true for the admin account, the system requires an
 * additional MFA verification step before issuing tokens. The admin must
 * provide a valid TOTP code generated from their mfa_secret. This adds an extra
 * layer of security, particularly important for super_admin roles.
 *
 * After all authentication and security checks pass, the system generates JWT
 * tokens. The access token includes claims: userId (admin.id), email, role
 * ('admin'), role_level (e.g., 'super_admin'), permissions array based on
 * role_level, iat (issued at), exp (expiration - 30 minutes), and type
 * ('access'). The refresh token includes: userId, tokenId (unique identifier),
 * iat, exp (30 days), and type ('refresh').
 *
 * A session record is created in shopping_mall_sessions with user_type='admin',
 * admin_id=admin.id, refresh_token, refresh_token_expires_at (30 days from
 * now), ip_address, user_agent, and parsed device information (device_type,
 * device_name, browser_name, operating_system, approximate_location based on
 * IP). This enables multi-device session tracking and management.
 *
 * The response returns the admin's complete profile information (id, email,
 * name, role_level, is_active, mfa_enabled, last_login_at) along with the
 * access token and refresh token, enabling the client to store tokens and make
 * authenticated API requests.
 *
 * @param props.connection
 * @param props.body Admin login credentials containing email and password
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials containing email and password */
    body: IShoppingMallAdmin.ILogin;
  };
  export type Body = IShoppingMallAdmin.ILogin;
  export type Response = IShoppingMallAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): IShoppingMallAdmin.IAuthorized =>
    typia.random<IShoppingMallAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh expired admin access token using valid refresh token.
 *
 * Refreshes an expired admin access token using a valid refresh token, enabling
 * continuous authentication without requiring credential re-entry. This
 * endpoint implements the JWT token refresh flow for admin users, supporting
 * seamless session continuation while maintaining security through short-lived
 * access tokens.
 *
 * The token refresh process begins when the client detects the access token has
 * expired (indicated by 401 responses on authenticated requests or by checking
 * the exp claim). The client sends the refresh token (originally issued during
 * login) to this endpoint. The system validates the refresh token against
 * several security criteria.
 *
 * First, the system queries the shopping_mall_sessions table to find a session
 * record matching the provided refresh_token where user_type='admin'. If no
 * matching session exists, the refresh token is invalid and the request is
 * rejected with 401 Unauthorized.
 *
 * Next, the system verifies the refresh token signature using the platform's
 * JWT secret key to ensure the token hasn't been tampered with. Invalid
 * signatures result in immediate rejection.
 *
 * The system checks the refresh_token_expires_at timestamp to ensure the token
 * hasn't expired. Refresh tokens have a 30-day lifetime from issuance. If the
 * current time exceeds the expiration timestamp, the token is expired and the
 * request is rejected with 401 Unauthorized. The client must redirect the admin
 * to the login page for re-authentication.
 *
 * The system verifies the is_revoked flag is false. Revoked refresh tokens
 * cannot be used for token refresh. Tokens are revoked when the admin logs out,
 * changes their password, or manually terminates the session. Revoked tokens
 * result in 401 Unauthorized.
 *
 * If all validation checks pass, the system retrieves the admin account details
 * from shopping_mall_admins using the admin_id from the session record. The
 * system verifies the admin account is still active (is_active=true) and the
 * account_status is 'active'. Suspended or inactive admin accounts cannot
 * refresh tokens.
 *
 * A new access token is generated with the same claims structure as the
 * original login: userId (admin.id), email (admin.email), role ('admin'),
 * role_level (admin.role_level), permissions array derived from role_level, iat
 * (current timestamp), exp (30 minutes from now), and type ('access').
 *
 * The system evaluates if the refresh token itself needs renewal. If the
 * refresh_token_expires_at is within 7 days of the current time, a new refresh
 * token is generated with a fresh 30-day expiration period. The
 * shopping_mall_sessions record is updated with the new refresh token and
 * expiration timestamp. This sliding expiration window ensures active sessions
 * remain valid without requiring login, while inactive sessions naturally
 * expire.
 *
 * The session's last_activity_at timestamp is updated to the current time,
 * tracking session usage for the 30-day inactivity timeout rule. Sessions with
 * last_activity_at older than 30 days are considered expired even if the
 * refresh token hasn't reached its expiration timestamp.
 *
 * The response returns the new access token and, if renewed, the new refresh
 * token. If the refresh token was not renewed, the response includes only the
 * new access token, and the client continues using the existing refresh token.
 * This enables the client to retry the original API request that triggered the
 * token refresh flow.
 *
 * If the refresh token is invalid, expired, or revoked, the system returns 401
 * Unauthorized with error code AUTH_TOKEN_EXPIRED or AUTH_INVALID_TOKEN,
 * signaling the client to redirect the admin to the login page.
 *
 * @param props.connection
 * @param props.body Refresh token for generating new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for generating new access token */
    body: IShoppingMallAdmin.IRefresh;
  };
  export type Body = IShoppingMallAdmin.IRefresh;
  export type Response = IShoppingMallAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): IShoppingMallAdmin.IAuthorized =>
    typia.random<IShoppingMallAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout admin user and revoke current session refresh token.
 *
 * Terminates the admin's current authenticated session by revoking the
 * associated refresh token. This endpoint implements the logout workflow for
 * admin users, invalidating the current session while preserving the session
 * record for security auditing and activity tracking.
 *
 * The logout process requires the admin to be authenticated with a valid JWT
 * access token. The system extracts the admin's userId from the JWT token
 * payload to identify which admin is logging out. Additionally, the client
 * should provide the refresh token in the request to identify the specific
 * session to terminate (supporting multi-device scenarios where an admin might
 * be logged in on multiple devices).
 *
 * The system queries the shopping_mall_sessions table to find the session
 * record matching the provided refresh_token where user_type='admin' and
 * admin_id matches the authenticated admin's ID. If the session is not found or
 * doesn't belong to the authenticated admin, the request is rejected with 403
 * Forbidden.
 *
 * Once the session is identified, the system updates the session record to mark
 * it as revoked: is_revoked is set to true, and revoked_at is set to the
 * current timestamp. This prevents the refresh token from being used to
 * generate new access tokens in the future. The session record is retained in
 * the database for security auditing, activity tracking, and compliance
 * purposes.
 *
 * The last_activity_at timestamp is updated to the current time to accurately
 * reflect when the logout occurred, completing the session activity timeline.
 *
 * The client is instructed to immediately discard both the access token and
 * refresh token from local storage (localStorage, sessionStorage, or cookies).
 * The access token will be rejected on subsequent API requests due to the
 * revoked session, and the refresh token can no longer generate new access
 * tokens.
 *
 * After logout completes, the admin must go through the full login process
 * again to access the platform, providing email and password credentials. This
 * ensures security by requiring credential verification for new sessions.
 *
 * The system logs the logout event in the session audit trail, recording the
 * timestamp, IP address, and reason (user-initiated logout) for security
 * monitoring and compliance.
 *
 * If the admin wants to logout from ALL devices (terminate all active
 * sessions), they should use the 'logout from all devices' endpoint instead.
 * The single logout endpoint affects only the current session identified by the
 * provided refresh token.
 *
 * The response returns a success confirmation message indicating the logout was
 * completed and the session has been terminated.
 *
 * @param props.connection
 * @param props.body Refresh token of the session to terminate
 * @path /auth/admin/logout
 * @accessor api.functional.auth.admin.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
  props: logout.Props,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
        props.body,
      );
}
export namespace logout {
  export type Props = {
    /** Refresh token of the session to terminate */
    body: IShoppingMallAdmin.ILogout;
  };
  export type Body = IShoppingMallAdmin.ILogout;
  export type Response = IShoppingMallAdmin.ILogoutResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/logout",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/logout";
  export const random = (): IShoppingMallAdmin.ILogoutResponse =>
    typia.random<IShoppingMallAdmin.ILogoutResponse>();
  export const simulate = (
    connection: IConnection,
    props: logout.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: logout.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
