import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdmin } from "../../../../../../structures/IShoppingMallAdmin";

/**
 * Complete admin password reset with token validation and session invalidation.
 *
 * Completes the admin password reset process by validating the reset token and
 * updating the password. This endpoint implements the final step of the account
 * recovery workflow, enforcing password security policies and invalidating
 * existing sessions for security.
 *
 * The password reset completion process begins when an admin clicks the reset
 * link in their email and submits the password_reset_token along with their new
 * desired password. The system first validates that both the token and new
 * password are provided in the request.
 *
 * Token validation involves querying the shopping_mall_admins table for an
 * account with the provided password_reset_token. If no matching token is
 * found, the request is rejected with error: 'Password reset link is invalid or
 * has expired' (AUTH_RESET_TOKEN_INVALID). This generic message is used whether
 * the token doesn't exist or has already been used, preventing token
 * enumeration.
 *
 * The system checks the password_reset_expires_at timestamp to ensure the token
 * hasn't expired. Tokens are valid for exactly 1 hour from issuance. If the
 * current time is after the expiration timestamp, the token is expired and the
 * request is rejected with the same error message. The admin must request a new
 * password reset token.
 *
 * Once the token is confirmed valid and not expired, the system validates the
 * new password against comprehensive security requirements. The password must
 * be at least 8 characters long and contain at least one uppercase letter, one
 * lowercase letter, one digit, and one special character from the set (@, $, !,
 * %, *, ?, &, #). If any requirement is not met, specific validation errors are
 * returned indicating which requirements failed.
 *
 * The system retrieves the admin's password_history JSON array and validates
 * the new password hash doesn't match any of the last 5 password hashes stored
 * in the history. This prevents password reuse as specified in the business
 * requirements. If the new password matches a recent password, the request is
 * rejected with error: 'Password cannot be the same as any of your last 5
 * passwords'.
 *
 * The new password is hashed using bcrypt with a cost factor of 12 or Argon2 to
 * generate a secure password_hash. The system updates the admin record:
 * password_hash is set to the new hash, password_reset_token and
 * password_reset_expires_at are cleared (set to null) to invalidate the token,
 * password_changed_at is updated to the current timestamp for security
 * auditing.
 *
 * The new password hash is added to the password_history JSON array. If the
 * array already contains 5 entries (the maximum), the oldest entry is removed
 * before adding the new one, maintaining a rolling history of the last 5
 * passwords.
 *
 * For security, all existing sessions for this admin are invalidated to prevent
 * unauthorized access using old session tokens. The system updates all records
 * in shopping_mall_sessions where admin_id matches the admin's ID and
 * user_type='admin', setting is_revoked=true and revoked_at=current timestamp.
 * This forces the admin to log in again on all devices using the new password.
 *
 * A confirmation email is sent to the admin's email address notifying them that
 * their password was successfully changed, including the timestamp and IP
 * address from which the change was made. If the admin did not initiate the
 * change, they are instructed to contact support immediately.
 *
 * The response returns a success confirmation message indicating the password
 * has been updated and the admin should log in with the new password.
 *
 * @param props.connection
 * @param props.body Password reset token and new password meeting security
 *   requirements
 * @path /auth/admin/password/reset/complete
 * @accessor api.functional.auth.admin.password.reset.complete.resetPassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resetPassword(
  connection: IConnection,
  props: resetPassword.Props,
): Promise<resetPassword.Response> {
  return true === connection.simulate
    ? resetPassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resetPassword.METADATA,
          path: resetPassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resetPassword {
  export type Props = {
    /** Password reset token and new password meeting security requirements */
    body: IShoppingMallAdmin.IPasswordReset;
  };
  export type Body = IShoppingMallAdmin.IPasswordReset;
  export type Response = IShoppingMallAdmin.IPasswordResetResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/password/reset/complete",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/password/reset/complete";
  export const random = (): IShoppingMallAdmin.IPasswordResetResponse =>
    typia.random<IShoppingMallAdmin.IPasswordResetResponse>();
  export const simulate = (
    connection: IConnection,
    props: resetPassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resetPassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
