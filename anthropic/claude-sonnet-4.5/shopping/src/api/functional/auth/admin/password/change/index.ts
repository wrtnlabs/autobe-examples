import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdmin } from "../../../../../structures/IShoppingMallAdmin";

/**
 * Change admin password with current password verification.
 *
 * Enables authenticated admin users to change their password by verifying the
 * current password and setting a new one. This endpoint implements the password
 * change workflow for admins who want to update their credentials proactively
 * for security reasons, requiring current password verification to prevent
 * unauthorized password changes.
 *
 * The password change process requires the admin to be authenticated with a
 * valid JWT access token. The system extracts the admin's userId from the JWT
 * token payload and uses it to retrieve the admin's full record from the
 * shopping_mall_admins table.
 *
 * The admin must provide their current password for verification as a security
 * measure, preventing unauthorized password changes if someone gains temporary
 * access to an authenticated session. The system compares the provided current
 * password against the stored password_hash using bcrypt comparison. If the
 * current password is incorrect, the request is rejected with error: 'Current
 * password is incorrect' (AUTH_INVALID_CREDENTIALS).
 *
 * Once the current password is verified, the system validates the new password
 * against comprehensive security requirements. The new password must meet all
 * complexity rules: minimum 8 characters, at least one uppercase letter, one
 * lowercase letter, one digit, and one special character from the set (@, $, !,
 * %, *, ?, &, #). Additionally, the new password cannot be the same as the
 * current password - this is checked by comparing the new password against the
 * current password_hash. If the passwords match, the request is rejected with
 * error: 'New password must be different from current password'.
 *
 * The system retrieves the password_history JSON array from the admin record
 * and validates the new password hash doesn't match any of the last 5 password
 * hashes. This enforces the password reuse prevention policy. If the new
 * password matches any recent password, the request is rejected with error:
 * 'Password cannot be the same as any of your last 5 passwords'.
 *
 * The new password is hashed using bcrypt with cost factor 12 or Argon2 to
 * generate a secure password_hash. The admin record is updated: password_hash
 * is set to the new hash, password_changed_at is updated to the current
 * timestamp for security auditing and password age tracking.
 *
 * The new password hash is prepended to the password_history JSON array. If the
 * array already contains 5 entries, the oldest entry is removed, maintaining a
 * rolling history of the last 5 passwords. The updated array is serialized and
 * stored in the password_history field.
 *
 * For security, all existing sessions for this admin are invalidated EXCEPT the
 * current session used to make this request. The system updates all
 * shopping_mall_sessions records where admin_id matches and user_type='admin'
 * and the session is not the current one, setting is_revoked=true and
 * revoked_at=current timestamp. This forces re-authentication on all other
 * devices while allowing the current session to continue.
 *
 * A security notification email is sent to the admin's email address confirming
 * the password was changed, including the timestamp, IP address, and device
 * information from the current session. The email includes a warning: 'If you
 * did not make this change, please contact support immediately' to alert the
 * admin of potential unauthorized access.
 *
 * The response returns a success confirmation message indicating the password
 * has been updated and other sessions have been terminated.
 *
 * @param props.connection
 * @param props.body Current password verification and new password
 * @path /auth/admin/password/change
 * @accessor api.functional.auth.admin.password.change.changePassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function changePassword(
  connection: IConnection,
  props: changePassword.Props,
): Promise<changePassword.Response> {
  return true === connection.simulate
    ? changePassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...changePassword.METADATA,
          path: changePassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace changePassword {
  export type Props = {
    /** Current password verification and new password */
    body: IShoppingMallAdmin.IPasswordChange;
  };
  export type Body = IShoppingMallAdmin.IPasswordChange;
  export type Response = IShoppingMallAdmin.IPasswordChangeResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/password/change",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/password/change";
  export const random = (): IShoppingMallAdmin.IPasswordChangeResponse =>
    typia.random<IShoppingMallAdmin.IPasswordChangeResponse>();
  export const simulate = (
    connection: IConnection,
    props: changePassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: changePassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
