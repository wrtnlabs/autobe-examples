import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../../../structures/IShoppingMallCustomer";

/**
 * Resend verification email with new token for unverified customer accounts
 * (shopping_mall_customers table).
 *
 * Resends the email verification link to customers who did not receive the
 * original verification email or whose verification token has expired. This
 * operation implements the verification email resend functionality defined in
 * the Email Verification section of the User Roles and Authentication
 * requirements, supporting customers who need a new verification link.
 *
 * When a customer requests a new verification email by providing their email
 * address, the system queries the shopping_mall_customers table to find a
 * customer record matching the provided email. If no customer exists with that
 * email, the system returns a generic success message 'If your email is
 * registered and unverified, you will receive a new verification link' without
 * revealing whether the account exists (following security best practice to
 * prevent account enumeration).
 *
 * For existing customer accounts, the system validates the account is eligible
 * for verification email resend by checking: (1) email_verified is false
 * (verified accounts don't need new verification emails), (2) account_status is
 * 'unverified' or 'active' (suspended or deleted accounts cannot receive
 * verification emails). If the account is already verified, the system returns
 * error 'This email address has already been verified. You can log in to your
 * account.'
 *
 * The system enforces rate limiting as specified in the business rules allowing
 * maximum 1 verification email resend per 5 minutes per customer. This is
 * validated by checking the email_verification_sent_at timestamp and comparing
 * it to current time. If less than 5 minutes have passed since the last
 * verification email was sent (email_verification_sent_at + 5 minutes > current
 * time), the system returns HTTP 429 error 'Verification email was recently
 * sent. Please wait a few minutes before requesting another one.' This prevents
 * abuse and email system overload.
 *
 * If rate limiting validation passes, the system generates a new
 * cryptographically secure email_verification_token (unique random string) and
 * sets a new expiration time of 24 hours from the current timestamp. The token
 * is stored in the email_verification_token field, and
 * email_verification_sent_at is updated to the current timestamp. The system
 * queues a verification email containing a link in format:
 * https://platform-url/auth/customer/email/verify?token={email_verification_token}.
 * The email explains the verification process, token expiration (24 hours), and
 * provides instructions for completing verification.
 *
 * The operation returns a generic success response 'If your email is registered
 * and unverified, you will receive a new verification link' to avoid revealing
 * account information while providing a user-friendly confirmation message. The
 * customer should check their email inbox (and spam folder) for the
 * verification link. The new token expires 24 hours from issuance, replacing
 * any previous unexpired tokens. Once the customer clicks the verification link
 * and the verifyEmail endpoint processes the token, their account transitions
 * from 'unverified' to 'active' status with email_verified set to true,
 * granting access to full platform features.
 *
 * @param props.connection
 * @param props.body Customer email address to resend verification link
 * @path /auth/customer/email/verify/resend
 * @accessor api.functional.auth.customer.email.verify.resend.resendVerification
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resendVerification(
  connection: IConnection,
  props: resendVerification.Props,
): Promise<resendVerification.Response> {
  return true === connection.simulate
    ? resendVerification.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resendVerification.METADATA,
          path: resendVerification.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resendVerification {
  export type Props = {
    /** Customer email address to resend verification link */
    body: IShoppingMallCustomer.IResendVerification;
  };
  export type Body = IShoppingMallCustomer.IResendVerification;
  export type Response = IShoppingMallCustomer.IResendVerificationResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/email/verify/resend",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/email/verify/resend";
  export const random = (): IShoppingMallCustomer.IResendVerificationResponse =>
    typia.random<IShoppingMallCustomer.IResendVerificationResponse>();
  export const simulate = (
    connection: IConnection,
    props: resendVerification.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resendVerification.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
