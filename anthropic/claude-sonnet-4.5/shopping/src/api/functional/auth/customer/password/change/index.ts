import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../../structures/IShoppingMallCustomer";

/**
 * Change customer password with current password verification
 * (shopping_mall_customers table).
 *
 * Allows authenticated customers to change their password by validating their
 * current password and updating to a new password that meets security
 * requirements. This operation implements the password change process defined
 * in the Password Management section of the User Roles and Authentication
 * requirements, providing customers with the ability to proactively update
 * their credentials for security purposes.
 *
 * This endpoint requires authentication via valid JWT access token in the
 * Authorization header. The system extracts the customer's userId from the
 * token payload and retrieves the customer record from the
 * shopping_mall_customers table. The customer must be authenticated and have an
 * active account (account_status = 'active') to change their password.
 *
 * The customer must provide both their current password and the desired new
 * password in the request body. The system first verifies the current password
 * by comparing it against the stored password_hash using bcrypt or Argon2
 * verification. If the current password is incorrect, the system returns HTTP
 * 401 error 'Current password is incorrect' and does not proceed with the
 * password change. This verification prevents unauthorized password changes if
 * someone gains temporary access to an authenticated session.
 *
 * The system validates the new password meets all password policy requirements
 * defined in the business rules: minimum 8 characters, maximum 128 characters,
 * contains at least one uppercase letter (A-Z), one lowercase letter (a-z), one
 * digit (0-9), and one special character (@$!%*?&#). The system rejects new
 * passwords that match the customer's email address or are found in the
 * commonly used weak password blocklist. Additionally, the system checks the
 * password_history JSON array field (storing hashes of the last 5 passwords) to
 * ensure the new password does not match any previously used password. If the
 * new password fails any validation rule, the system returns HTTP 400 error
 * with specific messages indicating which requirements are not met.
 *
 * Upon successful validation, the system hashes the new password using bcrypt
 * with cost factor 12 or Argon2 and stores the hash in the password_hash field.
 * The current password hash is prepended to the password_history JSON array,
 * and if the array exceeds 5 entries, the oldest hash is removed to maintain
 * the limit of 5 historical passwords. The password_changed_at timestamp is
 * updated to the current time for security auditing and password age tracking.
 *
 * As specified in the password change security requirements, the system
 * invalidates all existing customer sessions except the current session to
 * protect the account from unauthorized access. This is achieved by querying
 * the shopping_mall_sessions table for all records where customer_id matches
 * the customer and the session is not the current session (identified by the
 * refresh token from the current request), then setting is_revoked to true and
 * revoked_at to current timestamp for those sessions. This forces logout from
 * all other devices, ensuring only the device where the password was changed
 * remains authenticated.
 *
 * The system sends a password change confirmation email to the customer's email
 * address as a security notification, informing them their password was
 * successfully changed at the current timestamp from the current IP address and
 * device. The email advises the customer to contact support immediately if they
 * did not initiate this change. The operation returns a success response
 * confirming the password has been updated and all other sessions have been
 * logged out for security. The customer continues their authenticated session
 * with the current access and refresh tokens, while all other devices require
 * re-authentication with the new password.
 *
 * @param props.connection
 * @param props.body Current password and new password for password change
 * @path /auth/customer/password/change
 * @accessor api.functional.auth.customer.password.change.changePassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function changePassword(
  connection: IConnection,
  props: changePassword.Props,
): Promise<changePassword.Response> {
  return true === connection.simulate
    ? changePassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...changePassword.METADATA,
          path: changePassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace changePassword {
  export type Props = {
    /** Current password and new password for password change */
    body: IShoppingMallCustomer.IPasswordChange;
  };
  export type Body = IShoppingMallCustomer.IPasswordChange;
  export type Response = IShoppingMallCustomer.IPasswordChangeResponse;

  export const METADATA = {
    method: "PUT",
    path: "/auth/customer/password/change",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/password/change";
  export const random = (): IShoppingMallCustomer.IPasswordChangeResponse =>
    typia.random<IShoppingMallCustomer.IPasswordChangeResponse>();
  export const simulate = (
    connection: IConnection,
    props: changePassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: changePassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
