import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../../../structures/IShoppingMallCustomer";

/**
 * Complete password reset with token validation and update customer password
 * (shopping_mall_customers table).
 *
 * Completes the password reset process by validating the password reset token
 * from the email link and updating the customer's password to the newly
 * provided password. This operation implements the password reset completion
 * flow defined in the Password Management section of the User Roles and
 * Authentication requirements.
 *
 * When a customer clicks the password reset link from their email and submits a
 * new password, the system first validates the password_reset_token by querying
 * the shopping_mall_customers table to find a customer record with a matching
 * token. If no customer is found with the provided token, the system returns
 * error 'Password reset link is invalid or has expired' with HTTP 400 status.
 * For valid tokens, the system checks the password_reset_expires_at timestamp
 * to ensure the token has not expired (must be less than 1 hour old as per
 * business rules). Expired tokens return the same error message, prompting the
 * customer to request a new password reset link.
 *
 * The system validates the new password meets all security requirements defined
 * in the password policy: minimum 8 characters, maximum 128 characters,
 * contains at least one uppercase letter (A-Z), one lowercase letter (a-z), one
 * digit (0-9), and one special character (@$!%*?&#). The system rejects
 * passwords matching the customer's email address or found in the common weak
 * password blocklist. The system also validates the new password does not match
 * any of the last 5 passwords stored in the password_history JSON array field.
 * If password validation fails, the system returns specific error messages
 * indicating which requirements are not met.
 *
 * Upon successful validation, the system hashes the new password using bcrypt
 * with cost factor 12 or Argon2, ensuring the password is never stored in plain
 * text. The new hash is stored in the password_hash field. The system updates
 * password_changed_at to the current timestamp for security auditing. The
 * previous password hash is prepended to the password_history JSON array,
 * maintaining a maximum of 5 historical password hashes to enforce the password
 * reuse prevention rule. The password_reset_token and password_reset_expires_at
 * fields are cleared (set to null) to invalidate the reset token and prevent
 * reuse.
 *
 * As specified in the password change security requirements, the system
 * invalidates all existing customer sessions except the current one by querying
 * the shopping_mall_sessions table for all sessions where customer_id matches
 * the customer and setting is_revoked to true and revoked_at to current
 * timestamp. This forces logout from all devices and prevents unauthorized
 * access if the password reset was initiated due to account compromise. The
 * system sends a password change confirmation email to the customer's email
 * address as a security notification, alerting them that their password was
 * successfully changed and advising them to contact support if they did not
 * initiate this change.
 *
 * The operation returns a success response confirming the password has been
 * updated and all other sessions have been invalidated for security. The
 * customer should then log in using their new password via the login endpoint
 * to establish a new authenticated session.
 *
 * @param props.connection
 * @param props.body Password reset token and new password for account recovery
 * @path /auth/customer/password/reset/complete
 * @accessor api.functional.auth.customer.password.reset.complete.resetPassword
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resetPassword(
  connection: IConnection,
  props: resetPassword.Props,
): Promise<resetPassword.Response> {
  return true === connection.simulate
    ? resetPassword.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resetPassword.METADATA,
          path: resetPassword.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resetPassword {
  export type Props = {
    /** Password reset token and new password for account recovery */
    body: IShoppingMallCustomer.IPasswordReset;
  };
  export type Body = IShoppingMallCustomer.IPasswordReset;
  export type Response = IShoppingMallCustomer.IPasswordResetResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/password/reset/complete",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/password/reset/complete";
  export const random = (): IShoppingMallCustomer.IPasswordResetResponse =>
    typia.random<IShoppingMallCustomer.IPasswordResetResponse>();
  export const simulate = (
    connection: IConnection,
    props: resetPassword.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resetPassword.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
