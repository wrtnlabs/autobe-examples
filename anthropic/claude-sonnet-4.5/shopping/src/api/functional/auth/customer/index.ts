import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../structures/IShoppingMallCustomer";
export * as password from "./password/index";
export * as email from "./email/index";
export * as _logout from "./_logout/index";

/**
 * Register new customer account with email verification and issue JWT tokens
 * (shopping_mall_customers table).
 *
 * Creates a new customer account in the shopping mall platform by validating
 * provided registration information (email, password, name, phone) against
 * business rules defined in the User Roles and Authentication requirements. The
 * system enforces email uniqueness by checking the shopping_mall_customers
 * table to ensure no existing account uses the provided email address. Password
 * validation confirms the password meets security requirements: minimum 8
 * characters, at least one uppercase letter, one lowercase letter, one number,
 * and one special character. The password is hashed using bcrypt or Argon2
 * before storage in the password_hash field, and the plain text password is
 * never stored.
 *
 * Upon successful validation, the system creates a customer record in the
 * shopping_mall_customers table with account_status set to 'unverified' and
 * email_verified set to false. The system generates a unique
 * email_verification_token and records the email_verification_sent_at
 * timestamp, then sends a verification email containing a link with the token
 * that expires after 24 hours. The newly created account is assigned the
 * 'customer' role with permissions to browse products, manage shopping cart and
 * wishlist, and access customer-specific features as defined in the permission
 * matrix.
 *
 * The operation immediately generates JWT tokens (access token with 30-minute
 * expiration and refresh token with 30-day expiration) containing the
 * customer's userId, email, role ('customer'), and permissions in the token
 * payload. The access token uses HS256 algorithm and includes fields: userId,
 * email, role, permissions, iat, exp, and type ('access'). The refresh token
 * includes: userId, tokenId, iat, exp, and type ('refresh'). A session record
 * is created in the shopping_mall_sessions table linking the refresh token to
 * the customer account with device information and IP address for security
 * monitoring.
 *
 * This registration operation returns the complete customer profile information
 * along with the authentication tokens, enabling the customer to immediately
 * begin an authenticated session. The customer can browse products, manage cart
 * and wishlist, but cannot place orders until completing email verification
 * through the verification link sent to their email address. The
 * failed_login_attempts counter is initialized to 0, and password_history is
 * initialized as empty to support future password change policies.
 *
 * @param props.connection
 * @param props.body Customer registration information including email,
 *   password, name, and phone number
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/join
 * @accessor api.functional.auth.customer.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Customer registration information including email, password, name,
     * and phone number
     */
    body: IShoppingMallCustomer.ICreate;
  };
  export type Body = IShoppingMallCustomer.ICreate;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/join";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate customer with email and password and issue JWT tokens
 * (shopping_mall_customers table).
 *
 * Authenticates a customer using email and password credentials by performing
 * comprehensive validation against the shopping_mall_customers table and
 * business rules defined in the User Roles and Authentication document. The
 * system first validates the email format, then queries the
 * shopping_mall_customers table to find a customer record matching the provided
 * email address. If no matching customer exists, the system returns a generic
 * 'Invalid email or password' error without revealing whether the email exists
 * (security best practice to prevent account enumeration).
 *
 * For existing accounts, the system performs sequential validation checks: (1)
 * verifies account_status is 'active' and not 'suspended' or 'deleted', (2)
 * confirms email_verified is true (unverified accounts cannot log in), (3)
 * checks account_locked_until timestamp to ensure account is not currently
 * locked due to previous failed login attempts. If any validation fails, the
 * system returns appropriate error messages: 'Your account is inactive',
 * 'Please verify your email address before logging in', or 'Your account has
 * been locked due to multiple failed login attempts. Please try again in 30
 * minutes or reset your password'.
 *
 * Password verification compares the provided password with the stored
 * password_hash using bcrypt or Argon2 verification. If the password is
 * incorrect, the system increments the failed_login_attempts counter and
 * updates the failed_login_window_start_at timestamp if this is the first
 * failure in the current 15-minute window. After 5 failed attempts within a
 * 15-minute window, the system sets account_locked_until to 30 minutes in the
 * future and returns an account locked error. The system tracks failed attempts
 * using the failed_login_attempts counter and failed_login_window_start_at
 * timestamp to implement the business rule allowing 5 failures per 15-minute
 * window before 30-minute lockout.
 *
 * Upon successful password verification, the system resets
 * failed_login_attempts to 0 and clears failed_login_window_start_at. The
 * system then generates JWT tokens with access token (30-minute expiration)
 * containing userId, email, role ('customer'), permissions, iat, exp, and type
 * ('access'), and refresh token (30-day expiration) containing userId, tokenId,
 * iat, exp, and type ('refresh'). A new session record is created in the
 * shopping_mall_sessions table with user_type 'customer', the refresh token,
 * device information parsed from the user agent string, IP address, and
 * approximate_location derived from IP geolocation. The session supports
 * multi-device concurrent access and can be revoked individually.
 *
 * The login response returns the customer's profile information from the
 * shopping_mall_customers table (id, email, name, phone, account_status) along
 * with the JWT access and refresh tokens. The customer can now access all
 * authenticated customer features including shopping cart management, order
 * placement, wishlist functionality, address management, and order history as
 * defined in the permission matrix. The refresh token enables token renewal
 * without requiring re-login for 30 days.
 *
 * @param props.connection
 * @param props.body Customer login credentials with email and password
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/login
 * @accessor api.functional.auth.customer.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Customer login credentials with email and password */
    body: IShoppingMallCustomer.ILogin;
  };
  export type Body = IShoppingMallCustomer.ILogin;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/login";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT access token using valid refresh token without re-authentication
 * (shopping_mall_sessions table).
 *
 * Refreshes an expired or expiring JWT access token by validating the provided
 * refresh token and issuing a new access token without requiring customer
 * re-authentication. This operation implements the token refresh mechanism
 * defined in the JWT Token Management section of the User Roles and
 * Authentication requirements, enabling seamless session continuation across
 * the 30-minute access token lifetime.
 *
 * The system validates the refresh token through multiple security checks: (1)
 * verifies the JWT signature using the platform secret key to ensure the token
 * was issued by the platform and has not been tampered with, (2) checks the
 * refresh token has not expired by comparing current time against the
 * refresh_token_expires_at timestamp (30 days from issuance), (3) queries the
 * shopping_mall_sessions table to verify the refresh token exists and matches
 * an active session record, (4) confirms the session is not revoked by checking
 * is_revoked is false. If any validation fails, the system returns HTTP 401
 * Unauthorized with error code AUTH_TOKEN_EXPIRED or AUTH_INVALID_TOKEN,
 * requiring the customer to re-authenticate via the login endpoint.
 *
 * Upon successful refresh token validation, the system extracts the customer's
 * userId from the token payload and retrieves the current customer information
 * from the shopping_mall_customers table to ensure the account is still active
 * (account_status = 'active') and not suspended or deleted. The system
 * generates a new access token with a fresh 30-minute expiration timestamp,
 * containing the customer's userId, email, role ('customer'), permissions
 * array, iat (issued at), exp (expiration), and type ('access'). The new access
 * token uses the HS256 algorithm for signature.
 *
 * The system updates the shopping_mall_sessions table by setting
 * last_activity_at to the current timestamp to track session activity and
 * prevent automatic expiration after 30 days of inactivity. If the current
 * refresh token is within 7 days of expiration (refresh_token_expires_at < 7
 * days from now), the system also generates a new refresh token and updates the
 * session record with the new refresh token and extended expiration (30 days
 * from now). This rolling refresh token strategy maintains long-term session
 * validity for active customers without requiring frequent re-authentication.
 *
 * The operation returns the new access token to the client. If a new refresh
 * token was also generated (due to near-expiration), both tokens are returned.
 * The client should store the new access token and use it for subsequent
 * authenticated API requests in the Authorization header as 'Bearer
 * {access_token}'. This refresh mechanism supports continuous customer session
 * across multiple devices as tracked in the shopping_mall_sessions table with
 * concurrent session support.
 *
 * @param props.connection
 * @param props.body Refresh token for generating new access token
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/refresh
 * @accessor api.functional.auth.customer.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token for generating new access token */
    body: IShoppingMallCustomer.IRefresh;
  };
  export type Body = IShoppingMallCustomer.IRefresh;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/refresh";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout customer and revoke current session refresh token
 * (shopping_mall_sessions table).
 *
 * Logs out the customer by revoking the current session's refresh token and
 * invalidating the session record in the shopping_mall_sessions table. This
 * operation implements the logout process defined in the Session Management
 * section of the User Roles and Authentication requirements, allowing customers
 * to securely terminate their authenticated session.
 *
 * This endpoint requires authentication via valid JWT access token in the
 * Authorization header. The system extracts the customer's userId from the
 * token payload to identify the customer. The request must include the refresh
 * token (either in request body or extracted from httpOnly cookie depending on
 * storage strategy) to identify which specific session to terminate, supporting
 * the multi-device session management capability where customers can have
 * concurrent sessions on different devices.
 *
 * The system queries the shopping_mall_sessions table to find the session
 * record matching the provided refresh_token and customer_id. If no matching
 * session is found or the session is already revoked (is_revoked = true), the
 * system returns a success response anyway (idempotent operation) without
 * revealing session state details. For valid active sessions, the system
 * updates the session record by setting is_revoked to true and revoked_at to
 * the current timestamp. This immediately invalidates the refresh token,
 * preventing it from being used to generate new access tokens in future token
 * refresh requests.
 *
 * Revoking the refresh token effectively terminates the session because while
 * the current access token remains technically valid until its 30-minute
 * expiration, it cannot be renewed once the refresh token is revoked. This
 * means the customer will be logged out within 30 minutes at most, and
 * immediately if the client application discards the access token upon logout
 * (recommended client-side behavior). The session revocation is logged in the
 * shopping_mall_sessions table with the revoked_at timestamp for security
 * auditing and session history tracking.
 *
 * The operation instructs the client application to immediately discard both
 * the access token (stored in localStorage or sessionStorage) and refresh token
 * (stored in httpOnly cookie or localStorage) from client-side storage. This
 * ensures the customer cannot continue making authenticated requests with the
 * revoked session. The system response confirms successful logout and session
 * termination.
 *
 * This single-session logout operation terminates only the current session
 * associated with the provided refresh token. Other concurrent sessions on
 * different devices remain active and unaffected, as specified in the
 * multi-device support requirements. If the customer wants to log out from all
 * devices simultaneously, they should use a separate 'logout from all devices'
 * endpoint that revokes all refresh tokens associated with their customer_id in
 * the shopping_mall_sessions table. The current operation enables customers to
 * log out from one device while maintaining active sessions on their other
 * devices (e.g., logging out from work computer while staying logged in on
 * mobile phone).
 *
 * @param props.connection
 * @param props.body Refresh token of the session to terminate
 * @path /auth/customer/logout
 * @accessor api.functional.auth.customer.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
  props: logout.Props,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
        props.body,
      );
}
export namespace logout {
  export type Props = {
    /** Refresh token of the session to terminate */
    body: IShoppingMallCustomer.ILogout;
  };
  export type Body = IShoppingMallCustomer.ILogout;
  export type Response = IShoppingMallCustomer.ILogoutResponse;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/logout",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/logout";
  export const random = (): IShoppingMallCustomer.ILogoutResponse =>
    typia.random<IShoppingMallCustomer.ILogoutResponse>();
  export const simulate = (
    connection: IConnection,
    props: logout.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: logout.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
