import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProduct } from "../../../../../structures/IShoppingMallProduct";
import { IShoppingMallProductImage } from "../../../../../structures/IShoppingMallProductImage";
import { IPageIShoppingMallProductImage } from "../../../../../structures/IPageIShoppingMallProductImage";

/**
 * Upload and add a new image to a product's image gallery.
 *
 * This operation enables sellers to upload product images to enhance their
 * product listings with visual content. Product images are critical for
 * customer purchase decisions and product discoverability in the e-commerce
 * marketplace.
 *
 * The operation validates that the specified product exists in the
 * shopping_mall_products table and that the authenticated seller is the owner
 * of the product. Only sellers can upload images to their own products,
 * enforcing ownership-based authorization. The system checks that the product
 * has not exceeded the maximum limit of 10 images per product as defined in the
 * business requirements.
 *
 * Upon successful upload, the image is stored and a new record is created in
 * the shopping_mall_product_images table. The system automatically determines
 * the appropriate display_order based on existing images, and the is_primary
 * flag is set to true only if this is the first image for the product. The
 * image URL is generated by the storage service and persisted in the database.
 *
 * The uploaded image must meet the following validation criteria: accepted file
 * formats (JPEG, PNG, WebP), maximum file size of 5MB, and minimum resolution
 * of 800x800 pixels. The system generates multiple optimized versions
 * (thumbnail 150x150, medium 600x600, large 1200x1200) for responsive display
 * across different contexts. Invalid uploads are rejected with specific error
 * messages indicating the validation failure reason.
 *
 * This operation integrates with the product catalog management system defined
 * in the requirements, supporting the seller's ability to create compelling
 * product presentations. Images uploaded through this endpoint become part of
 * the product's visual gallery displayed to customers during product browsing
 * and detail viewing.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to which the image
 *   will be added
 * @param props.body Image file upload data including the image file and
 *   optional metadata such as alt text and variant association
 * @path /shoppingMall/seller/products/:productId/images
 * @accessor api.functional.shoppingMall.seller.products.images.createImage
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createImage(
  connection: IConnection,
  props: createImage.Props,
): Promise<createImage.Response> {
  return true === connection.simulate
    ? createImage.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createImage.METADATA,
          path: createImage.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createImage {
  export type Props = {
    /** Unique identifier of the product to which the image will be added */
    productId: string & tags.Format<"uuid">;

    /**
     * Image file upload data including the image file and optional metadata
     * such as alt text and variant association
     */
    body: IShoppingMallProduct.IImageCreate;
  };
  export type Body = IShoppingMallProduct.IImageCreate;
  export type Response = IShoppingMallProductImage;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products/:productId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/images`;
  export const random = (): IShoppingMallProductImage =>
    typia.random<IShoppingMallProductImage>();
  export const simulate = (
    connection: IConnection,
    props: createImage.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createImage.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve paginated list of images for a specific product with filtering and
 * sorting.
 *
 * Retrieve a comprehensive, paginated list of images associated with a specific
 * product from the shopping_mall_product_images table. This operation provides
 * advanced search and filtering capabilities for managing product image
 * galleries, supporting both general product images and variant-specific
 * images.
 *
 * The operation is designed to serve multiple user roles with different access
 * requirements. Sellers can retrieve and manage images for their own products
 * to maintain their product catalog and visual presentation. Administrators can
 * access images across all products for content moderation, policy enforcement,
 * and quality control purposes. The filtering capabilities enable efficient
 * image management even for products with large image galleries.
 *
 * Security considerations include role-based access control where sellers can
 * only retrieve images for products they own, while admins have platform-wide
 * access. The operation validates that the specified product exists and that
 * the requesting user has appropriate permissions based on their role and
 * product ownership.
 *
 * The response includes comprehensive image metadata from the
 * shopping_mall_product_images schema: image URLs for display, display_order
 * for gallery sequencing, is_primary flag to identify the main product image,
 * optional SKU associations for variant-specific images, alt_text for
 * accessibility, and creation timestamps. This metadata enables sophisticated
 * image management workflows including reordering, primary image selection, and
 * variant image coordination.
 *
 * The operation supports pagination to handle products with many images
 * efficiently, with configurable page size and sorting options. Sorting can be
 * applied by display_order (for gallery sequence), creation date
 * (chronological), or primary status (main images first). Filtering options
 * include SKU-specific images, primary image only, or date range filters.
 *
 * This operation integrates with the product catalog management system defined
 * in the requirements, supporting the business rule that products must have at
 * least one image and can have up to 10 images. The display_order field enables
 * the requirement that the first image (order 0) serves as the main product
 * image in listings and search results.
 *
 * Related operations that work together with this endpoint include retrieving
 * individual image details, creating new product images, updating image
 * properties (order, primary status), and deleting images. These operations
 * collectively enable complete product image lifecycle management as specified
 * in the product catalog management requirements.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose images are
 *   being retrieved
 * @param props.body Filtering, sorting, and pagination parameters for product
 *   image search
 * @path /shoppingMall/seller/products/:productId/images
 * @accessor api.functional.shoppingMall.seller.products.images.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the product whose images are being retrieved */
    productId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination parameters for product image
     * search
     */
    body: IShoppingMallProductImage.IRequest;
  };
  export type Body = IShoppingMallProductImage.IRequest;
  export type Response = IPageIShoppingMallProductImage;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/seller/products/:productId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/images`;
  export const random = (): IPageIShoppingMallProductImage =>
    typia.random<IPageIShoppingMallProductImage>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific product image.
 *
 * Retrieve comprehensive details for a single product image identified by its
 * unique ID within the context of a specific product. This operation accesses
 * the shopping_mall_product_images table to return complete image metadata and
 * properties.
 *
 * The operation provides detailed image information including the storage URL
 * for the image file, the display_order position determining where the image
 * appears in the product gallery sequence, the is_primary boolean flag
 * indicating whether this is the main product image shown in listings, optional
 * shopping_mall_sku_id reference if the image is specific to a product variant,
 * alt_text for accessibility and SEO purposes, and the created_at timestamp
 * showing when the image was uploaded.
 *
 * Security and authorization are critical aspects of this operation. Sellers
 * can only retrieve images for products they own, validated by checking that
 * the product's shopping_mall_seller_id matches the authenticated seller's ID.
 * Administrators have unrestricted access to retrieve any product image across
 * the platform for moderation and quality control purposes. The operation
 * validates that both the product and image exist before returning data,
 * ensuring referential integrity.
 *
 * The image URL returned uses the image_url field from the
 * shopping_mall_product_images schema, which stores the full path or URL to the
 * image file. The URL format follows the pattern defined in the schema with a
 * maximum length of 80,000 characters to support long URI formats including
 * data URIs or cloud storage URLs with authentication tokens.
 *
 * The display_order field indicates the image's position in the product
 * gallery, where position 0 represents the first image (which is the main
 * product image by convention). This information is essential for image
 * management interfaces that allow reordering images or identifying which image
 * serves as the primary product representation.
 *
 * The optional shopping_mall_sku_id association enables variant-specific
 * images. When this field is populated, it indicates the image specifically
 * represents a particular color, size, or option combination. This supports the
 * business requirement that customers should see variant-specific images when
 * selecting product variants during shopping. When the field is null, the image
 * is a general product image applicable to all variants.
 *
 * This operation is frequently used in conjunction with image update operations
 * (changing display order, setting primary status, updating alt text) and image
 * deletion operations. Together, these operations enable complete product image
 * lifecycle management as specified in the product catalog management
 * requirements document.
 *
 * The operation returns a single image object with all properties from the
 * shopping_mall_product_images table, formatted according to the
 * IShoppingMallProductImage response type. Error scenarios include product not
 * found (404), image not found (404), and unauthorized access (403) when the
 * seller attempts to access another seller's product images.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product that owns this image
 * @param props.imageId Unique identifier of the specific product image to
 *   retrieve
 * @path /shoppingMall/seller/products/:productId/images/:imageId
 * @accessor api.functional.shoppingMall.seller.products.images.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product that owns this image */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific product image to retrieve */
    imageId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallProductImage;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/products/:productId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IShoppingMallProductImage =>
    typia.random<IShoppingMallProductImage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata and properties of an existing product image.
 *
 * This operation enables sellers to modify the properties and metadata of
 * product images that have already been uploaded to their product listings. It
 * provides flexibility in managing product visual presentation without
 * requiring image re-upload.
 *
 * The operation validates that the specified product exists in the
 * shopping_mall_products table and that the authenticated seller is the owner
 * of the product. It further validates that the specified image exists in the
 * shopping_mall_product_images table and is associated with the specified
 * product. Only sellers can update images for their own products, enforcing
 * strict ownership-based authorization.
 *
 * Sellers can update the following image properties through this operation:
 * display_order (for reordering images in the gallery), is_primary (to
 * designate which image is the main product image shown in listings), alt_text
 * (for SEO and accessibility compliance), and shopping_mall_sku_id (to
 * associate the image with a specific product variant for variant-specific
 * visualization).
 *
 * When changing the is_primary flag to true, the system automatically sets
 * is_primary to false for any other image of the same product, ensuring only
 * one primary image exists per product as required by business rules. When
 * updating display_order, the system validates that the new order value is
 * appropriate and does not create gaps or duplicates in the image sequence.
 *
 * This operation is particularly useful for sellers who want to optimize their
 * product presentation by reordering images based on customer feedback, setting
 * variant-specific images for color options, or improving accessibility with
 * better alt text descriptions. Changes take effect immediately and are
 * reflected in customer-facing product pages.
 *
 * The operation integrates with the product catalog management requirements,
 * supporting sellers' ongoing product content optimization and visual
 * merchandising efforts. It complements the image creation operation by
 * providing full lifecycle management of product images.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product that owns the image
 *   being updated
 * @param props.imageId Unique identifier of the product image to be updated
 * @param props.body Updated image metadata including display order, primary
 *   designation, alt text, and variant association
 * @path /shoppingMall/seller/products/:productId/images/:imageId
 * @accessor api.functional.shoppingMall.seller.products.images.updateImage
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateImage(
  connection: IConnection,
  props: updateImage.Props,
): Promise<updateImage.Response> {
  return true === connection.simulate
    ? updateImage.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateImage.METADATA,
          path: updateImage.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateImage {
  export type Props = {
    /** Unique identifier of the product that owns the image being updated */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the product image to be updated */
    imageId: string & tags.Format<"uuid">;

    /**
     * Updated image metadata including display order, primary designation,
     * alt text, and variant association
     */
    body: IShoppingMallProduct.IImageUpdate;
  };
  export type Body = IShoppingMallProduct.IImageUpdate;
  export type Response = IShoppingMallProductImage;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/images/:imageId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IShoppingMallProductImage =>
    typia.random<IShoppingMallProductImage>();
  export const simulate = (
    connection: IConnection,
    props: updateImage.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateImage.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("imageId")(() => typia.assert(props.imageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific product image from the product gallery.
 *
 * This operation permanently removes a product image from the
 * shopping_mall_product_images table. The image is hard-deleted from the
 * database as the schema does not include soft deletion fields for product
 * images. This operation is critical for product media management, allowing
 * sellers to curate their product presentations by removing outdated,
 * incorrect, or low-quality images.
 *
 * The operation enforces strict authorization based on product ownership.
 * Sellers can only delete images from products they own (verified through
 * shopping_mall_products.shopping_mall_seller_id), while admins have
 * unrestricted access to delete any product image for content moderation
 * purposes. The system validates that the specified product and image exist and
 * that the image belongs to the specified product before processing the
 * deletion.
 *
 * Business rules enforce that products must maintain at least one image to
 * remain in active status. If the image being deleted is the only image for the
 * product, the deletion should be rejected with an appropriate error message.
 * If the deleted image is marked as the primary image (is_primary = true), the
 * system should either prevent deletion or automatically promote another image
 * to primary status to maintain product integrity.
 *
 * After successful deletion, the system recalculates the display_order values
 * for remaining images to maintain sequential ordering without gaps in the
 * gallery presentation. If the deleted image had display_order 2 in a gallery
 * with 5 images, the images with display_order 3, 4, and 5 are renumbered to 2,
 * 3, and 4 respectively.
 *
 * The operation also handles variant-specific images. If the deleted image was
 * associated with a specific SKU variant (shopping_mall_sku_id is not null),
 * removing it affects only that variant's visual representation and does not
 * impact other variants or the base product images.
 *
 * This operation integrates with the product management workflow defined in the
 * Product Catalog Management requirements. It should be available to sellers
 * through their product editing interface and to admins through the admin
 * dashboard product management tools.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product containing the image
 *   to be deleted
 * @param props.imageId Unique identifier of the specific product image to be
 *   deleted
 * @path /shoppingMall/seller/products/:productId/images/:imageId
 * @accessor api.functional.shoppingMall.seller.products.images.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the product containing the image to be deleted */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific product image to be deleted */
    imageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
