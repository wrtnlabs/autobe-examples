import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSeller } from "../../../../structures/IShoppingMallSeller";
export * as sessions from "./sessions/index";

/**
 * Retrieve detailed information for a specific seller account from the
 * shopping_mall_sellers table.
 *
 * Retrieve complete detailed information for a specific seller account on the
 * e-commerce shopping mall platform. This operation provides comprehensive
 * visibility into a seller's business profile, verification status, account
 * configuration, and operational details.
 *
 * The operation returns extensive seller information including business
 * identity (business name, business type, contact person), authentication and
 * security details (email, email verification status, account status), business
 * verification data (business registration number, tax ID, document
 * verification status), financial settings (bank account information,
 * commission rate, payout preferences), store customization (store URL slug,
 * description, logo, banner), and operational policies (return policy, shipping
 * policy, free shipping threshold).
 *
 * Security and authorization considerations are critical for this operation.
 * Administrator roles have unrestricted access to view detailed information for
 * any seller account on the platform, enabling oversight, verification, and
 * support functions. Seller roles can only access their own account details,
 * enforced through ownership validation that compares the authenticated
 * seller's ID with the requested sellerId parameter. This prevents sellers from
 * viewing competitors' business information, maintaining marketplace privacy
 * and competitive fairness.
 *
 * The response includes denormalized performance metrics and related entity
 * counts where applicable, such as total active products, total orders
 * fulfilled, average ratings, and account approval information including which
 * admin approved the account and when. Sensitive information such as password
 * hashes and full bank account numbers are excluded from the response for
 * security, with only masked/partial information provided where needed for
 * reference.
 *
 * This operation integrates with the shopping_mall_sellers table and related
 * entities as defined in the Prisma schema, including relationships to
 * shopping_mall_admins (for approval tracking), shopping_mall_products (for
 * product count), shopping_mall_orders (for fulfillment metrics), and
 * shopping_mall_addresses (for business location). The operation supports the
 * seller profile management, admin seller oversight, and seller dashboard
 * initialization use cases specified in the Seller Management and Admin
 * Dashboard requirements documents.
 *
 * Performance expectations require the operation to retrieve and return seller
 * details within 1 second under normal load conditions, with efficient database
 * queries leveraging indexed fields such as seller ID, email, and account
 * status. The response structure should be comprehensive yet optimized for both
 * display and potential editing workflows.
 *
 * @param props.connection
 * @param props.sellerId Unique identifier of the target seller account to
 *   retrieve
 * @path /shoppingMall/seller/sellers/:sellerId
 * @accessor api.functional.shoppingMall.seller.sellers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target seller account to retrieve */
    sellerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSeller;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/sellers/:sellerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): IShoppingMallSeller =>
    typia.random<IShoppingMallSeller>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update seller account information and business settings.
 *
 * Updates the seller's business profile and account settings including store
 * information, policies, and preferences. This operation enables sellers to
 * maintain current business information, customize their store presence, and
 * configure operational parameters.
 *
 * The seller can update various aspects of their account including business
 * name, contact information, store branding (logo and banner), store
 * description, return and shipping policies, and payout preferences. Changes to
 * business verification information such as tax ID or bank account details may
 * require additional admin verification before taking effect.
 *
 * Security considerations include verifying that the authenticated seller is
 * updating their own account (sellerId must match the authenticated user's
 * seller ID). The system validates all input fields according to business rules
 * including email format, phone number format, URL format for images, and
 * policy text length constraints.
 *
 * The operation integrates with the shopping_mall_sellers table in the Prisma
 * schema, updating fields such as business_name, email, phone,
 * store_description, store_logo_url, store_banner_url, return_policy,
 * shipping_policy, free_shipping_threshold, and bank account information.
 * Sensitive fields like password_hash are not updated through this endpoint -
 * separate password change endpoints should be used.
 *
 * Validation rules include ensuring email uniqueness (if changed), validating
 * image URLs and file size constraints (logo max 500KB, banner max 2MB),
 * enforcing policy text length limits, and validating free shipping threshold
 * is a positive number. The updated_at timestamp is automatically set to the
 * current time when any field is modified.
 *
 * Related API operations that might be used together include seller
 * authentication endpoints for verifying the seller's identity, seller product
 * management endpoints for managing the seller's catalog, and seller analytics
 * endpoints for viewing performance metrics after profile updates.
 *
 * @param props.connection
 * @param props.sellerId Unique identifier of the seller account to update
 * @param props.body Updated seller account information including business
 *   details, store settings, and policies
 * @path /shoppingMall/seller/sellers/:sellerId
 * @accessor api.functional.shoppingMall.seller.sellers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the seller account to update */
    sellerId: string & tags.Format<"uuid">;

    /**
     * Updated seller account information including business details, store
     * settings, and policies
     */
    body: IShoppingMallSeller.IUpdate;
  };
  export type Body = IShoppingMallSeller.IUpdate;
  export type Response = IShoppingMallSeller;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/sellers/:sellerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): IShoppingMallSeller =>
    typia.random<IShoppingMallSeller>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Deactivate seller account with soft deletion.
 *
 * Deactivates the seller's account by performing a soft deletion, marking the
 * account as deleted while preserving all historical data for legal compliance
 * and audit purposes. This operation is typically used when a seller wishes to
 * close their business on the platform or when an admin needs to remove a
 * seller for policy violations.
 *
 * When a seller account is deleted, the system sets the deleted_at timestamp in
 * the shopping_mall_sellers table, which effectively deactivates the account
 * while maintaining data integrity for past transactions. All products owned by
 * the seller are automatically hidden from customer view, preventing new
 * orders. However, existing order history, financial transaction records,
 * seller payout history, and customer reviews remain intact for compliance with
 * tax regulations and legal record-keeping requirements.
 *
 * Security considerations include strict verification that the authenticated
 * user is the seller who owns the account being deleted (sellerId must match
 * authenticated seller's ID), or that an admin with appropriate permissions is
 * performing the deletion. The operation validates that all pending orders from
 * the seller have been fulfilled or properly cancelled before allowing account
 * deletion. If the seller has pending payouts or unresolved disputes, the
 * deletion may be blocked pending resolution.
 *
 * The soft deletion mechanism updates the deleted_at field in the
 * shopping_mall_sellers table with the current timestamp. This approach allows
 * the system to filter out deleted sellers from active operations while
 * preserving complete historical records. Related entities such as products
 * (shopping_mall_products), orders (shopping_mall_orders), and reviews maintain
 * their relationships to the deleted seller through foreign key references,
 * ensuring order history displays correctly even after seller account
 * deletion.
 *
 * Business logic considerations include automatically deactivating all seller
 * products by setting their status to inactive, cancelling any pending seller
 * confirmations for new orders, processing final payouts for completed orders,
 * and notifying customers with pending orders from this seller. The seller's
 * store page becomes inaccessible to customers, but historical order details
 * continue to reference the seller's business name as it existed at the time of
 * the order.
 *
 * Validation rules enforce that sellers cannot delete their accounts if they
 * have active orders in 'confirmed', 'processing', or 'preparing_shipment'
 * states. All orders must be either delivered, cancelled, or refunded before
 * account deletion is permitted. Additionally, the seller must have zero
 * pending payout balance or agree to forfeit pending payouts (which is unusual
 * and should trigger manual admin review).
 *
 * Related API operations include seller account retrieval to view account
 * status before deletion, seller order management to ensure all orders are
 * fulfilled, and seller payout retrieval to verify all financial settlements
 * are complete. After deletion, sellers can contact platform support to
 * potentially reactivate accounts within a grace period (typically 90 days),
 * after which permanent deletion may occur.
 *
 * @param props.connection
 * @param props.sellerId Unique identifier of the seller account to deactivate
 * @path /shoppingMall/seller/sellers/:sellerId
 * @accessor api.functional.shoppingMall.seller.sellers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the seller account to deactivate */
    sellerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/sellers/:sellerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
