import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProduct } from "../../../../structures/IShoppingMallProduct";
export * as skus from "./skus/index";
export * as images from "./images/index";

/**
 * Create a new product listing for the authenticated seller.
 *
 * This operation allows sellers to create new product listings in their catalog
 * within the shopping_mall_products table. The operation validates that all
 * required product information is provided and meets the platform's business
 * rules before creating the product record.
 *
 * The product creation process enforces several critical validation rules. The
 * product name must be between 3 and 200 characters and unique within the
 * seller's existing product catalog to prevent duplicate listings. The product
 * description must contain at least 20 meaningful characters to ensure
 * customers receive adequate product information. The base price must be a
 * positive number greater than zero with maximum two decimal places. The seller
 * must assign the product to an active category from the
 * shopping_mall_categories table.
 *
 * All newly created products are initialized with 'draft' status, allowing
 * sellers to prepare complete product information including variants (SKUs),
 * images, and specifications before making the product visible to customers.
 * The draft status ensures incomplete products do not appear in customer-facing
 * catalog searches or category browsing. Sellers can later activate products by
 * changing status to 'active' once all required information including at least
 * one SKU and one product image is complete.
 *
 * The operation automatically associates the product with the authenticated
 * seller's account by capturing the seller_id from the authentication context.
 * This ensures proper ownership and access control, allowing sellers to manage
 * only their own products. The system records the creation timestamp for audit
 * purposes and product lifecycle tracking.
 *
 * This operation integrates with the product catalog management system and must
 * validate the category reference exists and is active. The created product
 * serves as the parent container for product variants (shopping_mall_skus),
 * product images (shopping_mall_product_images), and customer reviews
 * (shopping_mall_reviews). After creation, sellers typically proceed to add SKU
 * variants representing different color, size, and option combinations, upload
 * product images, and complete all required information before activating the
 * product for sale.
 *
 * Security considerations include validating the seller account is active and
 * verified before allowing product creation. The operation enforces rate
 * limiting to prevent spam product creation and validates input data to prevent
 * XSS attacks and SQL injection through malicious product names or
 * descriptions.
 *
 * @param props.connection
 * @param props.body Product creation data including name, description,
 *   category, pricing, and initial product information
 * @path /shoppingMall/seller/products
 * @accessor api.functional.shoppingMall.seller.products.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Product creation data including name, description, category, pricing,
     * and initial product information
     */
    body: IShoppingMallProduct.ICreate;
  };
  export type Body = IShoppingMallProduct.ICreate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/seller/products";
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update existing product information for seller-owned products.
 *
 * This operation allows sellers to update product information for products in
 * their catalog stored in the shopping_mall_products table. Sellers can modify
 * product attributes to correct errors, update descriptions, adjust pricing,
 * change categories, or manage product lifecycle status.
 *
 * The operation enforces strict ownership validation to ensure sellers can only
 * update their own products. When a seller submits an update request, the
 * system verifies the product's shopping_mall_seller_id matches the
 * authenticated seller's account ID. If the seller does not own the product,
 * the operation returns a 403 Forbidden error preventing unauthorized
 * modifications. This ownership check protects seller data and prevents
 * cross-seller interference.
 *
 * Sellers can update any product information fields including product name
 * (3-200 characters), description (minimum 20 characters), category assignment,
 * base price, brand, tags, specifications JSON, and product status. All field
 * validations from product creation apply to updates as well. The product name
 * must remain unique within the seller's catalog, the description must maintain
 * meaningful content, and prices must be positive numbers greater than zero
 * with maximum two decimal places.
 *
 * Product status updates enable sellers to manage product lifecycle. Sellers
 * can transition products between draft (hidden from customers), active
 * (published and visible), inactive (temporarily hidden), and discontinued
 * (permanently removed from active catalog). Status transitions must follow
 * valid business rules. For example, transitioning from draft to active
 * requires all mandatory information to be complete including at least one SKU
 * variant and one product image.
 *
 * When sellers update product prices for active products, the new price applies
 * immediately to all customer-facing displays including product listings,
 * detail pages, and search results. However, existing orders and shopping carts
 * preserve the original prices at the time of addition to maintain price
 * integrity and prevent customer confusion. Customers viewing their carts are
 * notified of price changes with updated totals before checkout.
 *
 * Category updates allow sellers to reorganize products within the platform
 * taxonomy. When changing a product's category, the system validates the new
 * category exists in shopping_mall_categories and is active. Category changes
 * affect product discoverability, applicable filters, and breadcrumb navigation
 * displayed to customers.
 *
 * The operation records the update timestamp in the updated_at field for audit
 * purposes and change tracking. The system maintains edit history through
 * timestamp tracking enabling administrators to monitor product modification
 * patterns and detect suspicious changes. Updates to critical fields like
 * pricing or category may trigger administrative review for fraud prevention.
 *
 * This operation integrates with the product catalog system and must maintain
 * referential integrity with related entities including SKUs, images, and
 * reviews. Sellers typically use this operation to respond to market
 * conditions, correct listing errors, refresh product descriptions with updated
 * information, and manage seasonal availability through status changes.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to be updated
 * @param props.body Updated product information including any modifiable fields
 *   such as name, description, category, price, brand, tags, specifications, or
 *   status
 * @path /shoppingMall/seller/products/:productId
 * @accessor api.functional.shoppingMall.seller.products.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the product to be updated */
    productId: string & tags.Format<"uuid">;

    /**
     * Updated product information including any modifiable fields such as
     * name, description, category, price, brand, tags, specifications, or
     * status
     */
    body: IShoppingMallProduct.IUpdate;
  };
  export type Body = IShoppingMallProduct.IUpdate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a product from the shopping_mall_products table.
 *
 * This operation permanently removes a product record from the
 * shopping_mall_products table in the database. It is designed for products
 * that have no order history or for administrative removal of policy-violating
 * content.
 *
 * The deletion is a hard delete operation that completely removes the product
 * from the database rather than soft-deleting it. When a product is deleted,
 * all associated data including SKU variants, product images, and variant
 * attribute configurations are also removed through cascading deletion as
 * defined in the Prisma schema relationships.
 *
 * This operation enforces strict business rules to maintain data integrity.
 * Products that have been included in customer orders cannot be deleted to
 * preserve historical transaction records and order details. Instead, sellers
 * should mark such products as discontinued through the product status update
 * functionality. Only products in draft status or products that have never been
 * ordered are eligible for deletion.
 *
 * Sellers can use this endpoint to remove their own draft products that were
 * created but never published or ordered. Admins can use this endpoint to
 * remove any product for policy violations, inappropriate content, or
 * administrative purposes, though they should exercise caution as this is an
 * irreversible operation.
 *
 * The operation validates that the requesting user (seller or admin) has
 * appropriate permissions to delete the specified product. Sellers can only
 * delete products they own, while admins can delete any product on the
 * platform. The operation returns an error if the product has associated orders
 * or if the requester lacks deletion permissions.
 *
 * This endpoint should be used sparingly as product deletion is permanent. For
 * most operational scenarios, changing the product status to 'inactive' or
 * 'discontinued' is preferred to maintain data integrity and support order
 * history display.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to be permanently
 *   deleted from the shopping_mall_products table
 * @path /shoppingMall/seller/products/:productId
 * @accessor api.functional.shoppingMall.seller.products.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the product to be permanently deleted from the
     * shopping_mall_products table
     */
    productId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
