import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProduct } from "../../../structures/IShoppingMallProduct";
import { IPageIShoppingMallProduct } from "../../../structures/IPageIShoppingMallProduct";
export * as skus from "./skus/index";

/**
 * Search and retrieve filtered, paginated list of products from the shopping
 * mall catalog.
 *
 * Retrieve a comprehensive, filtered, and paginated list of products from the
 * e-commerce shopping mall platform with advanced search and filtering
 * capabilities. This operation provides customers with powerful product
 * discovery tools to find items across the entire marketplace catalog.
 *
 * The operation performs full-text search across product names, descriptions,
 * brands, and tags from the shopping_mall_products table. It supports
 * hierarchical category filtering using the shopping_mall_categories
 * relationship, enabling customers to browse products within specific taxonomy
 * branches. Price range filtering operates on the minimum SKU price calculated
 * from associated shopping_mall_skus variants, as products may have multiple
 * variants with different pricing.
 *
 * Availability filtering checks the shopping_mall_skus table to determine stock
 * status, considering the available_quantity field for each variant. Products
 * are marked as in-stock if at least one active SKU has available_quantity
 * greater than zero. The operation also supports filtering by seller using the
 * shopping_mall_seller_id foreign key, brand name, and minimum product rating
 * calculated from aggregated shopping_mall_reviews.
 *
 * Search results are ranked by relevance for keyword searches, with exact
 * product name matches prioritized highest, followed by partial name matches,
 * brand matches, description matches, and tag matches. Within the same
 * relevance tier, results are further sorted by product popularity (sales
 * volume), seller rating, and recency. Customers can override relevance sorting
 * with explicit sort options including price ascending/descending, newest
 * first, best selling, and top rated.
 *
 * The response includes product summary information optimized for catalog
 * listings: product ID, name, primary image from shopping_mall_product_images,
 * starting price (lowest SKU price), average rating calculated from
 * shopping_mall_reviews, total review count, seller name from
 * shopping_mall_sellers, category breadcrumb path from shopping_mall_categories
 * hierarchy, and stock availability status. Only products with status 'active'
 * from shopping_mall_products are included in customer-facing search results.
 *
 * Pagination is implemented to handle large result sets efficiently, with
 * configurable page size and page number parameters. The operation maintains
 * high performance for catalogs with 100,000+ products through optimized
 * database indexing on shopping_mall_products.name,
 * shopping_mall_products.description, shopping_mall_products.status, and
 * related tables.
 *
 * Security considerations include rate limiting for search operations to
 * prevent abuse. The operation is publicly accessible without authentication,
 * allowing guest users to browse the product catalog. All product data returned
 * is sanitized and only publicly-appropriate information is exposed.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering options, sorting preferences,
 *   and pagination parameters for product discovery
 * @path /shoppingMall/products
 * @accessor api.functional.shoppingMall.products.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering options, sorting preferences, and
     * pagination parameters for product discovery
     */
    body: IShoppingMallProduct.IRequest;
  };
  export type Body = IShoppingMallProduct.IRequest;
  export type Response = IPageIShoppingMallProduct.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/products";
  export const random = (): IPageIShoppingMallProduct.ISummary =>
    typia.random<IPageIShoppingMallProduct.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve complete detailed information for a specific product including all
 * variants, images, and reviews.
 *
 * Retrieve comprehensive detailed information for a single product from the
 * shopping mall catalog, identified by the unique product ID from the
 * shopping_mall_products table. This operation provides all data necessary to
 * render a complete product detail page for customer viewing and purchasing
 * decisions.
 *
 * The operation fetches the core product entity including name, description,
 * base_price, status, brand, tags, and specifications from
 * shopping_mall_products. It validates that the product exists and has status
 * 'active' to ensure only published products are accessible to customers.
 * Discontinued, inactive, or draft products return appropriate error
 * responses.
 *
 * All product variants (SKUs) are loaded from the shopping_mall_skus table with
 * their relationships to shopping_mall_sku_colors, shopping_mall_sku_sizes, and
 * shopping_mall_sku_options. Each SKU variant includes its unique sku_code,
 * variant-specific price, available_quantity, reserved_quantity, and is_active
 * status. This enables customers to see all available color, size, and option
 * combinations with real-time inventory status for each variant.
 *
 * The complete product image gallery is retrieved from
 * shopping_mall_product_images ordered by display_order. Images include both
 * product-level images and variant-specific images (where shopping_mall_sku_id
 * is populated). The primary image (is_primary = true) is identified for main
 * display, with additional images forming the gallery for customer browsing and
 * zoom functionality.
 *
 * Category information is fetched from shopping_mall_categories including the
 * direct category assignment and the complete hierarchical breadcrumb path to
 * the root category. This supports navigation breadcrumbs and related product
 * suggestions based on category taxonomy.
 *
 * Seller information is retrieved from shopping_mall_sellers including
 * business_name, store_url_slug, and seller rating metrics. This allows
 * customers to view seller identity, access the seller's store page, and assess
 * seller reputation.
 *
 * Aggregate review statistics are calculated from shopping_mall_reviews
 * including average rating (calculated from rating field), total review count,
 * and rating distribution (count of reviews at each star level 1-5). Only
 * reviews with status 'approved' are included in these calculations. The
 * response may include a preview of recent top reviews with pagination support
 * for viewing all reviews.
 *
 * The operation also determines the product's stock availability status by
 * checking if any active SKU has available_quantity greater than zero. Products
 * with all SKUs out of stock display appropriate messaging while remaining
 * visible for wishlist addition and back-in-stock notifications.
 *
 * Security and performance considerations: This is a publicly accessible
 * endpoint requiring no authentication, enabling guest browsing. Response data
 * is cached for frequently accessed products to minimize database load. All
 * pricing displays use two decimal precision. Product view events may be
 * tracked for analytics purposes to measure product popularity and optimize
 * search ranking.
 *
 * Related API operations: After viewing product details, customers typically
 * add items to cart (POST /carts/items), add to wishlist (POST
 * /wishlists/items), or browse related products. For authenticated customers
 * who have purchased this product, the review submission endpoint becomes
 * available.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to retrieve from
 *   shopping_mall_products table
 * @path /shoppingMall/products/:productId
 * @accessor api.functional.shoppingMall.products.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the product to retrieve from
     * shopping_mall_products table
     */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
