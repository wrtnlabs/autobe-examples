import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSku } from "../../../../structures/IShoppingMallSku";
import { IPageIShoppingMallSku } from "../../../../structures/IPageIShoppingMallSku";

/**
 * Search and filter SKU variants for a specific product in shopping_mall_skus
 * table.
 *
 * This operation retrieves a comprehensive, filtered, and paginated list of SKU
 * (Stock Keeping Unit) variants associated with a specific product from the
 * shopping_mall_skus table. SKUs represent individual product variants with
 * unique combinations of attributes such as color, size, and custom options,
 * each maintaining independent pricing and inventory tracking.
 *
 * The endpoint supports advanced filtering capabilities enabling users to
 * narrow down SKU variants based on multiple criteria. Filters include variant
 * attributes (specific colors, sizes, or custom options), price ranges,
 * inventory availability (in stock, low stock, out of stock), and SKU activity
 * status. This flexible filtering is essential for both customer-facing product
 * displays and seller inventory management interfaces.
 *
 * Each SKU in the response includes complete variant information: the unique
 * SKU code, associated variant attributes (color name and hex code if
 * applicable, size value and category, custom option name and value), current
 * pricing, inventory levels (available quantity, reserved quantity for pending
 * orders, and low stock threshold), and availability status (active or
 * inactive). This comprehensive data enables accurate product variant selection
 * by customers and detailed inventory monitoring by sellers.
 *
 * The operation implements pagination to handle products with numerous variants
 * efficiently. Pagination parameters include page number, page size (default
 * 20, maximum 100 variants per page), and sorting options. Sort capabilities
 * include sorting by price (ascending or descending), available quantity (to
 * identify low-stock variants), SKU code alphabetically, or creation date
 * (newest or oldest first).
 *
 * Security and authorization considerations are critical for this endpoint.
 * Customers and public users can view only active SKUs with their pricing and
 * availability to support purchasing decisions. Sellers can view all their
 * product SKUs including inactive variants, reserved inventory quantities, and
 * comprehensive stock details for inventory management. Admins have full
 * visibility across all SKU data for any product on the platform for moderation
 * and oversight purposes.
 *
 * This endpoint directly references the shopping_mall_skus table structure from
 * the Prisma schema, including foreign key relationships to
 * shopping_mall_products (parent product), shopping_mall_sku_colors (color
 * variant), shopping_mall_sku_sizes (size variant), and
 * shopping_mall_sku_options (custom option variant). The response accurately
 * reflects these relationships by including denormalized variant attribute
 * details for efficient display.
 *
 * Performance requirements mandate that this operation returns results within
 * 500 milliseconds even for products with hundreds of variants. The
 * implementation should leverage database indexing on foreign keys, composite
 * indexes on product_id with is_active status, and efficient pagination
 * strategies to meet these performance targets.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product whose SKU
 *   variants are being retrieved from the shopping_mall_skus table
 * @param props.body Search and filtering criteria for SKU variants including
 *   variant attributes, price ranges, inventory filters, availability status,
 *   pagination parameters, and sort options
 * @path /shoppingMall/products/:productId/skus
 * @accessor api.functional.shoppingMall.products.skus.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the parent product whose SKU variants are being
     * retrieved from the shopping_mall_skus table
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Search and filtering criteria for SKU variants including variant
     * attributes, price ranges, inventory filters, availability status,
     * pagination parameters, and sort options
     */
    body: IShoppingMallSku.IRequest;
  };
  export type Body = IShoppingMallSku.IRequest;
  export type Response = IPageIShoppingMallSku;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/products/:productId/skus",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IPageIShoppingMallSku =>
    typia.random<IPageIShoppingMallSku>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific product SKU variant.
 *
 * Retrieve comprehensive details for a specific product variant (SKU)
 * identified by its unique SKU ID within the context of a parent product. This
 * operation provides all information necessary for customers to make informed
 * purchase decisions about a specific product variant.
 *
 * The SKU represents a Stock Keeping Unit with a unique combination of variant
 * attributes such as color, size, and custom options. Each SKU has independent
 * pricing that may differ from the base product price, allowing sellers to
 * charge different amounts for different sizes, colors, or configurations. The
 * SKU also maintains its own inventory tracking with available_quantity and
 * reserved_quantity fields.
 *
 * This endpoint returns complete SKU information including the SKU code (unique
 * identifier), current price, stock availability status (in stock, low stock,
 * out of stock based on available_quantity), low stock threshold configuration,
 * and whether the SKU is currently active for purchase. The response includes
 * references to variant attribute entities (shopping_mall_sku_colors,
 * shopping_mall_sku_sizes, shopping_mall_sku_options) that define the specific
 * variant combination.
 *
 * Customers use this information to understand exactly which product variant
 * they are viewing, check its availability, and see the specific price for
 * their selected combination of attributes. The inventory information helps
 * customers make immediate purchase decisions by showing real-time stock
 * status.
 *
 * Security considerations include validating that the SKU belongs to the
 * specified product to prevent unauthorized access to SKU details from
 * unrelated products. The operation is publicly accessible as customers need to
 * view SKU details during product browsing without authentication.
 *
 * This operation integrates with the shopping_mall_products table to verify the
 * parent product relationship and with variant attribute tables to provide
 * complete variant descriptions. Performance is critical as customers
 * frequently switch between variants on product pages, requiring sub-second
 * response times.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product containing the
 *   SKU variant
 * @param props.skuId Unique identifier of the specific SKU variant to retrieve
 * @path /shoppingMall/products/:productId/skus/:skuId
 * @accessor api.functional.shoppingMall.products.skus.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the parent product containing the SKU variant */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific SKU variant to retrieve */
    skuId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSku;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/products/:productId/skus/:skuId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): IShoppingMallSku =>
    typia.random<IShoppingMallSku>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
