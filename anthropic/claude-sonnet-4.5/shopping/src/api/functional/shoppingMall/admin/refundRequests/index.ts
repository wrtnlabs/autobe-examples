import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallRefundRequest } from "../../../../structures/IShoppingMallRefundRequest";

/**
 * Retrieve detailed information about a specific refund request.
 *
 * Retrieves comprehensive details about a specific refund request identified by
 * its unique ID from the shopping_mall_refund_requests table. This operation
 * provides complete visibility into the refund workflow including the original
 * order information, customer's refund reason and description, requested refund
 * amount, approved amount (if reviewed), current refund status, return
 * requirements, and tracking information.
 *
 * The refund request detail includes information about the requesting customer,
 * the associated order, the seller responsible for reviewing the request, and
 * any admin who may have overridden the decision. The response contains the
 * complete refund timeline with key timestamps including when the request was
 * submitted, the seller response deadline (3 business days from submission with
 * auto-approval if missed), when the request was reviewed, and when the refund
 * was completed.
 *
 * Security considerations include role-based access control where customers can
 * only view their own refund requests, sellers can view refund requests for
 * orders containing their products, and admins have full visibility across all
 * refund requests. The operation validates the refund request ID and ensures
 * the requesting user has appropriate permissions to access the refund request
 * details.
 *
 * This operation integrates with the order management system to provide order
 * context, the payment system to show refund processing status, and the review
 * workflow to display seller and admin responses. The refund request data helps
 * customers track their refund progress, enables sellers to make informed
 * approval decisions, and allows admins to resolve disputes and override
 * decisions when necessary.
 *
 * Related operations that might be used together include retrieving the
 * associated order details, viewing the order items that are being refunded,
 * and accessing the customer's refund request history for pattern analysis.
 *
 * @param props.connection
 * @param props.refundRequestId Unique identifier of the target refund request
 *   to retrieve
 * @path /shoppingMall/admin/refundRequests/:refundRequestId
 * @accessor api.functional.shoppingMall.admin.refundRequests.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target refund request to retrieve */
    refundRequestId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallRefundRequest;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/refundRequests/:refundRequestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/refundRequests/${encodeURIComponent(props.refundRequestId ?? "null")}`;
  export const random = (): IShoppingMallRefundRequest =>
    typia.random<IShoppingMallRefundRequest>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("refundRequestId")(() =>
        typia.assert(props.refundRequestId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update refund request status, review decision, and approval details.
 *
 * Updates the workflow status and review details of an existing refund request
 * in the shopping_mall_refund_requests table. This operation enables the refund
 * approval workflow where sellers review customer refund requests and admins
 * resolve disputes or override decisions. The update supports multiple actions
 * including approving full refunds, offering partial refunds with
 * justification, rejecting requests with detailed reasons, and specifying
 * return requirements and tracking.
 *
 * Sellers receive refund requests for orders containing their products and have
 * 3 business days to respond (recorded in seller_response_deadline). They can
 * approve the full requested amount, offer a partial refund with explanation in
 * review_notes, or reject the request with justification. When sellers approve
 * refunds, they indicate whether product return is required and provide return
 * shipping instructions. If sellers fail to respond within the deadline, the
 * system automatically approves the refund request per business rules.
 *
 * Admins can override any seller decision and make final binding determinations
 * on disputed refund requests. When customers reject seller partial refund
 * offers or appeal rejected requests, the case escalates to admin review.
 * Admins can approve full or partial refunds, mandate returns, or make final
 * rejection decisions. Admin decisions are recorded with reviewer_admin_id and
 * include detailed review_notes explaining the rationale.
 *
 * The operation validates that the refund_amount_approved does not exceed the
 * original refund_amount_requested and that the refund_status transitions are
 * valid (pending_review -> approved/rejected, rejected -> under_admin_review ->
 * approved/rejected). When refund status changes to approved, the operation
 * triggers the payment refund processing workflow. If return_required is true,
 * the customer must provide return_tracking_number before refund payment is
 * processed.
 *
 * Security and permission validation ensures that only the seller of the
 * product or an admin can update the refund request. Customers cannot directly
 * update refund requests after submission but can provide additional
 * information through support channels. All updates are logged in the audit
 * trail with timestamp and actor identification.
 *
 * Integration with the payment system initiates refund transactions when
 * requests are approved. Integration with inventory management restores stock
 * when returned products are received and confirmed. Integration with the
 * notification system sends status updates to customers at each workflow
 * stage.
 *
 * Related operations include retrieving refund request details to inform update
 * decisions, viewing the associated order to understand purchase context,
 * accessing customer refund history to identify patterns, and creating refund
 * transaction records when requests are approved.
 *
 * @param props.connection
 * @param props.refundRequestId Unique identifier of the target refund request
 *   to update
 * @param props.body Refund request update information including review
 *   decision, approved amount, status changes, return requirements, and review
 *   notes
 * @path /shoppingMall/admin/refundRequests/:refundRequestId
 * @accessor api.functional.shoppingMall.admin.refundRequests.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target refund request to update */
    refundRequestId: string & tags.Format<"uuid">;

    /**
     * Refund request update information including review decision, approved
     * amount, status changes, return requirements, and review notes
     */
    body: IShoppingMallRefundRequest.IUpdate;
  };
  export type Body = IShoppingMallRefundRequest.IUpdate;
  export type Response = IShoppingMallRefundRequest;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/refundRequests/:refundRequestId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/refundRequests/${encodeURIComponent(props.refundRequestId ?? "null")}`;
  export const random = (): IShoppingMallRefundRequest =>
    typia.random<IShoppingMallRefundRequest>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("refundRequestId")(() =>
        typia.assert(props.refundRequestId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
