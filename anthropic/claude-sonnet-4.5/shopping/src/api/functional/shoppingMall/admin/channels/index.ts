import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallChannel } from "../../../../structures/IShoppingMallChannel";
import { IPageIShoppingMallChannel } from "../../../../structures/IPageIShoppingMallChannel";

/**
 * Create a new sales channel for the shopping mall platform.
 *
 * Create a new sales channel to expand the marketplace's distribution
 * capabilities and enable multi-channel commerce operations. Sales channels in
 * the shopping mall platform represent distinct distribution methods, regional
 * marketplaces, platform types, or partner integrations through which products
 * are sold to customers. Each channel operates with its own configuration
 * including currency, language, timezone, and commission structure.
 *
 * This operation accepts comprehensive channel configuration data through the
 * request body and creates a new record in the shopping_mall_channels table.
 * The channel creation process validates that the provided channel_code is
 * unique across all existing channels (enforced by unique constraint in
 * schema), ensures required fields are complete, validates currency codes
 * against ISO 4217 standard (3-letter uppercase codes like USD, EUR, GBP),
 * validates language codes against ISO 639-1 standard (2-letter lowercase codes
 * like en, es, fr), and verifies the timezone identifier follows IANA timezone
 * database format (e.g., America/New_York, Europe/London).
 *
 * Channel types classify the distribution method (platform, regional, partner,
 * mobile) and help organize channels by operational category. The commission
 * rate specified during creation determines the platform's fee percentage for
 * all transactions processed through this channel, expressed as a decimal value
 * between 0.0 and 1.0 (e.g., 0.10 for 10% commission). This may differ from the
 * global platform default to accommodate different business models or
 * promotional strategies.
 *
 * New channels can be created in either active or inactive status based on the
 * is_active field in the request. Active channels are immediately available for
 * order processing and customer interactions, while inactive channels are
 * created for preparation but not yet operational. Channel-specific settings
 * can be stored in JSON format in the settings_json field to accommodate custom
 * parameters unique to each distribution method.
 *
 * This operation is exclusively available to platform administrators with admin
 * role, as channel management is a critical platform configuration that affects
 * financial processing, localization, and business operations across the
 * marketplace. The endpoint enforces strict validation to prevent
 * misconfiguration that could impact transaction processing or financial
 * reporting.
 *
 * Upon successful creation, the operation returns the complete channel record
 * including the system-generated unique identifier (UUID), creation timestamp,
 * and all configuration parameters. This enables administrators to verify the
 * channel was created correctly and obtain the channel ID for subsequent
 * operations or integration configuration.
 *
 * Validation errors are returned with specific field-level error messages to
 * guide administrators in correcting invalid input. Common validation failures
 * include duplicate channel codes, invalid currency or language codes,
 * malformed timezone identifiers, or commission rates outside the valid range.
 *
 * @param props.connection
 * @param props.body Sales channel configuration data for creation including
 *   channel code, name, type, currency, language, timezone, and commission
 *   rate
 * @path /shoppingMall/admin/channels
 * @accessor api.functional.shoppingMall.admin.channels.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Sales channel configuration data for creation including channel code,
     * name, type, currency, language, timezone, and commission rate
     */
    body: IShoppingMallChannel.ICreate;
  };
  export type Body = IShoppingMallChannel.ICreate;
  export type Response = IShoppingMallChannel;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/channels";
  export const random = (): IShoppingMallChannel =>
    typia.random<IShoppingMallChannel>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated sales channels from
 * shopping_mall_channels table.
 *
 * This operation provides comprehensive search and filtering capabilities for
 * sales channels in the multi-vendor e-commerce platform. Sales channels
 * represent different distribution pathways through which products are sold,
 * such as the main web platform, mobile applications, regional marketplaces, or
 * partner integrations.
 *
 * The shopping_mall_channels table stores channel configuration including
 * channel identification (channel_code, channel_name), operational parameters
 * (default_currency, default_language, timezone), business settings
 * (commission_rate), and status flags (is_active). This operation allows
 * administrators to search, filter, and analyze the channel landscape to manage
 * marketplace segmentation effectively.
 *
 * The search functionality supports complex filtering criteria including
 * channel status (active/inactive), channel type classification (platform,
 * regional, partner, mobile), creation date ranges for temporal analysis, and
 * full-text search across channel names and descriptions using PostgreSQL
 * trigram indexing for fuzzy matching capabilities.
 *
 * Results are returned in a paginated format to handle potentially large
 * numbers of channels efficiently. The response includes detailed channel
 * information such as channel identification codes, display names,
 * descriptions, operational settings (currency, language, timezone), commission
 * rates, and activity status. Each channel record also includes soft deletion
 * status (deleted_at) to support historical data retention while hiding
 * logically deleted channels from active operations.
 *
 * This operation is essential for platform administrators to monitor channel
 * performance, manage channel configurations, analyze commission structures
 * across different channels, and maintain the overall channel architecture of
 * the marketplace. The filtering and sorting capabilities enable administrators
 * to quickly identify channels requiring attention, compare channel
 * configurations, and make data-driven decisions about channel strategy.
 *
 * Channel data influences order processing, payment routing, content
 * localization, and analytics segmentation. Accurate channel configuration
 * ensures proper commission calculation, correct currency handling, and
 * appropriate language/timezone settings for customer communications. This
 * operation provides the foundation for effective channel governance and
 * marketplace expansion strategies.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, pagination, and sorting
 *   parameters for channel retrieval
 * @path /shoppingMall/admin/channels
 * @accessor api.functional.shoppingMall.admin.channels.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, pagination, and sorting parameters for
     * channel retrieval
     */
    body: IShoppingMallChannel.IRequest;
  };
  export type Body = IShoppingMallChannel.IRequest;
  export type Response = IPageIShoppingMallChannel;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/channels";
  export const random = (): IPageIShoppingMallChannel =>
    typia.random<IPageIShoppingMallChannel>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific sales channel by ID.
 *
 * Retrieve comprehensive configuration and details for a specific sales channel
 * identified by the channelId path parameter. Sales channels in the shopping
 * mall platform represent different distribution channels through which
 * products are sold, such as the main web platform, mobile applications,
 * regional marketplaces, or partner channels. Each channel maintains its own
 * configuration including currency, language, timezone, and commission rate
 * settings.
 *
 * This operation returns complete channel information from the
 * shopping_mall_channels table including the channel code, human-readable name,
 * description, channel type classification, active status, default currency
 * (ISO 4217), default language (ISO 639-1), timezone (IANA format), platform
 * commission rate, and any channel-specific settings stored in JSON format.
 *
 * The channel's active status determines whether it is currently accepting
 * orders and visible in customer-facing interfaces. Inactive channels are
 * preserved for historical reference and analytics but hidden from operational
 * use. The commission rate defines the platform's fee percentage for
 * transactions processed through this channel, which may differ from the global
 * platform default.
 *
 * The operation filters results to exclude soft-deleted channels where
 * deleted_at is not null. Only active and inactive channels that have not been
 * soft-deleted are returned. To access historical deleted channel data,
 * administrators should use dedicated archived channel endpoints if available.
 *
 * This endpoint is typically accessed by administrators who need to review or
 * verify channel configurations, or by system integrations that need to
 * retrieve channel-specific parameters for transaction processing,
 * localization, or analytics purposes. The endpoint provides read-only access
 * to channel data and does not modify any records.
 *
 * Security considerations include role-based access control ensuring only
 * authorized administrators can view channel configuration details, as
 * commission rates and business settings are sensitive operational data. The
 * operation supports efficient caching due to the infrequent changes in channel
 * configuration.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the sales channel to retrieve
 * @path /shoppingMall/admin/channels/:channelId
 * @accessor api.functional.shoppingMall.admin.channels.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the sales channel to retrieve */
    channelId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallChannel;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IShoppingMallChannel =>
    typia.random<IShoppingMallChannel>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update sales channel configuration including commission rates, currency,
 * language, and operational settings.
 *
 * Update the configuration and settings for a specific sales channel in the
 * e-commerce shopping mall platform. This operation modifies channel properties
 * including the channel name, description, channel type classification, active
 * status, default currency, default language, timezone, commission rate, and
 * channel-specific settings stored as JSON.
 *
 * This operation is essential for maintaining accurate channel configuration as
 * business requirements evolve. Administrators can adjust commission rates for
 * specific channels, change operational currencies for regional markets, update
 * localization settings (language and timezone), and toggle channel
 * availability by modifying the is_active flag.
 *
 * The operation corresponds to the shopping_mall_channels table in the Prisma
 * schema. Key fields that can be updated include channel_name (human-readable
 * display name), description (detailed channel purpose), channel_type
 * (classification like 'platform', 'regional', 'partner'), is_active
 * (visibility and order acceptance control), default_currency (ISO 4217 code),
 * default_language (ISO 639-1 code), timezone (IANA format), commission_rate
 * (decimal percentage for platform fees), and settings_json (channel-specific
 * configuration parameters).
 *
 * Security considerations include verifying the administrator has appropriate
 * permissions to modify channel configurations, validating that the channel_id
 * exists in the system, and ensuring commission rate changes do not
 * retroactively affect existing orders. The operation updates the updated_at
 * timestamp automatically to track configuration change history.
 *
 * Validation rules include ensuring commission_rate is a valid decimal between
 * 0 and 1 (representing 0-100%), default_currency follows ISO 4217 standard,
 * default_language follows ISO 639-1 standard, timezone is a valid IANA
 * timezone identifier, and channel_type matches predefined categories. The
 * operation maintains data integrity by validating all updated fields before
 * applying changes.
 *
 * This operation integrates with the email template system
 * (shopping_mall_email_templates reference channel_id), ensuring
 * channel-specific communication templates remain associated after
 * configuration updates. Related operations include retrieving channel
 * configuration (GET) and creating new channels (POST), which should be used
 * together with this update operation in typical channel management workflows.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the sales channel to update
 * @param props.body Updated channel configuration data including name,
 *   description, operational settings, commission rate, and localization
 *   parameters
 * @path /shoppingMall/admin/channels/:channelId
 * @accessor api.functional.shoppingMall.admin.channels.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the sales channel to update */
    channelId: string & tags.Format<"uuid">;

    /**
     * Updated channel configuration data including name, description,
     * operational settings, commission rate, and localization parameters
     */
    body: IShoppingMallChannel.IUpdate;
  };
  export type Body = IShoppingMallChannel.IUpdate;
  export type Response = IShoppingMallChannel;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/channels/:channelId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IShoppingMallChannel =>
    typia.random<IShoppingMallChannel>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a sales channel marking it inactive while preserving historical
 * data.
 *
 * Soft delete a sales channel by setting the deleted_at timestamp in the
 * shopping_mall_channels table. This operation marks the channel as deleted
 * while preserving all historical data associated with the channel, including
 * email templates, orders, and analytics records that reference this channel.
 *
 * The operation performs a soft delete rather than permanent deletion to
 * maintain data integrity for historical transactions and reporting. When a
 * channel is soft-deleted, it becomes hidden from active channel lists and
 * cannot accept new orders, but all existing references remain intact. This
 * approach ensures that historical orders, email templates, and analytics data
 * that reference this channel continue to function correctly.
 *
 * According to the Prisma schema, the shopping_mall_channels table includes a
 * deleted_at field (DateTime? @db.Timestamptz), which enables soft deletion
 * functionality. The operation sets this field to the current timestamp,
 * effectively removing the channel from active operations while preserving the
 * complete audit trail.
 *
 * This operation corresponds to the shopping_mall_channels table where each
 * channel has properties including channel_code (unique identifier),
 * channel_name (display name), channel_type (classification), is_active
 * (operational status), commission_rate (platform fee percentage), and various
 * localization settings (currency, language, timezone). The soft delete affects
 * the channel's visibility but does not cascade delete related entities.
 *
 * Security considerations include verifying that the administrator has
 * appropriate permissions to delete channels and ensuring that critical
 * channels required for platform operation cannot be deleted. The operation
 * should validate that no active orders are currently being processed through
 * this channel before allowing deletion.
 *
 * Business rules enforced by this operation include checking that the channel
 * is not marked as a required system channel, validating that dependent email
 * templates are either reassigned or archived, and ensuring that ongoing
 * transactions are not disrupted. The operation logs the deletion action with
 * administrator identification for audit trail purposes.
 *
 * Related operations include retrieving channel information (GET) and updating
 * channel configuration (PUT), which should be used to verify channel status
 * before deletion. After deletion, administrators can still retrieve historical
 * channel data for reporting purposes, but the channel will not appear in
 * active channel lists or be available for new order processing.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the sales channel to delete
 * @path /shoppingMall/admin/channels/:channelId
 * @accessor api.functional.shoppingMall.admin.channels.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the sales channel to delete */
    channelId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
