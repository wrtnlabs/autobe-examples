import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdminSession } from "../../../../../structures/IShoppingMallAdminSession";
import { IPageIShoppingMallAdminSession } from "../../../../../structures/IPageIShoppingMallAdminSession";

/**
 * Retrieve all active sessions for a specific admin user.
 *
 * This operation retrieves a comprehensive list of all active sessions
 * associated with a specific administrator account. It provides detailed
 * session management and security monitoring capabilities by returning
 * information about every device and browser where the admin is currently
 * logged in. This functionality is critical for security auditing, multi-device
 * session tracking, and detecting potentially unauthorized access to admin
 * accounts.
 *
 * The operation returns an array of session records from the
 * shopping_mall_sessions table where the admin_id matches the specified adminId
 * parameter, user_type is 'admin', is_revoked is false, and
 * refresh_token_expires_at is in the future (indicating active, non-expired
 * sessions). Each session record includes comprehensive metadata about the
 * login context, device information, and activity timeline.
 *
 * The response includes the following session details for each active session:
 * session ID, refresh token expiration timestamp, IP address from which the
 * session originated, complete user agent string, detected device type (mobile,
 * tablet, desktop), user-friendly device name (e.g., 'Chrome on Windows',
 * 'Safari on iPhone'), browser name and version, operating system, approximate
 * geographic location based on IP address, last activity timestamp showing when
 * the session was last used, and session creation timestamp indicating when the
 * admin logged in from that device.
 *
 * This operation supports important security use cases including reviewing all
 * current login locations, identifying suspicious or unrecognized devices,
 * monitoring session activity patterns, and enabling informed decisions about
 * which sessions to revoke. For example, if an admin sees a session from an
 * unfamiliar location or device, they can use this information to determine
 * whether to revoke that specific session through a separate session revocation
 * endpoint.
 *
 * Access control for this operation validates that the requesting admin has
 * permission to view the target admin's sessions. Admins can always view their
 * own sessions, while super admins can view sessions for any admin account on
 * the platform. This hierarchical permission model ensures appropriate access
 * control while enabling security oversight.
 *
 * The operation supports optional filtering and pagination through the request
 * body, allowing searches for sessions by device type, location, IP address, or
 * activity timeframe. This is particularly useful for admins with many
 * concurrent sessions or when investigating security incidents. The response is
 * sorted by last activity timestamp in descending order, showing the most
 * recently used sessions first for relevance.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin user whose sessions are
 *   being retrieved
 * @param props.body Optional filtering and pagination parameters for session
 *   retrieval including device type filter, location filter, date range, and
 *   pagination settings
 * @path /shoppingMall/admin/admins/:adminId/sessions
 * @accessor api.functional.shoppingMall.admin.admins.sessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the admin user whose sessions are being
     * retrieved
     */
    adminId: string & tags.Format<"uuid">;

    /**
     * Optional filtering and pagination parameters for session retrieval
     * including device type filter, location filter, date range, and
     * pagination settings
     */
    body: IShoppingMallAdminSession.IRequest;
  };
  export type Body = IShoppingMallAdminSession.IRequest;
  export type Response = IPageIShoppingMallAdminSession;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/admins/:adminId/sessions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/sessions`;
  export const random = (): IPageIShoppingMallAdminSession =>
    typia.random<IPageIShoppingMallAdminSession>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific admin session.
 *
 * This endpoint retrieves comprehensive session information for a specific
 * active admin session, enabling administrators to view details about their
 * current and past login sessions across different devices and browsers. The
 * operation is designed for security monitoring and multi-device session
 * management purposes.
 *
 * The session data provides critical security information including the device
 * type, browser name, operating system, IP address, approximate geographic
 * location based on IP, and the timestamp of last activity. This information
 * helps admins identify unauthorized access attempts, verify their own login
 * locations, and make informed decisions about which sessions to keep active or
 * revoke.
 *
 * The response includes authentication token metadata such as refresh token
 * expiration timestamp, session creation time, and revocation status. This
 * enables admins to understand when their session will expire and whether it
 * has been manually revoked. The session detail view is essential for
 * implementing the multi-device session management feature described in the
 * authentication requirements document.
 *
 * Security considerations include strict ownership validation: admins can only
 * retrieve session details for their own sessions, not sessions belonging to
 * other admins. The system validates that the adminId path parameter matches
 * the authenticated admin's user ID and that the session belongs to that admin
 * before returning any data. Unauthorized access attempts are logged for
 * security auditing.
 *
 * This operation is closely related to session revocation functionality. After
 * retrieving session details and identifying sessions the admin wants to
 * terminate (e.g., unrecognized devices or old sessions), the admin can use the
 * DELETE operation on the same endpoint to revoke specific sessions remotely.
 *
 * The session information returned is sourced directly from the
 * shopping_mall_sessions table in the Prisma schema, which tracks all active
 * and revoked sessions with complete metadata including device fingerprinting,
 * authentication tokens, and activity timestamps. Only sessions with
 * user_type='admin' and matching admin_id are retrievable through this
 * endpoint.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the authenticated admin user who
 *   owns the session
 * @param props.sessionId Unique identifier of the specific admin session to
 *   retrieve
 * @path /shoppingMall/admin/admins/:adminId/sessions/:sessionId
 * @accessor api.functional.shoppingMall.admin.admins.sessions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the authenticated admin user who owns the
     * session
     */
    adminId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific admin session to retrieve */
    sessionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdminSession;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/admins/:adminId/sessions/:sessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/sessions/${encodeURIComponent(props.sessionId ?? "null")}`;
  export const random = (): IShoppingMallAdminSession =>
    typia.random<IShoppingMallAdminSession>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.param("sessionId")(() => typia.assert(props.sessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke a specific admin session to terminate authentication for that device.
 *
 * This endpoint enables administrators to revoke specific active sessions,
 * effectively signing out from individual devices or browsers remotely. This is
 * a critical security feature for managing multi-device authentication and
 * protecting admin accounts from unauthorized access.
 *
 * The session revocation process is designed to support the 'logout from
 * specific device' use case described in the authentication requirements. When
 * an admin identifies a session they want to terminate—whether it's an old
 * session from a device they no longer use, a session from an unrecognized
 * location, or a potentially compromised session—they can revoke it using this
 * endpoint without affecting their other active sessions.
 *
 * Upon successful revocation, the system performs several important actions to
 * ensure complete session termination. First, it updates the session record in
 * the shopping_mall_sessions table by setting is_revoked to true and recording
 * the revocation timestamp in revoked_at. This permanently marks the session as
 * invalid. Second, it invalidates the associated refresh token, preventing any
 * future attempts to generate new access tokens using that session's refresh
 * token. The revoked session immediately becomes unusable for authentication
 * purposes.
 *
 * Security validation is paramount for this operation. The system strictly
 * enforces ownership verification: admins can only revoke their own sessions,
 * never sessions belonging to other administrators. The endpoint validates that
 * the adminId path parameter matches the authenticated admin's user ID
 * extracted from the JWT access token, and that the session with the given
 * sessionId belongs to that admin. Any attempt to revoke another admin's
 * session results in a 403 Forbidden response and is logged as a security
 * event.
 *
 * The operation provides immediate feedback to the client. Unlike the soft
 * delete pattern used in many other entities, session revocation uses a
 * revocation flag mechanism (is_revoked boolean and revoked_at timestamp) to
 * maintain the session record for audit trail purposes while making it
 * completely unusable for authentication. This supports security auditing
 * requirements and enables admins to review their historical sessions including
 * which ones were manually revoked and when.
 *
 * This operation integrates with the broader session management system defined
 * in the authentication requirements document. After revoking a session, that
 * session will no longer appear in the admin's active sessions list, though it
 * may be retained in historical session views for security audit purposes. The
 * revocation is permanent and irreversible—once revoked, a session cannot be
 * reactivated; the admin must log in again from that device to create a new
 * session.
 *
 * Common use cases for this endpoint include: removing sessions from lost or
 * stolen devices, terminating sessions from untrusted networks or locations,
 * cleaning up old sessions that are no longer needed, and responding to
 * security alerts about suspicious session activity. The session revocation
 * feature complements the 'logout from all devices' functionality (which would
 * revoke all sessions for an admin) by providing granular control over
 * individual session lifecycles.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the authenticated admin user who
 *   owns the session to be revoked
 * @param props.sessionId Unique identifier of the specific admin session to
 *   revoke and terminate
 * @path /shoppingMall/admin/admins/:adminId/sessions/:sessionId
 * @accessor api.functional.shoppingMall.admin.admins.sessions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the authenticated admin user who owns the
     * session to be revoked
     */
    adminId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the specific admin session to revoke and
     * terminate
     */
    sessionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/admins/:adminId/sessions/:sessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/sessions/${encodeURIComponent(props.sessionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.param("sessionId")(() => typia.assert(props.sessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
