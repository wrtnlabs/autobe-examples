import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../structures/IShoppingMallCustomer";
import { IPageIShoppingMallCustomer } from "../../../../structures/IPageIShoppingMallCustomer";
export * as sessions from "./sessions/index";

/**
 * Search and retrieve a filtered, paginated list of customer accounts.
 *
 * This operation retrieves a comprehensive list of customer accounts from the
 * shopping_mall_customers table with advanced filtering, searching, and
 * pagination capabilities. It is designed to support administrative customer
 * management workflows and customer analytics reporting.
 *
 * The endpoint accepts complex search criteria through the request body,
 * enabling filtering by multiple dimensions including account status (active,
 * suspended, deleted), email verification status, registration date ranges, and
 * text-based name searching. The PATCH method is used instead of GET to
 * accommodate the complexity and size of filter parameters that would be
 * impractical to encode in URL query strings.
 *
 * Administrators use this endpoint to monitor customer account registrations
 * and growth trends, identify customers requiring email verification follow-up,
 * find customers with specific account statuses for bulk operations, search for
 * customers by name for support inquiries, and generate customer reports with
 * filtered datasets.
 *
 * The response returns a paginated collection of customer records including
 * essential profile information such as name, email, phone number, account
 * status, email verification status, registration date, and account activity
 * timestamps. Sensitive authentication data (password hashes, verification
 * tokens, reset tokens, password history) are excluded from the response for
 * security.
 *
 * Pagination is implemented to handle large customer datasets efficiently, with
 * configurable page size and page number parameters. The response includes
 * pagination metadata showing total record count, current page, total pages,
 * and page size to enable proper pagination UI rendering.
 *
 * Security considerations include restricting this endpoint to authenticated
 * administrators only. Customer personal information is protected through
 * role-based access control, ensuring only authorized personnel can search and
 * view customer accounts.
 *
 * The search functionality utilizes database indexing on customer name (using
 * trigram GIN index) for fast full-text search performance. Account status and
 * email verification filters use indexed columns for efficient query execution
 * even with millions of customer records.
 *
 * Related operations: To view detailed information for a specific customer, use
 * GET /customers/{customerId}. To update customer account status, use PUT
 * /customers/{customerId}. To manage customer addresses, use the
 * /customers/{customerId}/addresses endpoints.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for filtering
 *   customer accounts
 * @path /shoppingMall/admin/customers
 * @accessor api.functional.shoppingMall.admin.customers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for filtering customer
     * accounts
     */
    body: IShoppingMallCustomer.IRequest;
  };
  export type Body = IShoppingMallCustomer.IRequest;
  export type Response = IPageIShoppingMallCustomer.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/customers";
  export const random = (): IPageIShoppingMallCustomer.ISummary =>
    typia.random<IPageIShoppingMallCustomer.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific customer account.
 *
 * Retrieves comprehensive customer account information from the
 * shopping_mall_customers table by customer ID. This operation provides
 * complete customer profile data including personal information, account
 * status, email verification status, and security metadata for administrative
 * oversight and customer support purposes.
 *
 * The endpoint returns detailed customer information including email address,
 * full name, phone number, account status (active, suspended, deleted), email
 * verification status, and timestamps for account creation and last update.
 * Security-sensitive fields such as password hashes, verification tokens, and
 * password reset tokens are excluded from the response to maintain security
 * compliance.
 *
 * This operation integrates with the user authentication system to validate
 * that only authorized administrators can access customer details. The customer
 * data is retrieved from the shopping_mall_customers table as defined in the
 * Prisma schema, ensuring accurate reflection of the current account state.
 *
 * Administrators use this endpoint to review customer accounts for support
 * inquiries, verify customer identity, investigate account issues, monitor
 * account status, and manage customer relationships. The operation supports the
 * admin dashboard functionality defined in the requirements for comprehensive
 * customer account management.
 *
 * Related operations include customer account listing, customer account
 * updates, and customer account suspension workflows. This endpoint serves as
 * the foundation for detailed customer profile inspection and administrative
 * decision-making regarding customer accounts.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer account to
 *   retrieve
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target customer account to retrieve */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update customer account information for administrative management.
 *
 * Updates an existing customer account record in the shopping_mall_customers
 * table with modified profile information. This operation allows administrators
 * to modify customer account details including name, phone number, account
 * status, and email verification status for account management, support
 * resolution, and compliance purposes.
 *
 * The endpoint accepts updated customer information and validates all fields
 * according to platform business rules. Name must be a valid non-empty string,
 * phone number must match international format standards, and account status
 * must be one of the valid values (active, suspended, deleted) as defined in
 * the business requirements. The operation prevents modification of immutable
 * fields like customer ID, email address (which requires separate email change
 * workflow), and password hash (which requires password reset workflow).
 *
 * This operation integrates with the user management system to ensure only
 * authorized administrators can modify customer accounts. All changes are
 * validated against the shopping_mall_customers table schema defined in the
 * Prisma database, ensuring data consistency and referential integrity.
 *
 * Administrators use this endpoint to update customer information when
 * resolving support tickets, manually verifying email addresses when
 * verification emails fail, correcting customer profile data, updating account
 * status for policy enforcement (suspensions), and managing customer account
 * lifecycle. The operation supports the admin dashboard functionality specified
 * in the requirements for comprehensive customer account management.
 *
 * Changes made through this endpoint are immediately reflected in the
 * customer's account and may trigger notifications to the customer (for status
 * changes or significant profile updates). The operation maintains an audit
 * trail of account modifications for compliance and security monitoring.
 * Related operations include retrieving customer details, suspending customer
 * accounts, and managing customer addresses.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer account to
 *   update
 * @param props.body Updated customer account information including profile data
 *   and account status modifications
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target customer account to update */
    customerId: string & tags.Format<"uuid">;

    /**
     * Updated customer account information including profile data and
     * account status modifications
     */
    body: IShoppingMallCustomer.IUpdate;
  };
  export type Body = IShoppingMallCustomer.IUpdate;
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Mark customer account as deleted (soft delete).
 *
 * Marks a customer account as deleted by setting the deleted_at timestamp in
 * the shopping_mall_customers table. This operation implements soft deletion,
 * preserving all customer-related data while preventing future account access
 * and filtering the account from normal platform queries.
 *
 * The shopping_mall_customers schema includes a deleted_at field (nullable
 * DateTime) that enables soft deletion. When this operation is executed, the
 * deleted_at field is set to the current timestamp, effectively marking the
 * account as deleted without removing any data from the database. This approach
 * satisfies multiple critical business and legal requirements.
 *
 * From a compliance perspective, soft deletion is essential for maintaining
 * financial records and audit trails. Order history, payment transactions, and
 * customer reviews must be preserved to comply with tax regulations, financial
 * reporting requirements, and legal record-keeping obligations. Hard deletion
 * of customer accounts would create gaps in financial records and violate
 * various regulatory requirements that mandate transaction history retention
 * (typically 7 years for tax purposes).
 *
 * When a customer account is marked as deleted, several automated actions
 * occur. First, all active sessions associated with the customer are
 * immediately revoked by setting is_revoked to true in the
 * shopping_mall_sessions table. This prevents the customer from continuing to
 * use any active login sessions across any devices. Second, the customer
 * account is filtered from login authentication queries, preventing future
 * login attempts with the deleted account credentials. Third, the
 * account_status field may be updated to 'deleted' to provide additional
 * filtering capability beyond the deleted_at timestamp.
 *
 * All related data is preserved in the database, including shopping_mall_orders
 * (order history), shopping_mall_payment_transactions (payment records),
 * shopping_mall_reviews (product reviews), shopping_mall_addresses (delivery
 * addresses), and shopping_mall_wishlists (saved items). The onDelete: Cascade
 * directives in the schema apply only to hard deletes (actual record removal),
 * not to soft deletes. Soft deletion simply marks the parent record as deleted
 * while leaving all child records intact.
 *
 * For GDPR compliance and the "right to erasure", this soft delete operation
 * can be combined with a separate data anonymization process. Personal
 * identifiable information (PII) such as the customer's name, email, phone
 * number, and addresses can be replaced with anonymized values (e.g.,
 * 'DELETED_USER_[ID]', 'deleted_[ID]@privacy.local') while maintaining the
 * order and transaction records with anonymized customer references. This
 * approach satisfies both the right to erasure and the legal requirement to
 * maintain financial records.
 *
 * From a security standpoint, only administrators with appropriate permissions
 * can execute this operation, preventing unauthorized account deletion. The
 * operation verifies that the customer account exists before attempting the
 * soft delete and returns appropriate error codes if the customer ID is not
 * found (404 Not Found) or if the account is already marked as deleted.
 *
 * This operation provides no response body upon success, following REST
 * conventions for DELETE operations. A successful soft deletion returns HTTP
 * 204 No Content. The deleted_at timestamp serves as the permanent record of
 * when the account was marked as deleted and by which administrator (tracked
 * through audit logs).
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer account to be
 *   marked as deleted
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer account to be marked as deleted */
    customerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
