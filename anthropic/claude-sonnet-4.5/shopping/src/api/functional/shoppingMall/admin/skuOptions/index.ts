import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSkuOption } from "../../../../structures/IShoppingMallSkuOption";
import { IPageIShoppingMallSkuOption } from "../../../../structures/IPageIShoppingMallSkuOption";

/**
 * Create a new custom SKU option for product variant configurations.
 *
 * This operation enables the creation of custom SKU option attributes that
 * extend beyond standard color and size variants. Custom options provide
 * flexibility for sellers to define product-specific attributes that
 * differentiate their SKU variants, such as storage capacity for electronics,
 * material composition for clothing, package quantities for consumables, or
 * subscription durations for services.
 *
 * The endpoint creates a new record in the shopping_mall_sku_options table with
 * the provided option_name (the attribute category) and option_value (the
 * specific value). The system enforces uniqueness on the combination of
 * option_name and option_value to prevent duplicate options across the
 * platform. For example, if 'Storage Capacity: 128GB' already exists,
 * attempting to create it again will be rejected.
 *
 * Once created, custom options become available for selection when sellers
 * create or update SKU variants through the product management interface. The
 * same option can be referenced by multiple SKUs across different products,
 * promoting consistency in variant naming and enabling effective filtering and
 * search capabilities.
 *
 * This operation is typically invoked during product listing creation workflows
 * when sellers need to define new variant attributes that don't exist in the
 * current option catalog. It may also be used by admins to pre-populate common
 * option values for specific product categories, ensuring standardization
 * across seller listings.
 *
 * Validation rules include verifying the option_name is descriptive and follows
 * consistent naming conventions (e.g., 'Storage Capacity' rather than 'storage'
 * or 'capacity'), and that option_value accurately represents the specific
 * variant characteristic. The system automatically assigns a unique UUID
 * identifier and records creation timestamp for audit purposes.
 *
 * Security considerations include restricting option creation to authenticated
 * sellers and admins, preventing spam or inappropriate option values, and
 * maintaining data integrity by rejecting options with malicious content or
 * excessive length.
 *
 * @param props.connection
 * @param props.body Custom SKU option creation data including option name and
 *   value
 * @path /shoppingMall/admin/skuOptions
 * @accessor api.functional.shoppingMall.admin.skuOptions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Custom SKU option creation data including option name and value */
    body: IShoppingMallSkuOption.ICreate;
  };
  export type Body = IShoppingMallSkuOption.ICreate;
  export type Response = IShoppingMallSkuOption;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/skuOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/skuOptions";
  export const random = (): IShoppingMallSkuOption =>
    typia.random<IShoppingMallSkuOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of custom SKU option variants
 * from shopping_mall_sku_options table.
 *
 * This operation provides comprehensive search and filtering capabilities for
 * retrieving custom SKU option variants from the shopping_mall_sku_options
 * table. Custom options represent seller-defined product variant attributes
 * beyond the standard color and size, such as storage capacity, material type,
 * package quantity, subscription period, and other product-specific
 * variations.
 *
 * The operation accepts complex search criteria in the request body, enabling
 * administrators and potentially sellers to search through available custom
 * option definitions when managing product variants. Search capabilities
 * include full-text search across option names and values, filtering by
 * creation date ranges, and pagination controls for managing large result
 * sets.
 *
 * The shopping_mall_sku_options table structure includes the following fields:
 * id (UUID primary key), option_name (the name of the custom option like
 * 'Storage Capacity'), option_value (the specific value like '128GB' or
 * '256GB'), created_at (timestamp when the option was created), and updated_at
 * (timestamp when last modified). The table uses a unique constraint on the
 * combination of option_name and option_value to prevent duplicate option
 * definitions.
 *
 * Security considerations include role-based access control where
 * administrators have full visibility into all custom options, while sellers
 * might have filtered views based on their product catalog needs. The operation
 * does not expose sensitive customer or financial information, focusing purely
 * on product variant configuration data.
 *
 * Relationship to underlying database entities: This operation queries the
 * shopping_mall_sku_options table, which is referenced by shopping_mall_skus
 * through the shopping_mall_sku_option_id foreign key. Each SKU can optionally
 * reference a custom option to represent variant differentiation beyond color
 * and size. This makes custom options a critical part of the product variant
 * architecture described in [Product Catalog
 * Management](03-product-catalog-management.md).
 *
 * Validation rules include ensuring pagination parameters are within acceptable
 * ranges (page size typically 10-100 records), validating date range filters if
 * provided, and sanitizing text search inputs to prevent injection attacks. The
 * system should handle empty result sets gracefully and provide appropriate
 * feedback when no options match the search criteria.
 *
 * Expected behavior includes returning a paginated response with total count,
 * current page metadata, and an array of matching custom option records sorted
 * by creation date (newest first) or by option name alphabetically based on
 * request parameters. Performance expectations require results to be returned
 * within 500 milliseconds for typical queries on datasets up to 10,000 option
 * records.
 *
 * @param props.connection
 * @param props.body Search and filter criteria for SKU custom options including
 *   text search, date ranges, and pagination parameters
 * @path /shoppingMall/admin/skuOptions
 * @accessor api.functional.shoppingMall.admin.skuOptions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter criteria for SKU custom options including text
     * search, date ranges, and pagination parameters
     */
    body: IShoppingMallSkuOption.IRequest;
  };
  export type Body = IShoppingMallSkuOption.IRequest;
  export type Response = IPageIShoppingMallSkuOption;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/skuOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/skuOptions";
  export const random = (): IPageIShoppingMallSkuOption =>
    typia.random<IPageIShoppingMallSkuOption>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing custom SKU option attribute for product variants.
 *
 * Updates the name and/or value of a custom SKU option attribute that is used
 * across product variants in the shopping mall catalog. This operation is
 * essential for maintaining accurate product variant information when sellers
 * need to correct option naming, update value labels, or refine variant
 * attribute definitions.
 *
 * Custom SKU options extend the standard color and size variant system by
 * allowing sellers to define product-specific attributes such as storage
 * capacity for electronics, material composition for apparel, package
 * quantities for consumables, or subscription periods for services. Each option
 * consists of an option_name (the attribute category) and option_value (the
 * specific variant) that together create unique product differentiators.
 *
 * When a custom SKU option is updated through this endpoint, the changes
 * propagate to all product SKUs that reference this option. For example,
 * updating an option from 'Storage: 128GB' to 'Storage Capacity: 128 GB' will
 * automatically update the variant description for all products using this
 * option. This ensures consistency across the product catalog and prevents
 * variant attribute fragmentation.
 *
 * Access to this operation is restricted based on user roles. Sellers can
 * update custom options that belong to their own products, while admins have
 * unrestricted access to update any SKU option across the platform. The system
 * validates that the updated option_name and option_value combination remains
 * unique to prevent duplicate variant attributes.
 *
 * This operation requires validation against the shopping_mall_sku_options
 * table structure, which contains id, option_name, option_value, created_at,
 * and updated_at fields. The option_name and option_value pair must remain
 * unique after the update, and the system must ensure that all referencing SKUs
 * maintain valid variant combinations. Updates are logged with timestamps for
 * audit trail and change tracking purposes.
 *
 * @param props.connection
 * @param props.optionId Unique identifier of the custom SKU option to update
 * @param props.body Updated custom SKU option information including option name
 *   and value
 * @path /shoppingMall/admin/skuOptions/:optionId
 * @accessor api.functional.shoppingMall.admin.skuOptions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the custom SKU option to update */
    optionId: string & tags.Format<"uuid">;

    /** Updated custom SKU option information including option name and value */
    body: IShoppingMallSkuOption.IUpdate;
  };
  export type Body = IShoppingMallSkuOption.IUpdate;
  export type Response = IShoppingMallSkuOption;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/skuOptions/:optionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/skuOptions/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallSkuOption =>
    typia.random<IShoppingMallSkuOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a custom SKU option attribute from the variant system.
 *
 * Permanently removes a custom SKU option attribute from the shopping mall
 * product variant system. This operation performs a hard delete that completely
 * removes the option record from the database, as the shopping_mall_sku_options
 * table does not support soft deletion.
 *
 * Custom SKU options are seller-defined variant attributes that extend beyond
 * the standard color and size system. Examples include storage capacity for
 * electronics (128GB, 256GB), material types for apparel (Cotton, Polyester),
 * package quantities for consumables (6-pack, 12-pack), or subscription periods
 * for services (Monthly, Annual). These options enable sellers to create rich
 * product variant combinations tailored to their specific product offerings.
 *
 * Before deleting a custom SKU option, the system must validate that no active
 * product SKUs are currently referencing this option. The shopping_mall_skus
 * table contains a foreign key shopping_mall_sku_option_id that links SKUs to
 * their custom option attributes. If any SKUs reference the option being
 * deleted, the operation must be rejected to prevent orphaned references and
 * maintain catalog data integrity. Sellers or admins must first reassign or
 * discontinue affected SKUs before the option can be deleted.
 *
 * This deletion operation is permanent and irreversible. Once executed, the
 * option_name and option_value combination is removed from the system and
 * cannot be recovered. Historical order data remains intact as order_items
 * snapshot variant attributes at purchase time, preserving accurate order
 * history even after variant options are deleted.
 *
 * Access to this operation is restricted by user role. Sellers can delete
 * custom options that belong exclusively to their own products and have no
 * active SKU references. Admins have broader deletion authority but must still
 * respect the referential integrity constraint requiring zero active SKU
 * references. The system logs all deletion operations with actor information
 * and timestamp for audit trail and compliance purposes.
 *
 * @param props.connection
 * @param props.optionId Unique identifier of the custom SKU option to
 *   permanently delete
 * @path /shoppingMall/admin/skuOptions/:optionId
 * @accessor api.functional.shoppingMall.admin.skuOptions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the custom SKU option to permanently delete */
    optionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/skuOptions/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/skuOptions/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
