import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSkuSize } from "../../../../structures/IShoppingMallSkuSize";

/**
 * Create a new size variant attribute for product SKU differentiation.
 *
 * Creates a new size variant attribute in the shopping_mall_sku_sizes table
 * that sellers can use when defining product variants. Size attributes enable
 * product differentiation by size dimensions such as Small/Medium/Large for
 * apparel or numeric sizes for shoes and other sized products.
 *
 * This operation is critical for expanding the platform's variant attribute
 * catalog. When sellers create products with multiple size options, they select
 * from existing size records in the shopping_mall_sku_sizes table. By adding
 * new size attributes through this endpoint, administrators ensure sellers have
 * the necessary options to accurately represent their product variants.
 *
 * The size creation requires a unique combination of size value and optional
 * size category. The value represents the actual size (e.g., 'Medium', '42',
 * 'XL'), while the category groups sizes by system (e.g., 'US Sizes', 'EU
 * Sizes', 'One Size'). This combination ensures clarity when sellers offer
 * products in different sizing systems.
 *
 * Once created, size attributes become available for SKU creation. Sellers can
 * then associate their product SKUs with these sizes through the
 * shopping_mall_skus table, which references shopping_mall_sku_sizes via the
 * shopping_mall_sku_size_id foreign key. The size attribute is immutable once
 * associated with active SKUs to maintain data integrity and prevent confusion
 * in existing product listings.
 *
 * This endpoint integrates with the product catalog management system defined
 * in the requirements analysis, supporting the comprehensive SKU-level
 * inventory management that differentiates this platform. Size attributes are a
 * fundamental component of the variant system, working alongside color and
 * custom option attributes to create unique, trackable product SKUs.
 *
 * @param props.connection
 * @param props.body Size variant attribute creation data including size value
 *   and optional category classification
 * @path /shoppingMall/admin/skuSizes
 * @accessor api.functional.shoppingMall.admin.skuSizes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Size variant attribute creation data including size value and
     * optional category classification
     */
    body: IShoppingMallSkuSize.ICreate;
  };
  export type Body = IShoppingMallSkuSize.ICreate;
  export type Response = IShoppingMallSkuSize;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/skuSizes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/skuSizes";
  export const random = (): IShoppingMallSkuSize =>
    typia.random<IShoppingMallSkuSize>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing size variant attribute's value or category.
 *
 * Updates an existing size variant attribute in the shopping_mall_sku_sizes
 * table, allowing administrators to modify size specifications for
 * platform-wide variant management. This operation enables correction of size
 * naming, reorganization of size categories, and standardization of sizing
 * systems across the marketplace.
 *
 * Size attributes in the shopping_mall_sku_sizes table are referenced by
 * product SKUs through the shopping_mall_skus.shopping_mall_sku_size_id foreign
 * key relationship. When a size attribute is updated, the changes affect how
 * that size is displayed across all products using it. This operation is
 * critical for maintaining consistent and accurate size representation
 * throughout the product catalog.
 *
 * Administrators can update the size value (e.g., changing 'M' to 'Medium' for
 * clarity) and the size category (e.g., moving a size from 'US Sizes' to 'EU
 * Sizes' for proper classification). The system validates that the updated
 * combination of value and category remains unique across all size records, as
 * enforced by the Prisma schema's unique constraint on [value, category]. If
 * the update would create a duplicate, the operation fails with a validation
 * error.
 *
 * This endpoint requires careful consideration of downstream impacts. Updating
 * a size attribute affects all SKUs that reference it, changing how those
 * product variants are displayed to customers. Therefore, this operation is
 * restricted to administrators who understand the platform-wide implications.
 * The shopping_mall_sku_sizes table tracks updated_at timestamps to maintain an
 * audit trail of size modifications.
 *
 * Size updates integrate with the product catalog system, ensuring that product
 * listings reflect the corrected or reorganized size information immediately.
 * Sellers do not need to take any action when size attributes are updated - the
 * changes propagate automatically through the foreign key relationships to all
 * associated SKUs and product displays.
 *
 * @param props.connection
 * @param props.sizeId Unique identifier of the size variant attribute to update
 * @param props.body Updated size variant attribute data including new value or
 *   category
 * @path /shoppingMall/admin/skuSizes/:sizeId
 * @accessor api.functional.shoppingMall.admin.skuSizes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the size variant attribute to update */
    sizeId: string & tags.Format<"uuid">;

    /** Updated size variant attribute data including new value or category */
    body: IShoppingMallSkuSize.IUpdate;
  };
  export type Body = IShoppingMallSkuSize.IUpdate;
  export type Response = IShoppingMallSkuSize;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/skuSizes/:sizeId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/skuSizes/${encodeURIComponent(props.sizeId ?? "null")}`;
  export const random = (): IShoppingMallSkuSize =>
    typia.random<IShoppingMallSkuSize>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sizeId")(() => typia.assert(props.sizeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific SKU size variant by ID from the
 * shopping_mall_sku_sizes table.
 *
 * This operation permanently removes a SKU size variant definition from the
 * e-commerce platform's product variant system. The size entity being deleted
 * belongs to the shopping_mall_sku_sizes table, which stores size variant
 * attributes such as 'Small', 'Medium', 'Large' or numeric sizes like '38',
 * '40', '42' along with optional size categories like 'US Sizes' or 'EU
 * Sizes'.
 *
 * The deletion is a hard delete operation that permanently removes the size
 * record from the database. This is an important distinction because the schema
 * does NOT contain soft delete columns (deleted_at) for the
 * shopping_mall_sku_sizes table, meaning the record is completely removed
 * rather than marked as deleted.
 *
 * Security considerations include ensuring that only authorized administrators
 * have permission to delete size variants, as this operation impacts the
 * product catalog structure across the platform. The operation should validate
 * referential integrity by checking whether any shopping_mall_skus records
 * currently reference this size ID through the shopping_mall_sku_size_id
 * foreign key. If active SKU records reference this size, the deletion should
 * fail with an appropriate error message to prevent orphaned SKU references.
 *
 * The operation integrates with the product catalog management system defined
 * in the requirements document [Product Catalog
 * Management](03-product-catalog-management.md), specifically the SKU and
 * variant management sections. Size variants are fundamental to the product
 * variant architecture that enables sellers to offer products in different
 * sizes.
 *
 * Before executing this deletion, the system should verify that no
 * shopping_mall_skus records have their shopping_mall_sku_size_id foreign key
 * pointing to this size ID. If such references exist, the operation must be
 * blocked and return an error indicating the size is in use by active product
 * variants. This prevents breaking the product catalog and ensures customers
 * can still view historical orders and product information correctly.
 *
 * Expected behavior includes returning a success status (204 No Content) upon
 * successful deletion when the size has no active references, or returning an
 * error status (409 Conflict or 400 Bad Request) if the size is currently in
 * use by SKU records.
 *
 * @param props.connection
 * @param props.sizeId Unique identifier of the SKU size variant to be
 *   permanently deleted from the shopping_mall_sku_sizes table
 * @path /shoppingMall/admin/skuSizes/:sizeId
 * @accessor api.functional.shoppingMall.admin.skuSizes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the SKU size variant to be permanently deleted
     * from the shopping_mall_sku_sizes table
     */
    sizeId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/skuSizes/:sizeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/skuSizes/${encodeURIComponent(props.sizeId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sizeId")(() => typia.assert(props.sizeId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
