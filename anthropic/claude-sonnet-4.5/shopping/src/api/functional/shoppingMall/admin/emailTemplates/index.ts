import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallEmailTemplate } from "../../../../structures/IShoppingMallEmailTemplate";
import { IPageIShoppingMallEmailTemplate } from "../../../../structures/IPageIShoppingMallEmailTemplate";

/**
 * Create a new email template for platform communications.
 *
 * Creates a new email template in the shopping mall platform's communication
 * system. Email templates provide reusable, customizable content for
 * transactional and marketing emails sent to customers, sellers, and
 * administrators throughout various platform workflows.
 *
 * This operation enables administrators to define email templates with dynamic
 * variable placeholders that are populated with actual data when emails are
 * sent. For example, an order confirmation template might include placeholders
 * like {{order_number}}, {{customer_name}}, and {{total_amount}} that are
 * replaced with specific order details for each customer.
 *
 * The template supports both HTML and plain text body content. The HTML body
 * enables rich formatting, branding, and visual design for modern email
 * clients, while the plain text body serves as a fallback for email clients
 * that don't support HTML rendering or for accessibility purposes. Both
 * versions should convey the same essential information.
 *
 * Templates can be associated with specific channels through the
 * shopping_mall_channel_id field, enabling channel-specific customization of
 * communications. For example, a mobile app channel might have different email
 * styling than the web platform channel. When shopping_mall_channel_id is null,
 * the template is available platform-wide across all channels.
 *
 * The template_code field serves as the unique identifier used by the
 * application logic to select the appropriate template for each email sending
 * scenario. Common codes include 'ORDER_CONFIRMATION', 'SHIPMENT_NOTIFICATION',
 * 'PASSWORD_RESET', 'WELCOME_EMAIL', 'REFUND_APPROVED', and 'REVIEW_REQUEST'.
 *
 * Multi-language support is provided through the language_code field following
 * ISO 639-1 standard. The platform can maintain separate templates for each
 * language, enabling localized communications. The combination of
 * template_code, language_code, and shopping_mall_channel_id must be unique.
 *
 * Template categorization through the category field enables organization by
 * business function such as 'transactional' (order/payment related),
 * 'marketing' (promotional campaigns), 'authentication' (login/verification),
 * and 'notification' (status updates). This grouping facilitates template
 * management and reporting.
 *
 * The variables_json field documents available placeholders in JSON format,
 * helping administrators understand which dynamic values can be used in the
 * template content. For example: [{"key": "order_number", "description":
 * "Unique order identifier"}, {"key": "customer_name", "description":
 * "Customer's full name"}].
 *
 * Version tracking through the version field enables audit trail of template
 * changes and potential rollback to previous versions if needed. Each update
 * increments the version number.
 *
 * Sender configuration through from_email, from_name, and reply_to_email fields
 * allows customization of the email envelope. These fields can override
 * platform defaults to provide context-specific sender identification. For
 * example, transactional emails might come from 'orders@shoppingmall.com' while
 * support emails come from 'support@shoppingmall.com'.
 *
 * Only administrators with content management permissions can create email
 * templates, ensuring consistent brand voice and compliance with communication
 * policies across the platform.
 *
 * @param props.connection
 * @param props.body Email template creation data including template
 *   identification, content bodies, variable definitions, and sender
 *   configuration
 * @path /shoppingMall/admin/emailTemplates
 * @accessor api.functional.shoppingMall.admin.emailTemplates.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Email template creation data including template identification,
     * content bodies, variable definitions, and sender configuration
     */
    body: IShoppingMallEmailTemplate.ICreate;
  };
  export type Body = IShoppingMallEmailTemplate.ICreate;
  export type Response = IShoppingMallEmailTemplate;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/emailTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/emailTemplates";
  export const random = (): IShoppingMallEmailTemplate =>
    typia.random<IShoppingMallEmailTemplate>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated list of email templates for platform
 * communications.
 *
 * Retrieve a comprehensive filtered and paginated list of email templates from
 * the shopping_mall_email_templates table. This operation provides advanced
 * search capabilities for administrators to find and manage email templates
 * based on multiple criteria including template category, channel association,
 * language code, active status, and content search.
 *
 * Email templates are critical platform components that define the structure
 * and content of all automated communications sent to customers, sellers, and
 * admins. Each template supports variable placeholders for dynamic content
 * personalization, multi-language support for international communications, and
 * channel-specific customization for different marketplace segments.
 *
 * The operation supports comprehensive filtering options to help administrators
 * locate specific templates efficiently. Filters include template category
 * (transactional emails like order confirmations, marketing emails like
 * promotional campaigns, authentication emails like password reset,
 * notification emails like shipping updates), channel assignment (platform-wide
 * templates or channel-specific variants), language code for localization, and
 * active status to show only enabled templates.
 *
 * Search functionality enables full-text search across template names,
 * subjects, and body content to locate templates containing specific keywords
 * or phrases. This is particularly valuable when administrators need to update
 * messaging across multiple related templates or audit template content for
 * compliance.
 *
 * Pagination support ensures efficient handling of large template libraries as
 * the platform grows to support multiple languages, channels, and communication
 * scenarios. The operation returns template summary information optimized for
 * list displays, with options to drill down into individual templates for
 * detailed editing.
 *
 * Security considerations include role-based access control ensuring only
 * administrators can search and view email templates, as templates may contain
 * sensitive business logic and communication strategies. Template content is
 * sanitized for display to prevent injection attacks.
 *
 * This operation integrates with the shopping_mall_channels table through the
 * optional shopping_mall_channel_id foreign key, enabling channel-specific
 * template filtering. Templates without channel association are platform-wide
 * defaults. The multi-language support through language_code enables localized
 * communications for international customers and sellers.
 *
 * Related operations that might be used together include retrieving individual
 * template details for editing, creating new templates for new communication
 * scenarios, updating template content for messaging improvements, and
 * activating/deactivating templates for A/B testing or seasonal campaigns.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for filtering
 *   email templates by category, channel, language, status, and content
 *   keywords
 * @path /shoppingMall/admin/emailTemplates
 * @accessor api.functional.shoppingMall.admin.emailTemplates.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for filtering email
     * templates by category, channel, language, status, and content
     * keywords
     */
    body: IShoppingMallEmailTemplate.IRequest;
  };
  export type Body = IShoppingMallEmailTemplate.IRequest;
  export type Response = IPageIShoppingMallEmailTemplate.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/emailTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/emailTemplates";
  export const random = (): IPageIShoppingMallEmailTemplate.ISummary =>
    typia.random<IPageIShoppingMallEmailTemplate.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve complete details of a specific email template by ID.
 *
 * Retrieve comprehensive information for a single email template identified by
 * its unique template ID from the shopping_mall_email_templates table. This
 * operation provides administrators with complete template details necessary
 * for viewing, editing, testing, and managing individual email communication
 * templates.
 *
 * Email templates define the structure and content of all automated platform
 * communications sent to customers, sellers, and administrators throughout
 * various business workflows. Each template contains carefully crafted
 * messaging with dynamic variable placeholders that are replaced with actual
 * data when emails are sent. Understanding the complete template structure is
 * essential for maintaining consistent, professional communication across the
 * platform.
 *
 * The operation returns exhaustive template information including the
 * template_code (unique identifier used by application logic to select
 * templates), template_name and description for administrative reference,
 * category classification (transactional, marketing, authentication,
 * notification), and language_code for localization support. Channel
 * association is included if the template is specific to a marketplace channel,
 * otherwise null indicates platform-wide usage.
 *
 * Critical template content includes both HTML and plain text versions of the
 * email body, enabling rich formatting for modern email clients while providing
 * accessible fallback for text-only readers. The subject line includes variable
 * placeholders for personalization such as order numbers, customer names, or
 * action-specific details. Administrators can review how these placeholders are
 * used throughout the template content.
 *
 * The variables_json field provides documentation of all available placeholders
 * for this template, describing each variable's purpose and expected data type.
 * This information is invaluable when customizing templates or troubleshooting
 * template rendering issues. Sender configuration (from_email, from_name,
 * reply_to_email) defines how the email appears to recipients and where replies
 * are directed.
 *
 * Template metadata includes activation status controlling whether the template
 * can be used for sending emails, version number tracking template evolution
 * over time, and creation/update timestamps for audit trail. The is_active flag
 * allows administrators to temporarily disable templates for testing or
 * revision without deleting template history.
 *
 * Security considerations include verifying the requesting user has
 * administrator role permissions, as email templates may contain sensitive
 * business logic and communication strategies. Template content is returned
 * without modification to enable accurate editing, but administrators must be
 * trusted users as template injection could affect platform communications.
 *
 * This operation integrates with the shopping_mall_channels relationship to
 * show channel-specific template variants versus platform-wide templates.
 * Understanding channel assignment helps administrators maintain template
 * consistency across marketplace segments while allowing necessary
 * customization.
 *
 * Related operations that might be used together include searching the template
 * library to locate templates by category or purpose, updating template content
 * to improve messaging or fix errors, creating new template versions for A/B
 * testing, and previewing template rendering with sample data before
 * deployment.
 *
 * @param props.connection
 * @param props.templateId Unique identifier of the target email template to
 *   retrieve
 * @path /shoppingMall/admin/emailTemplates/:templateId
 * @accessor api.functional.shoppingMall.admin.emailTemplates.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target email template to retrieve */
    templateId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallEmailTemplate;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/emailTemplates/:templateId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/emailTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): IShoppingMallEmailTemplate =>
    typia.random<IShoppingMallEmailTemplate>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing email template by ID.
 *
 * Updates an existing email template in the shopping mall platform's
 * communication system. This operation enables administrators to modify
 * template content, configuration, and settings to adapt to changing business
 * requirements, fix issues, or improve email effectiveness.
 *
 * Administrators can update any aspect of the email template including the
 * subject line, HTML body content, plain text body content, sender information,
 * active status, and template metadata. Each update increments the version
 * number, creating an audit trail of template changes over time.
 *
 * The template_code serves as the functional identifier used by the application
 * to select templates for specific email scenarios. While most template
 * properties can be updated, changing the template_code effectively changes
 * which emails will use this template. Care should be taken when modifying
 * template_code to ensure application logic references remain valid.
 *
 * HTML and plain text body content can be updated independently. When updating
 * email bodies, administrators should ensure both HTML and plain text versions
 * convey the same essential information for consistency across email clients.
 * The HTML body enables rich formatting and branding, while the plain text
 * version ensures accessibility and compatibility with text-only email
 * clients.
 *
 * Template variable placeholders (e.g., {{order_number}}, {{customer_name}})
 * can be added or removed from the body content. The variables_json field
 * should be updated accordingly to document available placeholders. This
 * documentation helps other administrators understand which dynamic values can
 * be used in the template.
 *
 * Sender configuration can be updated through from_email, from_name, and
 * reply_to_email fields. Changing these fields affects the sender identity
 * displayed to email recipients. For example, changing from
 * 'noreply@shoppingmall.com' to 'support@shoppingmall.com' makes the email
 * appear more personal and enables recipient replies.
 *
 * The is_active flag controls whether the template is available for sending
 * emails. Administrators can deactivate templates temporarily without deletion,
 * useful for testing new versions or temporarily disabling certain email
 * communications. Inactive templates are retained in the database but not
 * selectable for email sending operations.
 *
 * Multi-language templates can be updated independently for each language_code.
 * When updating a template for a specific language, only that language version
 * is affected. Other language versions of the same template_code remain
 * unchanged.
 *
 * Channel-specific templates (those with non-null shopping_mall_channel_id) can
 * be updated without affecting platform-wide templates or templates for other
 * channels. This enables channel-specific communication customization while
 * maintaining overall template structure.
 *
 * Template updates apply immediately to all future email sending operations
 * using this template. Emails that have already been sent are not affected by
 * template updates, ensuring historical email content remains consistent.
 *
 * The version field automatically increments with each update, providing
 * version history tracking. While this operation doesn't support rollback to
 * previous versions directly, the version history enables administrators to
 * track when changes occurred and potentially restore previous content manually
 * if needed.
 *
 * Only administrators with appropriate permissions can update email templates.
 * This restriction ensures communication consistency, maintains brand
 * standards, and prevents unauthorized modification of customer-facing content.
 * Template updates should be carefully reviewed before deployment as they
 * affect communications sent to all platform users.
 *
 * @param props.connection
 * @param props.templateId Unique identifier of the email template to update
 * @param props.body Email template update data containing fields to be modified
 * @path /shoppingMall/admin/emailTemplates/:templateId
 * @accessor api.functional.shoppingMall.admin.emailTemplates.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the email template to update */
    templateId: string & tags.Format<"uuid">;

    /** Email template update data containing fields to be modified */
    body: IShoppingMallEmailTemplate.IUpdate;
  };
  export type Body = IShoppingMallEmailTemplate.IUpdate;
  export type Response = IShoppingMallEmailTemplate;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/emailTemplates/:templateId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/emailTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): IShoppingMallEmailTemplate =>
    typia.random<IShoppingMallEmailTemplate>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an email template permanently from the system.
 *
 * This operation performs a permanent deletion of an email template identified
 * by the templateId path parameter. Email templates in the
 * shopping_mall_email_templates table are used throughout the platform for
 * sending transactional emails (order confirmations, shipping notifications,
 * password resets) and marketing communications.
 *
 * This endpoint is exclusively available to administrators who manage
 * platform-wide email communication templates. When a template is deleted, it
 * is permanently removed from the system - the schema does not include soft
 * deletion fields for email templates.
 *
 * The deletion is immediate and irreversible. Before deleting a template,
 * administrators should ensure that the template is not actively referenced by
 * scheduled email campaigns or set as default for critical system
 * notifications.
 *
 * The operation validates that the template exists before attempting deletion.
 * If the template ID does not correspond to an existing record, the system
 * returns a 404 Not Found error. The template is identified by its UUID primary
 * key passed as the templateId path parameter.
 *
 * Security considerations include verifying the requesting admin has
 * appropriate permissions to delete email templates. This operation is logged
 * in the audit trail for compliance and traceability of template management
 * actions.
 *
 * Related operations: To create new templates, use POST /emailTemplates. To
 * update existing templates, use PUT /emailTemplates/{templateId}. To retrieve
 * template details, use GET /emailTemplates/{templateId}.
 *
 * @param props.connection
 * @param props.templateId Unique identifier of the email template to delete
 * @path /shoppingMall/admin/emailTemplates/:templateId
 * @accessor api.functional.shoppingMall.admin.emailTemplates.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the email template to delete */
    templateId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/emailTemplates/:templateId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/emailTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
