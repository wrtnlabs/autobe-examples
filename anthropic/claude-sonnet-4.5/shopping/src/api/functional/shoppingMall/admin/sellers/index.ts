import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSeller } from "../../../../structures/IShoppingMallSeller";
import { IPageIShoppingMallSeller } from "../../../../structures/IPageIShoppingMallSeller";

/**
 * Search and retrieve a filtered, paginated list of seller accounts from the
 * shopping_mall_sellers table.
 *
 * Retrieve a comprehensive filtered and paginated list of seller accounts
 * registered on the e-commerce shopping mall platform. This operation provides
 * advanced search capabilities for finding sellers based on multiple criteria
 * including business name patterns, account status, verification status,
 * registration date ranges, and approval status.
 *
 * The operation supports comprehensive pagination with configurable page sizes
 * and sorting options. Results can be sorted by registration date, business
 * name, approval date, account status, or other relevant seller attributes in
 * ascending or descending order. This enables efficient management and
 * oversight of the seller ecosystem.
 *
 * Security considerations include restricting this operation to administrator
 * roles only, as it provides access to business information across all sellers
 * on the platform. Sellers should not be able to view other sellers' account
 * information to maintain competitive privacy. The response filters sensitive
 * information such as password hashes, tax IDs, and bank account details from
 * the summary view.
 *
 * This operation integrates with the shopping_mall_sellers table as defined in
 * the Prisma schema, incorporating all available seller fields and
 * relationships including approval status by admins, document verification
 * status, and account lifecycle timestamps. The response includes seller
 * summary information optimized for admin dashboard displays with key metrics
 * like total products, order count, and performance ratings where applicable.
 *
 * The operation is essential for admin dashboard functionality as specified in
 * the Admin Dashboard requirements document, enabling administrators to review
 * seller applications, monitor seller performance, manage account statuses, and
 * perform bulk operations on seller accounts. It supports the seller onboarding
 * workflow, performance monitoring, and marketplace quality control functions
 * critical to platform governance.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, pagination settings,
 *   and sorting options for seller account retrieval
 * @path /shoppingMall/admin/sellers
 * @accessor api.functional.shoppingMall.admin.sellers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, pagination settings, and
     * sorting options for seller account retrieval
     */
    body: IShoppingMallSeller.IRequest;
  };
  export type Body = IShoppingMallSeller.IRequest;
  export type Response = IPageIShoppingMallSeller.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/sellers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/sellers";
  export const random = (): IPageIShoppingMallSeller.ISummary =>
    typia.random<IPageIShoppingMallSeller.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific seller account from the
 * shopping_mall_sellers table.
 *
 * Retrieve complete detailed information for a specific seller account on the
 * e-commerce shopping mall platform. This operation provides comprehensive
 * visibility into a seller's business profile, verification status, account
 * configuration, and operational details.
 *
 * The operation returns extensive seller information including business
 * identity (business name, business type, contact person), authentication and
 * security details (email, email verification status, account status), business
 * verification data (business registration number, tax ID, document
 * verification status), financial settings (bank account information,
 * commission rate, payout preferences), store customization (store URL slug,
 * description, logo, banner), and operational policies (return policy, shipping
 * policy, free shipping threshold).
 *
 * Security and authorization considerations are critical for this operation.
 * Administrator roles have unrestricted access to view detailed information for
 * any seller account on the platform, enabling oversight, verification, and
 * support functions. Seller roles can only access their own account details,
 * enforced through ownership validation that compares the authenticated
 * seller's ID with the requested sellerId parameter. This prevents sellers from
 * viewing competitors' business information, maintaining marketplace privacy
 * and competitive fairness.
 *
 * The response includes denormalized performance metrics and related entity
 * counts where applicable, such as total active products, total orders
 * fulfilled, average ratings, and account approval information including which
 * admin approved the account and when. Sensitive information such as password
 * hashes and full bank account numbers are excluded from the response for
 * security, with only masked/partial information provided where needed for
 * reference.
 *
 * This operation integrates with the shopping_mall_sellers table and related
 * entities as defined in the Prisma schema, including relationships to
 * shopping_mall_admins (for approval tracking), shopping_mall_products (for
 * product count), shopping_mall_orders (for fulfillment metrics), and
 * shopping_mall_addresses (for business location). The operation supports the
 * seller profile management, admin seller oversight, and seller dashboard
 * initialization use cases specified in the Seller Management and Admin
 * Dashboard requirements documents.
 *
 * Performance expectations require the operation to retrieve and return seller
 * details within 1 second under normal load conditions, with efficient database
 * queries leveraging indexed fields such as seller ID, email, and account
 * status. The response structure should be comprehensive yet optimized for both
 * display and potential editing workflows.
 *
 * @param props.connection
 * @param props.sellerId Unique identifier of the target seller account to
 *   retrieve
 * @path /shoppingMall/admin/sellers/:sellerId
 * @accessor api.functional.shoppingMall.admin.sellers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target seller account to retrieve */
    sellerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSeller;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/sellers/:sellerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): IShoppingMallSeller =>
    typia.random<IShoppingMallSeller>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
