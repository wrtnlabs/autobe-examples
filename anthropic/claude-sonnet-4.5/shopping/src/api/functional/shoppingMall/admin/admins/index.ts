import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdmin } from "../../../../structures/IShoppingMallAdmin";
import { IPageIShoppingMallAdmin } from "../../../../structures/IPageIShoppingMallAdmin";
export * as sessions from "./sessions/index";

/**
 * Search and retrieve a filtered, paginated list of administrator accounts.
 *
 * Retrieves a comprehensive, filtered, and paginated list of all administrator
 * accounts on the platform. This operation is essential for super admins and
 * authorized administrators to search, discover, and manage admin users across
 * the entire system.
 *
 * Administrator accounts have privileged access to platform functions including
 * order management, product moderation, user management, dispute resolution,
 * and system configuration. This operation provides the necessary visibility
 * and search capabilities to effectively manage this critical user group.
 *
 * The operation supports extensive filtering capabilities to help
 * administrators find specific admin accounts or groups of admins based on
 * various criteria. Administrators can filter by role level (super_admin,
 * order_manager, content_moderator, support_admin) to view admins with specific
 * permission sets. Status filtering enables viewing active admins, inactive
 * accounts, or admins with unverified emails. Date range filtering helps
 * identify recently created admin accounts or accounts created during specific
 * periods for audit purposes.
 *
 * Text search functionality allows searching across admin names and email
 * addresses using partial matching, making it easy to locate specific
 * administrators even with incomplete information. For example, searching for
 * 'john' would return all admins with 'john' in their name or email address.
 *
 * The operation returns paginated results to handle potentially large admin
 * user bases efficiently. Each result includes comprehensive admin information:
 * unique identifier, email address, full name, assigned role level, account
 * status (active/inactive), email verification status, multi-factor
 * authentication enablement status, last login timestamp, account creation
 * date, and information about which admin created this account.
 *
 * Security considerations include role-based access control where only
 * authorized admins (typically super_admins) can access this operation. The
 * operation logs all admin account searches for security auditing. Sensitive
 * authentication data like password hashes, MFA secrets, and password reset
 * tokens are never included in the response to maintain security.
 *
 * Pagination parameters include page number, page size (typically 20-50 results
 * per page), and sorting options (by creation date, name, last login, or role
 * level). The response includes total count of matching admins, total pages,
 * current page number, and the array of admin records.
 *
 * This operation integrates with the user roles and authentication system
 * defined in the requirements, specifically supporting the admin account
 * management capabilities where super admins can oversee all admin users,
 * manage role assignments, and maintain proper access control across the
 * platform.
 *
 * The operation is critical for maintaining platform security, ensuring proper
 * segregation of duties among admin roles, monitoring admin activity patterns,
 * and conducting security audits when suspicious activity is detected.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for filtering
 *   administrator accounts
 * @path /shoppingMall/admin/admins
 * @accessor api.functional.shoppingMall.admin.admins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for filtering administrator
     * accounts
     */
    body: IShoppingMallAdmin.IRequest;
  };
  export type Body = IShoppingMallAdmin.IRequest;
  export type Response = IPageIShoppingMallAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/admins";
  export const random = (): IPageIShoppingMallAdmin.ISummary =>
    typia.random<IPageIShoppingMallAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific administrator account.
 *
 * This operation fetches complete administrator account information from the
 * shopping_mall_admins table for a specified admin ID. It is used by authorized
 * admins to view detailed profile information, account status, role
 * assignments, and security settings for platform administrators.
 *
 * The endpoint returns comprehensive admin data including email address, full
 * name, assigned role level (super_admin, order_manager, content_moderator, or
 * support_admin), account activity status, email verification status,
 * multi-factor authentication configuration, last login information, and
 * account timestamps. The response DTO (IShoppingMallAdmin) is specifically
 * designed to exclude sensitive authentication fields for security compliance.
 *
 * Security considerations include role-based access control ensuring only
 * authorized admins can view admin account details. The operation enforces
 * authentication requirements and validates that the requesting user has
 * appropriate admin permissions. Sensitive authentication fields are explicitly
 * excluded from the response DTO including: password_hash, mfa_secret,
 * password_history, password_reset_token, password_reset_expires_at,
 * email_verification_token, email_verification_sent_at, account_locked_until,
 * failed_login_attempts, and failed_login_window_start_at. These exclusions
 * prevent exposure of authentication secrets and security-sensitive data.
 *
 * The response includes safe account information useful for administration:
 * account identifiers, contact information, role assignments, account status
 * indicators, verification states, last login metadata (timestamp and IP), and
 * account lifecycle timestamps (created_at, updated_at). This data supports
 * administrative oversight without compromising account security.
 *
 * This operation is typically used in admin management interfaces where super
 * admins need to review other admin accounts, audit admin activities, verify
 * role assignments, check account security status, or investigate login and
 * authentication events. The data supports administrative oversight, security
 * monitoring, and account lifecycle management.
 *
 * Related operations include updating admin information (PUT
 * /admins/{adminId}), listing all admins for account management, and creating
 * new admin accounts through admin-initiated registration workflows. This
 * operation supports the admin account management capabilities defined in the
 * Admin Dashboard requirements document.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the target administrator account
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target administrator account */
    adminId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdmin;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IShoppingMallAdmin =>
    typia.random<IShoppingMallAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing administrator account's profile and settings.
 *
 * This operation modifies administrator account information in the
 * shopping_mall_admins table for a specified admin ID. It enables authorized
 * administrators (specifically those with super_admin role level) to update
 * admin profiles, change role assignments, modify account status, and manage
 * email verification states. Password management is explicitly excluded from
 * this operation and handled through dedicated password update endpoints.
 *
 * The endpoint accepts partial or complete update data for admin accounts
 * including email address changes, full name modifications, role level
 * reassignments (super_admin, order_manager, content_moderator, support_admin),
 * account status changes (activating or deactivating admins via is_active
 * field), email verification status updates (email_verified field), last login
 * information, and MFA configuration status (mfa_enabled field). The request
 * DTO (IShoppingMallAdmin.IUpdate) is specifically designed to exclude all
 * authentication-sensitive fields for security compliance.
 *
 * Password management is handled through separate dedicated endpoints with
 * proper security workflows. Password changes require validation of current
 * password, complexity checking (8+ characters with uppercase, lowercase,
 * number, special character), password history verification (cannot reuse last
 * 5 passwords), secure bcrypt/Argon2 hashing, and complete audit trail logging.
 * These workflows cannot be achieved through direct field updates and must use
 * dedicated password management endpoints (e.g., PUT
 * /admins/{adminId}/password).
 *
 * The request DTO explicitly excludes all authentication-sensitive fields to
 * prevent security bypasses: password_hash, mfa_secret, password_history,
 * password_reset_token, password_reset_expires_at, email_verification_token,
 * email_verification_sent_at, account_locked_until, failed_login_attempts,
 * failed_login_window_start_at, and password_changed_at. These fields are
 * managed through dedicated security workflows and administrative actions, not
 * direct profile updates.
 *
 * Security considerations include strict role-based access control. While the
 * endpoint requires admin authentication, business logic should additionally
 * verify the requesting admin has super_admin role level, as only super admins
 * should modify other admin accounts according to the platform's hierarchical
 * admin structure defined in the requirements. The operation validates that
 * role changes comply with business rules: super_admins cannot demote
 * themselves to prevent lockout, and at least one super_admin must remain
 * active on the platform. Email changes trigger re-verification workflows
 * requiring the admin to verify the new email address before it becomes
 * effective.
 *
 * Validation rules enforce data integrity including email uniqueness across
 * admins (email field has unique constraint in schema), valid role_level values
 * from the predefined set (super_admin, order_manager, content_moderator,
 * support_admin), boolean validation for is_active and email_verified fields,
 * and proper timestamp handling for datetime fields like last_login_at.
 *
 * The operation automatically updates the updated_at timestamp to track
 * modification time and maintains audit trails by logging all admin account
 * modifications through the order status history and admin activity logging
 * systems. Related business rules from the requirements include role hierarchy
 * enforcement (super_admin has all permissions, other roles have restricted
 * access), account status management (inactive admins cannot log in), and email
 * verification requirements for account activation.
 *
 * This operation is typically used in admin account management interfaces where
 * super admins need to update admin profiles, reassign roles when
 * responsibilities change, activate or deactivate admin access for
 * onboarding/offboarding, update contact information, toggle MFA requirements,
 * or correct account information. The operation supports the comprehensive
 * admin management capabilities defined in the Admin Dashboard requirements and
 * User Roles and Authentication requirements.
 *
 * Related operations include retrieving admin details (GET /admins/{adminId})
 * for viewing current information before updates, listing all admin accounts
 * for management overview, creating new admin accounts (super_admin privilege
 * only), dedicated password change endpoints for security-validated password
 * updates, and viewing admin activity audit logs for tracking account
 * modifications and security monitoring.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the administrator account to be
 *   updated
 * @param props.body Updated administrator account information excluding
 *   authentication fields - supports profile, role, and status updates only
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the administrator account to be updated */
    adminId: string & tags.Format<"uuid">;

    /**
     * Updated administrator account information excluding authentication
     * fields - supports profile, role, and status updates only
     */
    body: IShoppingMallAdmin.IUpdate;
  };
  export type Body = IShoppingMallAdmin.IUpdate;
  export type Response = IShoppingMallAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/admins/:adminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IShoppingMallAdmin =>
    typia.random<IShoppingMallAdmin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an admin user account from the platform.
 *
 * This operation permanently removes an administrator account from the shopping
 * mall platform. It performs a hard delete operation, completely removing the
 * admin record from the shopping_mall_admins table along with all associated
 * data through cascade deletion rules defined in the database schema.
 *
 * This is a highly privileged operation restricted exclusively to super
 * administrators with full platform access. The deletion is immediate and
 * cannot be reversed, making this a critical security operation requiring
 * careful verification before execution. Before deletion, the system validates
 * that the requesting admin has super_admin role level and that the target
 * admin account exists.
 *
 * When an admin account is deleted, the database automatically handles related
 * records through ON DELETE CASCADE foreign key constraints. This includes all
 * sessions associated with the admin (shopping_mall_sessions), address records
 * (shopping_mall_addresses), and any audit trail entries where the admin
 * appears as an actor (shopping_mall_order_status_history,
 * shopping_mall_cancellations, shopping_mall_refund_requests,
 * shopping_mall_refunds, shopping_mall_inventory_transactions). The
 * self-referential relationship through created_by_admin_id means that admins
 * created by the deleted admin will have their created_by_admin_id field set to
 * null, preserving those admin accounts while losing the creation reference.
 *
 * This operation is essential for administrative account lifecycle management,
 * allowing removal of compromised accounts, terminated administrators, or
 * accounts that are no longer needed. The deletion is logged in the platform's
 * audit trail with details including which super admin performed the deletion,
 * the timestamp, and the target admin's identifier for compliance and security
 * monitoring.
 *
 * Important security considerations include verifying the requesting admin's
 * identity through JWT token validation, ensuring the operation cannot be used
 * to delete one's own account (self-deletion prevention), and confirming that
 * at least one super admin remains active on the platform after deletion to
 * prevent complete administrative lockout.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin account to be permanently
 *   deleted
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the admin account to be permanently deleted */
    adminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
