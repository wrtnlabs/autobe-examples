import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallRefund } from "../../../structures/IShoppingMallRefund";
import { IPageIShoppingMallRefund } from "../../../structures/IPageIShoppingMallRefund";

/**
 * Retrieve filtered and paginated list of refund transactions with advanced
 * search capabilities.
 *
 * Retrieves a comprehensive, filtered, and paginated list of refund
 * transactions from the shopping_mall_refunds table. This operation provides
 * advanced search and filtering capabilities for customers to track their
 * refund history, sellers to manage refund processing for their orders, and
 * administrators to oversee all platform refund operations.
 *
 * The operation supports extensive filtering criteria including refund status
 * (pending, processing, completed, failed), date ranges for refund initiation
 * and completion, specific order references, customer identifiers, seller
 * identifiers, refund amount ranges, refund reasons (order_cancellation,
 * defective_product, customer_request, wrong_item, policy_violation), and actor
 * types (customer, seller, admin, system). These filters enable users to
 * quickly locate specific refunds or analyze refund patterns.
 *
 * Security considerations include role-based access control where customers can
 * only view their own refunds, sellers can view refunds related to their
 * products, and administrators have unrestricted access to all platform
 * refunds. The operation implements permission checks based on the
 * authenticated user's role and ownership relationships defined in the
 * shopping_mall_refunds table.
 *
 * The response includes detailed refund information such as refund amounts,
 * original payment transaction references, refund request associations,
 * processing status through payment gateway, actor information (who initiated
 * the refund), timestamps for key lifecycle events (processed_at, completed_at,
 * failed_at), failure reasons if applicable, and administrative notes. This
 * comprehensive data enables full refund lifecycle tracking and financial
 * reconciliation.
 *
 * Pagination parameters support efficient retrieval of large refund datasets,
 * with configurable page sizes and sorting options by refund date, refund
 * amount, completion date, or refund status. The operation integrates with the
 * shopping_mall_payment_transactions, shopping_mall_refund_requests,
 * shopping_mall_orders, shopping_mall_customers, shopping_mall_sellers, and
 * shopping_mall_admins tables to provide complete refund context.
 *
 * Related operations include POST /refunds for initiating new refund
 * transactions, GET /refunds/{refundId} for retrieving detailed information
 * about a specific refund, and PUT /refunds/{refundId} for updating refund
 * processing status or administrative notes.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, pagination settings,
 *   and sorting options for refund transaction retrieval
 * @path /shoppingMall/refunds
 * @accessor api.functional.shoppingMall.refunds.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, pagination settings, and
     * sorting options for refund transaction retrieval
     */
    body: IShoppingMallRefund.IRequest;
  };
  export type Body = IShoppingMallRefund.IRequest;
  export type Response = IPageIShoppingMallRefund;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/refunds",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/refunds";
  export const random = (): IPageIShoppingMallRefund =>
    typia.random<IPageIShoppingMallRefund>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific refund transaction.
 *
 * Retrieve comprehensive details for a specific refund transaction identified
 * by its unique refund ID. This operation provides complete refund information
 * including the original payment transaction reference, associated refund
 * request details (if refund was initiated through customer refund request
 * workflow), order information, refund amount processed, current processing
 * status, payment gateway transaction identifier, and the actor who initiated
 * the refund.
 *
 * The refund record contains critical financial data for reconciliation and
 * compliance. It tracks the complete refund lifecycle from initiation through
 * payment processing to completion or failure. The response includes timestamps
 * for each processing stage: when the refund was created, when payment
 * processing began, when it completed successfully, or when it failed with
 * detailed failure reasons.
 *
 * The initiated_by_type field indicates whether the refund was triggered by a
 * customer (through refund request), seller (through order cancellation), admin
 * (dispute resolution or override), or system (automatic processing). The
 * corresponding initiated_by_*_id foreign key provides the specific actor
 * reference.
 *
 * Security and authorization are role-based: customers can only retrieve
 * refunds for their own orders, sellers can retrieve refunds related to orders
 * for their products, and admins have unrestricted access to all platform
 * refunds for oversight and financial management. The system validates refund
 * ownership before returning data to prevent unauthorized access to financial
 * information.
 *
 * This operation is commonly used in customer service workflows for refund
 * status inquiries, financial reconciliation processes, dispute resolution
 * investigations, and audit trail reviews. The detailed refund information
 * enables transparent communication with customers about refund processing
 * timelines and provides sellers and admins with complete visibility into
 * refund operations.
 *
 * @param props.connection
 * @param props.refundId Unique identifier of the target refund transaction
 * @path /shoppingMall/refunds/:refundId
 * @accessor api.functional.shoppingMall.refunds.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target refund transaction */
    refundId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallRefund;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/refunds/:refundId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/refunds/${encodeURIComponent(props.refundId ?? "null")}`;
  export const random = (): IShoppingMallRefund =>
    typia.random<IShoppingMallRefund>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("refundId")(() => typia.assert(props.refundId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
