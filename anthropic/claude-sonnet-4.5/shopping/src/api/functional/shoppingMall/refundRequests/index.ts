import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallRefundRequest } from "../../../structures/IShoppingMallRefundRequest";
import { IPageIShoppingMallRefundRequest } from "../../../structures/IPageIShoppingMallRefundRequest";

/**
 * Search and retrieve filtered, paginated list of refund requests with advanced
 * filtering capabilities.
 *
 * Retrieve a comprehensive, paginated list of refund requests with advanced
 * filtering, searching, and sorting capabilities. This operation provides
 * role-based access to refund request data, returning different result sets
 * based on the authenticated user's role and permissions.
 *
 * For customers, this endpoint returns refund requests associated with their
 * own orders, enabling them to track the status of their refund requests from
 * submission through approval and completion. Customers can filter by refund
 * status (pending_review, pending_seller_response, approved, rejected,
 * processing, completed) and date ranges to find specific refund requests or
 * monitor active refunds.
 *
 * For sellers, this endpoint returns refund requests for orders containing
 * their products, allowing sellers to manage and respond to customer refund
 * requests efficiently. Sellers can filter by refund status to prioritize
 * pending requests requiring their response within the 3-business-day deadline.
 * The seller_response_deadline field enables sellers to identify urgent refund
 * requests approaching auto-approval.
 *
 * For admins, this endpoint provides unrestricted access to all platform refund
 * requests across all customers and sellers, supporting platform-wide refund
 * management, dispute resolution, and quality monitoring. Admins can filter by
 * customer, seller, order, refund status, date ranges, and refund amounts to
 * identify patterns, resolve disputes, or investigate high-value refund
 * requests requiring admin approval.
 *
 * The operation supports comprehensive filtering by refund_status
 * (pending_review, approved, rejected, etc.), date ranges for requested_at and
 * reviewed_at timestamps, customer and seller identifiers, order identifiers,
 * refund amount ranges, return requirements, and refund reasons. Multiple
 * filters can be combined to create precise queries for specific refund request
 * subsets.
 *
 * Sorting options include requested_at (newest or oldest first), refund_amount
 * (highest or lowest first), refund_status, and seller_response_deadline (to
 * prioritize urgent requests). The default sort order is requested_at
 * descending (newest requests first) to surface recent refund submissions.
 *
 * Pagination is implemented using limit and offset parameters, returning result
 * sets with total count for building pagination controls. The response includes
 * complete refund request details with denormalized order information, customer
 * and seller references, refund amounts (requested and approved), status
 * tracking, and timeline information (requested_at, reviewed_at,
 * completed_at).
 *
 * Security and authorization are enforced at the business logic layer,
 * automatically filtering results based on the authenticated user's role.
 * Customers see only their own refund requests, sellers see refund requests for
 * their products, and admins see all requests. The endpoint validates filter
 * parameters and returns appropriate error responses for invalid filter
 * combinations or missing required parameters.
 *
 * This operation is essential for the refund workflow management described in
 * the business requirements, supporting the 3-business-day seller response
 * deadline, auto-approval mechanism, admin escalation process, and refund
 * lifecycle tracking from request through completion. It integrates with the
 * shopping_mall_orders, shopping_mall_customers, shopping_mall_sellers, and
 * shopping_mall_admins tables through the Prisma schema relationships.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, sorting options, and
 *   pagination settings for refund request retrieval
 * @path /shoppingMall/refundRequests
 * @accessor api.functional.shoppingMall.refundRequests.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, sorting options, and
     * pagination settings for refund request retrieval
     */
    body: IShoppingMallRefundRequest.IRequest;
  };
  export type Body = IShoppingMallRefundRequest.IRequest;
  export type Response = IPageIShoppingMallRefundRequest;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/refundRequests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/refundRequests";
  export const random = (): IPageIShoppingMallRefundRequest =>
    typia.random<IPageIShoppingMallRefundRequest>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
