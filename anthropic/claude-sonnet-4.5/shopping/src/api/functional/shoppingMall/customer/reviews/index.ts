import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReview } from "../../../../structures/IShoppingMallReview";
import { IShoppingMallReviewHelpfulnessVote } from "../../../../structures/IShoppingMallReviewHelpfulnessVote";
export * as images from "./images/index";

/**
 * Submit a new product review with rating and optional feedback from verified
 * purchaser.
 *
 * Create a new product review for a purchased product, allowing verified
 * customers to share their experience and provide feedback. This operation
 * inserts a new record into the shopping_mall_reviews table with comprehensive
 * validation of customer eligibility, purchase verification, and content
 * quality requirements.
 *
 * The review submission process enforces critical business rules defined in the
 * requirements: only customers who have received the product in a completed
 * order (status='delivered') are eligible to review, ensuring authentic
 * feedback from verified purchasers. The system validates that the customer has
 * not already reviewed the same product by checking for existing reviews from
 * the same customer_id and product_id combination, as each customer can submit
 * only one review per product.
 *
 * The mandatory star rating must be an integer from 1 to 5, where 1=Terrible,
 * 2=Poor, 3=Average, 4=Very Good, 5=Excellent. The review text is optional,
 * allowing customers to submit rating-only reviews for quick feedback. When
 * text is provided, it must meet minimum quality standards: at least 10
 * characters for meaningful content, maximum 5000 characters, no profanity or
 * offensive language, no personal contact information or external URLs. The
 * optional review title provides a short summary limited to 100 characters.
 *
 * Customers can optionally upload up to 5 product images (JPEG, PNG, WebP
 * formats, 5MB maximum per image, minimum 400x400 pixels resolution) to provide
 * visual evidence and context. These images are particularly valuable for
 * reviews of defective or damaged products and enhance review helpfulness for
 * other customers.
 *
 * All submitted reviews enter a moderation workflow with initial
 * status='pending_moderation'. The system automatically flags reviews for
 * manual moderation if they contain potentially offensive language, very
 * negative ratings (1-2 stars), competitor mentions, or contact information
 * patterns. Reviews without moderation flags may be auto-approved for customers
 * with good review history. The moderation workflow ensures review quality and
 * policy compliance before publication.
 *
 * The operation automatically sets verified_purchase=true since only verified
 * purchasers can access this endpoint, and the verified purchase badge is
 * displayed with all reviews to build trust. The review is associated with the
 * specific order that enabled the review for audit trail and eligibility
 * validation.
 *
 * Upon successful submission, the system sends confirmation notification to the
 * customer, notifies the seller of the new review, and returns the created
 * review details including the assigned review ID and moderation status.
 *
 * Related operations that customers may use in conjunction include retrieving
 * product reviews to read others' feedback before writing their own, editing
 * submitted reviews within the 30-day window, and voting on other reviews'
 * helpfulness. Sellers can respond to published reviews through dedicated
 * seller response endpoints.
 *
 * @param props.connection
 * @param props.body Product review submission data including mandatory star
 *   rating, optional review text and title, product and order references, and
 *   optional customer-uploaded images
 * @path /shoppingMall/customer/reviews
 * @accessor api.functional.shoppingMall.customer.reviews.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Product review submission data including mandatory star rating,
     * optional review text and title, product and order references, and
     * optional customer-uploaded images
     */
    body: IShoppingMallReview.ICreate;
  };
  export type Body = IShoppingMallReview.ICreate;
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/reviews";
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing product review within 30-day edit window.
 *
 * Enables customers to modify their previously submitted product reviews
 * including star rating, title, review text, and uploaded images. This
 * operation is restricted to the original review author and must be performed
 * within 30 days of the original submission date as per platform business
 * rules.
 *
 * The review update process validates several critical conditions before
 * allowing modifications. First, the system verifies that the authenticated
 * customer is the original author of the review by comparing the customer ID
 * from the JWT token with the shopping_mall_customer_id in the review record.
 * Second, the system checks that the current date is within 30 days of the
 * review's created_at timestamp. Reviews older than 30 days are locked and
 * cannot be edited, requiring customers to contact support for exceptional
 * cases.
 *
 * When a customer updates a review, all modified content is re-submitted to the
 * moderation workflow. The review status transitions to 'pending_moderation'
 * and requires admin approval before the updated content becomes visible to
 * other customers. This ensures that edited reviews maintain the same quality
 * standards as new submissions. The system validates the updated content
 * against the same rules as new reviews: minimum 10 characters for review text,
 * maximum 5000 characters, no prohibited content (profanity, personal
 * information, external URLs), and proper image formats for uploaded photos.
 *
 * The updated_at timestamp is automatically set to the current time, and the
 * review receives an 'edited' badge that displays the last modification date to
 * other customers. This transparency helps maintain trust in the review
 * ecosystem. The edit history is preserved in audit logs accessible only to
 * administrators for moderation and dispute resolution purposes.
 *
 * Upon successful update, the system recalculates aggregate product ratings if
 * the star rating was modified, updates the review's helpful_count if
 * necessary, and sends a notification to the seller of the reviewed product.
 * The customer receives confirmation that their updated review is pending
 * moderation and will be published after admin approval.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review to update
 * @param props.body Updated review content including star rating, title, review
 *   text, and optional image modifications
 * @path /shoppingMall/customer/reviews/:reviewId
 * @accessor api.functional.shoppingMall.customer.reviews.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the review to update */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Updated review content including star rating, title, review text, and
     * optional image modifications
     */
    body: IShoppingMallReview.IUpdate;
  };
  export type Body = IShoppingMallReview.IUpdate;
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/reviews/:reviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a customer's product review with immediate effect.
 *
 * Enables customers to remove their previously submitted product reviews from
 * public visibility. This operation performs a soft deletion, setting the
 * deleted_at timestamp in the shopping_mall_reviews table while preserving the
 * review data for audit trails and historical compliance.
 *
 * The deletion process first validates that the authenticated customer owns the
 * review being deleted. The system compares the customer ID from the JWT
 * authentication token with the shopping_mall_customer_id field in the review
 * record. If the review belongs to a different customer, the operation returns
 * a 403 Forbidden error, preventing unauthorized deletion attempts.
 *
 * Upon successful validation, the system performs several critical operations
 * atomically. First, the deleted_at timestamp is set to the current date and
 * time, marking the review as deleted. Second, the product's aggregate rating
 * statistics are immediately recalculated, removing this review's star rating
 * from the average rating calculation and decrementing the total review count
 * displayed on the product page. This ensures that product ratings accurately
 * reflect only active, visible reviews.
 *
 * The system also handles related data cleanup. Any helpfulness votes on this
 * review (from the shopping_mall_review_helpfulness_votes table) are retained
 * for audit purposes but excluded from public helpful count displays. If a
 * seller had posted a response to this review (shopping_mall_seller_responses),
 * the response is also soft-deleted in cascade to maintain data consistency.
 *
 * A notification is sent to the seller of the reviewed product, informing them
 * that a review has been removed. This helps sellers track changes to their
 * product feedback. The customer receives confirmation that their review has
 * been successfully deleted.
 *
 * The soft deletion approach maintains referential integrity with the
 * shopping_mall_orders table, preserving the historical link between the order
 * that enabled the verified purchase review and the now-deleted review record.
 * This is essential for audit trails and compliance with data retention
 * policies while respecting customer privacy and control over their contributed
 * content.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review to delete
 * @path /shoppingMall/customer/reviews/:reviewId
 * @accessor api.functional.shoppingMall.customer.reviews.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the review to delete */
    reviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Cast or update helpfulness vote on a product review.
 *
 * Records a customer's vote indicating whether a product review was helpful or
 * not helpful, operating on the shopping_mall_review_helpfulness_votes table in
 * the Reviews namespace. This voting mechanism helps surface the most useful
 * reviews by allowing the community to collectively identify which reviews
 * provide the most value to future shoppers.
 *
 * The endpoint supports the core review helpfulness voting system where any
 * authenticated customer can vote on any published review, regardless of
 * whether they have purchased the product themselves. This inclusive voting
 * policy enables a broader community to participate in identifying
 * high-quality, informative reviews. Each customer can cast exactly one vote
 * per review, implemented through a unique constraint on the combination of
 * review ID and customer ID.
 *
 * When a customer votes on a review they have previously voted on, the system
 * updates the existing vote record rather than creating a duplicate. This
 * allows customers to change their minds and update their vote from 'helpful'
 * to 'not helpful' or vice versa. The updated_at timestamp tracks when votes
 * were changed, providing audit capability for vote manipulation detection.
 *
 * The operation enforces a critical business rule: reviewers cannot vote on
 * their own reviews. This prevents self-promotion and maintains voting
 * integrity. The system validates that the authenticated customer ID does not
 * match the review author's customer ID before accepting the vote.
 *
 * Helpful vote counts are aggregated and displayed publicly on each review,
 * contributing to the 'Most Helpful' sorting algorithm which ranks reviews by
 * net helpful votes (helpful votes minus not-helpful votes). Reviews with
 * higher helpful counts appear first when customers sort by 'Most Helpful',
 * directly influencing which feedback is most prominently featured.
 *
 * Not-helpful votes are recorded in the database but are not publicly displayed
 * to customers to avoid creating negative sentiment around reviews. These votes
 * still contribute to the internal helpfulness score calculation and can inform
 * admins about potentially problematic reviews that receive high not-helpful
 * vote counts.
 *
 * The voting system integrates with review moderation workflows - reviews that
 * receive unusually high not-helpful vote counts may be flagged for admin
 * review to verify they meet content quality standards. The system also
 * monitors for suspicious voting patterns such as coordinated voting from new
 * accounts, which could indicate vote manipulation attempts.
 *
 * Related operations include review retrieval endpoints that display helpful
 * vote counts and implement 'Most Helpful' sorting, and review moderation
 * endpoints that use voting patterns as quality signals.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the product review being voted on
 *   for helpfulness
 * @param props.body Vote information indicating whether the customer found the
 *   review helpful or not helpful
 * @path /shoppingMall/customer/reviews/:reviewId/vote
 * @accessor api.functional.shoppingMall.customer.reviews.vote
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function vote(
  connection: IConnection,
  props: vote.Props,
): Promise<vote.Response> {
  return true === connection.simulate
    ? vote.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...vote.METADATA,
          path: vote.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace vote {
  export type Props = {
    /**
     * Unique identifier of the product review being voted on for
     * helpfulness
     */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Vote information indicating whether the customer found the review
     * helpful or not helpful
     */
    body: IShoppingMallReview.IVote;
  };
  export type Body = IShoppingMallReview.IVote;
  export type Response = IShoppingMallReviewHelpfulnessVote;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/reviews/:reviewId/vote",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/reviews/${encodeURIComponent(props.reviewId ?? "null")}/vote`;
  export const random = (): IShoppingMallReviewHelpfulnessVote =>
    typia.random<IShoppingMallReviewHelpfulnessVote>();
  export const simulate = (
    connection: IConnection,
    props: vote.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: vote.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
