import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCart } from "../../../../structures/IShoppingMallCart";
export * as items from "./items/index";

/**
 * Retrieve complete shopping cart details for a specific cart by ID.
 *
 * Retrieve comprehensive details of a specific shopping cart identified by its
 * unique cart ID from the shopping_mall_carts table. This operation returns
 * complete cart information including all associated cart items from
 * shopping_mall_cart_items, with full product and SKU details, current pricing,
 * inventory availability, and calculated totals.
 *
 * The operation enforces ownership-based access control by validating that the
 * authenticated customer owns the requested cart. Customers can only access
 * their own carts, preventing unauthorized access to other users' shopping cart
 * data. The cart ID must match a cart belonging to the authenticated customer's
 * account.
 *
 * This endpoint provides real-time cart data essential for cart page display,
 * checkout initiation, and cart synchronization across devices. The response
 * includes current SKU pricing and availability status, enabling the frontend
 * to display accurate information and handle scenarios where prices have
 * changed or items have become unavailable since being added to the cart.
 *
 * The cart details include grouping of items by seller to support multi-seller
 * order visualization, showing which products will be fulfilled by which
 * sellers. This grouping is critical for displaying shipping costs per seller
 * and preparing customers for potential multiple shipments from a single
 * checkout.
 *
 * Integration with the product catalog ensures that returned cart items include
 * up-to-date product names, images, and SKU variant details even if the
 * underlying product information has been updated since items were added to the
 * cart. Deleted or discontinued products are flagged appropriately, allowing
 * the frontend to prompt customers to remove unavailable items.
 *
 * The operation calculates cart subtotals, estimated taxes (if delivery address
 * is available), and potential shipping costs (if shipping methods are
 * pre-selected), providing customers with a comprehensive view of their pending
 * purchase total. Price change notifications are included when SKU prices have
 * changed since items were added.
 *
 * This is a read-only operation that does not modify cart state, inventory
 * reservations, or user data. It serves as the primary cart detail retrieval
 * endpoint for customer cart management workflows.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the shopping cart to retrieve
 * @path /shoppingMall/customer/carts/:cartId
 * @accessor api.functional.shoppingMall.customer.carts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the shopping cart to retrieve */
    cartId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCart;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): IShoppingMallCart =>
    typia.random<IShoppingMallCart>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Clear all items from the shopping cart and mark cart as deleted.
 *
 * This operation clears the entire shopping cart by removing all cart items and
 * marking the cart record as deleted. It provides a convenient way for
 * customers to start fresh with an empty cart without manually removing each
 * item individually.
 *
 * The operation first validates that the shopping cart identified by cartId
 * belongs to the authenticated customer. This ownership validation is critical
 * for security, preventing customers from clearing other customers' carts. If
 * the cart does not belong to the authenticated customer or does not exist, the
 * operation returns an appropriate error response.
 *
 * When the validation passes, the operation performs multiple coordinated
 * actions. First, it retrieves all cart items associated with the cart from the
 * shopping_mall_cart_items table. For each cart item, the system calculates the
 * total reserved quantity (item quantity) and releases the inventory
 * reservation by updating the corresponding SKU record in the
 * shopping_mall_skus table. The reserved_quantity is decreased and the
 * available_quantity is increased for each SKU that was in the cart.
 *
 * Each inventory release operation is recorded in the
 * shopping_mall_inventory_transactions table with transaction_type set to
 * 'reservation_release', transaction_status set to 'completed', and
 * quantity_change reflecting the returned quantity. This maintains a complete
 * audit trail of all inventory movements as required by the business rules.
 *
 * After releasing all inventory reservations, the operation permanently deletes
 * all shopping_mall_cart_items records associated with the cart. Then, it
 * performs a soft deletion on the shopping_mall_carts record by setting the
 * deleted_at timestamp to the current time. Soft deletion preserves the cart
 * record for analytics and audit purposes while marking it as inactive.
 * According to the Prisma schema, the unique constraint on shopping_mall_carts
 * includes the deleted_at column, allowing customers to create new carts after
 * clearing previous ones.
 *
 * This operation is typically used when customers want to completely clear
 * their cart to start over, when they decide not to proceed with their current
 * selections, or when they want to begin a new shopping session. It provides a
 * clean slate without requiring individual item removal operations.
 *
 * The operation returns a success response with no content upon successful
 * completion. All inventory updates, transaction logging, and cart deletion are
 * performed atomically to maintain data consistency. If any part of the
 * operation fails, the entire operation is rolled back to prevent partial cart
 * clearing or inventory inconsistencies.
 *
 * This operation integrates with the shopping cart business rules defined in
 * the requirements analysis, specifically the cart persistence rules and
 * inventory reservation management. It ensures that clearing a cart properly
 * releases all inventory back to the available pool, maintaining accurate stock
 * levels for other customers.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the shopping cart to be cleared and
 *   deleted
 * @path /shoppingMall/customer/carts/:cartId
 * @accessor api.functional.shoppingMall.customer.carts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the shopping cart to be cleared and deleted */
    cartId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
