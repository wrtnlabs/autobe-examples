import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallWishlistItem } from "../../../../../structures/IShoppingMallWishlistItem";
import { IPageIShoppingMallWishlistItem } from "../../../../../structures/IPageIShoppingMallWishlistItem";

/**
 * Add a product SKU to customer's wishlist for future purchase consideration.
 *
 * Add a new product SKU to the specified customer wishlist. This operation
 * enables customers to save products of interest for future purchase by
 * creating a wishlist item entry in the shopping_mall_wishlist_items table.
 *
 * The operation validates several conditions before adding the item. First, it
 * verifies that the specified wishlist exists in the shopping_mall_wishlists
 * table and belongs to the authenticated customer making the request. Second,
 * it validates that the provided SKU identifier exists in the
 * shopping_mall_skus table and corresponds to an active product variant. Third,
 * it checks that the same SKU is not already present in this wishlist to
 * prevent duplicate entries.
 *
 * When the SKU is successfully added to the wishlist, the system creates a new
 * record in shopping_mall_wishlist_items with references to both the wishlist
 * and the SKU. The created_at and updated_at timestamps are set to the current
 * time. The operation returns the complete wishlist item information including
 * product details, SKU variant attributes, current pricing, and stock
 * availability status.
 *
 * Security considerations include verifying that the customer has permission to
 * modify the specified wishlist through ownership validation. The operation
 * enforces the business rule that wishlists can contain unlimited items without
 * quantity limits, differentiating it from shopping cart constraints. Products
 * can be added to wishlists regardless of stock availability, enabling
 * customers to save out-of-stock items for future notification when inventory
 * is replenished.
 *
 * This operation integrates with the product catalog system to retrieve current
 * product information and pricing at the time of display, ensuring customers
 * see up-to-date details when viewing their wishlist items.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the target customer wishlist
 * @param props.body SKU identifier and optional metadata for the wishlist item
 *   to be added
 * @path /shoppingMall/customer/wishlists/:wishlistId/items
 * @accessor api.functional.shoppingMall.customer.wishlists.items.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target customer wishlist */
    wishlistId: string & tags.Format<"uuid">;

    /**
     * SKU identifier and optional metadata for the wishlist item to be
     * added
     */
    body: IShoppingMallWishlistItem.ICreate;
  };
  export type Body = IShoppingMallWishlistItem.ICreate;
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/wishlists/:wishlistId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/items`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered wishlist items with pagination and current
 * product data.
 *
 * This operation provides comprehensive search and filtering capabilities for
 * items within a specific customer wishlist. The wishlist is identified by the
 * wishlistId path parameter, and the operation returns detailed information
 * about saved products including real-time pricing, stock availability, and
 * variant attributes.
 *
 * The operation validates that the requesting customer owns the specified
 * wishlist before returning any data. Attempts to access another customer's
 * wishlist items will result in authorization errors, ensuring privacy of
 * wishlist data.
 *
 * Unlike simple wishlist retrieval, this operation supports advanced filtering
 * through the request body, enabling customers to find specific items within
 * large wishlists. Supported filtering criteria include product availability
 * (in stock, out of stock), price ranges, categories, date added ranges, and
 * SKU variant attributes like color or size.
 *
 * Each wishlist item in the response includes up-to-date product information
 * fetched from the shopping_mall_products and shopping_mall_skus tables. This
 * ensures customers see current prices even if they have changed since the item
 * was added to the wishlist. Stock availability is also validated in real-time,
 * allowing customers to identify which saved items are currently available for
 * purchase.
 *
 * The operation joins wishlist items with their associated SKU, product, and
 * product image data to provide complete display information. This includes
 * product names, variant details (color, size, options from
 * shopping_mall_sku_colors, shopping_mall_sku_sizes,
 * shopping_mall_sku_options), primary product images, current pricing, and
 * inventory status.
 *
 * Results are paginated to handle wishlists containing hundreds of items
 * efficiently. The response includes pagination metadata (current page, total
 * pages, total items) along with the filtered item data. Default page size is
 * 20 items, with support for customizable page sizes through the request
 * parameters.
 *
 * This operation is frequently used when customers view their wishlist page,
 * filter saved items by availability before purchasing, or search for specific
 * products they saved previously. The real-time data updates help customers
 * make informed decisions about which wishlist items to move to cart for
 * purchase.
 *
 * Related operations include moving wishlist items to cart (requires separate
 * operation), removing individual wishlist items (DELETE on specific item), and
 * adding products to wishlist (POST operation). Customers typically use this
 * operation before deciding which items to purchase or remove from their
 * wishlist.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist containing the
 *   items to retrieve
 * @param props.body Search criteria, filtering parameters, and pagination
 *   settings for wishlist items including availability filters, price ranges,
 *   and sort preferences
 * @path /shoppingMall/customer/wishlists/:wishlistId/items
 * @accessor api.functional.shoppingMall.customer.wishlists.items.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the wishlist containing the items to retrieve */
    wishlistId: string & tags.Format<"uuid">;

    /**
     * Search criteria, filtering parameters, and pagination settings for
     * wishlist items including availability filters, price ranges, and sort
     * preferences
     */
    body: IShoppingMallWishlistItem.IRequest;
  };
  export type Body = IShoppingMallWishlistItem.IRequest;
  export type Response = IPageIShoppingMallWishlistItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/wishlists/:wishlistId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallWishlistItem =>
    typia.random<IPageIShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a specific product item from customer's wishlist.
 *
 * Remove the specified item from the customer's wishlist by permanently
 * deleting the record from the shopping_mall_wishlist_items table. This
 * operation enables customers to manage their saved products by removing items
 * they no longer wish to track.
 *
 * The operation performs several validation checks before deletion. First, it
 * verifies that the specified wishlist exists in the shopping_mall_wishlists
 * table and belongs to the authenticated customer making the request through
 * ownership validation. Second, it confirms that the wishlist item with the
 * given itemId exists in the shopping_mall_wishlist_items table and is
 * associated with the correct wishlist through the shopping_mall_wishlist_id
 * foreign key.
 *
 * This is a hard delete operation that permanently removes the wishlist item
 * record from the database. The shopping_mall_wishlist_items table does not
 * have a deleted_at soft delete column, so the record is completely removed.
 * Once deleted, the item cannot be recovered and the customer would need to add
 * the product to their wishlist again if desired.
 *
 * Security considerations include verifying the customer has permission to
 * modify the specified wishlist through ownership validation, preventing
 * customers from deleting items from other customers' wishlists. The operation
 * enforces authorization by checking that the wishlist referenced by the item
 * belongs to the authenticated customer.
 *
 * After successful deletion, the operation returns a success confirmation. No
 * response body is needed since the resource has been removed. The deletion
 * immediately affects the wishlist item count and list display for the customer
 * across all devices through real-time synchronization.
 *
 * This operation integrates with the wishlist management system and maintains
 * referential integrity by removing the item relationship between the wishlist
 * and the SKU. The parent shopping_mall_wishlists record and the referenced
 * shopping_mall_skus record remain intact, as only the linking wishlist_items
 * record is deleted.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the customer wishlist containing
 *   the item
 * @param props.itemId Unique identifier of the specific wishlist item to be
 *   removed
 * @path /shoppingMall/customer/wishlists/:wishlistId/items/:itemId
 * @accessor api.functional.shoppingMall.customer.wishlists.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer wishlist containing the item */
    wishlistId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific wishlist item to be removed */
    itemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/wishlists/:wishlistId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
