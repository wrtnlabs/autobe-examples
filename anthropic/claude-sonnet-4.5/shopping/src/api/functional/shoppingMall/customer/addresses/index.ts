import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAddress } from "../../../../structures/IShoppingMallAddress";
import { IPageIShoppingMallAddress } from "../../../../structures/IPageIShoppingMallAddress";

/**
 * Create a new delivery address for the authenticated customer.
 *
 * Creates a new delivery address record in the shopping_mall_addresses table
 * for the authenticated customer. This operation supports address management
 * capabilities required during checkout and order fulfillment. The system
 * validates all required address fields including recipient name, phone number,
 * complete street address (address_line1), city, state/province, postal code,
 * country, and country code.
 *
 * Address validation includes checking postal code format matches the country,
 * validating phone number format, and ensuring all required fields are
 * populated. The operation automatically sets user_type to 'customer' and
 * associates the address with shopping_mall_customer_id of the authenticated
 * customer.
 *
 * If this is the customer's first address, the system automatically sets
 * is_default to true. If the customer already has addresses and the request
 * specifies is_default as true, the system updates the previous default address
 * to remove its default status. Customers can optionally provide a label for
 * the address (such as 'Home', 'Office') which must be unique per customer.
 *
 * The address is initially marked as unverified (is_verified=false) and can be
 * verified through an address validation service integration after creation.
 * This operation is essential for the checkout flow as customers must have at
 * least one delivery address to complete order placement.
 *
 * @param props.connection
 * @param props.body Complete address information including recipient details,
 *   street address components, city, state, postal code, country, and optional
 *   settings like default designation and label
 * @path /shoppingMall/customer/addresses
 * @accessor api.functional.shoppingMall.customer.addresses.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Complete address information including recipient details, street
     * address components, city, state, postal code, country, and optional
     * settings like default designation and label
     */
    body: IShoppingMallAddress.ICreate;
  };
  export type Body = IShoppingMallAddress.ICreate;
  export type Response = IShoppingMallAddress;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/addresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/addresses";
  export const random = (): IShoppingMallAddress =>
    typia.random<IShoppingMallAddress>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of delivery addresses.
 *
 * Retrieve a comprehensive list of delivery addresses with advanced filtering,
 * searching, sorting, and pagination capabilities. This operation provides full
 * address search functionality for authenticated users to manage their saved
 * delivery addresses efficiently.
 *
 * This endpoint operates on the shopping_mall_addresses table which stores
 * delivery addresses for customers, sellers, and admins using a polymorphic
 * user ownership pattern. Each address contains complete delivery information
 * including recipient details, phone number, multi-line street address, city,
 * state/province, postal code, country data, verification status, default
 * designation, and optional user-defined labels.
 *
 * Security and authorization are enforced based on the authenticated user's
 * role. Customers can only retrieve their own addresses by filtering on their
 * customer_id. Sellers can only retrieve their own addresses by filtering on
 * their seller_id. Admins have platform-wide access and can retrieve addresses
 * for any user across all user types, enabling administrative address
 * management and customer support functions.
 *
 * The operation supports comprehensive filtering capabilities including user
 * type discrimination (customer, seller, admin), country-based filtering,
 * verification status (is_verified), default address filtering (is_default),
 * postal code searches, city and state filtering, and soft deletion status
 * (deleted_at). This enables users to find specific addresses quickly and
 * admins to perform advanced address data analysis.
 *
 * Pagination is implemented to handle users with multiple saved addresses
 * efficiently. The response includes total count, current page number, page
 * size, and the array of address records matching the filter criteria. Sorting
 * options include chronological ordering (created_at, updated_at), alphabetical
 * ordering by recipient name or city, and custom ordering by verification
 * status or default designation.
 *
 * Address data returned includes all fields from the Prisma schema:
 * recipient_name, phone_number, address_line1, address_line2 (optional), city,
 * state_province, postal_code, country, country_code, is_default, label
 * (optional), is_verified, verified_at timestamp, and soft deletion timestamp
 * deleted_at. The user_type discriminator field indicates ownership type
 * (customer, seller, admin) and the corresponding user foreign key
 * (shopping_mall_customer_id, shopping_mall_seller_id, or
 * shopping_mall_admin_id) identifies the owner.
 *
 * This operation integrates with the order placement and checkout processes
 * where customers select delivery addresses. Addresses are preserved as
 * snapshots in completed orders even when the user later updates or deletes the
 * address record, maintaining historical accuracy for order fulfillment and
 * customer service.
 *
 * Related operations include retrieving individual address details (GET
 * /addresses/{addressId}), creating new addresses (POST /addresses), updating
 * existing addresses (PUT /addresses/{addressId}), and deleting addresses
 * (DELETE /addresses/{addressId}).
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, sorting options, and
 *   pagination controls for address retrieval
 * @path /shoppingMall/customer/addresses
 * @accessor api.functional.shoppingMall.customer.addresses.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, sorting options, and
     * pagination controls for address retrieval
     */
    body: IShoppingMallAddress.IRequest;
  };
  export type Body = IShoppingMallAddress.IRequest;
  export type Response = IPageIShoppingMallAddress;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/addresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/addresses";
  export const random = (): IPageIShoppingMallAddress =>
    typia.random<IPageIShoppingMallAddress>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific delivery address by ID.
 *
 * Retrieve complete details for a specific delivery address identified by the
 * addressId path parameter. This operation returns comprehensive address
 * information including recipient details, complete street address components,
 * verification status, default address designation, and user ownership data.
 *
 * This endpoint operates on the shopping_mall_addresses table which implements
 * polymorphic user ownership supporting customers, sellers, and admins. Each
 * address record contains recipient_name, phone_number, address_line1,
 * address_line2 (optional apartment/suite information), city, state_province,
 * postal_code, country, country_code (ISO 3166-1 alpha-2), is_default flag,
 * optional user-defined label, verification status (is_verified), verification
 * timestamp (verified_at), and soft deletion status (deleted_at).
 *
 * Strict authorization and ownership verification are enforced to protect
 * address privacy. Customers can only retrieve addresses where
 * shopping_mall_customer_id matches their authenticated user ID. Sellers can
 * only retrieve addresses where shopping_mall_seller_id matches their
 * authenticated user ID. Admins have platform-wide access and can retrieve any
 * address regardless of ownership for customer support, dispute resolution, and
 * administrative functions.
 *
 * The addressId path parameter must be a valid UUID format matching an existing
 * record in the shopping_mall_addresses table. The operation validates that the
 * address exists and performs ownership verification before returning data. If
 * the address does not exist or the authenticated user does not have permission
 * to access it, appropriate error responses are returned (404 Not Found for
 * non-existent addresses, 403 Forbidden for unauthorized access attempts).
 *
 * The response includes the complete address record with all fields from the
 * Prisma schema. The user_type field (values: customer, seller, admin)
 * indicates the ownership type, and the corresponding foreign key field
 * (shopping_mall_customer_id, shopping_mall_seller_id, or
 * shopping_mall_admin_id) identifies the specific owner. This polymorphic
 * pattern enables unified address management across all user types while
 * maintaining clear ownership boundaries.
 *
 * Address data returned includes verification metadata showing whether the
 * address has been validated through an address verification service
 * (is_verified) and when verification occurred (verified_at). Verified
 * addresses provide higher confidence for order delivery and reduce shipping
 * errors. Unverified addresses may prompt customers to confirm accuracy during
 * checkout.
 *
 * The is_default field indicates whether this is the user's default delivery
 * address, which is pre-selected during checkout for convenience. Only one
 * address per user should be marked as default. The optional label field allows
 * users to assign friendly names like 'Home', 'Office', 'Parents House' for
 * quick identification.
 *
 * This operation integrates with checkout and order management workflows where
 * customers select delivery addresses for order fulfillment. When orders are
 * placed, the complete address is snapshotted and stored with the order record,
 * preserving historical accuracy even if the user later updates or deletes the
 * address. This ensures order history displays the correct delivery destination
 * for all past orders.
 *
 * The soft deletion pattern (deleted_at timestamp) allows users to remove
 * addresses from their active list while preserving the data for historical
 * order references. Deleted addresses are filtered out from normal address
 * selection interfaces but remain accessible for order history display and
 * audit purposes.
 *
 * Related operations include searching and listing addresses (PATCH
 * /addresses), creating new addresses (POST /addresses), updating address
 * details (PUT /addresses/{addressId}), and deleting addresses (DELETE
 * /addresses/{addressId}).
 *
 * @param props.connection
 * @param props.addressId Unique identifier of the target delivery address to
 *   retrieve
 * @path /shoppingMall/customer/addresses/:addressId
 * @accessor api.functional.shoppingMall.customer.addresses.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target delivery address to retrieve */
    addressId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAddress;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/addresses/:addressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): IShoppingMallAddress =>
    typia.random<IShoppingMallAddress>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("addressId")(() => typia.assert(props.addressId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing delivery address for the authenticated customer.
 *
 * Updates an existing address record in the shopping_mall_addresses table for
 * the authenticated customer. This operation enables customers to modify their
 * saved delivery addresses including recipient information, street address
 * components, city, state/province, postal code, country, and optional settings
 * like default designation and custom label.
 *
 * The system validates that the authenticated customer owns the address being
 * updated by verifying the address's shopping_mall_customer_id matches the
 * authenticated customer's ID. If ownership validation fails, the operation
 * returns HTTP 403 Forbidden.
 *
 * All address fields are validated according to the same rules as address
 * creation: postal code format must match the country, phone number format must
 * be valid, all required fields must be completed, and the label must be unique
 * per customer if provided.
 *
 * When the update sets is_default to true for this address, the system
 * automatically updates the customer's previous default address to set
 * is_default to false, ensuring only one address per customer is marked as
 * default at any time.
 *
 * Address updates do not affect historical order records. Orders preserve
 * address information through snapshot fields (delivery_recipient_name,
 * delivery_address_line1, etc.) in the shopping_mall_orders table. The system
 * updates the is_verified field to false when address components change,
 * requiring revalidation.
 *
 * @param props.connection
 * @param props.addressId Unique identifier of the delivery address to update
 * @param props.body Updated address information including modified recipient
 *   details, street address components, and optional settings
 * @path /shoppingMall/customer/addresses/:addressId
 * @accessor api.functional.shoppingMall.customer.addresses.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the delivery address to update */
    addressId: string & tags.Format<"uuid">;

    /**
     * Updated address information including modified recipient details,
     * street address components, and optional settings
     */
    body: IShoppingMallAddress.IUpdate;
  };
  export type Body = IShoppingMallAddress.IUpdate;
  export type Response = IShoppingMallAddress;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/addresses/:addressId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): IShoppingMallAddress =>
    typia.random<IShoppingMallAddress>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("addressId")(() => typia.assert(props.addressId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a delivery address using soft delete.
 *
 * Permanently removes a delivery address from the customer's, seller's, or
 * admin's saved addresses by setting the deleted_at timestamp (soft delete).
 * This operation validates that the authenticated user owns the address before
 * performing the deletion. Addresses cannot be deleted if they are associated
 * with pending orders, as this would compromise order fulfillment data
 * integrity.
 *
 * The soft delete approach preserves historical references from completed
 * orders while hiding the address from the user's active address list. When an
 * address is soft deleted, it remains in the database with a deleted_at
 * timestamp but is excluded from all user-facing address retrieval operations.
 *
 * If the deleted address was designated as the user's default address
 * (is_default = true), the business logic layer should handle updating the
 * default designation. This may involve clearing the default flag or prompting
 * the user to select a new default address from their remaining active
 * addresses.
 *
 * Security considerations include verifying the authenticated user's identity
 * matches the address owner (customer_id, seller_id, or admin_id) to prevent
 * unauthorized deletion of other users' addresses. The operation returns no
 * response body on successful deletion, following standard HTTP DELETE
 * semantics with 204 No Content status.
 *
 * @param props.connection
 * @param props.addressId Unique identifier of the delivery address to be
 *   deleted
 * @path /shoppingMall/customer/addresses/:addressId
 * @accessor api.functional.shoppingMall.customer.addresses.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the delivery address to be deleted */
    addressId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/addresses/:addressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/addresses/${encodeURIComponent(props.addressId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("addressId")(() => typia.assert(props.addressId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
