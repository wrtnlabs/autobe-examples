import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallPaymentMethod } from "../../../../structures/IShoppingMallPaymentMethod";
import { IPageIShoppingMallPaymentMethod } from "../../../../structures/IPageIShoppingMallPaymentMethod";

/**
 * Create and save a new payment method for the authenticated customer.
 *
 * Creates a new saved payment method entry in the shopping_mall_payment_methods
 * table for the authenticated customer. This operation tokenizes payment
 * information through the selected payment gateway (Stripe, PayPal, Braintree,
 * etc.) and stores only the secure token along with display information like
 * last 4 digits and card brand. Full credit card numbers are never persisted to
 * maintain PCI DSS compliance.
 *
 * The payment method creation process validates that the provided payment
 * information is complete and valid. For credit/debit cards, this includes
 * validating card number format using the Luhn algorithm, ensuring expiration
 * date is in the future, verifying CVV length matches card type, and confirming
 * billing address information. The system supports multiple payment method
 * types including credit cards (Visa, MasterCard, American Express, Discover),
 * debit cards, digital wallets (PayPal, Apple Pay, Google Pay), and bank
 * accounts.
 *
 * Customers can optionally associate a billing address with the payment method
 * by referencing a saved address from shopping_mall_addresses. If this is the
 * customer's first payment method, the system automatically marks it as
 * default. Otherwise, customers can explicitly specify whether this new payment
 * method should become their default for future checkouts. The default payment
 * method is pre-selected during checkout to streamline the purchase process.
 *
 * The operation returns the created payment method record with tokenized
 * information, display details (last 4 digits, card brand), expiration
 * information, and default status. The returned token can be used in future
 * payment transactions without re-entering payment information. This enhances
 * user experience by enabling faster checkout flows while maintaining security
 * through gateway tokenization.
 *
 * Security considerations include validating that the authenticated customer
 * owns the billing address if provided, preventing storage of complete card
 * numbers, encrypting gateway tokens at rest, and logging payment method
 * creation for audit trails. Rate limiting prevents abuse of payment method
 * creation endpoints, and suspicious patterns (multiple failed tokenization
 * attempts, unusual billing addresses) are flagged for fraud review.
 *
 * @param props.connection
 * @param props.body Payment method creation data including payment type,
 *   gateway token, card details, billing information, and default preference
 * @path /shoppingMall/customer/paymentMethods
 * @accessor api.functional.shoppingMall.customer.paymentMethods.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Payment method creation data including payment type, gateway token,
     * card details, billing information, and default preference
     */
    body: IShoppingMallPaymentMethod.ICreate;
  };
  export type Body = IShoppingMallPaymentMethod.ICreate;
  export type Response = IShoppingMallPaymentMethod;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/paymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/paymentMethods";
  export const random = (): IShoppingMallPaymentMethod =>
    typia.random<IShoppingMallPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered list of customer's saved payment methods.
 *
 * Retrieve a filtered and paginated list of saved payment methods for the
 * authenticated customer from the system. This operation provides comprehensive
 * search and filtering capabilities for customers to manage their saved payment
 * instruments including credit cards, debit cards, digital wallets, and bank
 * accounts.
 *
 * The operation supports filtering by payment type (credit_card, debit_card,
 * paypal, bank_account, digital_wallet), payment gateway provider, expiration
 * status, default designation, and card brand. Customers can search by card
 * last 4 digits, billing name, or nickname to quickly locate specific payment
 * methods. Sorting options include creation date, last used date, card brand,
 * and expiration date.
 *
 * Security considerations are paramount for this operation. Only tokenized
 * payment data is transmitted - full card numbers are never exposed through the
 * API. The operation returns only the payment methods belonging to the
 * authenticated customer, with strict user ownership validation. All payment
 * data access is logged for security auditing and PCI compliance monitoring.
 *
 * This operation integrates with the shopping_mall_payment_methods table as
 * defined in the Prisma schema, incorporating all available payment method
 * fields including tokenized gateway references, card metadata, billing
 * information, and expiration tracking. The response includes payment method
 * summary information optimized for display in account settings and checkout
 * payment selection interfaces.
 *
 * Related API operations include retrieving individual payment method details
 * (GET /paymentMethods/{methodId}), adding new payment methods during checkout
 * or account management (POST /paymentMethods), updating payment method
 * settings like default designation (PUT /paymentMethods/{methodId}), and
 * removing saved payment methods (DELETE /paymentMethods/{methodId}). This
 * search operation provides the entry point for customers to discover and
 * manage their complete collection of saved payment instruments.
 *
 * Payment method data is sensitive financial information requiring HTTPS
 * transmission, secure token storage, and compliance with PCI DSS standards.
 * The operation validates customer authentication and session validity before
 * returning any payment data. Expired payment methods are clearly indicated to
 * prompt customers to update their information before attempting purchases.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, pagination settings,
 *   and sorting options for payment method retrieval
 * @path /shoppingMall/customer/paymentMethods
 * @accessor api.functional.shoppingMall.customer.paymentMethods.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, pagination settings, and
     * sorting options for payment method retrieval
     */
    body: IShoppingMallPaymentMethod.IRequest;
  };
  export type Body = IShoppingMallPaymentMethod.IRequest;
  export type Response = IPageIShoppingMallPaymentMethod.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/paymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/paymentMethods";
  export const random = (): IPageIShoppingMallPaymentMethod.ISummary =>
    typia.random<IPageIShoppingMallPaymentMethod.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific saved payment method.
 *
 * Retrieve complete details for a specific saved payment method identified by
 * the methodId parameter. This operation returns comprehensive payment method
 * information including payment type, gateway provider, tokenized payment data,
 * card metadata (last 4 digits, brand, expiration), billing address
 * association, default status, and expiration indicators.
 *
 * The operation validates that the requested payment method belongs to the
 * authenticated customer through strict ownership verification. Customers can
 * only access their own payment methods - attempts to access other customers'
 * payment methods result in authorization errors. This ownership validation is
 * critical for protecting sensitive financial information and maintaining PCI
 * compliance.
 *
 * Security and compliance considerations are paramount for this operation. Only
 * tokenized payment gateway references are returned - full card numbers, CVV
 * codes, and other sensitive card data are never exposed through the API. All
 * payment method access is logged for security auditing and PCI DSS compliance
 * monitoring. The operation requires HTTPS transmission and active customer
 * authentication with valid JWT token.
 *
 * This operation integrates with the shopping_mall_payment_methods table as
 * defined in the Prisma schema, incorporating all available payment method
 * fields including gateway tokens, card metadata, billing information, default
 * designation, and expiration tracking. The response includes associated
 * billing address information when available, enabling complete payment method
 * display.
 *
 * Related API operations that work together with this endpoint include
 * searching payment methods (PATCH /paymentMethods) to get the list of payment
 * method IDs, updating payment method settings such as default designation or
 * nickname (PUT /paymentMethods/{methodId}), and removing saved payment methods
 * (DELETE /paymentMethods/{methodId}). The detail retrieval operation provides
 * complete information needed for payment method management interfaces and
 * checkout payment selection screens.
 *
 * The operation handles various error scenarios including payment method not
 * found (when methodId is invalid), unauthorized access (when customer doesn't
 * own the payment method), and expired payment methods (clearly indicated in
 * response for customer awareness). Expired payment methods prompt customers to
 * update their information before attempting purchases.
 *
 * @param props.connection
 * @param props.methodId Unique identifier of the target payment method to
 *   retrieve
 * @path /shoppingMall/customer/paymentMethods/:methodId
 * @accessor api.functional.shoppingMall.customer.paymentMethods.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target payment method to retrieve */
    methodId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallPaymentMethod;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/paymentMethods/:methodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/paymentMethods/${encodeURIComponent(props.methodId ?? "null")}`;
  export const random = (): IShoppingMallPaymentMethod =>
    typia.random<IShoppingMallPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("methodId")(() => typia.assert(props.methodId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing saved payment method for the authenticated customer.
 *
 * Updates specific attributes of an existing payment method record in the
 * shopping_mall_payment_methods table. This operation allows customers to
 * maintain their saved payment information by modifying billing address
 * associations, default status, expiration dates, or display nicknames. The
 * authenticated customer must own the payment method being updated, with
 * ownership validated by checking that shopping_mall_customer_id matches the
 * requesting user's customer ID from the JWT token.
 *
 * Common update scenarios include changing the billing address when customers
 * move, updating card expiration dates when renewed cards are issued by banks,
 * setting a different payment method as default for checkout convenience, and
 * adding or modifying user-friendly nicknames for easy payment method
 * identification. The system preserves the original payment gateway token, as
 * the underlying payment instrument identifier cannot be changed without
 * creating a new payment method.
 *
 * When a customer designates this payment method as default by setting
 * is_default to true, the system automatically updates any previously default
 * payment method to remove its default status, ensuring data integrity with
 * only one default payment method per customer. This atomic operation prevents
 * race conditions when multiple payment method updates occur simultaneously.
 *
 * The operation validates that any referenced billing address exists in
 * shopping_mall_addresses and belongs to the requesting customer. For card
 * expiration date updates, the system validates that the new expiration month
 * is between 1-12 and the year is current or future, preventing invalid
 * expiration dates. The is_expired flag is automatically recalculated based on
 * the updated expiration date.
 *
 * Security measures include verifying customer ownership of both the payment
 * method and any referenced billing address, logging all payment method
 * modifications with timestamps and IP addresses for audit trails, and
 * preventing modification of gateway tokens to maintain payment integrity. The
 * operation returns the updated payment method with all current values,
 * enabling clients to refresh their display of payment method information.
 *
 * This operation supports the payment method management workflow defined in the
 * business requirements, enabling customers to keep their payment information
 * current without needing to delete and recreate payment methods. It enhances
 * user experience by allowing customers to organize and maintain their saved
 * payment options efficiently.
 *
 * @param props.connection
 * @param props.methodId Unique identifier of the payment method to update
 * @param props.body Updated payment method information including billing
 *   address, default status, expiration dates, and nickname
 * @path /shoppingMall/customer/paymentMethods/:methodId
 * @accessor api.functional.shoppingMall.customer.paymentMethods.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the payment method to update */
    methodId: string & tags.Format<"uuid">;

    /**
     * Updated payment method information including billing address, default
     * status, expiration dates, and nickname
     */
    body: IShoppingMallPaymentMethod.IUpdate;
  };
  export type Body = IShoppingMallPaymentMethod.IUpdate;
  export type Response = IShoppingMallPaymentMethod;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/paymentMethods/:methodId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/paymentMethods/${encodeURIComponent(props.methodId ?? "null")}`;
  export const random = (): IShoppingMallPaymentMethod =>
    typia.random<IShoppingMallPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("methodId")(() => typia.assert(props.methodId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a saved payment method from customer account.
 *
 * Removes a saved payment method from a customer's account in the
 * shopping_mall_payment_methods table. This operation allows customers to
 * delete payment methods they no longer wish to use, such as expired credit
 * cards, outdated debit cards, or disconnected digital wallets.
 *
 * The operation performs a soft delete by setting the deleted_at timestamp,
 * preserving the payment method record for audit trail and historical
 * transaction references while making it unavailable for future use. This
 * ensures compliance with financial record-keeping requirements while allowing
 * customers to manage their saved payment options.
 *
 * Security considerations include verifying that the requesting customer owns
 * the payment method being deleted. The system prevents deletion of payment
 * methods that are currently set as default without first designating a
 * different default method. Before deletion, the system validates that no
 * pending payment transactions reference this payment method.
 *
 * The payment method is identified by the methodId path parameter, which
 * corresponds to the shopping_mall_payment_methods.id field. After successful
 * deletion, the payment method will no longer appear in the customer's saved
 * payment methods list and cannot be selected during checkout.
 *
 * Related operations include GET /paymentMethods for retrieving all saved
 * payment methods, POST /paymentMethods for adding new payment methods, and PUT
 * /paymentMethods/{methodId} for updating payment method details such as
 * expiration date or billing address.
 *
 * @param props.connection
 * @param props.methodId Unique identifier of the payment method to be deleted
 *   from the shopping_mall_payment_methods table
 * @path /shoppingMall/customer/paymentMethods/:methodId
 * @accessor api.functional.shoppingMall.customer.paymentMethods.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the payment method to be deleted from the
     * shopping_mall_payment_methods table
     */
    methodId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/paymentMethods/:methodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/paymentMethods/${encodeURIComponent(props.methodId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("methodId")(() => typia.assert(props.methodId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
