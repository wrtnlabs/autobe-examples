import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallWishlist } from "../../../../structures/IShoppingMallWishlist";
import { IPageIShoppingMallWishlist } from "../../../../structures/IPageIShoppingMallWishlist";
export * as items from "./items/index";

/**
 * Create a new wishlist for the authenticated customer.
 *
 * Creates a new wishlist for the authenticated customer, enabling them to
 * organize and save products for future purchase consideration. This operation
 * allows customers to create multiple named wishlists to categorize products
 * based on different purposes such as 'Holiday Gifts', 'Favorites', or
 * 'Birthday Ideas'.
 *
 * The wishlist serves as a container for wishlist items (specific product SKUs)
 * that customers want to save. Upon creation, the wishlist is initialized as
 * empty and can subsequently receive items through the add-to-wishlist
 * operations. Each wishlist is uniquely identified and associated with the
 * customer's account.
 *
 * This operation validates the provided wishlist name to ensure it meets
 * business requirements (minimum length, no offensive content). The newly
 * created wishlist is immediately available for the customer to add products.
 *
 * The wishlist creation is linked to the shopping_mall_wishlists table in the
 * Prisma schema, which tracks wishlist metadata including the customer owner,
 * wishlist name, creation timestamp, and soft deletion status. The wishlist
 * supports unlimited items and persists indefinitely until explicitly deleted
 * by the customer.
 *
 * This operation is a fundamental part of the customer engagement features,
 * allowing customers to save products they're interested in but not ready to
 * purchase immediately. Wishlists improve customer retention by keeping
 * customers engaged with products and enabling easy purchase when they're
 * ready.
 *
 * @param props.connection
 * @param props.body Wishlist creation data including the name for the new
 *   wishlist
 * @path /shoppingMall/customer/wishlists
 * @accessor api.functional.shoppingMall.customer.wishlists.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Wishlist creation data including the name for the new wishlist */
    body: IShoppingMallWishlist.ICreate;
  };
  export type Body = IShoppingMallWishlist.ICreate;
  export type Response = IShoppingMallWishlist;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/wishlists",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/wishlists";
  export const random = (): IShoppingMallWishlist =>
    typia.random<IShoppingMallWishlist>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated list of customer wishlists.
 *
 * Retrieve a comprehensive filtered and paginated list of wishlists belonging
 * to the authenticated customer. This operation provides advanced search
 * capabilities for finding wishlists based on various criteria including
 * wishlist name, creation date ranges, and last update timestamps.
 *
 * The operation supports flexible pagination with configurable page sizes and
 * multiple sorting options. Customers can sort wishlists by creation date, last
 * update time, or wishlist name to organize their saved product collections
 * effectively.
 *
 * Security considerations include authentication verification to ensure
 * customers can only access their own wishlists. The operation respects the
 * soft deletion mechanism defined in the shopping_mall_wishlists table,
 * filtering out wishlists marked as deleted (deleted_at is not null) by default
 * unless explicitly requested through search parameters.
 *
 * This operation integrates with the shopping_mall_wishlists table as defined
 * in the Prisma schema, incorporating wishlist metadata including ID, name,
 * timestamps, and soft delete status. The response includes wishlist summary
 * information optimized for list displays, with aggregated data such as total
 * item count per wishlist and most recent update activity.
 *
 * Customers typically use this endpoint to view and manage their collection of
 * wishlists (e.g., 'Favorites', 'Holiday Gifts', 'Birthday Ideas') before
 * accessing individual wishlist details or moving items to their shopping cart.
 * The pagination and filtering capabilities enable efficient browsing even for
 * customers with numerous wishlists containing many saved products.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering options, and pagination
 *   parameters for retrieving customer wishlists
 * @path /shoppingMall/customer/wishlists
 * @accessor api.functional.shoppingMall.customer.wishlists.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering options, and pagination parameters for
     * retrieving customer wishlists
     */
    body: IShoppingMallWishlist.IRequest;
  };
  export type Body = IShoppingMallWishlist.IRequest;
  export type Response = IPageIShoppingMallWishlist.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/wishlists",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/wishlists";
  export const random = (): IPageIShoppingMallWishlist.ISummary =>
    typia.random<IPageIShoppingMallWishlist.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific customer wishlist by ID.
 *
 * Retrieve comprehensive details for a specific wishlist identified by its
 * unique wishlist ID. This operation provides complete wishlist information
 * including the wishlist name, creation and update timestamps, and all items
 * currently saved in the wishlist with their associated product and SKU
 * details.
 *
 * The operation validates that the authenticated customer is the owner of the
 * requested wishlist to enforce proper access control and data privacy.
 * Customers cannot access wishlists belonging to other users, ensuring wishlist
 * privacy as defined in the business requirements.
 *
 * This endpoint respects the soft deletion mechanism in the
 * shopping_mall_wishlists table. If the requested wishlist has been
 * soft-deleted (deleted_at is not null), the operation returns an appropriate
 * error indicating the wishlist is no longer available, preventing access to
 * deleted resources.
 *
 * The response includes detailed wishlist information with all wishlist items,
 * each containing references to the product and SKU, current pricing, stock
 * availability status, and product images. This enables customers to view
 * comprehensive information about their saved products, check if prices have
 * changed since adding to wishlist, verify current stock availability, and make
 * informed decisions about moving items to their shopping cart.
 *
 * Customers typically access this endpoint after viewing their wishlist list
 * (from the index operation) to see full details of a specific wishlist's
 * contents. The detailed information supports actions like moving items to
 * cart, removing items from wishlist, checking price changes, and receiving
 * out-of-stock or back-in-stock notifications for saved products.
 *
 * The operation integrates with the shopping_mall_wishlist_items table to
 * retrieve all items within the wishlist, joining with shopping_mall_skus and
 * shopping_mall_products to provide current product information including
 * pricing, availability, images, and variant attributes. This ensures customers
 * see real-time product data even though items were added to wishlist at
 * earlier times with potentially different prices or stock levels.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the target wishlist to retrieve
 * @path /shoppingMall/customer/wishlists/:wishlistId
 * @accessor api.functional.shoppingMall.customer.wishlists.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target wishlist to retrieve */
    wishlistId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallWishlist;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/wishlists/:wishlistId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}`;
  export const random = (): IShoppingMallWishlist =>
    typia.random<IShoppingMallWishlist>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing wishlist's name or properties.
 *
 * Updates an existing wishlist's properties for the authenticated customer.
 * This operation allows customers to modify wishlist metadata, primarily the
 * wishlist name, to better organize their saved products as their needs
 * evolve.
 *
 * The update operation enforces strict ownership validation, ensuring that
 * customers can only modify wishlists they own. The system verifies that the
 * wishlist identified by the wishlistId parameter belongs to the authenticated
 * customer before applying any changes. If the customer attempts to update a
 * wishlist they don't own, the operation returns an authorization error.
 *
 * This operation validates the new wishlist name against business requirements
 * including minimum length, maximum length, and content appropriateness. The
 * wishlist name must be meaningful and help the customer organize their saved
 * products effectively.
 *
 * The updated wishlist metadata is persisted to the shopping_mall_wishlists
 * table in the Prisma schema. The updated_at timestamp is automatically set to
 * track when the modification occurred. The operation preserves all wishlist
 * items - updating wishlist properties does not affect the products saved
 * within the wishlist.
 *
 * This operation supports the customer's ability to maintain organized
 * wishlists as their shopping interests and priorities change over time. For
 * example, a customer might rename 'General Wishlist' to 'Summer Wardrobe' as
 * they refine their shopping plans.
 *
 * If the wishlist has been soft-deleted (deleted_at is not null), this
 * operation will fail with an appropriate error indicating the wishlist no
 * longer exists.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist to update
 * @param props.body Updated wishlist information including the new name
 * @path /shoppingMall/customer/wishlists/:wishlistId
 * @accessor api.functional.shoppingMall.customer.wishlists.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the wishlist to update */
    wishlistId: string & tags.Format<"uuid">;

    /** Updated wishlist information including the new name */
    body: IShoppingMallWishlist.IUpdate;
  };
  export type Body = IShoppingMallWishlist.IUpdate;
  export type Response = IShoppingMallWishlist;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/wishlists/:wishlistId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}`;
  export const random = (): IShoppingMallWishlist =>
    typia.random<IShoppingMallWishlist>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a customer's wishlist by marking it as deleted.
 *
 * This operation enables customers to delete one of their wishlists by setting
 * the deleted_at timestamp on the wishlist record. The wishlist is identified
 * by the wishlistId path parameter, which must correspond to a valid wishlist
 * owned by the authenticated customer.
 *
 * The operation performs authorization checks to ensure the requesting customer
 * owns the specified wishlist before deletion. Attempts to delete another
 * customer's wishlist will result in permission errors.
 *
 * According to the Prisma schema, the shopping_mall_wishlists table includes a
 * deleted_at column supporting soft deletion. When a customer deletes a
 * wishlist, the system sets the deleted_at timestamp to the current time rather
 * than removing the record from the database. This soft delete approach
 * preserves the wishlist data for audit purposes and maintains referential
 * integrity.
 *
 * The associated wishlist items in shopping_mall_wishlist_items remain in the
 * database when the parent wishlist is soft deleted. Normal application queries
 * filter out items belonging to deleted wishlists by checking the parent
 * wishlist's deleted_at status. This approach prevents orphaned data while
 * maintaining complete historical records.
 *
 * Soft deleted wishlists are excluded from normal customer wishlist queries and
 * displays. The customer will not see the deleted wishlist in their wishlist
 * list, and the wishlist name becomes available for reuse in new wishlists.
 * However, the data remains in the database for administrative purposes,
 * analytics, and potential data recovery if needed.
 *
 * This operation is commonly used when customers finish shopping for specific
 * occasions, want to consolidate wishlists, or simply no longer need to track
 * certain products. After soft deletion, customers can create new wishlists
 * with the same name at any time.
 *
 * The operation does not return any response body upon success, following
 * standard REST DELETE semantics. Clients should handle successful deletion by
 * removing the wishlist from local state and refreshing the wishlist display.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist to be soft deleted
 * @path /shoppingMall/customer/wishlists/:wishlistId
 * @accessor api.functional.shoppingMall.customer.wishlists.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the wishlist to be soft deleted */
    wishlistId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/wishlists/:wishlistId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
