import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrder } from "../../../../structures/IShoppingMallOrder";
export * as refund from "./refund/index";
export * as statusHistory from "./statusHistory/index";

/**
 * Create new order from shopping cart with payment processing.
 *
 * Create and process a new order from the customer's shopping cart, handling
 * complete checkout workflow including payment authorization, inventory
 * allocation, and multi-seller order splitting.
 *
 * This operation processes the customer's shopping cart and creates confirmed
 * order records in the shopping_mall_orders table. When the cart contains items
 * from multiple sellers, the system automatically splits the order into
 * separate shopping_mall_orders records—one per seller—each with a unique
 * order_number in format ORD-YYYYMMDD-NNNNNN. All orders from the same checkout
 * session share a checkout_transaction_id for grouping and display purposes.
 *
 * The operation performs comprehensive validation before order creation:
 * verifies customer authentication and account status, validates all cart items
 * are still available and in stock, confirms delivery address is complete and
 * valid, validates selected payment method, and ensures cart total meets
 * minimum order value ($5.00). Real-time inventory availability is checked
 * immediately before payment processing to prevent overselling.
 *
 * Payment processing integrates with configured payment gateways (Stripe,
 * PayPal, etc.) following PCI-DSS compliant practices. The system processes a
 * single payment transaction for the entire cart total even when creating
 * multiple seller orders, then internally allocates payment amounts to each
 * seller based on their order subtotals. Payment authorization must succeed
 * before any order records are created or inventory is allocated. If payment
 * fails, the cart remains unchanged and customers can retry with the same or
 * different payment method (maximum 5 attempts).
 *
 * Address information from shopping_mall_addresses is snapshotted into the
 * order record (delivery_recipient_name, delivery_phone,
 * delivery_address_line1, delivery_address_line2, delivery_city,
 * delivery_state_province, delivery_postal_code, delivery_country) to preserve
 * historical accuracy even if the customer later modifies or deletes the
 * address. Similarly, product information is snapshotted in
 * shopping_mall_order_items (product_name, variant_attributes,
 * product_image_url, unit_price) to maintain accurate order history regardless
 * of future product changes.
 *
 * Inventory management is handled atomically: cart reservations are converted
 * to permanent allocations by creating shopping_mall_inventory_transactions
 * records with transaction_type 'sale' and transaction_status 'completed'. The
 * shopping_mall_skus table is updated with reduced available_quantity and
 * increased reserved_quantity. This ensures inventory consistency and prevents
 * overselling through transaction-level locking.
 *
 * Upon successful order creation, the system generates
 * shopping_mall_order_status_history records tracking the initial status
 * transition, sends order confirmation emails to the customer within 5 minutes,
 * notifies each seller of new orders within 5 minutes, and clears the
 * customer's shopping_mall_cart_items. The response includes all generated
 * order numbers, complete order details, estimated delivery dates, and payment
 * confirmation information for customer reference and order tracking.
 *
 * @param props.connection
 * @param props.body Order creation payload containing delivery address, payment
 *   method, shipping preferences, and optional customer notes
 * @path /shoppingMall/customer/orders
 * @accessor api.functional.shoppingMall.customer.orders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Order creation payload containing delivery address, payment method,
     * shipping preferences, and optional customer notes
     */
    body: IShoppingMallOrder.ICreate;
  };
  export type Body = IShoppingMallOrder.ICreate;
  export type Response = IShoppingMallOrder.ICreateResponse;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/orders";
  export const random = (): IShoppingMallOrder.ICreateResponse =>
    typia.random<IShoppingMallOrder.ICreateResponse>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Request cancellation of an existing order.
 *
 * Request cancellation of a customer's order, with automatic approval or seller
 * approval workflow depending on current order status and timing rules defined
 * in business requirements.
 *
 * This operation creates a record in the shopping_mall_cancellations table to
 * track the cancellation request workflow. The cancellation process varies
 * based on the current status of the shopping_mall_orders record being
 * cancelled. For orders in early states (pending_payment, payment_confirmed,
 * awaiting_seller_confirmation), the cancellation is immediately approved and
 * processed without requiring seller confirmation. For orders in later states
 * (confirmed, preparing_shipment), the request requires seller approval and
 * enters pending_approval status, with the seller having 24 hours to respond
 * before automatic approval.
 *
 * The operation enforces strict business rules regarding cancellation
 * eligibility. Customers can freely cancel orders before the preparing_shipment
 * state. Orders in confirmed or preparing_shipment states require seller
 * approval (requester_customer_id is set, cancellation_status is
 * pending_approval). Orders that have reached shipped, in_transit,
 * out_for_delivery, or delivered states cannot be cancelled through this
 * endpoint—customers must use the refund request process instead for delivered
 * orders.
 *
 * When a cancellation request is created, the system populates the
 * shopping_mall_cancellations record with requester_customer_id (the
 * authenticated customer), cancellation_reason (from predefined options:
 * customer_changed_mind, found_better_price, order_mistake, delivery_too_long,
 * or other), optional cancellation_notes for additional context, refund_amount
 * (typically the full order total_amount), and requested_at timestamp. The
 * system immediately notifies the associated seller (shopping_mall_seller_id
 * from the order) about the cancellation request.
 *
 * For immediate cancellations (no approval required), the system atomically
 * updates the shopping_mall_orders.status to 'cancelled', sets cancelled_at
 * timestamp, creates shopping_mall_inventory_transactions records with
 * transaction_type 'cancellation' to restore inventory quantities back to
 * shopping_mall_skus.available_quantity, and initiates refund processing by
 * creating shopping_mall_refunds record referencing the original
 * shopping_mall_payment_transactions. The entire cart quantity is returned to
 * available stock within 5 seconds, and refund processing begins immediately
 * with funds returned to the customer's original payment method within 24
 * hours.
 *
 * For approval-required cancellations, the
 * shopping_mall_cancellations.cancellation_status remains pending_approval, and
 * a notification is sent to the seller who must respond within 24 hours. If the
 * seller approves (approver_seller_id is set, cancellation_status changes to
 * approved), the cancellation proceeds as described above. If the seller does
 * not respond within 24 hours, the system automatically approves the
 * cancellation (auto-approval business rule). If the seller rejects the
 * request, the customer is notified and the order continues normal processing.
 *
 * Multi-seller order cancellation is supported: if an order is part of a
 * multi-seller checkout (identified by checkout_transaction_id), each seller's
 * order can be cancelled independently. Cancelling all orders from a checkout
 * session results in full transaction cancellation and complete refund. Partial
 * cancellations result in partial refunds calculated based on the cancelled
 * order items.
 *
 * The operation validates that the authenticated customer owns the order being
 * cancelled (shopping_mall_orders.shopping_mall_customer_id matches the
 * authenticated user), preventing unauthorized cancellation attempts. It also
 * validates the current order status allows cancellation and returns
 * appropriate error messages for ineligible orders with guidance on alternative
 * actions (refund requests for delivered orders).
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to be cancelled
 * @param props.body Cancellation request details including reason for
 *   cancellation and optional explanatory notes
 * @path /shoppingMall/customer/orders/:orderId/cancel
 * @accessor api.functional.shoppingMall.customer.orders.cancel
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function cancel(
  connection: IConnection,
  props: cancel.Props,
): Promise<cancel.Response> {
  return true === connection.simulate
    ? cancel.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...cancel.METADATA,
          path: cancel.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace cancel {
  export type Props = {
    /** Unique identifier of the order to be cancelled */
    orderId: string & tags.Format<"uuid">;

    /**
     * Cancellation request details including reason for cancellation and
     * optional explanatory notes
     */
    body: IShoppingMallOrder.ICancelRequest;
  };
  export type Body = IShoppingMallOrder.ICancelRequest;
  export type Response = IShoppingMallOrder.ICancelResponse;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/orders/:orderId/cancel",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/cancel`;
  export const random = (): IShoppingMallOrder.ICancelResponse =>
    typia.random<IShoppingMallOrder.ICancelResponse>();
  export const simulate = (
    connection: IConnection,
    props: cancel.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: cancel.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
