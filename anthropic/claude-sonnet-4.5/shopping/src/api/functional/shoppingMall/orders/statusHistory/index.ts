import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrderStatusHistory } from "../../../../structures/IShoppingMallOrderStatusHistory";
import { IPageIShoppingMallOrderStatusHistory } from "../../../../structures/IPageIShoppingMallOrderStatusHistory";

/**
 * Retrieve the complete status change audit trail for a specific order with
 * filtering and pagination.
 *
 * Retrieves the comprehensive audit trail of all status transitions for a
 * specific order from the shopping_mall_order_status_history table as defined
 * in the Prisma schema. This operation provides complete visibility into the
 * order lifecycle, documenting every state change from initial placement
 * through final completion, cancellation, or refund.
 *
 * Each status history record includes the previous status, new status,
 * timestamp of the change, reason for the transition, optional notes, and
 * identification of the actor who triggered the change (customer, seller,
 * admin, or system-generated). This detailed audit trail is essential for order
 * tracking, customer service, dispute resolution, and compliance with business
 * audit requirements.
 *
 * The operation implements role-based access control with permission filtering
 * in the backend implementation. Customers can retrieve status history only for
 * orders they placed (validated by matching shopping_mall_customer_id). Sellers
 * can retrieve status history for orders containing their products (validated
 * by matching shopping_mall_seller_id). Admins have unrestricted access to view
 * status history for any order across the platform for oversight and dispute
 * resolution purposes. Authorization validation occurs at the provider function
 * level, ensuring each user type sees only the data they are permitted to
 * access.
 *
 * The request body supports advanced filtering capabilities to narrow down the
 * status history results. Filters include date range (from/to timestamps),
 * specific status values (to find transitions to particular states like
 * 'shipped' or 'delivered'), actor types (customer-initiated, seller-initiated,
 * admin-initiated, system-generated), and change reasons. These filters enable
 * efficient retrieval of relevant status events without overwhelming users with
 * complete histories for long-lived orders.
 *
 * Pagination is implemented to handle orders with extensive status histories
 * efficiently. The response includes standard pagination metadata (total count,
 * page number, page size, has next page) along with the sorted status history
 * records. Results are ordered by created_at timestamp in descending order
 * (most recent changes first) by default, providing immediate visibility into
 * the latest order state transitions.
 *
 * This operation integrates with the order status lifecycle defined in the
 * Order Management and Tracking requirements document. It provides read access
 * to the append-only audit trail that tracks all order state transitions
 * according to the valid status transition rules (pending_payment →
 * payment_confirmed → processing → shipped → in_transit → out_for_delivery →
 * delivered → completed, with possible cancellation and refund branches).
 *
 * The status history data includes both user-initiated actions (customer
 * cancellation requests, seller shipment updates) and system-generated events
 * (automatic payment confirmation, carrier tracking updates, auto-completion
 * after 7 days). The is_system_generated flag distinguishes between manual and
 * automated status changes, enabling analysis of order workflow automation
 * effectiveness.
 *
 * Related operations include retrieving order details, updating order status
 * (seller and admin operations), and processing cancellations or refunds. This
 * endpoint provides the temporal dimension of order data, complementing the
 * current order state with complete historical context.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order whose status history is
 *   being retrieved
 * @param props.body Search criteria for filtering order status history
 *   including date range, status values, actor types, and pagination
 *   parameters
 * @path /shoppingMall/orders/:orderId/statusHistory
 * @accessor api.functional.shoppingMall.orders.statusHistory.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the order whose status history is being
     * retrieved
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Search criteria for filtering order status history including date
     * range, status values, actor types, and pagination parameters
     */
    body: IShoppingMallOrderStatusHistory.IRequest;
  };
  export type Body = IShoppingMallOrderStatusHistory.IRequest;
  export type Response = IPageIShoppingMallOrderStatusHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/orders/:orderId/statusHistory",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/orders/${encodeURIComponent(props.orderId ?? "null")}/statusHistory`;
  export const random = (): IPageIShoppingMallOrderStatusHistory =>
    typia.random<IPageIShoppingMallOrderStatusHistory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
