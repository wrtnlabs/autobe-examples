import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReview } from "../../../structures/IShoppingMallReview";
import { IPageIShoppingMallReview } from "../../../structures/IPageIShoppingMallReview";
export * as images from "./images/index";

/**
 * Search and retrieve a filtered, paginated list of product reviews.
 *
 * Retrieve a filtered and paginated collection of product reviews from the
 * shopping mall platform. This operation provides advanced search capabilities
 * for finding reviews based on multiple criteria including product ID, customer
 * ID, rating levels, verification status, moderation status, helpfulness
 * scores, and date ranges. The endpoint supports comprehensive filtering,
 * sorting, and pagination to enable efficient review discovery and management.
 *
 * This operation is essential for multiple use cases across different user
 * roles. Customers use it to browse reviews when evaluating products, filtering
 * by rating level or sorting by helpfulness to find the most useful reviews.
 * Sellers use it to monitor customer feedback on their products, track review
 * sentiment, and identify products requiring attention based on negative
 * reviews. Admins use it to manage the review moderation queue, filtering by
 * status to find pending or flagged reviews requiring approval or removal.
 *
 * The review system corresponds to the shopping_mall_reviews table in the
 * Prisma schema, which stores customer product reviews with star ratings (1-5),
 * optional text content, and optional customer-uploaded images. All reviews are
 * from verified purchases, meaning only customers who completed orders for the
 * product can submit reviews. Reviews go through moderation workflow before
 * publication, with statuses including pending_moderation, approved, and
 * rejected.
 *
 * Security considerations include role-based access where customers see only
 * approved reviews when browsing products, sellers see all reviews (including
 * pending) for their products, and admins see all reviews platform-wide
 * including rejected reviews for moderation purposes. The endpoint enforces
 * appropriate filtering based on the requesting user's role and permissions.
 *
 * The response includes review content (rating, title, text), reviewer
 * information, verified purchase badges, helpfulness vote counts, moderation
 * status, associated product and SKU details, and timestamps. For reviews with
 * seller responses, it includes the response content and status. The pagination
 * structure provides total count, page information, and navigation metadata to
 * support efficient client-side display.
 *
 * This operation integrates with the product catalog to enrich reviews with
 * current product information, with the order system to verify purchase
 * eligibility, and with the helpfulness voting system to calculate and display
 * vote counts. Sorting options include most recent, most helpful, highest
 * rating, and lowest rating to support various customer browsing patterns.
 *
 * Related API operations include creating new reviews (POST /reviews),
 * retrieving specific review details (GET /reviews/{reviewId}), updating
 * reviews (PUT /reviews/{reviewId}), and managing review helpfulness votes.
 * Customers typically use GET /products/{productId} to view product details
 * before searching its reviews, and POST /orders to complete purchases that
 * enable future review submission.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, sorting options, and
 *   pagination configuration for review retrieval
 * @path /shoppingMall/reviews
 * @accessor api.functional.shoppingMall.reviews.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, sorting options, and
     * pagination configuration for review retrieval
     */
    body: IShoppingMallReview.IRequest;
  };
  export type Body = IShoppingMallReview.IRequest;
  export type Response = IPageIShoppingMallReview;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/reviews";
  export const random = (): IPageIShoppingMallReview =>
    typia.random<IPageIShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific product review by ID.
 *
 * Retrieve comprehensive details about a specific product review identified by
 * its unique review ID. This operation returns complete review information from
 * the shopping_mall_reviews table including the star rating (1-5), optional
 * review title, review text content, customer information, product and SKU
 * references, verified purchase status, moderation status, and aggregated
 * helpfulness vote counts.
 *
 * The review detail includes all associated data such as customer-uploaded
 * review images (from shopping_mall_review_images), seller responses if any
 * exist (from shopping_mall_seller_responses), and the complete review metadata
 * including creation and modification timestamps. The verified_purchase badge
 * is always true since only customers who completed and received orders can
 * submit reviews.
 *
 * Security considerations include role-based access control where customers can
 * view all approved reviews, sellers can view all reviews on their own products
 * regardless of moderation status, and admins have unrestricted visibility for
 * moderation purposes. The endpoint enforces that only approved reviews
 * (status='approved') are visible to regular customers, while
 * pending_moderation and rejected reviews are accessible only to the review
 * author, the product seller, and platform administrators.
 *
 * This operation integrates with the shopping_mall_products table to provide
 * product context, the shopping_mall_customers table for reviewer information,
 * and the shopping_mall_orders table to validate verified purchase status. The
 * response includes aggregated helpfulness vote counts from
 * shopping_mall_review_helpfulness_votes to display community feedback on
 * review quality.
 *
 * Related operations include searching reviews for a product, submitting new
 * reviews after purchase, editing existing reviews within the 30-day window,
 * and voting on review helpfulness. This endpoint is essential for displaying
 * detailed review information on product pages and in review management
 * interfaces.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the product review to retrieve
 * @path /shoppingMall/reviews/:reviewId
 * @accessor api.functional.shoppingMall.reviews.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product review to retrieve */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
