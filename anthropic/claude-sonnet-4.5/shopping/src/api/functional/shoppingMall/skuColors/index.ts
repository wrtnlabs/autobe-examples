import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSkuColor } from "../../../structures/IShoppingMallSkuColor";
import { IPageIShoppingMallSkuColor } from "../../../structures/IPageIShoppingMallSkuColor";

/**
 * Search and retrieve a filtered, paginated list of SKU color variants.
 *
 * This operation provides comprehensive search and filtering capabilities for
 * SKU color variants stored in the shopping_mall_sku_colors table. It enables
 * retrieval of color options used throughout the platform's product catalog,
 * supporting use cases such as color filter facets in product search, seller
 * color management interfaces, and admin color taxonomy oversight.
 *
 * The operation accepts complex search criteria including text-based search on
 * color names (with support for partial matching and fuzzy search), filtering
 * by specific color attributes like hex codes, and date-based filtering for
 * recently added colors. The search functionality uses full-text search
 * capabilities with trigram indexing on the name field to provide efficient and
 * flexible color discovery.
 *
 * Pagination support is essential as the platform may accumulate hundreds of
 * distinct color variants across all sellers and products. The request body
 * should include pagination parameters such as page number, page size, and
 * optional cursor-based pagination for efficient large dataset traversal.
 * Default page size should be configurable but typically 20-50 color records
 * per page.
 *
 * Sorting capabilities allow ordering results by color name (alphabetical),
 * creation date (newest or oldest first), or usage frequency (colors used in
 * the most active SKUs). This helps users discover popular colors, recently
 * added options, or navigate alphabetically through the color taxonomy.
 *
 * The response includes comprehensive color information from the
 * shopping_mall_sku_colors table: unique color ID, color name, optional hex
 * code for visual representation, creation timestamp, and optionally aggregated
 * statistics like the number of SKUs using each color. The hex_code field
 * enables client applications to render accurate color swatches in filter
 * interfaces and product variant selectors.
 *
 * Authorization is public (empty array) as color variant information is
 * non-sensitive reference data needed for product browsing and filtering.
 * Customers need to view available colors when filtering products, sellers need
 * to select colors when creating product variants, and admins need to manage
 * the color taxonomy. No authentication is required for read access to color
 * options.
 *
 * This operation integrates with the product catalog search and filtering
 * functionality defined in the Product Catalog Management requirements. Color
 * filters are a critical component of the product discovery experience,
 * enabling customers to narrow product searches to their preferred color
 * options. The operation supports the SKU variant architecture where colors are
 * one of the primary differentiating attributes alongside size and custom
 * options.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering parameters, sorting options, and
 *   pagination settings for SKU color variant retrieval
 * @path /shoppingMall/skuColors
 * @accessor api.functional.shoppingMall.skuColors.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering parameters, sorting options, and
     * pagination settings for SKU color variant retrieval
     */
    body: IShoppingMallSkuColor.IRequest;
  };
  export type Body = IShoppingMallSkuColor.IRequest;
  export type Response = IPageIShoppingMallSkuColor;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/skuColors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/skuColors";
  export const random = (): IPageIShoppingMallSkuColor =>
    typia.random<IPageIShoppingMallSkuColor>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific SKU color variant by ID.
 *
 * Retrieve complete details of a specific SKU color variant identified by its
 * unique color ID from the shopping_mall_sku_colors table. This operation
 * provides comprehensive color information including the color name displayed
 * to customers (e.g., 'Navy Blue', 'Forest Green', 'Crimson Red') and the
 * optional hex color code used for visual swatch representation in product
 * variant selection interfaces.
 *
 * This endpoint serves multiple business purposes across different user roles.
 * Customers use this information when browsing product variants to see
 * available color options with visual swatches. Sellers reference color details
 * when creating or updating product SKUs to maintain consistent color variant
 * definitions across their catalog. Admins access this endpoint when managing
 * the platform-wide color taxonomy and ensuring color data consistency.
 *
 * The color information is critical for the product variant selection workflow.
 * When customers select product variants, the system displays color options
 * using the name and hex code to provide both textual and visual
 * identification. The hex code enables rendering color swatches that give
 * customers an accurate preview of the actual product color before making a
 * purchase decision.
 *
 * Security considerations include standard authentication to ensure only valid
 * users access the system, though color information itself is generally
 * non-sensitive reference data. The endpoint returns the complete color record
 * including the creation timestamp for audit purposes.
 *
 * This operation integrates with the broader product catalog system where SKU
 * color variants are referenced by shopping_mall_skus records through the
 * shopping_mall_sku_color_id foreign key relationship. The color data is shared
 * across multiple products and SKUs, maintaining a centralized color taxonomy
 * that ensures consistency throughout the marketplace.
 *
 * @param props.connection
 * @param props.colorId Unique identifier of the target SKU color variant to
 *   retrieve
 * @path /shoppingMall/skuColors/:colorId
 * @accessor api.functional.shoppingMall.skuColors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target SKU color variant to retrieve */
    colorId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSkuColor;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/skuColors/:colorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/skuColors/${encodeURIComponent(props.colorId ?? "null")}`;
  export const random = (): IShoppingMallSkuColor =>
    typia.random<IShoppingMallSkuColor>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("colorId")(() => typia.assert(props.colorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
