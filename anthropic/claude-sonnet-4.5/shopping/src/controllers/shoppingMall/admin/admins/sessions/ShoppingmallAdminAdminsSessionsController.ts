import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchShoppingMallAdminAdminsAdminIdSessions } from "../../../../../providers/patchShoppingMallAdminAdminsAdminIdSessions";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { getShoppingMallAdminAdminsAdminIdSessionsSessionId } from "../../../../../providers/getShoppingMallAdminAdminsAdminIdSessionsSessionId";
import { deleteShoppingMallAdminAdminsAdminIdSessionsSessionId } from "../../../../../providers/deleteShoppingMallAdminAdminsAdminIdSessionsSessionId";

import { IPageIShoppingMallAdminSession } from "../../../../../api/structures/IPageIShoppingMallAdminSession";
import { IShoppingMallAdminSession } from "../../../../../api/structures/IShoppingMallAdminSession";

@Controller("/shoppingMall/admin/admins/:adminId/sessions")
export class ShoppingmallAdminAdminsSessionsController {
  /**
   * Retrieve all active sessions for a specific admin user.
   *
   * This operation retrieves a comprehensive list of all active sessions
   * associated with a specific administrator account. It provides detailed
   * session management and security monitoring capabilities by returning
   * information about every device and browser where the admin is currently
   * logged in. This functionality is critical for security auditing,
   * multi-device session tracking, and detecting potentially unauthorized
   * access to admin accounts.
   *
   * The operation returns an array of session records from the
   * shopping_mall_sessions table where the admin_id matches the specified
   * adminId parameter, user_type is 'admin', is_revoked is false, and
   * refresh_token_expires_at is in the future (indicating active, non-expired
   * sessions). Each session record includes comprehensive metadata about the
   * login context, device information, and activity timeline.
   *
   * The response includes the following session details for each active
   * session: session ID, refresh token expiration timestamp, IP address from
   * which the session originated, complete user agent string, detected device
   * type (mobile, tablet, desktop), user-friendly device name (e.g., 'Chrome on
   * Windows', 'Safari on iPhone'), browser name and version, operating system,
   * approximate geographic location based on IP address, last activity
   * timestamp showing when the session was last used, and session creation
   * timestamp indicating when the admin logged in from that device.
   *
   * This operation supports important security use cases including reviewing
   * all current login locations, identifying suspicious or unrecognized
   * devices, monitoring session activity patterns, and enabling informed
   * decisions about which sessions to revoke. For example, if an admin sees a
   * session from an unfamiliar location or device, they can use this
   * information to determine whether to revoke that specific session through a
   * separate session revocation endpoint.
   *
   * Access control for this operation validates that the requesting admin has
   * permission to view the target admin's sessions. Admins can always view
   * their own sessions, while super admins can view sessions for any admin
   * account on the platform. This hierarchical permission model ensures
   * appropriate access control while enabling security oversight.
   *
   * The operation supports optional filtering and pagination through the
   * request body, allowing searches for sessions by device type, location, IP
   * address, or activity timeframe. This is particularly useful for admins with
   * many concurrent sessions or when investigating security incidents. The
   * response is sorted by last activity timestamp in descending order, showing
   * the most recently used sessions first for relevance.
   *
   * @param connection
   * @param adminId Unique identifier of the admin user whose sessions are being
   *   retrieved
   * @param body Optional filtering and pagination parameters for session
   *   retrieval including device type filter, location filter, date range, and
   *   pagination settings
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAdminSession.IRequest,
  ): Promise<IPageIShoppingMallAdminSession> {
    try {
      return await patchShoppingMallAdminAdminsAdminIdSessions({
        admin,
        adminId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed information for a specific admin session.
   *
   * This endpoint retrieves comprehensive session information for a specific
   * active admin session, enabling administrators to view details about their
   * current and past login sessions across different devices and browsers. The
   * operation is designed for security monitoring and multi-device session
   * management purposes.
   *
   * The session data provides critical security information including the
   * device type, browser name, operating system, IP address, approximate
   * geographic location based on IP, and the timestamp of last activity. This
   * information helps admins identify unauthorized access attempts, verify
   * their own login locations, and make informed decisions about which sessions
   * to keep active or revoke.
   *
   * The response includes authentication token metadata such as refresh token
   * expiration timestamp, session creation time, and revocation status. This
   * enables admins to understand when their session will expire and whether it
   * has been manually revoked. The session detail view is essential for
   * implementing the multi-device session management feature described in the
   * authentication requirements document.
   *
   * Security considerations include strict ownership validation: admins can
   * only retrieve session details for their own sessions, not sessions
   * belonging to other admins. The system validates that the adminId path
   * parameter matches the authenticated admin's user ID and that the session
   * belongs to that admin before returning any data. Unauthorized access
   * attempts are logged for security auditing.
   *
   * This operation is closely related to session revocation functionality.
   * After retrieving session details and identifying sessions the admin wants
   * to terminate (e.g., unrecognized devices or old sessions), the admin can
   * use the DELETE operation on the same endpoint to revoke specific sessions
   * remotely.
   *
   * The session information returned is sourced directly from the
   * shopping_mall_sessions table in the Prisma schema, which tracks all active
   * and revoked sessions with complete metadata including device
   * fingerprinting, authentication tokens, and activity timestamps. Only
   * sessions with user_type='admin' and matching admin_id are retrievable
   * through this endpoint.
   *
   * @param connection
   * @param adminId Unique identifier of the authenticated admin user who owns
   *   the session
   * @param sessionId Unique identifier of the specific admin session to
   *   retrieve
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":sessionId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAdminSession> {
    try {
      return await getShoppingMallAdminAdminsAdminIdSessionsSessionId({
        admin,
        adminId,
        sessionId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke a specific admin session to terminate authentication for that
   * device.
   *
   * This endpoint enables administrators to revoke specific active sessions,
   * effectively signing out from individual devices or browsers remotely. This
   * is a critical security feature for managing multi-device authentication and
   * protecting admin accounts from unauthorized access.
   *
   * The session revocation process is designed to support the 'logout from
   * specific device' use case described in the authentication requirements.
   * When an admin identifies a session they want to terminate—whether it's an
   * old session from a device they no longer use, a session from an
   * unrecognized location, or a potentially compromised session—they can revoke
   * it using this endpoint without affecting their other active sessions.
   *
   * Upon successful revocation, the system performs several important actions
   * to ensure complete session termination. First, it updates the session
   * record in the shopping_mall_sessions table by setting is_revoked to true
   * and recording the revocation timestamp in revoked_at. This permanently
   * marks the session as invalid. Second, it invalidates the associated refresh
   * token, preventing any future attempts to generate new access tokens using
   * that session's refresh token. The revoked session immediately becomes
   * unusable for authentication purposes.
   *
   * Security validation is paramount for this operation. The system strictly
   * enforces ownership verification: admins can only revoke their own sessions,
   * never sessions belonging to other administrators. The endpoint validates
   * that the adminId path parameter matches the authenticated admin's user ID
   * extracted from the JWT access token, and that the session with the given
   * sessionId belongs to that admin. Any attempt to revoke another admin's
   * session results in a 403 Forbidden response and is logged as a security
   * event.
   *
   * The operation provides immediate feedback to the client. Unlike the soft
   * delete pattern used in many other entities, session revocation uses a
   * revocation flag mechanism (is_revoked boolean and revoked_at timestamp) to
   * maintain the session record for audit trail purposes while making it
   * completely unusable for authentication. This supports security auditing
   * requirements and enables admins to review their historical sessions
   * including which ones were manually revoked and when.
   *
   * This operation integrates with the broader session management system
   * defined in the authentication requirements document. After revoking a
   * session, that session will no longer appear in the admin's active sessions
   * list, though it may be retained in historical session views for security
   * audit purposes. The revocation is permanent and irreversible—once revoked,
   * a session cannot be reactivated; the admin must log in again from that
   * device to create a new session.
   *
   * Common use cases for this endpoint include: removing sessions from lost or
   * stolen devices, terminating sessions from untrusted networks or locations,
   * cleaning up old sessions that are no longer needed, and responding to
   * security alerts about suspicious session activity. The session revocation
   * feature complements the 'logout from all devices' functionality (which
   * would revoke all sessions for an admin) by providing granular control over
   * individual session lifecycles.
   *
   * @param connection
   * @param adminId Unique identifier of the authenticated admin user who owns
   *   the session to be revoked
   * @param sessionId Unique identifier of the specific admin session to revoke
   *   and terminate
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":sessionId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminAdminsAdminIdSessionsSessionId({
        admin,
        adminId,
        sessionId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
