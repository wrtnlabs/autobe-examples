import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerCartsCartIdItems } from "../../../../../providers/postShoppingMallCustomerCartsCartIdItems";
import { CustomerAuth } from "../../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerCartsCartIdItems } from "../../../../../providers/patchShoppingMallCustomerCartsCartIdItems";
import { putShoppingMallCustomerCartsCartIdItemsItemId } from "../../../../../providers/putShoppingMallCustomerCartsCartIdItemsItemId";
import { deleteShoppingMallCustomerCartsCartIdItemsItemId } from "../../../../../providers/deleteShoppingMallCustomerCartsCartIdItemsItemId";

import { IShoppingMallCartItem } from "../../../../../api/structures/IShoppingMallCartItem";
import { IPageIShoppingMallCartItem } from "../../../../../api/structures/IPageIShoppingMallCartItem";

@Controller("/shoppingMall/customer/carts/:cartId/items")
export class ShoppingmallCustomerCartsItemsController {
  /**
   * Add a new product item to a customer's shopping cart.
   *
   * Add a new product item with specific SKU variant to a customer's shopping
   * cart, with comprehensive validation and inventory reservation.
   *
   * This endpoint creates a new shopping_mall_cart_items record associated with
   * the specified cart ID. When a customer selects a product variant (specific
   * combination of color, size, and custom options identified by
   * shopping_mall_sku_id) and requests to add it to their cart, this operation
   * performs the following:
   *
   * 1. **Cart Validation**: Verifies that the specified cart exists in
   *    shopping_mall_carts table and belongs to an authenticated customer. The
   *    cart must be active (deleted_at is null).
   * 2. **SKU Validation**: Validates that the requested SKU exists in
   *    shopping_mall_skus, is active (is_active = true), and belongs to a
   *    product that is active and not deleted. Checks that the product's seller
   *    account (shopping_mall_sellers) is active and in good standing.
   * 3. **Inventory Availability**: Performs real-time inventory check against
   *    shopping_mall_skus.available_quantity to ensure sufficient stock exists
   *    for the requested quantity. The operation validates that requested
   *    quantity does not exceed available inventory and respects the maximum
   *    per-item limit of 99 units.
   * 4. **Duplicate Handling**: Checks if the same SKU already exists as a cart
   *    item in this cart. If found, instead of creating a new cart_items
   *    record, the system increases the existing item's quantity (subject to
   *    inventory and limit validations).
   * 5. **Cart Limits Enforcement**: Validates that adding this item does not
   *    exceed cart limits: maximum 100 distinct SKUs per cart, maximum 999
   *    total units across all items, and maximum 99 units per individual SKU.
   * 6. **Inventory Reservation**: Upon successful validation, creates the
   *    shopping_mall_cart_items record with the current SKU price (from
   *    shopping_mall_skus.price) and immediately updates
   *    shopping_mall_skus.reserved_quantity to reserve the inventory. This
   *    prevents overselling during the cart session.
   * 7. **Price Snapshot**: Captures the current unit_price from
   *    shopping_mall_skus.price at the time of addition. This preserves pricing
   *    information even if the seller later changes the product price, though
   *    the cart will reflect current prices when viewed.
   *
   * The operation returns the created cart item with complete details including
   * product information, variant attributes, pricing, and updated cart summary.
   * If validation fails at any step, appropriate error responses are returned
   * with specific reasons (SKU not found, insufficient inventory, cart limits
   * exceeded, etc.).
   *
   * Security: Only authenticated customers can add items to their own cart. The
   * system verifies cart ownership before allowing item addition.
   *
   * Related Operations: This endpoint is typically used in conjunction with GET
   * /carts/{cartId} to display updated cart contents, and PATCH
   * /carts/{cartId}/items/{itemId} to modify quantities. It integrates with the
   * product catalog (shopping_mall_products, shopping_mall_skus) for product
   * information and inventory management.
   *
   * @param connection
   * @param cartId Unique identifier of the customer's shopping cart to which
   *   the product item will be added
   * @param body Product item information to add to the cart including SKU
   *   selection and quantity
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("cartId")
    cartId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCartItem.ICreate,
  ): Promise<IShoppingMallCartItem> {
    try {
      return await postShoppingMallCustomerCartsCartIdItems({
        customer,
        cartId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve filtered, paginated list of cart items for a specific
   * cart.
   *
   * Retrieve a filtered and paginated list of shopping cart items for a
   * specific cart identified by the cartId path parameter from the
   * shopping_mall_cart_items table. This operation provides advanced search and
   * filtering capabilities for cart item management, supporting scenarios where
   * customers need to view subsets of their cart contents based on specific
   * criteria.
   *
   * The operation enforces strict ownership validation by verifying that the
   * authenticated customer owns the cart specified in the path parameter. This
   * security check prevents unauthorized access to other customers' cart item
   * data and ensures customers can only query their own cart contents.
   *
   * This endpoint supports comprehensive filtering capabilities including
   * filtering cart items by seller (grouping items by the seller who owns the
   * product), product categories, price ranges, availability status (in stock,
   * low stock, out of stock), and specific SKU attributes like color, size, or
   * custom options. The flexible filtering enables customers to manage complex
   * carts with items from multiple sellers efficiently.
   *
   * Advanced sorting options allow customers to organize cart items by various
   * criteria including date added (most recent first), product name
   * (alphabetical), price (ascending or descending), seller name, or
   * availability status. Sorting helps customers prioritize items, identify
   * expensive items quickly, or group items logically for review before
   * checkout.
   *
   * The operation performs real-time inventory validation for all returned cart
   * items, checking current availability against the shopping_mall_skus table.
   * Items that have become unavailable or have insufficient stock since being
   * added to the cart are clearly flagged in the response, enabling the
   * frontend to prompt customers to update quantities or remove unavailable
   * items.
   *
   * Price synchronization is performed by comparing the cart item's unit_price
   * (snapshotted when added) against the current SKU price from
   * shopping_mall_skus. Price changes are highlighted in the response, allowing
   * the frontend to notify customers when prices have increased or decreased,
   * maintaining transparency and building trust.
   *
   * The response includes complete product and SKU information for each cart
   * item, incorporating data from shopping_mall_products, shopping_mall_skus,
   * shopping_mall_sellers, and related variant attribute tables
   * (shopping_mall_sku_colors, shopping_mall_sku_sizes,
   * shopping_mall_sku_options). This comprehensive data enables rich cart item
   * display with product images, variant details, and seller information.
   *
   * Pagination is implemented to handle large carts efficiently, returning a
   * configurable number of items per page with total count and page navigation
   * information. This ensures performant cart display even for customers with
   * extensive cart contents exceeding 100 items.
   *
   * The operation calculates cart item subtotals (quantity × unit_price),
   * identifies seller groupings for multi-seller cart visualization, and
   * provides aggregated statistics such as total item count, unique seller
   * count, and estimated cart total. These calculated values support
   * comprehensive cart summary displays and checkout preparation.
   *
   * This endpoint is essential for cart management workflows, enabling
   * customers to review, filter, and organize cart contents before proceeding
   * to checkout. It complements the simple cart detail retrieval endpoint by
   * providing advanced querying capabilities for complex cart scenarios.
   *
   * @param connection
   * @param cartId Unique identifier of the shopping cart whose items to
   *   retrieve
   * @param body Search criteria, filtering parameters, sorting options, and
   *   pagination settings for cart items
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("cartId")
    cartId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCartItem.IRequest,
  ): Promise<IPageIShoppingMallCartItem> {
    try {
      return await patchShoppingMallCustomerCartsCartIdItems({
        customer,
        cartId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update the quantity of an existing item in a customer's shopping cart.
   *
   * Update the quantity of an existing cart item with comprehensive validation,
   * inventory management, and automatic removal for zero quantities.
   *
   * This endpoint modifies an existing shopping_mall_cart_items record
   * identified by the cart item ID within the specified cart. When a customer
   * adjusts the quantity of a product already in their shopping cart, this
   * operation performs the following:
   *
   * 1. **Cart and Item Validation**: Verifies that the specified cart exists in
   *    shopping_mall_carts and is active (deleted_at is null). Validates that
   *    the cart item exists within this cart and belongs to the authenticated
   *    customer. Ensures the customer owns the cart being modified for
   *    security.
   * 2. **SKU and Product Validation**: Retrieves the associated SKU from
   *    shopping_mall_skus through the cart item's shopping_mall_sku_id foreign
   *    key. Validates that the SKU is still active (is_active = true) and
   *    belongs to an active product (shopping_mall_products.status = 'active').
   *    Verifies the product's seller (shopping_mall_sellers) is active and in
   *    good standing.
   * 3. **Quantity Update Scenarios**:
   *
   * - **Increasing Quantity**: When new quantity is greater than current
   *   quantity, validates that additional units are available in
   *   shopping_mall_skus.available_quantity. Checks that the new quantity does
   *   not exceed the per-item maximum of 99 units. If sufficient inventory
   *   exists, updates cart_items.quantity and increases
   *   shopping_mall_skus.reserved_quantity by the difference.
   * - **Decreasing Quantity**: When new quantity is less than current quantity
   *   but greater than zero, updates cart_items.quantity and decreases
   *   shopping_mall_skus.reserved_quantity by the difference, returning
   *   inventory to available stock.
   * - **Zero Quantity**: When new quantity is zero, removes the cart item
   *   entirely from shopping_mall_cart_items and restores all reserved_quantity
   *   to available inventory in shopping_mall_skus.
   *
   * 4. **Inventory Availability Validation**: Performs real-time inventory check
   *    for quantity increases to ensure sufficient stock exists. If requested
   *    quantity exceeds available inventory, the operation rejects the update
   *    and returns an error indicating the maximum available quantity. This
   *    prevents overselling and maintains inventory accuracy.
   * 5. **Price Recalculation**: Updates the cart_items.updated_at timestamp. The
   *    operation may also refresh the unit_price from the current
   *    shopping_mall_skus.price to reflect any price changes, ensuring
   *    customers see current pricing. Calculates line total (quantity ×
   *    unit_price) for the updated item.
   * 6. **Cart Totals Update**: Recalculates cart-level totals including subtotal
   *    across all items, which is returned in the response for immediate UI
   *    updates.
   * 7. **Automatic Item Removal**: If the new quantity is set to zero or if the
   *    update would violate business rules, the cart item is automatically
   *    removed from shopping_mall_cart_items (hard delete since cart items are
   *    transient pre-purchase data). Reserved inventory is immediately released
   *    back to available stock.
   *
   * The operation returns the updated cart item with complete details including
   * current pricing, quantity, variant attributes, and product information. If
   * the item was removed (quantity = 0), a success response is returned without
   * cart item data. If validation fails (insufficient inventory, invalid
   * quantity, item not found), appropriate error responses with specific
   * reasons are returned.
   *
   * Security: Only authenticated customers can update items in their own carts.
   * The system verifies cart ownership and prevents customers from modifying
   * other customers' carts.
   *
   * Related Operations: This endpoint works in conjunction with POST
   * /carts/{cartId}/items (add new items), DELETE
   * /carts/{cartId}/items/{itemId} (remove items), and GET /carts/{cartId}
   * (view complete cart). It integrates with the inventory management system
   * through shopping_mall_skus and shopping_mall_inventory_transactions tables
   * for accurate stock tracking.
   *
   * Business Rules Applied: Enforces minimum quantity of 1 (or removal),
   * maximum quantity of 99 per cart item, validates against available inventory
   * in real-time, updates reserved_quantity atomically to prevent race
   * conditions, and maintains cart item price synchronization with current SKU
   * pricing.
   *
   * @param connection
   * @param cartId Unique identifier of the customer's shopping cart containing
   *   the item to update
   * @param itemId Unique identifier of the specific cart item whose quantity
   *   will be updated
   * @param body Updated quantity information for the cart item, including new
   *   quantity value and optional price refresh flag
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":itemId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("cartId")
    cartId: string & tags.Format<"uuid">,
    @TypedParam("itemId")
    itemId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCartItem.IUpdate,
  ): Promise<IShoppingMallCartItem> {
    try {
      return await putShoppingMallCustomerCartsCartIdItemsItemId({
        customer,
        cartId,
        itemId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Remove a specific item from the customer's shopping cart.
   *
   * This operation permanently removes a specific cart item from a customer's
   * shopping cart by deleting the corresponding record from the
   * shopping_mall_cart_items table. The operation is initiated when a customer
   * decides to remove a product they previously added to their cart.
   *
   * The operation validates that the cart identified by cartId belongs to the
   * authenticated customer and that the cart item identified by itemId exists
   * within that cart. If either validation fails, the operation returns an
   * appropriate error. The system enforces ownership validation to prevent
   * customers from modifying other customers' carts.
   *
   * When a cart item is successfully deleted, the system performs several
   * automated actions. First, it releases the inventory reservation associated
   * with the removed item by decreasing the reserved_quantity and increasing
   * the available_quantity in the shopping_mall_skus table for the
   * corresponding SKU. This ensures that the inventory becomes immediately
   * available for other customers to purchase. The inventory update is recorded
   * in the shopping_mall_inventory_transactions table with transaction_type set
   * to 'reservation_release' and transaction_status set to 'completed'.
   *
   * After the cart item deletion and inventory release, the shopping cart's
   * updated_at timestamp is automatically updated to reflect the modification.
   * This timestamp update enables proper cart synchronization across multiple
   * devices and sessions for the same customer.
   *
   * The operation returns a success response with no content body upon
   * successful deletion. If the cart or cart item does not exist, or if the
   * cart does not belong to the authenticated customer, the operation returns
   * an error response indicating the specific validation failure.
   *
   * This operation is commonly used during the shopping journey when customers
   * refine their selections, compare alternatives, or adjust their purchase
   * decisions before proceeding to checkout. It integrates with the shopping
   * cart business rules defined in the requirements, ensuring proper inventory
   * management and cart state consistency.
   *
   * @param connection
   * @param cartId Unique identifier of the shopping cart containing the item to
   *   be removed
   * @param itemId Unique identifier of the specific cart item to be removed
   *   from the cart
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":itemId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("cartId")
    cartId: string & tags.Format<"uuid">,
    @TypedParam("itemId")
    itemId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallCustomerCartsCartIdItemsItemId({
        customer,
        cartId,
        itemId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
