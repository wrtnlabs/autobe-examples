import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthCustomerJoin } from "../../../providers/postAuthCustomerJoin";
import { postAuthCustomerLogin } from "../../../providers/postAuthCustomerLogin";
import { postAuthCustomerRefresh } from "../../../providers/postAuthCustomerRefresh";
import { postAuthCustomerLogout } from "../../../providers/postAuthCustomerLogout";
import { CustomerAuth } from "../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../decorators/payload/CustomerPayload";

import { IShoppingMallCustomer } from "../../../api/structures/IShoppingMallCustomer";

@Controller("/auth/customer")
export class AuthCustomerController {
  /**
   * Register new customer account with email verification and issue JWT tokens
   * (shopping_mall_customers table).
   *
   * Creates a new customer account in the shopping mall platform by validating
   * provided registration information (email, password, name, phone) against
   * business rules defined in the User Roles and Authentication requirements.
   * The system enforces email uniqueness by checking the
   * shopping_mall_customers table to ensure no existing account uses the
   * provided email address. Password validation confirms the password meets
   * security requirements: minimum 8 characters, at least one uppercase letter,
   * one lowercase letter, one number, and one special character. The password
   * is hashed using bcrypt or Argon2 before storage in the password_hash field,
   * and the plain text password is never stored.
   *
   * Upon successful validation, the system creates a customer record in the
   * shopping_mall_customers table with account_status set to 'unverified' and
   * email_verified set to false. The system generates a unique
   * email_verification_token and records the email_verification_sent_at
   * timestamp, then sends a verification email containing a link with the token
   * that expires after 24 hours. The newly created account is assigned the
   * 'customer' role with permissions to browse products, manage shopping cart
   * and wishlist, and access customer-specific features as defined in the
   * permission matrix.
   *
   * The operation immediately generates JWT tokens (access token with 30-minute
   * expiration and refresh token with 30-day expiration) containing the
   * customer's userId, email, role ('customer'), and permissions in the token
   * payload. The access token uses HS256 algorithm and includes fields: userId,
   * email, role, permissions, iat, exp, and type ('access'). The refresh token
   * includes: userId, tokenId, iat, exp, and type ('refresh'). A session record
   * is created in the shopping_mall_sessions table linking the refresh token to
   * the customer account with device information and IP address for security
   * monitoring.
   *
   * This registration operation returns the complete customer profile
   * information along with the authentication tokens, enabling the customer to
   * immediately begin an authenticated session. The customer can browse
   * products, manage cart and wishlist, but cannot place orders until
   * completing email verification through the verification link sent to their
   * email address. The failed_login_attempts counter is initialized to 0, and
   * password_history is initialized as empty to support future password change
   * policies.
   *
   * @param connection
   * @param body Customer registration information including email, password,
   *   name, and phone number
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IShoppingMallCustomer.ICreate,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate customer with email and password and issue JWT tokens
   * (shopping_mall_customers table).
   *
   * Authenticates a customer using email and password credentials by performing
   * comprehensive validation against the shopping_mall_customers table and
   * business rules defined in the User Roles and Authentication document. The
   * system first validates the email format, then queries the
   * shopping_mall_customers table to find a customer record matching the
   * provided email address. If no matching customer exists, the system returns
   * a generic 'Invalid email or password' error without revealing whether the
   * email exists (security best practice to prevent account enumeration).
   *
   * For existing accounts, the system performs sequential validation checks:
   * (1) verifies account_status is 'active' and not 'suspended' or 'deleted',
   * (2) confirms email_verified is true (unverified accounts cannot log in),
   * (3) checks account_locked_until timestamp to ensure account is not
   * currently locked due to previous failed login attempts. If any validation
   * fails, the system returns appropriate error messages: 'Your account is
   * inactive', 'Please verify your email address before logging in', or 'Your
   * account has been locked due to multiple failed login attempts. Please try
   * again in 30 minutes or reset your password'.
   *
   * Password verification compares the provided password with the stored
   * password_hash using bcrypt or Argon2 verification. If the password is
   * incorrect, the system increments the failed_login_attempts counter and
   * updates the failed_login_window_start_at timestamp if this is the first
   * failure in the current 15-minute window. After 5 failed attempts within a
   * 15-minute window, the system sets account_locked_until to 30 minutes in the
   * future and returns an account locked error. The system tracks failed
   * attempts using the failed_login_attempts counter and
   * failed_login_window_start_at timestamp to implement the business rule
   * allowing 5 failures per 15-minute window before 30-minute lockout.
   *
   * Upon successful password verification, the system resets
   * failed_login_attempts to 0 and clears failed_login_window_start_at. The
   * system then generates JWT tokens with access token (30-minute expiration)
   * containing userId, email, role ('customer'), permissions, iat, exp, and
   * type ('access'), and refresh token (30-day expiration) containing userId,
   * tokenId, iat, exp, and type ('refresh'). A new session record is created in
   * the shopping_mall_sessions table with user_type 'customer', the refresh
   * token, device information parsed from the user agent string, IP address,
   * and approximate_location derived from IP geolocation. The session supports
   * multi-device concurrent access and can be revoked individually.
   *
   * The login response returns the customer's profile information from the
   * shopping_mall_customers table (id, email, name, phone, account_status)
   * along with the JWT access and refresh tokens. The customer can now access
   * all authenticated customer features including shopping cart management,
   * order placement, wishlist functionality, address management, and order
   * history as defined in the permission matrix. The refresh token enables
   * token renewal without requiring re-login for 30 days.
   *
   * @param connection
   * @param body Customer login credentials with email and password
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IShoppingMallCustomer.ILogin,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT access token using valid refresh token without
   * re-authentication (shopping_mall_sessions table).
   *
   * Refreshes an expired or expiring JWT access token by validating the
   * provided refresh token and issuing a new access token without requiring
   * customer re-authentication. This operation implements the token refresh
   * mechanism defined in the JWT Token Management section of the User Roles and
   * Authentication requirements, enabling seamless session continuation across
   * the 30-minute access token lifetime.
   *
   * The system validates the refresh token through multiple security checks:
   * (1) verifies the JWT signature using the platform secret key to ensure the
   * token was issued by the platform and has not been tampered with, (2) checks
   * the refresh token has not expired by comparing current time against the
   * refresh_token_expires_at timestamp (30 days from issuance), (3) queries the
   * shopping_mall_sessions table to verify the refresh token exists and matches
   * an active session record, (4) confirms the session is not revoked by
   * checking is_revoked is false. If any validation fails, the system returns
   * HTTP 401 Unauthorized with error code AUTH_TOKEN_EXPIRED or
   * AUTH_INVALID_TOKEN, requiring the customer to re-authenticate via the login
   * endpoint.
   *
   * Upon successful refresh token validation, the system extracts the
   * customer's userId from the token payload and retrieves the current customer
   * information from the shopping_mall_customers table to ensure the account is
   * still active (account_status = 'active') and not suspended or deleted. The
   * system generates a new access token with a fresh 30-minute expiration
   * timestamp, containing the customer's userId, email, role ('customer'),
   * permissions array, iat (issued at), exp (expiration), and type ('access').
   * The new access token uses the HS256 algorithm for signature.
   *
   * The system updates the shopping_mall_sessions table by setting
   * last_activity_at to the current timestamp to track session activity and
   * prevent automatic expiration after 30 days of inactivity. If the current
   * refresh token is within 7 days of expiration (refresh_token_expires_at < 7
   * days from now), the system also generates a new refresh token and updates
   * the session record with the new refresh token and extended expiration (30
   * days from now). This rolling refresh token strategy maintains long-term
   * session validity for active customers without requiring frequent
   * re-authentication.
   *
   * The operation returns the new access token to the client. If a new refresh
   * token was also generated (due to near-expiration), both tokens are
   * returned. The client should store the new access token and use it for
   * subsequent authenticated API requests in the Authorization header as
   * 'Bearer {access_token}'. This refresh mechanism supports continuous
   * customer session across multiple devices as tracked in the
   * shopping_mall_sessions table with concurrent session support.
   *
   * @param connection
   * @param body Refresh token for generating new access token
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IShoppingMallCustomer.IRefresh,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logout customer and revoke current session refresh token
   * (shopping_mall_sessions table).
   *
   * Logs out the customer by revoking the current session's refresh token and
   * invalidating the session record in the shopping_mall_sessions table. This
   * operation implements the logout process defined in the Session Management
   * section of the User Roles and Authentication requirements, allowing
   * customers to securely terminate their authenticated session.
   *
   * This endpoint requires authentication via valid JWT access token in the
   * Authorization header. The system extracts the customer's userId from the
   * token payload to identify the customer. The request must include the
   * refresh token (either in request body or extracted from httpOnly cookie
   * depending on storage strategy) to identify which specific session to
   * terminate, supporting the multi-device session management capability where
   * customers can have concurrent sessions on different devices.
   *
   * The system queries the shopping_mall_sessions table to find the session
   * record matching the provided refresh_token and customer_id. If no matching
   * session is found or the session is already revoked (is_revoked = true), the
   * system returns a success response anyway (idempotent operation) without
   * revealing session state details. For valid active sessions, the system
   * updates the session record by setting is_revoked to true and revoked_at to
   * the current timestamp. This immediately invalidates the refresh token,
   * preventing it from being used to generate new access tokens in future token
   * refresh requests.
   *
   * Revoking the refresh token effectively terminates the session because while
   * the current access token remains technically valid until its 30-minute
   * expiration, it cannot be renewed once the refresh token is revoked. This
   * means the customer will be logged out within 30 minutes at most, and
   * immediately if the client application discards the access token upon logout
   * (recommended client-side behavior). The session revocation is logged in the
   * shopping_mall_sessions table with the revoked_at timestamp for security
   * auditing and session history tracking.
   *
   * The operation instructs the client application to immediately discard both
   * the access token (stored in localStorage or sessionStorage) and refresh
   * token (stored in httpOnly cookie or localStorage) from client-side storage.
   * This ensures the customer cannot continue making authenticated requests
   * with the revoked session. The system response confirms successful logout
   * and session termination.
   *
   * This single-session logout operation terminates only the current session
   * associated with the provided refresh token. Other concurrent sessions on
   * different devices remain active and unaffected, as specified in the
   * multi-device support requirements. If the customer wants to log out from
   * all devices simultaneously, they should use a separate 'logout from all
   * devices' endpoint that revokes all refresh tokens associated with their
   * customer_id in the shopping_mall_sessions table. The current operation
   * enables customers to log out from one device while maintaining active
   * sessions on their other devices (e.g., logging out from work computer while
   * staying logged in on mobile phone).
   *
   * @param connection
   * @param body Refresh token of the session to terminate
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallCustomer.ILogout,
  ): Promise<IShoppingMallCustomer.ILogoutResponse> {
    try {
      return await postAuthCustomerLogout({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
