import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthSellerVerificationResend } from "../../../../../providers/postAuthSellerVerificationResend";

import { IShoppingMallSeller } from "../../../../../api/structures/IShoppingMallSeller";

@Controller("/auth/seller/verification/resend")
export class AuthSellerVerificationResendController {
  /**
   * Resend email verification link to seller.
   *
   * Generates and sends a new email verification token to sellers who did not
   * receive the original verification email or whose token expired. This
   * endpoint supports the seller onboarding workflow by providing a
   * self-service mechanism to complete email verification, which is required
   * before the seller account can be approved by administrators and before full
   * platform access is granted.
   *
   * The operation accepts the seller's registered email address and queries the
   * shopping_mall_sellers table to verify the account exists and requires
   * verification. Email verification status is checked by reading the
   * email_verified field - if email_verified is true, the endpoint returns
   * error 'Email address is already verified' since there is no need to resend
   * verification for already-confirmed accounts.
   *
   * Rate limiting enforcement prevents email flooding and abuse by checking the
   * email_verification_sent_at timestamp. The system calculates the time
   * elapsed since the last verification email was sent by comparing
   * email_verification_sent_at against the current timestamp. If less than 5
   * minutes have passed, the endpoint rejects the request with error 'Please
   * wait before requesting another verification email. You can request a new
   * email in {remaining_minutes} minutes' to enforce the business rule of
   * maximum 1 verification email per 5 minutes.
   *
   * Token generation creates a new cryptographically secure random verification
   * token (minimum 32 bytes using crypto.randomBytes or equivalent secure
   * random generation) and stores it in the email_verification_token field,
   * overwriting any previous token. The email_verification_sent_at timestamp is
   * updated to the current time, resetting the rate limiting window and
   * tracking when this new verification email was sent. The new token has a
   * 24-hour lifetime from email_verification_sent_at.
   *
   * Account status validation ensures the seller account is not in 'banned'
   * status, which would prevent email verification resend. Sellers with
   * account_status of 'pending_approval', 'active', 'suspended', or 'on_hold'
   * can request verification email resend, as email verification is independent
   * of approval status and may be needed at various account lifecycle stages.
   *
   * Email notification system integration triggers the seller email
   * verification template with personalized content including the seller's
   * business_name, verification link (typically
   * https://platform.com/seller/verify-email?token={email_verification_token}),
   * token expiration information (24 hours from sending), and onboarding
   * guidance. The email is sent asynchronously to the seller's registered email
   * address (the email field) within 5 minutes of the request.
   *
   * The endpoint returns a simple success message 'Verification email sent
   * successfully. Please check your inbox and spam folder' without exposing
   * sensitive account details. No JWT tokens are issued, and no session
   * modifications occur. The seller must complete email verification by
   * clicking the link in the email, which will trigger a separate email
   * verification confirmation endpoint that updates email_verified to true and
   * potentially changes account status if all verification requirements are
   * met.
   *
   * This operation is idempotent within the rate limit window - multiple
   * requests with the same email within 5 minutes return rate limit error, but
   * requests spaced more than 5 minutes apart successfully generate new tokens
   * each time, with each new token invalidating the previous one (only the most
   * recent email_verification_token is valid).
   *
   * @param connection
   * @param body Seller email address for verification email resend
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async resendVerificationEmail(
    @TypedBody()
    body: IShoppingMallSeller.IResendVerificationRequest,
  ): Promise<IShoppingMallSeller.IResendVerificationResponse> {
    try {
      return await postAuthSellerVerificationResend({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
