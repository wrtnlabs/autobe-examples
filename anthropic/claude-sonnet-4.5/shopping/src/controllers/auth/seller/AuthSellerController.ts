import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthSellerJoin } from "../../../providers/postAuthSellerJoin";
import { postAuthSellerLogin } from "../../../providers/postAuthSellerLogin";
import { postAuthSellerRefresh } from "../../../providers/postAuthSellerRefresh";
import { postAuthSellerLogout } from "../../../providers/postAuthSellerLogout";
import { SellerAuth } from "../../../decorators/SellerAuth";
import { SellerPayload } from "../../../decorators/payload/SellerPayload";

import { IShoppingMallSeller } from "../../../api/structures/IShoppingMallSeller";

@Controller("/auth/seller")
export class AuthSellerController {
  /**
   * Register new seller account and issue authentication tokens.
   *
   * Creates a new seller account in the shopping_mall_sellers table with
   * comprehensive business information required for vendor onboarding and
   * marketplace participation. This endpoint handles the complete seller
   * registration workflow including business entity verification data
   * collection, authentication credential setup, and initial JWT token issuance
   * for immediate platform access.
   *
   * The registration process collects essential business information including
   * business_name (publicly displayed store name), business_type (individual,
   * LLC, corporation, partnership), contact_person_name (primary contact),
   * email (unique authentication identifier), phone (business contact number),
   * business_address (physical location for verification), tax_id (for tax
   * reporting and payout processing), and optional banking details
   * (bank_account_number, bank_routing_number, bank_account_holder_name) for
   * future payout configuration.
   *
   * Upon successful registration, the system creates a seller record with
   * account_status set to 'pending_approval' and email_verified set to false,
   * requiring subsequent email verification and administrator approval before
   * full platform access is granted. The operation generates a unique
   * email_verification_token (expires in 24 hours) and sets
   * email_verification_sent_at timestamp for verification workflow tracking.
   *
   * Security measures include password hashing using bcrypt or Argon2 (stored
   * in password_hash field), initialization of failed login attempt tracking
   * (failed_login_attempts set to 0, failed_login_window_start_at set to null),
   * and account lockout prevention fields (account_locked_until set to null).
   * The password_changed_at timestamp is set to the current time, and
   * password_history is initialized as empty JSON array for future password
   * rotation enforcement.
   *
   * The endpoint immediately issues JWT authentication tokens (access token
   * with 30-minute expiration and refresh token with 30-day expiration)
   * enabling the seller to access their account dashboard and view application
   * status, though product management and order fulfillment capabilities remain
   * restricted until account approval. The commission_rate is set to the
   * platform default (typically 0.10 for 10%), and optional store customization
   * fields (store_url_slug, store_description, store_logo_url,
   * store_banner_url) can be provided or configured later.
   *
   * This operation integrates with the email notification system to send
   * verification emails, the session management system to create initial
   * authentication sessions, and the admin notification system to alert
   * administrators of new seller applications requiring review. The created_at
   * and updated_at timestamps are set to the current time for audit trail
   * establishment.
   *
   * @param connection
   * @param body Seller registration information including business details,
   *   contact information, and authentication credentials
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IShoppingMallSeller.ICreate,
  ): Promise<IShoppingMallSeller.IAuthorized> {
    try {
      return await postAuthSellerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate seller and issue access tokens.
   *
   * Validates seller login credentials (email and password) and issues JWT
   * authentication tokens for platform access. This endpoint performs
   * multi-layered authentication validation to ensure secure seller access to
   * product management, inventory controls, order fulfillment, and analytics
   * features.
   *
   * The authentication process validates the seller exists in the
   * shopping_mall_sellers table by querying with the provided email address
   * (must match exactly, case-insensitive comparison). The endpoint verifies
   * the account_status field is set to 'active' - accounts with
   * 'pending_approval', 'suspended', 'banned', or 'on_hold' status are denied
   * access with specific error messages indicating the account state and
   * required actions.
   *
   * Email verification is enforced by checking the email_verified field is
   * true. Sellers who have registered but not verified their email
   * (email_verified = false) cannot authenticate and receive a prompt to
   * complete email verification using the verification link sent to their
   * registered email address. The system allows requesting a new verification
   * email if the original email_verification_token has expired (24-hour
   * expiration from email_verification_sent_at timestamp).
   *
   * Password validation compares the provided password against the stored
   * password_hash using bcrypt or Argon2 verification. The system implements
   * account lockout protection by checking if account_locked_until timestamp is
   * set and has not passed - locked accounts display the remaining lockout
   * duration and suggest password reset or waiting for automatic unlock (30
   * minutes from lock time).
   *
   * Failed authentication attempts are tracked using failed_login_attempts
   * counter and failed_login_window_start_at timestamp. The system increments
   * failed_login_attempts on invalid password and checks if 5 failures occurred
   * within the 15-minute window defined by failed_login_window_start_at. Upon
   * reaching 5 failures, the account_locked_until field is set to 30 minutes
   * from current time, account is locked, and the seller receives notification
   * email about the security lockout.
   *
   * Successful authentication resets security counters (failed_login_attempts
   * to 0, failed_login_window_start_at to null, account_locked_until to null),
   * generates new JWT access token (30-minute expiration) and refresh token
   * (30-day expiration), creates a session record in shopping_mall_sessions
   * table with device information and IP address tracking, and returns the
   * complete seller profile along with authentication tokens.
   *
   * The response includes seller account details (id, email, business_name,
   * account_status, store information), authentication tokens for API access,
   * and session metadata. The seller can immediately access their dashboard,
   * manage products and inventory, view and process orders, respond to reviews,
   * and access sales analytics using the provided tokens.
   *
   * @param connection
   * @param body Seller login credentials containing email and password for
   *   authentication
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IShoppingMallSeller.ILogin,
  ): Promise<IShoppingMallSeller.IAuthorized> {
    try {
      return await postAuthSellerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh seller access tokens using valid refresh token.
   *
   * Renews JWT access tokens for sellers using a valid refresh token, enabling
   * session extension without re-authentication. This endpoint is critical for
   * maintaining continuous seller access to the platform when access tokens
   * expire (30-minute lifetime), providing seamless user experience for ongoing
   * product management, inventory updates, and order fulfillment activities.
   *
   * The token refresh process validates the provided refresh token by querying
   * the shopping_mall_sessions table where refresh_token matches the provided
   * token, user_type equals 'seller', and seller_id is not null. The system
   * performs comprehensive validation checks including verifying
   * refresh_token_expires_at timestamp has not passed (30-day token lifetime),
   * confirming is_revoked field is false (session not manually terminated), and
   * validating the associated seller account exists and is active in
   * shopping_mall_sellers table.
   *
   * Session activity tracking updates the last_activity_at timestamp to the
   * current time, maintaining the session as active and preventing automatic
   * expiration due to the 30-day inactivity threshold. The system checks if
   * sessions have been inactive for 30 days by comparing current time against
   * last_activity_at, automatically expiring and revoking stale sessions.
   *
   * Token renewal logic generates a new JWT access token with fresh 30-minute
   * expiration containing seller authentication claims (seller ID, email, role,
   * permissions). The existing refresh token is maintained unless it is within
   * 7 days of expiration (refresh_token_expires_at - current_time < 7 days), in
   * which case a new refresh token is generated with extended 30-day lifetime
   * and the session record is updated with the new refresh_token value and
   * refresh_token_expires_at timestamp.
   *
   * The endpoint returns the complete seller profile information (id, email,
   * business_name, account_status, email_verified, store_url_slug,
   * store_description, commission_rate, and other seller-specific fields from
   * shopping_mall_sellers table) along with the new access token and refresh
   * token (if renewed). This enables the seller application to update stored
   * credentials and continue authenticated operations without interruption.
   *
   * Security features include automatic session revocation detection
   * (is_revoked = true returns authentication error), device and location
   * tracking through existing session metadata (ip_address, user_agent,
   * device_type, browser_name, operating_system, approximate_location fields),
   * and comprehensive audit logging of token refresh operations for security
   * monitoring and fraud detection.
   *
   * @param connection
   * @param body Refresh token for generating new access tokens
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IShoppingMallSeller.IRefresh,
  ): Promise<IShoppingMallSeller.IAuthorized> {
    try {
      return await postAuthSellerRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logout seller from current session.
   *
   * Terminates the seller's current authentication session by revoking the
   * refresh token and invalidating access, requiring fresh login for subsequent
   * platform access. This endpoint provides sellers with immediate logout
   * functionality to end their work session securely, clear authentication
   * state, and ensure their account credentials are not accessible from the
   * current device or browser.
   *
   * Session identification determines the current session by extracting the
   * refresh token from the request (typically sent in Authorization header as
   * Bearer token or in httpOnly session cookie). The system queries the
   * shopping_mall_sessions table for the record where refresh_token equals the
   * provided token, user_type equals 'seller', and seller_id equals the
   * authenticated seller's ID (from JWT access token claims). If the session is
   * not found or already revoked (is_revoked = true), the endpoint returns
   * error 'Session not found or already logged out'.
   *
   * Authentication validation verifies the seller is authenticated with a valid
   * JWT access token before processing logout. While logout conceptually ends
   * authentication, the request itself must be authenticated to prevent
   * unauthorized session termination. The seller ID from the access token must
   * match the seller_id associated with the refresh token's session to ensure
   * sellers can only log out their own sessions.
   *
   * Session revocation executes an atomic database update on the
   * shopping_mall_sessions table, setting is_revoked to true and revoked_at to
   * the current timestamp for the session where refresh_token matches the
   * request's refresh token. This immediately invalidates the session - the
   * refresh token can no longer be used to generate new access tokens, and the
   * seller is effectively logged out. The last_activity_at timestamp is updated
   * to the current time as the final activity of the session.
   *
   * Token invalidation guidance instructs the client application to immediately
   * discard all stored authentication credentials including the access token
   * (stored in memory, localStorage, or sessionStorage), the refresh token
   * (stored in httpOnly cookie or secure storage), and any cached seller
   * profile data. The response confirms 'Logged out successfully. Please remove
   * all stored tokens' to ensure client-side cleanup.
   *
   * Current access token remains technically valid until its natural expiration
   * (30 minutes from issuance) since JWT tokens are stateless and cannot be
   * immediately invalidated server-side without token blacklisting
   * infrastructure. However, the revoked refresh token prevents generation of
   * new access tokens, so the seller's session effectively ends within 30
   * minutes maximum (when current access token expires). For immediate access
   * revocation, the platform may implement optional access token blacklisting
   * checked on each authenticated request.
   *
   * Security audit logging records the logout event with comprehensive details
   * including the seller's ID, email, session metadata (device_name,
   * browser_name, operating_system, approximate_location, ip_address), logout
   * timestamp, and session lifetime (created_at to revoked_at duration). This
   * audit trail supports security monitoring and investigation of unusual
   * account activity.
   *
   * Anomalous logout detection identifies logout events from unusual locations
   * or devices that differ from the seller's typical login patterns. If logout
   * occurs from an IP address or location inconsistent with the seller's
   * historical logins, the system sends a security notification email to the
   * seller's registered email address alerting them that a logout occurred from
   * an unfamiliar location (e.g., 'Your account was logged out from Paris,
   * France on Chrome/Windows at 2025-10-13 14:30 UTC'). This notification helps
   * sellers detect potential account compromise where an attacker gained access
   * and then logged out to cover tracks.
   *
   * Multi-session awareness does not affect other active sessions - logout only
   * revokes the specific session associated with the provided refresh token.
   * Sellers logged in on other devices or browsers remain authenticated with
   * their respective sessions until those sessions are individually logged out
   * or revoked. To log out from all devices simultaneously, sellers should use
   * a 'logout from all devices' endpoint (if available) or manually revoke all
   * sessions via the session management interface.
   *
   * The endpoint returns a minimal success response with confirmation message
   * and no sensitive data, as the seller is being logged out and should not
   * continue using authentication credentials. Client applications should
   * redirect to login page or public homepage after successful logout.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @SellerAuth()
    seller: SellerPayload,
  ): Promise<IShoppingMallSeller.ILogoutResponse> {
    try {
      return await postAuthSellerLogout({
        seller,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
