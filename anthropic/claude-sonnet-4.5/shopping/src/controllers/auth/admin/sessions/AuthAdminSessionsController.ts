import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { getAuthAdminSessions } from "../../../../providers/getAuthAdminSessions";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { deleteAuthAdminSessionsSessionId } from "../../../../providers/deleteAuthAdminSessionsSessionId";

import { IShoppingMallAdmin } from "../../../../api/structures/IShoppingMallAdmin";

@Controller("/auth/admin/sessions")
export class AuthAdminSessionsController {
  /**
   * List all active sessions for authenticated admin across devices.
   *
   * Retrieves all active sessions for the authenticated admin user, providing
   * visibility into login activity across multiple devices. This endpoint
   * implements the multi-device session management feature, enabling admins to
   * monitor where they are logged in and identify potentially unauthorized
   * access.
   *
   * The session listing process requires the admin to be authenticated with a
   * valid JWT access token. The system extracts the admin's userId from the
   * token payload to identify which admin's sessions to retrieve.
   *
   * The system queries the shopping_mall_sessions table for all session records
   * matching the following criteria: user_type='admin', admin_id equals the
   * authenticated admin's ID, and is_revoked=false (only active, non-revoked
   * sessions). The query results are ordered by last_activity_at descending,
   * showing the most recently active sessions first.
   *
   * For each session record retrieved, the system constructs a detailed session
   * information object containing device and activity data. This includes the
   * session ID (unique identifier for session management actions),
   * refresh_token_expires_at (when the session will expire), ip_address (IP
   * from which the session originated), device_type (mobile, tablet, or
   * desktop), device_name (user-friendly description like 'Chrome on Windows'),
   * browser_name (Chrome, Firefox, Safari), operating_system (Windows, macOS,
   * iOS, Android, Linux), approximate_location (city and country based on IP
   * geolocation), created_at (when the admin logged in to create this session),
   * and last_activity_at (most recent token refresh or important action).
   *
   * The system identifies the current session (the one associated with the
   * access token making this request) and marks it with an is_current=true flag
   * in the response, helping the admin distinguish their current device from
   * other logged-in devices.
   *
   * Each session object includes security-relevant information enabling the
   * admin to make informed decisions about session management. For example, if
   * the admin sees a session from an unfamiliar location or device, they can
   * identify it as potentially unauthorized and revoke it using the session
   * management endpoint.
   *
   * The response provides session count information (total active sessions)
   * along with the detailed session list. This gives the admin an overview of
   * their account's login footprint across devices.
   *
   * Sessions that have expired (refresh_token_expires_at is in the past) are
   * automatically excluded from the active sessions list, though they remain in
   * the database for audit purposes.
   *
   * The system supports pagination if an admin has a large number of active
   * sessions (unlikely but supported for completeness). The default page size
   * is 50 sessions, which accommodates most usage patterns.
   *
   * This endpoint does not include revoked or expired sessions - only currently
   * active sessions that could be used for API access are displayed. Admins
   * reviewing their login history for security auditing can access a separate
   * endpoint for complete session history including revoked and expired
   * sessions.
   *
   * The response returns an array of session objects with comprehensive device
   * and activity information, enabling the admin to monitor and manage their
   * account security effectively.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async listSessions(
    @AdminAuth()
    admin: AdminPayload,
  ): Promise<IShoppingMallAdmin.ISessionList> {
    try {
      return await getAuthAdminSessions({
        admin,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke specific admin session by ID for remote device logout.
   *
   * Revokes a specific admin session by session ID, enabling remote logout from
   * individual devices. This endpoint implements the multi-device session
   * management feature, allowing admins to terminate sessions on specific
   * devices without affecting other logged-in sessions.
   *
   * The session revocation process requires the admin to be authenticated with
   * a valid JWT access token. The system extracts the admin's userId from the
   * token payload to verify ownership of the session being revoked.
   *
   * The admin provides a session_id parameter identifying which session to
   * terminate. This session ID is obtained from the 'list all sessions'
   * endpoint, which displays all active sessions with their unique
   * identifiers.
   *
   * The system queries the shopping_mall_sessions table to retrieve the session
   * record matching the provided session_id. Several validation checks are
   * performed before allowing revocation.
   *
   * First, the system verifies the session exists. If no session is found with
   * the provided ID, the request is rejected with error: 'Session not found'
   * (404 Not Found).
   *
   * Second, the system verifies the session belongs to the authenticated admin
   * by checking user_type='admin' and admin_id equals the admin's ID from the
   * JWT token. If the session belongs to a different user, the request is
   * rejected with error: 'You do not have permission to revoke this session'
   * (403 Forbidden). This prevents admins from revoking each other's sessions.
   *
   * Third, the system checks if the session is already revoked by examining the
   * is_revoked flag. If is_revoked is already true, the request is rejected
   * with error: 'This session has already been revoked' (400 Bad Request), as
   * there's no need to revoke an already-terminated session.
   *
   * If all validation checks pass, the system updates the session record:
   * is_revoked is set to true, and revoked_at is set to the current timestamp.
   * This marks the session as terminated and records exactly when the
   * revocation occurred for audit purposes.
   *
   * The revoked refresh token can no longer be used to generate new access
   * tokens. Any attempt to use the revoked refresh token on the token refresh
   * endpoint will result in 401 Unauthorized with error code
   * AUTH_INVALID_TOKEN.
   *
   * If the session being revoked is the current session (the one making this
   * request), the admin effectively logs themselves out from the current
   * device. The response is successfully returned before the session becomes
   * invalid, and subsequent API requests from this device will fail
   * authentication.
   *
   * If the session being revoked is a different session (another device), the
   * current session remains active and unaffected. The admin stays logged in on
   * the current device but the specified session is terminated. The other
   * device will be forced to re-authenticate on its next API request or token
   * refresh attempt.
   *
   * A security notification email is sent to the admin's email address
   * informing them that a session was revoked, including device information and
   * timestamp of the revoked session. This provides transparency and alerts the
   * admin if sessions are revoked without their knowledge.
   *
   * The system logs the session revocation event in the audit trail, recording
   * which admin performed the revocation, which session was revoked, the
   * timestamp, and the IP address from which the revocation was initiated.
   *
   * The response returns a success confirmation message indicating the session
   * has been revoked, along with device information about the terminated
   * session for the admin's reference.
   *
   * @param connection
   * @param sessionId Unique identifier of the session to revoke
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":sessionId")
  public async revokeSession(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAdmin.ISessionRevokeResponse> {
    try {
      return await deleteAuthAdminSessionsSessionId({
        admin,
        sessionId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
