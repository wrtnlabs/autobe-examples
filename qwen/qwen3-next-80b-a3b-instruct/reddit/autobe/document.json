{"operations":[{"method":"post","path":"/auth/guest/join","name":"join","authorizationRole":"guest","authorizationType":"join","specification":"Creates a temporary guest account for unauthenticated users allowing limited platform access. This operation generates a temporary session identifier and issues a time-limited JWT token that grants only read-only access to public content. The API accepts no request body as guest accounts are purely temporary with no user-provided credentials. This operation is essential for allowing anonymous users to explore the platform before registration.","summary":"Creates a temporary guest account with limited read-only access to public content.","description":"This API operation creates a temporary guest account for users who have not registered or logged in. The system generates a unique guest identifier (UUID) and assigns it to the guest user entity, creating a temporary session that persists across page views. This functionality enables users to browse public communities, view posts, and explore platform content without providing any personal credentials. Upon successful creation, a time-limited JWT access token is issued with a scope restricted to read-only operations on public entities. The guest account is not associated with any authentication credentials and will expire after a short session timeout period. This design aligns with the business requirement that guests have minimal access rights while maintaining platform security by preventing permanent anonymous access. The operation is implemented by creating a record in the community_platform_guest table, which captures the session initiation timestamp, IP address, and user agent information for security analytics and abuse detection. Since guests are unauthenticated by design, there are no password fields or email verification requirements associated with this process.\n\nThe implementation leverages the community_platform_guest table to store the ephemeral session state. The generated guest ID becomes the unique identifier for all subsequent guest interactions during the session. The JWT token issued contains only the guest ID as a claim with no role assignments beyond guest status, ensuring no elevated privileges are granted. Tokens are signed with a short lifespan (typically 15 minutes) and are not refreshable, as per the security requirements for temporary access. This approach satisfies the business rule that guests cannot interact with the platform (post, comment, vote, subscribe) while preserving their ability to browse public content.\n\nFrom a business context perspective, this operation supports the platform's mission by allowing potential users to explore the community ecosystem before committing to registration. It aligns with the success metric of guest-to-member conversion rate by providing a frictionless pathway for initial content exploration. The operation respects the principle that authentication is required for interaction, while providing sufficient access to demonstrate platform value. Security considerations are paramount: no personal data is collected, no authentication credentials are stored, and sessions are purged automatically.\n\nThe implementation is tightly constrained by the schema: the system can only use the fields present in the community_platform_guest table (id, created_at, ip_address, user_agent, last_active). No additional fields can be used since they don't exist in the schema. This operation is fundamentally different from member registration (join) as it does not require email, password, or username verification. Related authentication operations include the guest refresh operation, but there is no login operation because guests have no credentials to authenticate against.","parameters":[],"requestBody":null,"responseBody":{"description":"Authentication response containing the temporary guest JWT token and session details.","typeName":"ICommunityPlatformGuest.IAuthorized"},"prerequisites":[]},{"method":"get","path":"/auth/guest/refresh","name":"refresh","authorizationRole":"guest","authorizationType":"refresh","specification":"Renews the temporary guest session by issuing a new JWT access token without requiring authentication. This operation extends the guest session duration without creating a new guest account or requiring any user credentials. It provides an uninterrupted browsing experience for guests viewing public content.","summary":"Extends temporary guest session by renewing the access token without authentication.","description":"This API operation refreshes an existing temporary guest session by issuing a new time-limited JWT access token. The system validates the presence of a valid guest access token in the Authorization header and verifies that the associated guest entity exists in the community_platform_guest table with an active session state. Upon confirmation, a new token is generated with an extended expiration time, extending the guest's capability to access public content. This operation is essential for maintaining uninterrupted browsing experiences during extended sessions while adhering to the security principle than guest sessions are temporary and not refreshable indefinitely.\n\nThe implementation strictly adheres to the guest session model defined in the Prisma schema. The system references the existing guest_id from the incoming token and confirms the record's existence in the community_platform_guest table using the id field as the primary identifier. The last_active timestamp is updated to reflect the refresh operation, ensuring session activity records are maintained for abuse detection and analytics purposes. The refresh operation does not create a new guest account, does not modify any user-supplied information (as none exists), and has no interaction with authentication credentials since guests are anonymous by design. The token refresh mechanism is implemented with a short maximum session lifespan (typically 2 hours total) that cannot be extended beyond this limit even with multiple refresh calls.\n\nFrom a business context perspective, this operation supports the guest exploration experience by preventing users from being logged out during prolonged browsing sessions while still enforcing the platform's security model that guests have ephemeral, temporary access. It aligns with the user journey where guests may spend significant time exploring communities before deciding to register. The operation is constrained to the schema fields available in community_platform_guest table (id, created_at, ip_address, user_agent, last_active) - no additional fields can be referenced since they don't exist. Security considerations are paramount: the refresh operation cannot be used to extend access indefinitely, cannot be used to elevate privileges, and cannot be exploited since guest sessions are automatically purged after the maximum timeframe. Related operations include the guest join operation which initiates the session, and there is no login operation as guests do not authenticate with credentials.","parameters":[],"requestBody":null,"responseBody":{"description":"Authentication response containing the renewed guest JWT token.","typeName":"ICommunityPlatformGuest.IAuthorized"},"prerequisites":[]},{"specification":"Authentication operation for user registration. This endpoint allows any unauthenticated user to create a new member account by providing email, username, and password. The operation directly corresponds to the community_platform_member table which contains email, username, and password_hash fields. Successfully creating an account requires all three fields to be present and valid according to business rules - email must be unique, username must be unique, and password must meet complexity requirements (8+ characters with uppercase, lowercase, and digit). This operation is fundamental to the platform's member onboarding flow and is explicitly supported by the community_platform_member table schema.","authorizationType":"join","description":"This API operation handles user registration (join) for member accounts on the communityPlatform. When a user submits registration details, the system validates the email and username for uniqueness against the community_platform_member table, ensures the password meets complexity requirements (min 8 characters, uppercase, lowercase, digit), and creates a new record in the community_platform_member table with is_verified set to false. The password is securely hashed using bcrypt before storage in the password_hash column. A verification token is generated and stored in the community_platform_email_verifications table linked to the new member's ID. The operation creates an initial record in the community_platform_member table with default values for created_at, updated_at, deleted_at (null), and karma (0). This operation does not invoke any authentication tokens directly but sets the foundation for subsequent login and refresh operations by establishing the member's identity in the database.\n\nThe implementation is constrained by the community_platform_member table structure which contains precisely the required fields: email, username, password_hash, is_verified, created_at, updated_at, deleted_at, and karma. The operation must not attempt to populate fields not present in the schema such as phone_number, first_name, or last_name. The email and username fields have unique constraints which the operation must respect and validate against. The password_hash field is mandatory and must be populated through server-side hashing. The email_verifications table referenced for token storage is linked to community_platform_member through member_id foreign key, requiring the new member to be created first before token generation.\n\nThis registration flow is critical to the member role's authentication chain. Without successful registration, members cannot subsequently log in, refresh tokens, or access any authenticated features of the platform. The action is irreversible from the user perspective (no self-deletion of accounts), and the created_at timestamp establishes the account's birthdate for lifetime value calculations. The member_count in community_platform_communities is not directly affected by this operation; it is only incremented when the user subscribes to a community in a separate process.\n\nThe operation is intentionally stateless with no side effects on other tables beyond community_platform_member and community_platform_email_verifications. It does not trigger profile creation, karma calculation, notification preferences, or stripe customer creation - those are handled by separate operations triggered after successful verification. This separation ensures a clear authentication boundary and prevents accidental data pollution during registration.\n\nThe operation is publicly accessible and requires no authentication, though it is subject to rate limiting as defined in community_platform_platform_settings.max_posts_per_hour (though this setting applies to posts, not registration). The operation uses the email and username to uniquely identify accounts and prevent duplicate registrations. All failures return appropriate error codes (400 for validation failures, 409 for duplicate data) rather than attempting to recover or auto-resolve conflicts.","summary":"Register a new member account by creating a record in the community_platform_member table with provided email, username, and password_hash.","parameters":[],"path":"/auth/member/join","method":"post","name":"join","authorizationRole":"member","prerequisites":[],"requestBody":{"description":"Request payload for member registration containing email, username, and password.","typeName":"ICommunityPlatformMember.IJoin"},"responseBody":{"description":"Response containing authentication tokens and member identification after successful registration.","typeName":"ICommunityPlatformMember.IAuthorized"}},{"specification":"Authentication operation for user login. This endpoint allows authenticated members to validate their credentials and obtain JWT tokens for subsequent API requests. The operation directly corresponds to the community_platform_member table which stores email and password_hash for authentication validation. When provided with email and password, the system validates the credentials against the stored hash, checks if the account is active (deleted_at is null), and verifies email verification status (is_verified is true). This operation is fundamental to the member role's authentication flow and is explicitly supported by the community_platform_member table schema.","authorizationType":"login","description":"This API operation handles user login for member accounts on the communityPlatform. When a user submits their email and password, the system retrieves the corresponding community_platform_member record and validates the password_hash against the provided password using bcrypt comparison. The system verifies that the account is active by ensuring deleted_at is null and that email verification is complete (is_verified is true). Upon successful validation, the system generates a short-lived access token (15-minute expiration) and a refresh token (7-day expiration), both stored in hashed form in the community_platform_user_sessions table with the member's ID, IP address, and user agent. The user agent and IP are used for security monitoring in the community_platform_security_logs table. The operation returns a response containing the access token, refresh token, and member's ID, which constitutes the ICommunityPlatformMember.IAuthorized response type.\n\nThe operation is constrained by the fields in the community_platform_member table. It requires email to identify the account and password_hash to validate credentials. The system does not infers or uses any other fields that are not part of the schema such as last_login_at, login_count, or device_id, despite these being common in other systems. The verification status (is_verified) is checked to ensure only verified accounts can log in, preventing access to unverified registrations. The operation does not increment a login counter or update the updated_at timestamp in the member table as these are not schema-defined fields.\n\nThis login flow enables the member role to access protected resources. Without successful login, none of the member-specific operations (posting, commenting, voting) are accessible. The authentication tokens are protected by being stored only in HTTP-only, Secure, SameSite=Strict cookies, as referenced in the security requirements. The login operation is subject to rate limiting based on community_platform_platform_settings.max_posts_per_hour, which is extended to authentication attempts for security. Failures return appropriate error codes (401 for invalid credentials, 403 for non-verified accounts) rather than providing account enumeration hints.\n\nThe operation uses the community_platform_member table's unique constraints on email to ensure precise user identification. Each successful login creates a new session record in community_platform_user_sessions with a unique session ID, refresh_token_hash, access_token_hash, and corresponding timestamps, with support for the device_type classification. The operation does not directly interact with any other tables than community_platform_member and community_platform_user_sessions. Password reset capability is handled by a separate operation (not this one) and requires a different flow entirely.","summary":"Authenticate a member user and issue access/refresh JWT tokens based on email and password verification from the community_platform_member table.","parameters":[],"path":"/auth/member/login","method":"post","name":"login","authorizationRole":"member","prerequisites":[],"requestBody":{"description":"Request payload for member login containing email and password.","typeName":"ICommunityPlatformMember.ILogin"},"responseBody":{"description":"Response containing authentication tokens and member identification after successful login.","typeName":"ICommunityPlatformMember.IAuthorized"}},{"specification":"Authentication operation for token refresh. This endpoint allows authenticated members to obtain a new access token using a valid refresh token. The operation directly corresponds to the community_platform_user_sessions table which stores the refresh_token_hash and enables token validation without re-authentication. When a member's access token expires, this endpoint validates the refresh token against the stored hash in the user_sessions table, confirms the session is active (is_active is true), and issues a new access token while extending the refresh token's lifespan. This operation is fundamental to maintaining authenticated sessions without requiring re-login.","authorizationType":"refresh","description":"This API operation handles token refresh for member accounts on the communityPlatform. When a member's short-lived access token expires (after 15 minutes), they can submit their refresh token to this endpoint to obtain a new access token without requiring re-authentication. The system validates the provided refresh token against the refresh_token_hash stored in the community_platform_user_sessions table corresponding to the member's ID. The system checks that the session's is_active flag is true and the session_expiry hasn't been reached (7 days). If validation succeeds, a new access token is generated with 15-minute expiration and a new refresh_token_hash is generated (replaced) with 7-day expiration that is stored in the same community_platform_user_sessions record. The existing session's updated_at timestamp is refreshed. The response contains the new access token and the new refresh token, forming the ICommunityPlatformMember.IAuthorized type.\n\nThe operation is constrained by the community_platform_user_sessions table schema, which contains refresh_token_hash and is_active fields that are critical for validation. The operation does not rely on or verify any fields outside the schema such as device_id, location, or last_ping. The refresh token is not renewed after every use but has a fixed lifetime (7 days) and the operation allows only one active session per member (the refresh token is rotated on each use). The old refresh_token_hash is immediately invalidated, ensuring session uniqueness and security. The operation does not update the member table (community_platform_member) or trigger any other side effects like notification or audit logging beyond what is mandated by schema references.\n\nThis refresh flow is critical to the member role's session management. Without this operation, users would need to re-authenticate frequently, which would degrade the user experience. The refresh token stored in cookie is protected by HTTP-only, Secure, SameSite=Strict attributes as defined in security requirements. The operation accepts the refresh token exclusively in the cookie header and does not allow it in request headers or body to prevent interception. Failure to validate the refresh token produces a 401 Unauthorized response, which triggers client-side login redirection. The session record in community_platform_user_sessions is used to determine token validity and does not reference any other tables for this operation. The refresh logic does not interact with password_resets or email_verifications tables as those are unrelated to session management.","summary":"Refresh expired access token using a valid refresh token from community_platform_user_sessions, issuing a new access/refresh token pair for continued authentication.","parameters":[],"path":"/auth/member/refresh","method":"post","name":"refresh","authorizationRole":"member","prerequisites":[],"requestBody":{"description":"Request payload for token refresh containing the refresh token (provided in cookie header).","typeName":"ICommunityPlatformMember.IRefresh"},"responseBody":{"description":"Response containing newly issued access and refresh tokens after successful validation from community_platform_user_sessions.","typeName":"ICommunityPlatformMember.IAuthorized"}},{"specification":"This API operation handles the registration (join) process for moderator users. It creates a new moderator account with initially active status, issues JWT tokens, and requires email verification as specified in the Prisma schema's community_platform_member table. The operation aligns with the business requirement that moderator users have 'member' kind, requiring full authentication flow including registration, login, and refresh.","authorizationType":"join","description":"This API operation handles the registration (join) process for moderator users. When a new user registers as a moderator, this endpoint creates a new account in the community_platform_member table with is_verified set to false by default, as per the schema definition. The operation requires email address, username, and password_hash fields, all of which exist in the schema and are mandatory for member accounts. After registration, the system sends a verification email to the provided email address (using the community_platform_email_verifications table) as shown in the schema relationships. The endpoint returns a temporary access token and refresh token as specified in the response body type ICommunityPlatformModerator.IAuthorized. Authentication is always required for moderator registration since they are classified as 'member' kind users, not guest users. This is different from guest users who do not require authentication flows.\n\nThe operation is closely tied to the community_platform_member and community_platform_email_verifications tables. The registration process creates a record in community_platform_member with is_verified = false, and simultaneously creates a corresponding entry in community_platform_email_verifications with a unique token that expires in 24 hours. This ensures email ownership before granting full privileges. The schema clearly defines these tables and their FK relationships, confirming this exact flow must be implemented. Passwords are stored as hashes in the password_hash column, as required by the schema.\n\nThis operation integrates with the authentication system defined in the Prisma schema, where moderator accounts are classified as 'member' kind with full authentication requirements. The operation follows the JWT-based session management pattern established in the schema with community_platform_user_sessions table for managing active sessions. When authentication succeeds, the system generates access and refresh tokens that are hashed and stored in the community_platform_user_sessions table as access_token_hash and refresh_token_hash, respectively.\n\nFrom a security perspective, the operation must validate all input against the schema's field constraints: email must be unique in community_platform_member table (unique index), username must be unique (unique index), and password must meet complexity requirements as documented in business rules (though these are application-level, not schema-level). The password_hash field must be properly salted and hashed with bcrypt before storage, as required by the schema.\n\nThis operation is related to other authentication flows: refresh_token must be provided for subsequent refresh operations, and login must be used for authentication after registration. The join operation is the first step in the moderator authentication lifecycle, which progresses to login and refresh as defined by the role type.","summary":"Register a new moderator user account with email verification required, matching the member kind in the Prisma schema.","parameters":[],"method":"post","path":"/auth/moderator/join","name":"join","authorizationRole":"moderator","requestBody":{"description":"Request body containing registration information for a new moderator account.","typeName":"ICommunityPlatformModerator.ICreate"},"responseBody":{"description":"Authentication data returned upon successful registration, including access and refresh tokens.","typeName":"ICommunityPlatformModerator.IAuthorized"},"prerequisites":[]},{"specification":"This API operation handles the login process for moderator users, authenticating them by validating their email and password against the community_platform_member table. As moderators are classified as 'member' kind users, they require full authentication including login, which is mandated by the system's authentication requirements for non-guest users.","authorizationType":"login","description":"This API operation handles the login process for moderator users, authenticating them by validating their email and password against the community_platform_member table. This is a core authentication operation that follows the schema-defined data model, where the moderator account extends from the community_platform_member table with its email, password_hash, and is_verified fields.\n\nWhen a moderator attempts to log in, the system verifies that the provided email exists in the community_platform_member table and that the bcrypt-hashed password matches the stored password_hash. The is_verified field must be true for login to succeed, as per schema requirements and business rules. The schema clearly defines these fields, confirming this exact verification process. Authentication failure results in appropriate error handling without exposing whether email or password was incorrect, adhering to security best practices.\n\nFor successful authentication, the service generates a short-lived access token and refresh token. These are stored as hashed values (access_token_hash and refresh_token_hash) in the community_platform_user_sessions table, along with the IP address, user agent, and session expiration timestamp. The schema relationships show this table is directly linked to community_platform_member, ensuring session tracking aligns with user identity.\n\nThe login operation is specifically designed for moderator (member) users as defined by the role kind property. Unlike guest users who do not authenticate, moderators require this flow. This operation is the second step in the authentication lifecycle after join, followed by refresh when tokens expire. The operation returns an ICommunityPlatformModerator.IAuthorized response object as specified in the naming convention, consistent with the role and service prefix.\n\nFrom a security perspective, the operation must respect the schema's field limitations and constraints. The password_hash field stores encrypted credentials, preventing plaintext exposure. Sessions are managed through the community_platform_user_sessions table, which includes connection-specific data (ip_address and user_agent) for forensic auditing as required by the schema's security design. This authentication flow is fundamental to the platform's access control system, ensuring only verified moderator users can access moderator-specific functionality.","summary":"Authenticate a moderator user and issue access/refresh tokens based on email/password credentials from the member table.","parameters":[],"method":"post","path":"/auth/moderator/login","name":"login","authorizationRole":"moderator","requestBody":{"description":"Request body containing login credentials for moderator authentication.","typeName":"ICommunityPlatformModerator.ILogin"},"responseBody":{"description":"Authentication data returned upon successful login, including access and refresh tokens.","typeName":"ICommunityPlatformModerator.IAuthorized"},"prerequisites":[]},{"specification":"This API operation handles the refresh token flow for moderator users, allowing them to obtain new access tokens without re-authentication using their refresh token stored in the community_platform_user_sessions table. As moderators are classified as 'member' kind users, they require the refresh operation as part of their full authentication lifecycle.","authorizationType":"refresh","description":"This API operation handles the refresh token flow for moderator users, allowing them to obtain new access tokens without re-authentication using their refresh token stored in the community_platform_user_sessions table. As moderators are classified as 'member' kind users, they require the refresh operation as part of their full authentication lifecycle.\n\nThe operation validates the refresh token provided by the client by matching its hash against the refresh_token_hash field in the community_platform_user_sessions table. This field exists in the schema, confirming the required storage mechanism. The operation checks that the session is still active (is_active = true) and that the session has not expired (session_expiry > current time), directly using the available schema fields. If validation succeeds, the system generates a new access token and refresh token. The new refresh token is stored with a new hash in the refresh_token_hash field of the same session record, and the old refresh token is effectively invalidated.\n\nThe refresh flow follows the schema's session management design, where the community_platform_user_sessions table tracks tokens and session states. This design ensures security by preventing token replay and ensuring proper token rotation. The refresh token expiration policy aligns with the schema design, where session_expiry controls the maximum lifetime of the refresh token (7 days according to business requirements), though the actual expiration value is stored per session.\n\nThis operation is essential for maintaining authorization state after the short-lived access token expires (after 15 minutes). It is only available to moderator ('member') users, not guest users. The response returns updated authentication data in ICommunityPlatformModerator.IAuthorized format, consistent with the naming convention for authentication responses. This operation is directly related to the join and login operations, completing the three-part authentication flow required for all member users per the role kind specification.\n\nThe operation includes an authorization mechanism that prevents authenticated users from using refresh tokens on unauthorized devices. The link between the refresh token and the specific session (identified by its hash and associated user ID) ensures that refresh requests are validated against the original authentication context, as the schema enables through the community_platform_user_sessions and community_platform_member relationship.","summary":"Refresh access token for moderator users using a valid refresh token from the user sessions table.","parameters":[],"method":"post","path":"/auth/moderator/refresh","name":"refresh","authorizationRole":"moderator","requestBody":{"description":"Request body containing refresh token to exchange for a new access token.","typeName":"ICommunityPlatformModerator.IRefresh"},"responseBody":{"description":"Authentication data returned upon successful refresh, including new access and refresh tokens.","typeName":"ICommunityPlatformModerator.IAuthorized"},"prerequisites":[]},{"specification":"This operation handles user registration for admin accounts in the communityPlatform system. Admin accounts are created through this endpoint and require full validation of email uniqueness, password complexity, and compliance with platform policies. The operation creates a new community_platform_member record with is_verified set to false initially, then sends a verification email. After email verification, the account becomes active with member role, and an admin role is subsequently assigned by an existing super admin through a separate process. This is a public endpoint that accepts any valid registration request.","authorizationType":"join","description":"This API operation creates a new admin account registration in the communityPlatform system. When a user submits a registration request for admin privileges, the system validates all inputs according to security requirements: email uniqueness, password complexity (minimum 8 characters with uppercase, lowercase, and digit), username uniqueness, and compliance with platform naming rules.\n\nThe operation first checks if the email address is already registered in the community_platform_member table. If the email exists but is unverified, the system re-sends the verification email instead of creating a duplicate. If the username already exists, the operation fails with appropriate error messaging. The password is securely hashed using bcrypt with a cost factor of 12 before storage in the password_hash field.\n\nA new record is created in the community_platform_member table with is_verified set to false, created_at and updated_at timestamps set to the current time, and karma set to 0. Simultaneously, a new entry is created in the community_platform_email_verifications table with a unique token, token_hash, expires_at (24 hours from creation), and sent_at timestamp. The verification token is sent to the user's email address via the SendGrid email integration.\n\nUpon successful registration, the system returns a minimal response indicating success, without exposing any internal identifiers. No immediate admin privileges are granted at this stage - admin roles can only be assigned by existing super administrators through the admin assignment API.\n\nThe operation follows all constraints in the community_platform_member schema, including the requirement for email and username uniqueness. The description refers to specific fields: password_hash for secure storage, is_verified for status tracking, and email/username for unique constraints.","summary":"Register a new admin account for the communityPlatform system","parameters":[{"name":"email","in":"body","schema":{"type":"string","format":"email","minLength":5,"maxLength":254},"description":"The email address for the new admin account. Must be unique and follow standard email format."},{"name":"username","in":"body","schema":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[a-zA-Z0-9_]+$"},"description":"The display username for the admin account. Must be unique and contain only alphanumeric characters and underscores."},{"name":"password","in":"body","schema":{"type":"string","minLength":8,"maxLength":128,"pattern":"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$"},"description":"The password for the new admin account. Must be at least 8 characters with at least one uppercase letter, one lowercase letter, and one digit."}],"path":"/auth/admin/join","method":"post","name":"join","requestBody":{"description":"Registration data for creating a new admin account.","typeName":"ICommunityPlatformAdmin.IJoin"},"responseBody":{"description":"Success response indicating that the admin account registration has been initiated.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"prerequisites":[]},{"specification":"This operation authenticates admin users by validating their credentials against the community_platform_member table. The endpoint confirms the existence of the email in the member table, validates the password hash against the stored hash, and verifies the email has been verified. Upon successful authentication, a short-lived access token and a long-lived refresh token are generated, with the tokens' hashes stored in community_platform_user_sessions table. This operation supports both web and API client authentication and results in session creation.","authorizationType":"login","description":"This API operation authenticates admin users through credential verification against the communityPlatform system's user database. When the user submits credentials via email and password, the system locates the record in the community_platform_member table using the email field. The system verifies that the account is not marked with a deleted_at timestamp (account is not deactivated) and confirms that is_verified is set to true.\n\nThe password authentication process uses the bcrypt algorithm to compare the provided password against the password_hash stored in the database. The comparison uses the same cost factor of 12 as used during registration. If the password matches, the system generates a new JWT access token with a 15-minute expiration and a refresh token with a 7-day expiration. The access_token_hash and refresh_token_hash are stored in the community_platform_user_sessions table, with the session_start and session_expiry timestamps set appropriately, the ip_address captured from the request, and is_active set to true.\n\nThe operation validates authentication attempts with rate limiting based on community_platform_security_logs. After 5 consecutive failed attempts within 15 minutes, the system triggers an account lockout by setting is_active to false in community_platform_user_sessions for the relevant IP address, with appropriate notification to the user. The response includes the access token as a bearer token in the Authorization header and the refresh token as an HTTP-only, Secure, SameSite=Strict cookie.\n\nAll operations reference the community_platform_member schema fields: email for user identification, password_hash for authentication verification, is_verified for status validation, and deleted_at for account state determination. The response does not include any sensitive user data, following the security principle of minimal information exposure.","summary":"Login as an admin to generate authentication tokens for the communityPlatform system","parameters":[{"name":"email","in":"body","schema":{"type":"string","format":"email","minLength":5,"maxLength":254},"description":"The email address associated with the admin account."},{"name":"password","in":"body","schema":{"type":"string","minLength":8,"maxLength":128},"description":"The password for the admin account."}],"path":"/auth/admin/login","method":"post","name":"login","requestBody":{"description":"Login credentials for authenticating an admin user.","typeName":"ICommunityPlatformAdmin.ILogin"},"responseBody":{"description":"Tokens for session management after successful admin authentication.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"prerequisites":[]},{"specification":"This operation refreshes the access token for an authenticated admin user by validating the refresh token stored in the community_platform_user_sessions table. The endpoint accepts a refresh token in an HTTP-only cookie, validates its hash against the stored hash, checks the session expiry, and issues a new access token while maintaining the same session. This approach avoids frequent re-authentication while maintaining security through token rotation.","authorizationType":"refresh","description":"This API operation refreshes the access token for an admin user by validating the stored refresh token. The refresh token must be provided in an HTTP-only, Secure, SameSite=Strict cookie and is validated against the stored refresh_token_hash in the community_platform_user_sessions table. The system verifies that the session is active (is_active = true) and that the session_expiry is in the future (greater than current server time).\n\nThe refresh token uses the same cryptographic key as the access token to generate and validate the JWT signature. A new, short-lived (15-minute) access token is generated and returned in the Authorization header as a bearer token, while the refresh token remains unchanged. The updated_at timestamp in the community_platform_user_sessions table is updated to reflect the token refresh event, maintaining session continuity without changing the underlying session state.\n\nThis operation does not reset the session expiry or re-authenticate the user's credentials. It occurs server-side using the stored refresh_token_hash values without requiring user input beyond the existing session cookie. This leverages the existing community_platform_user_sessions schema fields: refresh_token_hash for validation, session_expiry to check validity, is_active to confirm session status, and updated_at to record refresh events.\n\nThe operation follows the security best practice of token rotation to reduce the risk of compromise. The refresh token remains valid for 7 days from initial login, after which the user must re-authenticate through the login endpoint.","summary":"Refresh the access token for an admin user's authenticated session","parameters":[],"path":"/auth/admin/refresh","method":"post","name":"refresh","requestBody":{"description":"Refresh request with no additional data required (refresh token is included in HTTP-only cookie).","typeName":"ICommunityPlatformAdmin.IRefresh"},"responseBody":{"description":"New access token for continued session after token refresh.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"prerequisites":[]},{"specification":"This operation allows an admin to assign moderator privileges to any existing member within a designated community through the community_platform_moderator table. The system validates that the target admin is authorized to make this assignment, the user exists and is an active member, and the community is active. This operation is restricted to admin users only and creates a relationship between member and community in the moderator junction table.","authorizationType":null,"description":"This API operation enables a system administrator to assign moderator privileges to a member within a specific community. The root admin authenticates and calls this endpoint to grant moderation rights to another user. The system validates that the requester has admin privileges via the community_platform_admin table, the target user exists as an active member in the community_platform_member table (deleted_at is null), and the target community exists in the community_platform_communities table and is not suspended.\n\nThe operation creates a new record in the community_platform_moderator table with the member_id from the target user and the community_id from the target community, setting created_at to the current timestamp. The operation ensures no duplicate moderator assignments exist by validating against the unique constraint [member_id, community_id]. No new tokens are issued as this is a resource modification rather than an authentication operation.\n\nFor audit purposes, the operation logs the action in the community_platform_audit_logs table with actor_user_id as the admin performing the action, target_user_id as the member being assigned, target_community_id as the community, and action_description set to 'Admin assigned moderator role'. The description references the key community_platform_admin, community_platform_member, community_platform_communities, and community_platform_moderator tables and their fields to ensure compliance with schema constraints.\n\nThe operation may fail with specific error codes if the requester is unauthorized, user does not exist, community does not exist, or the assignment duplicate. These failure conditions ensure data integrity according to schema constraints.","summary":"Assign moderator role to a member within a specific community","parameters":[{"name":"memberId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the member to be assigned as moderator."},{"name":"communityId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the community for which the member is assigned as moderator."}],"path":"/admin/members/{memberId}/communities/{communityId}/moderator","method":"post","name":"assignModerator","requestBody":{"description":"No additional payload required - moderator assignment is determined by path parameters.","typeName":"ICommunityPlatformAdmin.IEmpty"},"responseBody":{"description":"Confirmation that the moderator assignment has been successfully created.","typeName":"ICommunityPlatformAdmin.IModeratorAssignment"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must exist before moderator privileges can be assigned to a member within it"},{"endpoint":{"path":"/communityPlatform/member/subscriptions","method":"post"},"description":"Member must be a registered user with an active account before being assigned moderator privileges"}]},{"specification":"This operation allows an admin to revoke moderator privileges from a member within a specific community by updating or deleting the moderator record in the community_platform_moderator table. This requires admin authentication and validates the relationship before removal.","authorizationType":null,"description":"This API operation enables a system administrator to remove moderator privileges from a member within a specified community. The admin authenticates with valid credentials and sends a request to delete the relationship between the member and community from the community_platform_moderator table.\n\nThe system first confirms the requester has admin privileges using the community_platform_admin table. Then it verifies that a moderator record exists in community_platform_moderator for the given member_id and community_id pair. If the record exists, it is deleted. Concurrently, the system logs this change in the community_platform_audit_logs table with actor_user_id as the revoking admin, target_user_id as the removed moderator, target_community_id as the affected community, and action_description set to 'Admin revoked moderator role'.\n\nThe operation ensures data integrity through schema enforcement, including foreign key constraints from community_platform_moderator to community_platform_member and community_platform_communities. This operation completes successfully only if the target relationship exists; if the moderator record does not exist, the system returns a 404. The request does not affect the target user's basic member status or community subscriptions.\n\nThe description references community_platform_admin, community_platform_moderator, and community_platform_audit_logs tables to ensure all referenced fields and relationships are properly verified according to the schema.","summary":"Revoke moderator role from a member within a specific community","parameters":[{"name":"memberId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the member whose moderator privileges are to be revoked."},{"name":"communityId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the community from which the member's moderator privileges are to be revoked."}],"path":"/admin/members/{memberId}/communities/{communityId}/moderator","method":"delete","name":"revokeModerator","requestBody":{"description":"No additional payload required - moderator revocation is determined by path parameters.","typeName":"ICommunityPlatformAdmin.IEmpty"},"responseBody":{"description":"Confirmation that the moderator assignment has been successfully revoked.","typeName":"ICommunityPlatformAdmin.IModeratorRevocation"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/admin/members/{memberId}/communities/{communityId}/moderator","method":"post"},"description":"Moderator relationship must be established before it can be revoked"}]},{"specification":"This operation allows an admin to system-wide ban a user by updating the community_platform_member record with a deleted_at timestamp. This action removes the user from all communities, prevents re-registration with the same email or username, and ensures appropriate notification and audit logging.","authorizationType":null,"description":"This API operation authorizes a system administrator to perform a system-wide ban on any user account. When invoked, the system validates that the requester has admin privileges in the community_platform_admin table. The target user is identified by their member_id, which is verified in the community_platform_member table to ensure existence and confirm the account is active (deleted_at is null).\n\nThe operation then updates the community_platform_member record for the target user by setting the deleted_at field to the current timestamp, effectively soft-deleting the account. This immediately revokes all permissions, removes access to the platform, and prevents authentication. The system also invalidates all active sessions for this user by setting is_active to false in all entries in the community_platform_user_sessions table.\n\nThe operation logs this action in the community_platform_audit_logs table with actor_user_id as the banning admin, target_user_id as the banned user, and action_description set to 'Admin banned user'. Simultaneously, a notification is sent to the banned user via the community_platform_notifications table if email notification is enabled.\n\nThe description references key schema fields: deleted_at for account deactivation, user_sessions for session invalidation, and audit_logs for compliance tracking. The ban is irreversible without database intervention, ensuring disciplinary actions are permanent. User data is preserved in the system for compliance purposes, but becomes inaccessible to the user.","summary":"Permanently ban a user from the entire communityPlatform system","parameters":[{"name":"userId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the user to be banned from the entire system."}],"path":"/admin/users/{userId}/ban","method":"post","name":"banUser","requestBody":{"description":"An optional reason for the ban, which will be included in the audit log and notification.","typeName":"ICommunityPlatformAdmin.IBanReason"},"responseBody":{"description":"Confirmation that the user has been permanently banned from the system.","typeName":"ICommunityPlatformAdmin.IUserBanStatus"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"User must be created before they can be banned. The ban operation requires a valid user record to exist in the system, which is created by the POST /communityPlatform/member/communities operation."}]},{"specification":"This operation allows an admin to unban a previously banned user by removing the deleted_at timestamp from the community_platform_member record. This restores the user's account and re-enables authentication while preserving all previous data, including karma and subscription history.","authorizationType":null,"description":"This API operation permits a system administrator to unban a previously banned user account. The process begins with authentication validation to confirm the requester has admin privileges in the community_platform_admin table. The target user is identified by member_id, which is checked in the community_platform_member table to verify that the deleted_at field is not null, confirming the user is indeed banned.\n\nThe system then updates the community_platform_member record by setting the deleted_at field to null. This restores the user's account status, allowing the user to log in again using their existing credentials, and reinstates all previous site access rights including karma scoring and subscription preferences. The system also updates all previously invalidated sessions by setting is_active to true in the community_platform_user_sessions table for the user's previous sessions.\n\nThis action is logged in the community_platform_audit_logs table with actor_user_id as the unbanning admin, target_user_id as the restored user, and action_description set to 'Admin unbanned user'. The previous moderation actions and content history remain preserved in the database, ensuring full auditability and transparency.\n\nThe description references the community_platform_member, community_platform_user_sessions, and community_platform_audit_logs schemas to confirm that the operation properly utilizes the deleted_at field for state management and maintains data integrity through foreign key constraints and audit trails.","summary":"Restore a previously banned user's access to the entire communityPlatform system","parameters":[{"name":"userId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the user to be unbanned from the entire system."}],"path":"/admin/users/{userId}/unban","method":"post","name":"unbanUser","requestBody":{"description":"An optional reason for the unban, which will be included in the audit log and notification.","typeName":"ICommunityPlatformAdmin.IUnbanReason"},"responseBody":{"description":"Confirmation that the user has been successfully unbanned from the system.","typeName":"ICommunityPlatformAdmin.IUserUnbanStatus"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"User must be created before they can be unbanned. The unban operation requires a valid user record to exist in the system, which is created by the POST /communityPlatform/member/communities operation."}]},{"specification":"This operation allows an admin to reset any user's password through a secure, audit-protected process. The system generates a temporary reset token and sends it via email to the target user, while logging all details in community_platform_password_resets and community_platform_audit_logs tables for security compliance.","authorizationType":null,"description":"This API operation provides authorized system administrators with the capability to force a password reset for any user account on the communityPlatform system. The admin authenticates and submits a request with the target user's member_id from the community_platform_member table.\n\nThe system generates a cryptographically secure, time-limited (15-minute) reset token, which is stored in the community_platform_password_resets table with the token_hash, expires_at, requested_at timestamps, and associated with the target member_id. The plain token is sent to the user's registered email via the SendGrid integration.\n\nThe operation logs the action immediately in the community_platform_audit_logs table with actor_user_id as the admin initiator, target_user_id as the user whose password is being reset, and action_description set to 'Admin initiated password reset for user'. This ensures full accountability for all password reset requests.\n\nThe operation differs from standard user-initiated password resynchronization (which requires identity verification) by bypassing all identity verification requirements due to the admin's elevated privileges. The target user is notified via email, but cannot initiate the reset themselves. The actual password is not changed until the user clicks the reset link.\n\nAll actions reference specific community_platform_member, community_platform_password_resets, and community_platform_audit_logs table fields to ensure strict compliance with the schema and to prevent unauthorized operations.","summary":"Trigger a password reset for any user account via admin-initiated request","parameters":[{"name":"userId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the user whose password needs to be reset."}],"path":"/admin/users/{userId}/password/reset","method":"post","name":"resetPassword","requestBody":{"description":"An optional note explaining the reason for the password reset, included in the audit log.","typeName":"ICommunityPlatformAdmin.IResetPasswordNote"},"responseBody":{"description":"Confirmation that the password reset request has been initiated and notification has been sent.","typeName":"ICommunityPlatformAdmin.IPasswordResetInitiated"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/admin/users/{userId}/ban","method":"post"},"description":"The target user must exist in the system before a password reset can be initiated."}]},{"specification":"This operation allows an admin to force verify any user's email address to bypass the normal email verification workflow. This enables administrators to grant posting and commenting privileges to users who have not completed the verification process yet.","authorizationType":null,"description":"This API operation grants a system administrator the ability to forcibly verify any user's email address, overriding the standard email verification workflow. The admin authenticates and submits a request with the target user's member_id from the community_platform_member table.\n\nThe system validates that the requester has admin privileges in the community_platform_admin table and that the target user exists in community_platform_member. If the user's is_verified field is already true, the operation does nothing and returns a success status. If is_verified is false, the system updates the community_platform_member table by setting is_verified to true and updates the updated_at timestamp to the current time.\n\nThe system also deletes any unexpired email verification records in the community_platform_email_verifications table associated with this user, as they are no longer needed. The change is logged in community_platform_audit_logs table with actor_user_id as the admin, target_user_id as the user, and action_description set to 'Admin forced email verification for user'.\n\nThis operation is crucial for administrative management, allowing trust-based access for users who have valid external identity verification, or for resolving technical issues with email delivery. It directly interacts with the community_platform_member.is_verified field and modifies the state according to the business requirement that admin overrides can bypass standard verification.\n\nThe description references the community_platform_admin, community_platform_member, and community_platform_email_verifications tables to ensure schema compliance and auditable changes.","summary":"Force email verification for any user account to grant posting privileges immediately","parameters":[{"name":"userId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID of the user whose email verification should be forced."}],"path":"/admin/users/{userId}/email/verify","method":"post","name":"forceVerifyEmail","requestBody":{"description":"An optional note explaining the reason for forcing verification, included in the audit log.","typeName":"ICommunityPlatformAdmin.IForceVerifyNote"},"responseBody":{"description":"Confirmation that the user's email has been successfully verified.","typeName":"ICommunityPlatformAdmin.IEmailVerified"},"authorizationRole":"admin","prerequisites":[{"endpoint":{"path":"/admin/users/{userId}/ban","method":"post"},"description":"The target user must exist in the system before email verification can be forced."}]},{"specification":"This operation retrieves a paginated, filtered, and sorted list of communities based on advanced search criteria such as name, description, NSFW status, and public visibility. It supports full-text search on community names and descriptions using trigram indexing, and allows sorting by member count, post count, or creation date. The operation is designed for community discovery and feed personalization, querying the community_platform_communities table which contains the core attributes for community discovery like name, description, is_public, and nsfw. This endpoint supports large-scale pagination and is optimized for performance with appropriate database indexes on name, is_public, nsfw, member_count, and post_count. Filtering is performed server-side with proper authorization checks requiring no authentication for public communities, but hides private communities from unauthenticated users.","path":"/communityPlatform/communities","method":"patch","summary":"Search and retrieve a filtered, sorted, and paginated list of communities","description":"Retrieve a paginated, filtered, and sorted list of public and user-subscribed communities based on advanced criteria. This operation supports comprehensive search capabilities for discovering communities by name or description keywords, filtering by visibility (public/private), NSFW status, and sorting by member count, post count, or creation date. The operation queries the community_platform_communities table, using its indexed fields for optimal performance. For unauthorized users, only public communities (is_public = true) are returned. For authenticated users, both public and subscribed private communities are included based on community_platform_subscriptions join. This matches the performance requirements of under 2 seconds for 50 results and supports infinite scrolling. The operation also respects the platform's max_community_members limit in results to prevent excessively large response sizes. Authorization roles are empty as this is a public-facing discovery endpoint, though internal business logic filters results based on session state.\n\nThis endpoint is crucial for user onboarding and engagement, allowing new users to find communities matching their interests and existing users to discover new content. It supports the \"hot\" and \"top\" list scalings defined in the business rules by allowing clients to sort by member_count and post_count. The trigram indexing on name and description enables efficient fuzzy matching for search queries.\n\nThe operation returns community summary data including only essential fields to minimize payload size. It excludes sensitive fields like the description (unless specifically requested) and does not include relationships to moderators or settings to prevent unintended data leakage. The response uses IPageICommunityPlatformCommunity.ISummary to ensure consistent output format across all list endpoints.\n\nRelated operations:\n- GET /communities/{communityId} retrieves detailed information about a specific community, which might be reached after selecting from this list.\n- PATCH /communities/{communityId}/subscribe allows users to add a community to their subscription list after discovering it via this search.\n- PATCH /users/{userId}/subscriptions retrieves a user's subscribed communities list, which may be merged with this search for personalized feeds.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for community filtering","typeName":"ICommunityPlatformCommunity.IRequest"},"responseBody":{"description":"Paginated list of community summary information matching search criteria","typeName":"IPageICommunityPlatformCommunity.ISummary"},"authorizationType":null,"authorizationRole":null,"name":"search","prerequisites":[]},{"specification":"This operation retrieves the detailed information of a specific community by its unique identifier. It returns comprehensive data about the community including its name, description, visibility settings, NSFW status, and counts. This operation queries the community_platform_communities table to retrieve the primary community data, and conditionally joins with community_platform_community_settings to provide custom display information like title, banner image, and rules if available. The operation includes all fields defined in the Prisma schema with proper null handling for optional attributes like description and banner_url. The return payload is designed to support the community detail page experience, showing both standard metadata and any custom branding provided by moderators.\n\nAuthorization requires no role to view public communities, but private communities (is_public = false) are only accessible if the user is authenticated and subscribed to the community via community_platform_subscriptions. This ensures the platform's privacy model is enforced. The operation does not expose moderator lists or exact user counts of private communities to unauthorized users.\n\nThis operation responds with a single community object using the ICommunityPlatformCommunity type, which is the main full-detail schema for communities as defined in the Prisma schema. The operation avoids including the full moderation log or nested settings to keep response size manageable and respects the performance requirement of under 2 seconds for a single item request. This endpoint is essential for community landing pages as requested in the user journey model for \"Viewing Community Page\".","path":"/communityPlatform/communities/{communityId}","method":"get","summary":"Retrieve detailed information about a specific community","description":"Fetch the complete details of a single community identified by its unique UUID. This operation reads from the community_platform_communities table, which is the core entity representing each community on the platform. It retrieves the community's name, description, creation timestamp, is_public flag (determining visibility), nsfw flag (controlling explicit content filters), post_review_mode and comment_review_mode settings (determining moderation requirements), member_count, and post_count.\n\nFor optimal performance and data consistency, this operation also performs a left join with the community_platform_community_settings table to retrieve optional customizations such as the display title, banner_url, icon_url, and rules. These settings are nullable and only included if available, ensuring backward compatibility with communities that have not been customized.\n\nAuthorization is enforced based on the community's is_public flag and the user's authentication state and subscription status:\n- Public communities (is_public = true): Accessible to all users, including guests\n- Private communities (is_public = false): Only accessible to authenticated users who are subscribed to the community via community_platform_subscriptions\n- Non-subscribed users attempting to access a private community are denied access\n\nThis design protects user privacy while still permitting organic community discovery. The returned payload includes all immediately relevant metadata for display on a community detail page, including statistics like member_count and post_count to give users context about the community's size and activity.\n\nThe operation does not return relationships to posts, comments, or moderators to prevent N+1 query problems and maintain response performance under 2 seconds. Related operations like GET /communities/{communityId}/posts or GET /communities/{communityId}/moderators can be called separately if needed.\n\nProvisioned response schema ICommunityPlatformCommunity ensures data type consistency and alignment with the Prisma schema, and no fields are omitted or inferred — all field usage strictly follows the existing database structure.","parameters":[{"name":"communityId","description":"The unique identifier of the target community in UUID format","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information about the specified community","typeName":"ICommunityPlatformCommunity"},"authorizationType":null,"authorizationRole":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/subscriptions","method":"post"},"description":"Subscription must be created to access private communities via community_platform_subscriptions table"}]},{"specification":"This operation creates a new community (subreddit) on the platform. It requires a community name and optionally a description. The community is created as public by default and assigned to the authenticated member as its initial moderator. The name must be unique across the platform and follow naming conventions (alphanumeric and hyphens only). This operation directly maps to the community_platform_communities table and triggers the creation of a corresponding community_platform_community_settings record with default values.","path":"/communityPlatform/member/communities","method":"post","summary":"Create a new community","description":"Create a new community on the platform. When a member submits a new community name, the system validates that the name is unique and adheres to the following rules: Community names must be between 3 and 50 characters long, contain only alphanumeric characters and hyphens, and must not start or end with a hyphen. The system also checks that the name is not a reserved keyword (e.g., \"admin\", \"moderator\"). If validation passes, the system creates a new community record in the community_platform_communities table with is_public set to true, nsfw set to false, and default values for moderation settings (post_review_mode and comment_review_mode). The system automatically assigns the authenticated user as the primary moderator by creating a record in the community_platform_moderator table linking the member to the new community. A corresponding community_platform_community_settings record is created with default formatting options and a timestamp for creation. The community is immediately activated in the platform and appears in public listings. Security considerations include ensuring only authenticated members can create communities and preventing role escalation through community creation. Related API operations include GET /communities to list public communities and PUT /communities/{communityId} to update community settings after creation.","parameters":[],"requestBody":{"description":"Request body containing the details for creating a new community.","typeName":"ICommunityPlatformCommunity.ICreate"},"responseBody":{"description":"The newly created community object with its system-generated ID and all default settings.","typeName":"ICommunityPlatformCommunity"},"authorizationRoles":["member"],"name":"create","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"This operation updates the settings of an existing community. It allows mods or admins to modify the community's display title, description, visibility settings, moderation policies, and appearance. The operation requires the authenticated user to be the primary moderator of the community or an admin. This operation only modifies the community_platform_community_settings entity and does not change the base community_platform_communities record except for update tracking.","path":"/communityPlatform/moderator/communities/{communityId}","method":"put","summary":"Update a community's settings","description":"Update the configuration settings for an existing community. This operation allows a community moderator or platform administrator to modify the community's display title, description, banner and icon URLs, rules, and moderation preferences. The operation requires the authenticated user to have moderator privileges for this specific community, enforced through the community_platform_moderator table. The system validates that the request comes from a valid moderator or admin and that the community exists and has not been deleted. The operation updates the community_platform_community_settings record linked to the community through community_platform_community_id, adjusting fields such as title, banner_url, icon_url, rules, moderator_invite_only, and allow_self_post. It also updates the updated_at timestamp. The base community infrastructure (name, created_at) remains immutable. Security considerations include ensuring only authorized moderators can change settings and preventing unauthorized access through the community view. Related API operations include GET /communities/{communityId} to retrieve the current settings and POST /communities to create a new community.","parameters":[{"name":"communityId","description":"The unique identifier of the community to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Request body containing the updated settings for the community.","typeName":"ICommunityPlatformCommunitySettings.IUpdate"},"responseBody":{"description":"The updated community settings object with all modified fields and timestamps.","typeName":"ICommunityPlatformCommunitySettings"},"authorizationRoles":["moderator"],"name":"update","authorizationRole":"moderator","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must be created before its settings can be updated"}]},{"specification":"This operation permanently deletes a community from the platform. It removes the community record and all associated data including posts, comments, and subscriptions. This is a hard delete operation since there is no soft_delete_column defined in the community_platform_communities schema. The community must exist and be accessible to the caller, but since this is an administrative operation, only admins have the privilege to execute it.","path":"/communityPlatform/admin/communities/{communityId}","method":"delete","summary":"Permanently delete a community by its unique identifier","description":"This operation permanently deletes a community from the platform. The community is removed from the system entirely, including all associated posts, comments, subscriptions, settings, and audit records.\n\nThis is a hard delete operation that cannot be undone, as there is no soft_delete_column defined in the community_platform_communities schema. The deletion affects the entire community hierarchy: all community_platform_posts records with the matching community_platform_community_id are deleted, all community_platform_subscriptions linking users to this community are removed, all community_platform_community_settings for this community are removed, and all community_platform_audit_logs related to this community are preserved for audit purposes but the community itself is removed.\n\nSecurity considerations require that only users with admin privileges can execute this operation, as deleting a community is a high-impact administrative action. The caller must have admin role, and this operation will be enforced through the authorizationRoles field. The operation returns a 204 status code on success with no content response body.\n\nBusiness logic: This operation must trigger cascading deletion of all children records in the database relationships, which is handled at the database level with ON DELETE CASCADE constraints on the related tables. This prevents orphaned records across the system.\n\nRelated operations: This should only be called after confirming with the community moderators and when no further relevance exists for the topic. It should not be used for suspending communities; for suspension, use the community status update to inactive instead.","parameters":[{"name":"communityId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The UUID identifier of the community to be permanently deleted."}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation searches and retrieves paginated posts with advanced filtering, sorting, and search capabilities across all communities. It supports complex queries based on community, author, time range, and sorting algorithms (new, hot, top, controversial). The operation uses the community_platform_posts table as its data source and implements search functionality across title and content fields using full-text search.","path":"/communityPlatform/posts","method":"patch","summary":"Search and retrieve paginated posts with filtering and sorting options","description":"This operation retrieves a paginated list of posts from the platform with advanced filtering, searching, and sorting capabilities. It supports querying across all communities or a specific community, filtering by author, time ranges, and applying different ranking algorithms for sorting.\n\nThe operation supports pagination with configurable page size and cursor/offset-based navigation. Users can search posts by keyword across the title and content fields using full-text search capabilities (GIN indexes on title and content). Sorting can be performed using the four algorithms defined in the business rules: 'new', 'hot', 'top', and 'controversial'. The default sort algorithm can be overridden by the request parameter.\n\nSecurity considerations include restricting sensitive post data based on visibility settings (nsfw posts require explicit user settings) and respecting community visibility (public vs private communities). The operation returns summarized post data optimized for display in feeds rather than full-post details.\n\nThis operation integrates with the community_platform_posts table as defined in the Prisma schema and is the primary mechanism for content discovery on the platform. It does not return individual post images or links - instead, it returns metadata pointers to these resources. The operation is designed to handle high request volumes efficiently through proper indexing (created_at, community_platform_community_id, status, vote_count).\n\nRelated operations: This operation can be preceded by GET /communities to discover communities to search within, and can be followed by GET /posts/{postId} to retrieve detailed post information.","parameters":[],"requestBody":{"description":"Search criteria, pagination parameters, and sorting preferences for post filtering","typeName":"ICommunityPlatformPost.IRequest"},"responseBody":{"description":"Paginated list of post summary information matching search criteria","typeName":"IPageICommunityPlatformPost.ISummary"},"authorizationType":null,"authorizationRole":null,"name":"search","prerequisites":[]},{"specification":"This operation creates a new post in a community. It accepts a title, content type (text, link, or image), and corresponding content data (text body, URL, or image reference). The post is associated with the authenticated user and a specified community. The system validates the post content according to business rules (character limits, file size, URL format) and assigns initial metadata (vote_count = 0, comment_count = 0, created_at = current timestamp). The post's status is set based on the community's post_review_mode: 'published' if false, 'unreviewed' if true. This operation maps to the community_platform_posts table, which stores post metadata, content, and association with author and community.","path":"/communityPlatform/member/posts","method":"post","summary":"Create a new post in a community","description":"This operation allows an authenticated member to create a new post within a specific community on the platform. When a user submits a post, the system validates the input according to strict business rules: the title must be between 1 and 300 characters, and the content body (if text type) must be between 1 and 10,000 characters; for link posts, a valid HTTP/HTTPS URL is required; for image posts, a valid image file (under 10MB) must be uploaded. The post's author is automatically inferred from the authenticated user's session, and the community is specified in the request.\n\nThe post's metadata is initialized with zero upvotes and downvotes, zero comments, and a timestamp of creation. Based on the community's configuration, the post's visibility status is determined: if the community requires post review mode, the status is set to 'unreviewed' and the post will not be visible to other users until approved by a moderator; otherwise, the status is set to 'published' immediately. This behavior ensures that communities can maintain content quality control while allowing public communities to enable immediate posting.\n\nThe operation persists the post data in the community_platform_posts table, linking it to the author's user ID and the community's identifier. A related audit log is automatically generated to track the creation event. The response returns the full created post object, including its unique ID, enabling the client to reference or manage the newly created post. The system enforces a rate limit of five posts per hour per user to prevent spam.","parameters":[],"requestBody":{"description":"The data required to create a new post, including its title, content type, and the specific content (text body, URL, or image).","typeName":"ICommunityPlatformPost.ICreate"},"responseBody":{"description":"The newly created post object, including its unique identifier, metadata, content, and status. This represents the full state of the post immediately after creation in the database.","typeName":"ICommunityPlatformPost"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must be created before a post can be associated with it"}]},{"specification":"This operation retrieves a single post by its unique identifier. It fetches the full post details from the database, including its title, content, author, associated community, vote count, comment count, and status. This operation is used to display an individual post and its entire context in a detail view. It maps directly to the community_platform_posts table, which stores the core post data and metadata.","path":"/communityPlatform/posts/{postId}","method":"get","summary":"Retrieve a specific post by its ID","description":"This operation allows a user to retrieve detailed information about a single, specific post by providing its unique UUID identifier. When a client requests a post by its ID, the system performs a direct lookup in the community_platform_posts table to fetch the complete record. The response includes all critical post information: the title, the content body (if text), the URL (if a link post), the image reference (if an image post), the author's ID, the community ID, the current vote score (calculation of upvotes minus downvotes), the number of comments on the post, and its moderation status (e.g., 'published', 'unreviewed', 'removed').\n\nThe system ensures that only posts with a status of 'published' or 'unreviewed' are returned to users who do not have moderator or admin privileges. Posts with a status of 'removed' or 'archived' are excluded from the response for security and policy compliance. For users with appropriate permissions (moderator or admin), additional metadata may be included, such as the deletion timestamp. This operation supports the core web flow where users click on a post title from a feed to view it in isolation.\n\nThe operation is designed to be fast and efficient for single-item retrieval, and it directly references the community_platform_posts table's structure, ensuring that the returned schema is a complete representation of the underlying entity. This endpoint is fundamental for the detailed post view, enabling the display of the post and its related content, including any linked images or URLs, and serving as the foundation for user interaction like commenting and voting.","parameters":[{"name":"postId","description":"The unique identifier of the post to retrieve, formatted as a UUID.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"The complete post entity including its ID, title, content, author, community, vote count, comment count, status, and creation timestamp.","typeName":"ICommunityPlatformPost"},"authorizationType":null,"authorizationRole":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must exist to validate the post's association"}]},{"specification":"This operation updates an existing post by its unique identifier. The post must exist and be owned by the authenticated user. This operation allows modification of the post's title and content fields, with validations for character limits. Post type cannot be changed after creation. Updates are recorded in the post's updated_at timestamp. Operations are permitted within 15 minutes of post creation, as defined by community_platform_platform_settings.post_edit_window_minutes.","path":"/communityPlatform/member/posts/{postId}","method":"put","summary":"Update a post by ID within edit window","description":"This operation allows authenticated members to update their own posts by providing a new title and/or content. The post must be owned by the authenticated user and can only be modified within the 15-minute edit window defined by the platform settings.\n\nThe operation requires the postId to be a valid UUID reference to an existing post. The user must be the original author, and the post must not have been deleted or removed. Only the title and content fields can be updated; the post_type field cannot be modified after creation.\n\nThe update operation validates character limits: title must be between 1 and 300 characters, and content must be between 1 and 10,000 characters for text posts. If the post type is link or image, the content field may be updated but complete URL or image specifications cannot be modified.\n\nThe operation updates the post's updated_at timestamp to the current datetime. All updates are logged in the community_platform_post_snapshots table for audit purposes, capturing the state of the post before modification.\n\nAuthentication is required to perform this operation. Membership verification is enforced through the JWT token, and post ownership is validated against community_platform_posts.author_id. Users attempting to update posts they don't own receive a 403 Forbidden response.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The unique identifier of the post to be updated. Must be a valid UUID that exists in the community_platform_posts table."}],"requestBody":{"description":"The updated content for the post, including title and optional content fields. Must be valid JSON object with appropriate constraints.","typeName":"ICommunityPlatformPost.IUpdate"},"responseBody":{"description":"The updated post object reflecting changes made, including revised title, content, and updated_at timestamp.","typeName":"ICommunityPlatformPost"},"authorizationRoles":["member"],"name":"update","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"This operation permanently deletes a post by its unique identifier. The post must exist and be owned by the authenticated user. This is a hard delete operation that removes the post from the database and all associated content, including comments, votes, and related assets. Post deletion is allowed at any time, regardless of edit window restrictions.","path":"/communityPlatform/member/posts/{postId}","method":"delete","summary":"Permanently delete a post by ID","description":"This operation permanently removes a post from the system and its associated data. The post must be owned by the authenticated user making the request, with ownership verified against community_platform_posts.author_id.\n\nThis is a hard delete operation that completely removes the post from the database without soft deletion markers. The operation cascades to delete all associated comments in the community_platform_comments table, post votes in community_platform_post_votes, post images in community_platform_post_images, post links in community_platform_post_links, and related audit logs. This ensures complete data removal from the system.\n\nAfter deletion, the post cannot be recovered. The deleted_at field is not utilized for posts since this is a hard delete operation as defined by the database schema, which lacks a deleted_at column for posts.\n\nAuthentication is required to perform this operation. The user must be the post owner. Users attempting to delete posts they don't own receive a 403 Forbidden response. The operation will succeed even if the post has received many votes or has been reported.\n\nThe deletion triggers an audit log entry in the community_platform_audit_logs table, recording the deletion action with the user's ID and timestamp. No response body is returned upon success, consistent with REST conventions for delete operations.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The unique identifier of the post to be deleted. Must be a valid UUID that exists in the community_platform_posts table and is owned by the authenticated user."}],"requestBody":null,"responseBody":null,"authorizationRoles":["member"],"name":"erase","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"This operation retrieves a specific comment from a post using its unique identifier. It operates on the community_platform_comments table from the Prisma schema, returning the full comment details including content, vote count, creation timestamp, and moderation status. The comment must belong to the specified post and be in a published or active state to be returned. This endpoint is used by clients to display individual comment threads in response to user navigation or deep linking. The implementation ensures that comments are only returned if they are not deleted or removed, aligning with the status field in the Prisma schema.","path":"/communityPlatform/posts/{postId}/comments/{commentId}","method":"get","summary":"Retrieve a specific comment by its ID within a post","description":"Retrieve a specific comment by its unique identifier within a post. This operation targets the community_platform_comments table in the database, returning the full details of a single comment including its content, vote count, creation timestamp, and moderation status. The comment must be associated with the specified post via the community_platform_post_id foreign key relationship and must have a status of 'published' to be returned. Comments with status 'removed', 'archived', or 'unreviewed' are excluded from results and will return a 404 error.\n\nSecurity considerations include ensuring that only authenticated users can retrieve comments, although visibility of the comment is based on its moderation status rather than user permissions. The operation does not require any special role privileges beyond authentication, as comment content is generally public-facing. The response includes the comment's depth_level, which determines its visual nesting in the thread, and its updated_at timestamp to reflect any recent edits.\n\nThis operation integrates with the community_platform_comments table as defined in the Prisma schema, incorporating all available comment fields and relationships. The implementation follows the business rule that comment content cannot be edited after 10 minutes, so the updated_at field may be identical to the created_at field for older comments. This endpoint is typically called after a user navigates to a specific comment from a post listing or from an external link, making fast response time critical for user experience.\n\nRelated API operations include PATCH /posts/{postId}/comments to retrieve a paginated list of comments for a specific post, and DELETE /posts/{postId}/comments/{commentId} to remove a comment (only permitted for authors or moderators). Error handling follows the platform-wide pattern, returning 404 for non-existent or inaccessible comments and 403 for unauthorized access.","parameters":[{"name":"postId","description":"Unique identifier of the target post that contains the comment","schema":{"type":"string","format":"uuid"}},{"name":"commentId","description":"Unique identifier of the target comment to retrieve","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Details of the requested comment including content, metadata, and moderation status","typeName":"ICommunityPlatformComment"},"authorizationRole":null,"authorizationType":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"Post must be created before a specific comment within it can be retrieved"},{"endpoint":{"path":"/communityPlatform/member/posts/{postId}/comments","method":"post"},"description":"Comment must be created and validated within the post before it can be individually retrieved"}]},{"specification":"This operation retrieves a paginated, filtered, and sorted list of comments for a specific post. It operates on the community_platform_comments table from the Prisma schema, supporting advanced search, filtering by status, sorting by creation time or vote count, and pagination with configurable limits. This endpoint is designed for loading the full threaded comment section of a post and is the primary method for clients to fetch comments in batches as the user scrolls. The operation is stateless and idempotent, returning the same results given identical parameters regardless of session state.","path":"/communityPlatform/posts/{postId}/comments","method":"patch","summary":"Search and retrieve a paginated, filtered list of comments for a post","description":"Retrieve a paginated, filtered, and sorted list of comments associated with a specific post. This operation targets the community_platform_comments table in the database and supports complex querying to filter comments by moderation status, sort by creation date or vote count, and paginate results with customizable page sizes. The operation returns only comments with status 'published', excluding those with 'removed', 'archived', or 'unreviewed' statuses. This ensures users only see finalized, approved content.\n\nSecurity considerations include ensuring that only authenticated users can request comments, although the visibility of comments themselves is determined by their moderation status rather than the requesting user's role. The operation supports sorting by created_at (descending) for a 'newest first' view, or vote_count (descending) for a 'most popular' view, aligning with business rules that promote high-quality discussion. The limit parameter defaults to 20 comments per page (matching client-side loading patterns) and can be increased up to a maximum of 50 to prevent performance degradation.\n\nThis operation integrates with the community_platform_comments table as defined in the Prisma schema, incorporating all available comment fields and relationships. The response returns a paginated structure with metadata including total count, current page, and page size, optimized for efficient client-side rendering. Related API operations include GET /posts/{postId}/comments/{commentId} to retrieve a single comment by ID and POST /posts/{postId}/comments to create a new comment within the post. Implementation follows the platform-wide constraint that comment depth is limited to a maximum of 8 levels as defined in community_platform_platform_settings.max_comment_depth, but this operation does not filter by depth level itself.","parameters":[{"name":"postId","description":"Unique identifier of the target post for which to retrieve comments","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Search criteria, sorting preferences, and pagination parameters for filtering comments","typeName":"ICommunityPlatformComment.IRequest"},"responseBody":{"description":"Paginated list of comment summaries matching search criteria, with metadata for pagination","typeName":"IPageICommunityPlatformComment.ISummary"},"authorizationRole":null,"authorizationType":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"Post must be created before its comments can be retrieved or filtered"}]},{"specification":"This operation creates a new comment on a specific post within the communityPlatform system. It operates on the community_platform_comments table and requires the post ID in the path parameter. The comment content is limited to 2,000 characters as defined in the Prisma schema, and the operation automatically sets the comment depth level based on the parent comment (if any). The comment's status is set to 'published' if the community's comment_review_mode is disabled, or 'unreviewed' if review is required.","path":"/communityPlatform/member/posts/{postId}/comments","method":"post","summary":"Create a new comment on a specific post","description":"This operation allows an authenticated member to create a new comment in response to a specific post within the communityPlatform system. Comments are associated with both the target post and the authenticated user who created them. The system implements strict content validation, restricting comment text to a maximum of 2,000 characters as defined in the Prisma schema's community_platform_comments table.\n\nSecurity is enforced through the member authentication mechanism; only authenticated users can create comments. The operation automatically assigns the current user's ID as the comment's author_id and derives the community from the target post. The comment's depth_level is calculated based on whether the comment is a direct reply to the post (depth_level = 1) or a reply to another comment (depth_level = parent.depth_level + 1), with a hard limit of 8 levels defined in the community_platform_platform_settings.max_comment_depth configuration.\n\nThe moderation status of the new comment is determined by the target community's comment_review_mode setting. If the community requires moderation, the comment is created with status 'unreviewed' and becomes visible only after a moderator approves it. If no review is required, the comment is immediately published with status 'published'. This ensures both efficient user experience and robust content moderation controls.\n\nThe system records this action in the community_platform_audit_logs table with the actor_user_id set to the authenticated member and the target_post_id referencing the associated post, providing a full audit trail for platform governance.","parameters":[{"name":"postId","description":"Unique identifier of the target post to which the comment is being added. This must correspond to an existing post in the community_platform_posts table.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"The content of the new comment to be created, limited to 2,000 characters as defined in the Prisma schema. This is the text body of the comment with no HTML or markdown formatting permitted.","typeName":"ICommunityPlatformComment.ICreate"},"responseBody":{"description":"The created comment object with all its fields including the unique ID, author, timestamps, and moderation status. This represents a full instance of the community_platform_comments table.","typeName":"ICommunityPlatformComment"},"authorizationRole":"member","authorizationType":null,"name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"The target post must be created before a comment can be created on it."}]},{"specification":"This operation updates an existing comment on a specific post. It operates on the community_platform_comments table and requires both the post ID and comment ID in the path parameters. The update is restricted to the original author of the comment and is subject to a 10-minute edit window defined in the community_platform_platform_settings table. Any attempt to update a comment after this window closes returns an error, and the operation logs the edit in the community_platform_comment_snapshots table to preserve audit history.","path":"/communityPlatform/member/posts/{postId}/comments/{commentId}","method":"put","summary":"Update an existing comment","description":"This operation allows an authenticated member to modify an existing comment they previously created on a specific post. The update is strictly governed by the edit window defined in the community_platform_platform_settings.comment_edit_window_minutes field, which is set to 10 minutes. This constraint ensures content stability while allowing for minor corrections immediately after posting.\n\nThe operation verifies that the authenticated user is the original author of the comment by comparing the user_id in the authentication token with the author_id in the target comment record from the community_platform_comments table. If the user is not the author, the operation fails with an access denial. If the comment was created more than 10 minutes ago, the operation fails with an 'EDIT_WINDOW_EXPIRED' error code as defined in the business rules.\n\nWhen a successful update occurs, the system first creates a snapshot of the original comment state in the community_platform_comment_snapshots table, capturing the comment's content, depth_level, vote_count, and status at the moment before modification. This ensures complete auditability for moderation and compliance purposes. The system then updates the original comment record with the new content and sets the updated_at timestamp to the current system time.\n\nThe operation does not permit changing the parent_post_id or any other relationship fields, maintaining data integrity. The comment's moderation status (published/unreviewed/removed) also remains unchanged during an edit, preserving the community's moderation decisions. All edit operations are logged in the community_platform_audit_logs table with the actor_user_id set to the authenticated member and the target_comment_id pointing to the edited comment.","parameters":[{"name":"postId","description":"Unique identifier of the target post containing the comment to be updated. This must correspond to an existing post in the community_platform_posts table.","schema":{"type":"string","format":"uuid"}},{"name":"commentId","description":"Unique identifier of the target comment to be updated. This must correspond to an existing comment in the community_platform_comments table that is associated with the specified post.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"The updated content of the comment, limited to 2,000 characters as defined in the Prisma schema. This replaces the existing comment content. Must contain only plain text with no HTML or markdown formatting.","typeName":"ICommunityPlatformComment.IUpdate"},"responseBody":{"description":"The updated comment object with all its fields including the unique ID, author, timestamps, and moderation status. This represents a full instance of the community_platform_comments table reflecting the changes after the update operation.","typeName":"ICommunityPlatformComment"},"authorizationRole":"member","authorizationType":null,"name":"update","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"The target post must be created before a comment can be updated on it."}]},{"specification":"This operation permanently deletes a specific comment within a post. The system does not implement soft deletion as there is no deleted_at column in the community_platform_comments schema. This action removes the comment and all its nested replies from the database irreversibly. The operation is only available to the comment's author and administrators, with additional access controls enforced at the service layer based on ownership and permission checks.","path":"/communityPlatform/member/posts/{postId}/comments/{commentId}","method":"delete","summary":"Permanently delete a specific comment and its nested replies.","description":"This operation permanently removes a specified comment from the system, along with all of its nested replies. Unlike systems with soft deletion capabilities, the communityPlatform schema lacks a deleted_at column and implements only hard deletion. This means the comment is permanently removed from the database with no possibility of recovery, and all associated votes, audit logs, and notification records are also purged.\n\nSecurity considerations require that only the original author of the comment or a system administrator may initiate this deletion. The system implements a check to ensure the authenticated user matches the comment's author_id field. If the user is not the author and is not an administrator, the operation will fail with a permission denied error regardless of authentication status.\n\nThis operation affects the comment_count field of the parent post (community_platform_posts), which will be decremented by 1. The karma score for the comment's author will be recalculated to remove any upvotes or downvotes received on this comment. Additionally, any references to this comment in the community_platform_notification_queue will be removed and the associated notification will be marked as deleted.\n\nThis operation must not trigger a moderation action or report update, as deletion is not considered a moderation action but a user-initiated removal. The deletion is instantaneous and does not require review. This behavior aligns with the business requirements specified in section 8.8 of the functional requirements document, which states that users may delete their own comments at any time.\n\nRelated API operations that might be used together include retrieving the comment details before deletion (GET /posts/{postId}/comments/{commentId}) to confirm content, and retrieving the parent post to verify context before deletion.","parameters":[{"name":"postId","description":"Unique identifier of the post containing the comment.","schema":{"type":"string","format":"uuid"}},{"name":"commentId","description":"Unique identifier of the comment to be deleted.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":null,"name":"erase","prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts/{postId}/comments","method":"post"},"description":"Comment must be created before it can be deleted"}]},{"specification":"This operation permanently deletes a specific comment within a post. The system does not implement soft deletion as there is no deleted_at column in the community_platform_comments schema. This action removes the comment and all its nested replies from the database irreversibly. The operation is only available to the comment's author and administrators, with additional access controls enforced at the service layer based on ownership and permission checks.","path":"/communityPlatform/admin/posts/{postId}/comments/{commentId}","method":"delete","summary":"Permanently delete a specific comment and its nested replies.","description":"This operation permanently removes a specified comment from the system, along with all of its nested replies. Unlike systems with soft deletion capabilities, the communityPlatform schema lacks a deleted_at column and implements only hard deletion. This means the comment is permanently removed from the database with no possibility of recovery, and all associated votes, audit logs, and notification records are also purged.\n\nSecurity considerations require that only the original author of the comment or a system administrator may initiate this deletion. The system implements a check to ensure the authenticated user matches the comment's author_id field. If the user is not the author and is not an administrator, the operation will fail with a permission denied error regardless of authentication status.\n\nThis operation affects the comment_count field of the parent post (community_platform_posts), which will be decremented by 1. The karma score for the comment's author will be recalculated to remove any upvotes or downvotes received on this comment. Additionally, any references to this comment in the community_platform_notification_queue will be removed and the associated notification will be marked as deleted.\n\nThis operation must not trigger a moderation action or report update, as deletion is not considered a moderation action but a user-initiated removal. The deletion is instantaneous and does not require review. This behavior aligns with the business requirements specified in section 8.8 of the functional requirements document, which states that users may delete their own comments at any time.\n\nRelated API operations that might be used together include retrieving the comment details before deletion (GET /posts/{postId}/comments/{commentId}) to confirm content, and retrieving the parent post to verify context before deletion.","parameters":[{"name":"postId","description":"Unique identifier of the post containing the comment.","schema":{"type":"string","format":"uuid"}},{"name":"commentId","description":"Unique identifier of the comment to be deleted.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["member","admin"],"name":"erase","authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/posts/{postId}/comments","method":"post"},"description":"Comment must be created before it can be deleted"}]},{"specification":"This operation retrieves a paginated list of user subscriptions with advanced filtering, sorting, and searching capabilities. It operates on the community_platform_subscriptions table and supports comprehensive queries to retrieve a user's active subscription status, subscription date, and associated community information. The request body contains parameters for filtering by subscription status, sorting by date, and pagination controls.","path":"/communityPlatform/member/subscriptions","method":"patch","summary":"Search and retrieve a filtered, paginated list of user subscriptions.","description":"Retrieve a paginated and filtered list of the authenticated user's community subscriptions. This operation allows users to view all their subscribed communities with options to filter by the subscription's active status, sort by subscription creation date (asc/desc), and retrieve a specific page of results.\n\nAccording to the business requirements, users can subscribe to up to 1,000 communities. This operation respects the subscription limit and only returns subscriptions where the deleted_at field is null and the active flag is true. The response includes the community name, subscription creation date, and a flag indicating whether the community is publicly visible.\n\nSecurity considerations ensure that only the authenticated user (represented by user_id) can query their own subscription list. The system does not rely solely on JWT token validation but validates the user_id against the subscription records. No admin access is required as this is a user-specific data endpoint.\n\nThis operation integrates with the community_platform_subscriptions table as defined in the Prisma schema, incorporating all available subscription fields and relationships. The response includes community summary information optimized for list displays, with links to the full community details via the community/Id endpoint.\n\nThis operation is essential for the user profile and subscription management flow, as described in user journey steps 6.5 and 8.1 of the requirements. It supports the \"My Subscribed Communities\" panel functionality.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters filtering user subscriptions","typeName":"ICommunityPlatformSubscription.IRequest"},"responseBody":{"description":"Paginated list of user subscription summary information matching search criteria","typeName":"IPageICommunityPlatformSubscription"},"authorizationType":null,"authorizationRole":"member","name":"search","prerequisites":[]},{"specification":"This operation retrieves a specific subscription by its unique identifier. It fetches the subscription record from the database using the subscriptionId path parameter, returning details about the user's subscription status, creation date, and associated community. This operation corresponds to the community_platform_subscriptions table in the Prisma schema, which tracks the many-to-many relationship between users and communities.","path":"/communityPlatform/member/subscriptions/{subscriptionId}","method":"get","summary":"Retrieve a specific community subscription by ID","description":"Retrieve a specific community subscription by its unique identifier. This operation fetches the subscription record from the database using the subscriptionId path parameter, returning details about the user's subscription status, creation date, and associated community. This operation supports both authenticated users viewing their own subscriptions and administrators viewing any subscription.\n\nThe operation corresponds to the community_platform_subscriptions table in the Prisma schema, which tracks the many-to-many relationship between users and communities. The subscription record contains the member_id (user who subscribed), community_platform_communities_id (the community being subscribed to), created_at timestamp, updated_at timestamp, deleted_at soft-delete timestamp, and active boolean status flag.\n\nSecurity considerations require proper authorization: authenticated users may only view their own subscriptions, while administrators may view any subscription. The operation validates that the subscription exists and returns 404 if not found. Concurrency issues are handled by the database engine through standard locking mechanisms.\n\nThis operation complements the POST /subscriptions endpoint for creating new subscriptions and the GET /subscriptions endpoint for listing all subscriptions. It enables targeted retrieval of subscription details for user profile displays, subscription management interfaces, and administrative dashboards.","parameters":[{"name":"subscriptionId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Unique identifier of the subscription to retrieve. Must be a valid UUID."}],"requestBody":null,"responseBody":{"description":"Detailed information about the subscription including user, community, and status details","typeName":"ICommunityPlatformSubscription"},"authorizationRoles":["member"],"name":"at","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/subscriptions","method":"post"},"description":"Subscription must be created before it can be retrieved by ID"},{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must be created before a subscription can be established for it"}]},{"specification":"This operation creates a new community subscription for the authenticated user. It requires the user to be authenticated and adds an entry to the community_platform_subscriptions table linking the user to a specified community. The operation enforces business rules around subscription limits, community existence, and duplicate subscriptions. This corresponds to the community_platform_subscriptions table in the Prisma schema, which manages the many-to-many relationship between users and communities.","path":"/communityPlatform/member/subscriptions","method":"post","summary":"Subscribe to a community","description":"Subscribe the authenticated user to a specified community. This operation creates a new subscription record in the community_platform_subscriptions table, establishing the many-to-many relationship between a user and a community.\n\nThe request body must include the community_id field specifying the target community. The operation validates that the community exists, the user is not already subscribed to it, and the user has not exceeded the maximum subscription limit of 1,000 communities as defined in the community_platform_platform_settings table. The operation also checks that the community is not deleted or inactive.\n\nUpon success, the operation creates the subscription with active: true, created_at and updated_at timestamps set to the current time, and deleted_at set to null. The member_id is automatically populated from the authenticated user's profile.\n\nThe authorizationRoles include only \"member\" since only authenticated members can subscribe to communities. This operation does not allow guest access and does not require administrative privileges. Enabling a subscription triggers notifications to the user and updates the community's member_count field in the community_platform_communities table as a side effect.\n\nThis operation complements the GET /subscriptions endpoint for listing subscriptions and the DELETE /subscriptions/{subscriptionId} endpoint for unsubscribing.","parameters":[],"requestBody":{"description":"Information required to create a new community subscription","typeName":"ICommunityPlatformSubscription.ICreate"},"responseBody":{"description":"The newly created subscription record with all details","typeName":"ICommunityPlatformSubscription"},"authorizationRoles":["member"],"name":"create","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"This operation updates a user's subscription status for a specific community. It modifies the active flag in the community_platform_subscriptions table to either enable or disable the subscription. The endpoint accepts a subscription ID in the path and a JSON body with the active status. This operation is used when users manually unsubscribe from communities through the UI.","path":"/communityPlatform/member/subscriptions/{subscriptionId}","method":"put","summary":"Update subscription status for a specific community","description":"Update the subscription status for a specific community by setting the active flag in the community_platform_subscriptions table.\n\nThis operation allows users to re-enable a previously disabled subscription or modify the subscription status. When called with active: true, the subscription becomes active and the user will begin receiving content from the community in their feed. When called with active: false, the subscription is deactivated and the user will no longer see posts from this community in their feed.\n\nThe operation requires the subscriptionId path parameter to identify which subscription to modify. This ID corresponds to the primary key in the community_platform_subscriptions table.\n\nThe request body must contain the active boolean flag to specify the desired subscription state. If the subscription ID does not exist or belongs to a different user, the operation will return a 404 error. Only authenticated users can update their own subscriptions.\n\nThis operation does not delete the subscription record from the database - it only toggles the active flag. This preserves the subscription history and allows users to re-subscribe without losing their subscription preferences. The updated_at timestamp will be automatically updated to reflect when the change occurred.\n\nThis operation is related to the DELETE /subscriptions/{subscriptionId} endpoint which permanently removes the subscription record from the database.","parameters":[{"name":"subscriptionId","description":"Unique identifier of the subscription to update","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Subscription status update information","typeName":"ICommunityPlatformSubscription.IUpdate"},"responseBody":{"description":"Updated subscription details","typeName":"ICommunityPlatformSubscription"},"authorizationRoles":["member"],"name":"update","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"This operation deletes a user's subscription to a specific community from the system. It removes the subscription record permanently from the community_platform_subscriptions table, effectively un-subscribing the user upon request. This is different from updating the active flag to false, as it completely removes the subscription record.","path":"/communityPlatform/member/subscriptions/{subscriptionId}","method":"delete","summary":"Permanently delete a user's subscription to a community","description":"Permanently delete a user's subscription to a specific community from the database by removing the record from the community_platform_subscriptions table.\n\nThis operation completely removes the subscription record from the database when a user wants to permanently erase their subscription history. Unlike the PUT /subscriptions/{subscriptionId} endpoint which toggles the active flag, this operation performs a hard delete that removes all trace of the subscription.\n\nThe operation requires the subscriptionId path parameter to identify which subscription to delete. This ID corresponds to the primary key in the community_platform_subscriptions table. When successfully deleted, the operation returns a 204 No Content response with no body.\n\nThe user must be authenticated and the subscription must belong to them. Attempting to delete a subscription that doesn't exist or belongs to another user will return a 404 error.\n\nThis operation is meant for users who want to completely remove their subscription history from the system rather than just deactivating it. After deletion, the user would need to subscribe again to rejoin the community.\n\nThis operation is related to the PUT /subscriptions/{subscriptionId} endpoint which updates the active status of a subscription without deleting it.","parameters":[{"name":"subscriptionId","description":"Unique identifier of the subscription to delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["member"],"name":"erase","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/subscriptions","method":"post"},"description":"Subscription must exist before it can be deleted, requiring creation of subscription record in community_platform_subscriptions table."}]},{"specification":"This operation retrieves a specific report by its unique identifier. It fetches detailed information about a content report including the target type, reporter, status, reason, and timestamps. This is essential for moderator and admin workflows to review reported content. The operation operates on the community_platform_reports table from the Prisma schema.","path":"/communityPlatform/member/reports/{reportId}","method":"get","summary":"Retrieve a specific content report by ID","description":"This operation fetches detailed information about a specific content report identified by its unique reportId. The response includes the report's status (pending, dismissed, removed, escalated), the reason category selected by the reporter, optional additional context provided by the reporter, and timestamps for when the report was created and last updated.\n\nFor security and privacy compliance, the reporter's identity is anonymized from the content author and appears only as a user ID in the response, not as a username or email. This protects reporters from potential retaliation while still allowing administrators to audit report origins.\n\nA successful response returns the complete report record as defined in the Prisma schema's community_platform_reports table. This includes the reported content ID (post or comment), the reporter ID, the report reason (mapped to the community_platform_report_categories table), and the current status.\n\nThis operation requires authentication as a member, moderator, or admin. Regular members can view reports they themselves submitted, while moderators and admins can view any report on their assigned communities or the platform respectively.","parameters":[{"name":"reportId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The unique identifier of the report to retrieve. Must be a valid UUID conforming to RFC 4122."}],"requestBody":null,"responseBody":{"description":"The complete report object as stored in the system, including the target type, reporter, status, reason, and timestamp information.","typeName":"ICommunityPlatformReport"},"authorizationRoles":["member","moderator","admin"],"name":"at","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/reports","method":"post"},"description":"Report must exist before it can be retrieved, requiring creation of report record in community_platform_reports table."}]},{"specification":"This operation retrieves a specific report by its unique identifier. It fetches detailed information about a content report including the target type, reporter, status, reason, and timestamps. This is essential for moderator and admin workflows to review reported content. The operation operates on the community_platform_reports table from the Prisma schema.","path":"/communityPlatform/moderator/reports/{reportId}","method":"get","summary":"Retrieve a specific content report by ID","description":"This operation fetches detailed information about a specific content report identified by its unique reportId. The response includes the report's status (pending, dismissed, removed, escalated), the reason category selected by the reporter, optional additional context provided by the reporter, and timestamps for when the report was created and last updated.\n\nFor security and privacy compliance, the reporter's identity is anonymized from the content author and appears only as a user ID in the response, not as a username or email. This protects reporters from potential retaliation while still allowing administrators to audit report origins.\n\nA successful response returns the complete report record as defined in the Prisma schema's community_platform_reports table. This includes the reported content ID (post or comment), the reporter ID, the report reason (mapped to the community_platform_report_categories table), and the current status.\n\nThis operation requires authentication as a member, moderator, or admin. Regular members can view reports they themselves submitted, while moderators and admins can view any report on their assigned communities or the platform respectively.","parameters":[{"name":"reportId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The unique identifier of the report to retrieve. Must be a valid UUID conforming to RFC 4122."}],"requestBody":null,"responseBody":{"description":"The complete report object as stored in the system, including the target type, reporter, status, reason, and timestamp information.","typeName":"ICommunityPlatformReport"},"authorizationRoles":["member","moderator","admin"],"name":"at","authorizationRole":"moderator","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/reports","method":"post"},"description":"The report must exist in the system before it can be retrieved by moderator"}]},{"specification":"This operation retrieves a specific report by its unique identifier. It fetches detailed information about a content report including the target type, reporter, status, reason, and timestamps. This is essential for moderator and admin workflows to review reported content. The operation operates on the community_platform_reports table from the Prisma schema.","path":"/communityPlatform/admin/reports/{reportId}","method":"get","summary":"Retrieve a specific content report by ID","description":"This operation fetches detailed information about a specific content report identified by its unique reportId. The response includes the report's status (pending, dismissed, removed, escalated), the reason category selected by the reporter, optional additional context provided by the reporter, and timestamps for when the report was created and last updated.\n\nFor security and privacy compliance, the reporter's identity is anonymized from the content author and appears only as a user ID in the response, not as a username or email. This protects reporters from potential retaliation while still allowing administrators to audit report origins.\n\nA successful response returns the complete report record as defined in the Prisma schema's community_platform_reports table. This includes the reported content ID (post or comment), the reporter ID, the report reason (mapped to the community_platform_report_categories table), and the current status.\n\nThis operation requires authentication as a member, moderator, or admin. Regular members can view reports they themselves submitted, while moderators and admins can view any report on their assigned communities or the platform respectively.","parameters":[{"name":"reportId","in":"path","schema":{"type":"string","format":"uuid"},"description":"The unique identifier of the report to retrieve. Must be a valid UUID conforming to RFC 4122."}],"requestBody":null,"responseBody":{"description":"The complete report object as stored in the system, including the target type, reporter, status, reason, and timestamp information.","typeName":"ICommunityPlatformReport"},"authorizationRoles":["member","moderator","admin"],"name":"at","authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/reports","method":"post"},"description":"The report must exist in the system before it can be retrieved by admin"}]},{"specification":"This operation performs a search and filter operation across all content reports on the platform. It supports advanced filtering by reporter, target type, status, and report reason, as well as pagination and sorting. This is essential for moderators and administrators to triage and manage the volume of reported content. The operation operates on the community_platform_reports table from the Prisma schema.","path":"/communityPlatform/moderator/reports","method":"patch","summary":"Search and filter content reports with advanced criteria","description":"This operation provides a comprehensive search interface across all reported content on the platform. Unlike a simple GET, it accepts a complex request body containing search filters, pagination parameters, and sorting options to efficiently query reports without overloading the API.\n\nThe request body allows filtering by reporter user ID, target type ('post' or 'comment'), status ('pending', 'dismissed', 'removed', 'escalated'), report reason (mapped to community_platform_report_categories), and date ranges for created_at/updated_at. Sorting can be performed by creation date, update date, popularity of the target post, or number of moderator actions taken.\n\nPagination is handled with a limit and offset system, with a default limit of 25 reports per page and a maximum limit of 100. Results are sorted by creation date (newest first) by default but can be reordered based on other criteria specified in the request.\n\nThe response returns a paginated list of reports with only the essential data: report ID, target type, target ID, reporter ID, status, report reason, creation timestamp, and update timestamp. This minimizes response size. For full detail, clients should use the GET /reports/{reportId} endpoint with individual report IDs.\n\nAccess to this endpoint is restricted to moderators and administrators. Regular members cannot perform cross-report searches for privacy and security reasons, though they can only view reports they themselves submitted via the /reports/{reportId} endpoint.","parameters":[],"requestBody":{"description":"Search filter criteria, pagination parameters, and sorting options for querying reports.","typeName":"ICommunityPlatformReport.IRequest"},"responseBody":{"description":"Paginated list of reports matching the search criteria, with essential summary information for each report.","typeName":"IPageICommunityPlatformReport"},"authorizationRoles":["moderator","admin"],"name":"search","authorizationRole":"moderator","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must exist for posts and comments to be associated with it"},{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"Post must exist before being reported"},{"endpoint":{"path":"/communityPlatform/member/posts/{postId}/comments","method":"post"},"description":"Comment must exist before being reported"}]},{"specification":"This operation performs a search and filter operation across all content reports on the platform. It supports advanced filtering by reporter, target type, status, and report reason, as well as pagination and sorting. This is essential for moderators and administrators to triage and manage the volume of reported content. The operation operates on the community_platform_reports table from the Prisma schema.","path":"/communityPlatform/admin/reports","method":"patch","summary":"Search and filter content reports with advanced criteria","description":"This operation provides a comprehensive search interface across all reported content on the platform. Unlike a simple GET, it accepts a complex request body containing search filters, pagination parameters, and sorting options to efficiently query reports without overloading the API.\n\nThe request body allows filtering by reporter user ID, target type ('post' or 'comment'), status ('pending', 'dismissed', 'removed', 'escalated'), report reason (mapped to community_platform_report_categories), and date ranges for created_at/updated_at. Sorting can be performed by creation date, update date, popularity of the target post, or number of moderator actions taken.\n\nPagination is handled with a limit and offset system, with a default limit of 25 reports per page and a maximum limit of 100. Results are sorted by creation date (newest first) by default but can be reordered based on other criteria specified in the request.\n\nThe response returns a paginated list of reports with only the essential data: report ID, target type, target ID, reporter ID, status, report reason, creation timestamp, and update timestamp. This minimizes response size. For full detail, clients should use the GET /reports/{reportId} endpoint with individual report IDs.\n\nAccess to this endpoint is restricted to moderators and administrators. Regular members cannot perform cross-report searches for privacy and security reasons, though they can only view reports they themselves submitted via the /reports/{reportId} endpoint.","parameters":[],"requestBody":{"description":"Search filter criteria, pagination parameters, and sorting options for querying reports.","typeName":"ICommunityPlatformReport.IRequest"},"responseBody":{"description":"Paginated list of reports matching the search criteria, with essential summary information for each report.","typeName":"IPageICommunityPlatformReport"},"authorizationRoles":["moderator","admin"],"name":"search","authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPlatform/member/communities","method":"post"},"description":"Community must exist for posts and comments to be associated with it"},{"endpoint":{"path":"/communityPlatform/member/posts","method":"post"},"description":"Post must exist before being reported"},{"endpoint":{"path":"/communityPlatform/member/posts/{postId}/comments","method":"post"},"description":"Comment must exist before being reported"}]},{"specification":"This operation allows authenticated members to report inappropriate content (posts or comments) on the platform. The report is submitted with a reason category (`report_reason`) from predefined values and optionally additional context. The system infers whether the target is a post or a comment based on whether `reported_content_id` or `reported_comment_id` is provided, but not both. This operation triggers automated moderation flagging and queues the report for manual moderator review. It does not immediately remove content but initiates the platform’s reporting workflow as defined in the business rules and compliance requirements.","path":"/communityPlatform/member/reports","method":"post","summary":"Submit a report on a post or comment","description":"This operation enables authenticated members to formally report content they believe violates community guidelines. The report must specify the category of the violation using the `report_reason` field, which must be one of the pre-defined values from community_platform_report_categories: \"spam\", \"harassment\", \"inappropriate\", or \"other\". This field maps directly to the `name` field in the report categories table.\n\nThe system infers the target type from which ID is provided: \n- If `reported_content_id` is provided, the target is a post\n- If `reported_comment_id` is provided, the target is a comment\n- Exactly one of these fields MUST be provided; submitting both or neither is invalid\n\nThe reporter's identity is recorded anonymously to the content author but retained for audit purposes as required by GDPR and platform compliance policies. The report is immediately queued for moderator review.\n\nThe post or comment being reported must exist and be publicly visible. If the content has already been removed or deleted, the submission is rejected with an appropriate error. The report may include optional notes (up to 500 characters) to provide additional context to moderators, which are stored in `report_notes`.\n\nAll reports are logged in the community_platform_reports table and trigger events for analytics and audit logging. The operation supports rate limiting per user (max 10 reports per day) as specified in platform settings. If the user exceeds this limit, the operation returns a 429 Too Many Requests error.\n\nSuccessful report submission returns a 201 Created status with the report object’s ID and status. The operation does not return the full post or comment content, preserving privacy and reducing payload size. Content visibility is immediately affected if automated moderation systems classify it as high-risk (high toxicity_score or spam_score from Perspective API), but this decision is in the background and does not alter the API response to the reporter.\n\nRelated Operations: This operation is preceded by viewing a post or comment (GET /posts/{postId} or GET /comments/{commentId}) and is followed by moderator actions via GET /reports/{reportId} and PUT /reports/{reportId}/actions. This operation must be initiated before any moderation actions can occur.","parameters":[],"requestBody":{"description":"Payload containing the details of the content report, including the target content ID, report category, and optional additional context.","typeName":"ICommunityPlatformReport.ICreate"},"responseBody":{"description":"The newly created report record containing its ID, status, target, and timestamps.","typeName":"ICommunityPlatformReport"},"authorizationRoles":["member"],"name":"create","authorizationType":null,"authorizationRole":"member","prerequisites":[]}],"components":{"authorization":[{"name":"guest","description":"Users who have not logged in. Can view public content and communities but cannot post, vote, comment, or interact with the platform. Can access registration and login pages.","kind":"guest"},{"name":"member","description":"Authenticated users who can create and join communities, submit posts, comment on posts with nested replies, upvote or downvote content, earn karma, subscribe to communities, view their own profile and activity history, and report inappropriate content.","kind":"member"},{"name":"moderator","description":"Curated members selected by administrators to manage specific communities. Can moderate posts and comments within assigned communities, remove inappropriate content, ban users from their community, and pin important posts. Cannot manage system-wide settings or other communities.","kind":"member"},{"name":"admin","description":"System administrators with full access to manage all communities, users, and platform-wide settings. Can assign or revoke moderator roles, ban users system-wide, review reported content, and monitor platform health and compliance.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageICommunityPlatformCommunity.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommunity.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPlatformPost.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPost.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPlatformComment.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformComment.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPlatformSubscription":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformSubscription"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPlatformReport":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformReport"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ICommunityPlatformGuest.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The unique identifier for the guest session.\n\nThis value is generated by the system and corresponds to the id field in the community_platform_guest table.\n\nIt is used to identify the temporary guest session across multiple requests during the session lifetime."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authentication response containing the temporary guest JWT token and session details.\n\nThis type represents the successful response from the guest join and refresh operations.\n\nIt provides the client with the necessary credentials to maintain a temporary session with limited read-only access to the platform.\n\nThe guest session is ephemeral and cannot be used to perform authenticated actions like posting, commenting, or voting — these require a full member account.\n\nThe system relies on the community_platform_guest table to maintain the association between the guest ID and session state, ensuring security by preventing permanent anonymous access."},"ICommunityPlatformMember.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","minLength":5,"maxLength":254,"description":"The email address for the new member account.\n\nThis email serves as the primary identifier for authentication and communication.\n\nMust be unique across the platform as enforced by the unique constraint on the email field in the community_platform_member table.\n\nThe system sends a verification email to this address as part of the membership onboarding process, using the community_platform_email_verifications table to manage the verification token."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[a-zA-Z0-9_]+$","description":"The display username for the new member account.\n\nThis username will be publicly visible in posts and comments.\n\nMust be unique across the platform as enforced by the unique constraint on the username field in the community_platform_member table.\n\nOnly alphanumeric characters and underscores are allowed, as specified in the pattern constraint."},"password":{"type":"string","minLength":8,"maxLength":128,"pattern":"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$","description":"The password for the new member account.\n\nThis password must meet the complexity requirements defined in the business rules: at least 8 characters with at least one uppercase letter, one lowercase letter, and one digit.\n\nThe system will hash this password using bcrypt with a cost factor of 12 before storing it in the password_hash field of the community_platform_member table.\n\nThe plaintext password is never stored and is immediately discarded after hashing."}},"required":["email","username","password"],"description":"Request payload for member registration containing email, username, and password.\n\nThis schema defines the exact input structure expected by the POST /auth/member/join endpoint for creating a new member account.\n\nIt maps directly to the required fields in the community_platform_member table: email, username, and password_hash.\n\nThe system validates uniqueness and complexity constraints before creating the record.\n\nAfter successful registration, a corresponding email verification record is created in the community_platform_email_verifications table, which links to the new member via member_id."},"ICommunityPlatformMember.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated member.\n\nThis UUID is the primary key of the community_platform_member table and is used to identify the user across all system operations.\n\nThe field is required for linking authentication sessions and user-specific data. It is returned in all authorization responses to enable client-side user context management."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response containing JWT token.\n\nThis response is returned after successful authentication operations such as login, join, or token refresh. It contains the authenticated user's ID and token information to establish a secure session.\n\nThe token contains the user's role information and is signed with a cryptographic key. This enables stateless authentication on subsequent requests.\n\nThe response is designed to be consumed by web and mobile clients to maintain authentication state across requests. The ID field allows the client to identify the user without exposing sensitive information like email or username.\n\nThe token property references the standard IAuthorizationToken type to ensure consistent token structure across all user roles (member, moderator, admin). This structure enables complete JWT token lifecycle management."},"ICommunityPlatformMember.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The email address associated with the member account for authentication.\n\nThis field is required for login operations and must match a registered email in the community_platform_member table. The email format must be valid according to standard email syntax rules.\n\nBusiness rules require this field to be unique across the platform, and the system enforces this constraint during both registration and login operations. This field is used to identify the user account in the database and is crucial for the authentication process.\n\nThe description references the email field in the community_platform_member table, which has a unique constraint and is not nullable, ensuring this field must be provided and correctly formatted for successful authentication."},"password":{"type":"string","minLength":8,"maxLength":128,"description":"The plaintext password for authenticating the member account.\n\nThis field contains the user's password in plaintext format as submitted during the login request. The system will hash this password using bcrypt with a cost factor of 12 before comparing it against the stored password_hash in the community_platform_member table.\n\nBusiness rules dictate that passwords must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, and one digit.\n\nThis field is transmitted in plaintext during the login request but is never stored in plaintext in any database records. The system enforces this constraint to ensure secure password handling and prevent plain-text password storage. The password_hash field in the community_platform_member table stores the hashed version, while this field contains the raw password provided by the user for authentication."}},"required":["email","password"],"description":"Request payload for member login containing email and password for authentication.\n\nThis schema defines the structure of the login request body for member users on the communityPlatform. It contains two required fields: email and password, which are used to authenticate the user against the system.\n\nThe email field must be a valid email address that exists in the community_platform_member table and has been verified (is_verified = true). The password field must be the plaintext password that, when hashed with bcrypt, matches the password_hash stored in the database.\n\nThis schema is specifically designed for the /auth/member/login endpoint and is used to initiate the authentication flow for member accounts. It ensures all required authentication data is provided in a structured format with proper validation constraints.\n\nThe description references the specific fields required for authentication and the business logic around password validation and email verification as defined in the community_platform_member table schema and function specification. This ensures complete alignment between the API interface and the underlying data model."},"ICommunityPlatformMember.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"The refresh token used to authenticate the user and obtain a new access token.\n\nThis token is a long-lived credential issued during login or refresh operations and is stored securely in an HTTP-only cookie.\n\nThe token is validated by comparing its hash against the refresh_token_hash stored in the community_platform_user_sessions table.\n\nThis field is mandatory for the refresh operation and must be provided by the client in the HTTP-only cookie header. The refresh token cannot be used to modify user state or access protected resources directly; it is only valid for obtaining new access tokens. For security, this token expires after 7 days even if unused, and is rotated on each successful refresh.\n\nThe refresh token is a JWT string signed with the server's private key and contains minimal claims: the user ID, issuance time, and expiration time. It never contains sensitive data like passwords, emails, or roles. \n\nThis field is strictly defined by the authentication system's security model and corresponds to the refresh_token_hash field in the community_platform_user_sessions table."}},"required":["refresh_token"],"description":"Request payload for token refresh containing the refresh token (provided in the HTTP-only cookie).\n\nThis type represents the structure of the request body expected by the /auth/member/refresh endpoint. The refresh token must be provided as an HTTP-only cookie, not in the request body, but this schema defines the token field as required for type consistency and validation.\n\nThis schema is aligned with the community_platform_user_sessions table, where refresh_token_hash is stored and validated during the refresh operation.\n\nThe object contains exactly one field: refresh_token, which corresponds to the base64-encoded JWT string issued during login or previous refresh.\n\nAll other authentication data (user context, session status, device information) is derived from the token's signature and verified against the user_sessions table."},"ICommunityPlatformModerator.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The unique email address of the moderator being registered.\n\nThis must be a valid email format and must be unique across the entire platform.\n\nThis field is mandatory and corresponds to the email column in the community_platform_member table.\n\nEmail is used for authentication, notification delivery, and verification. It is subject to uniqueness constraints and must not be used by any other member.\n\nThe email is not displayed publicly and does not appear in the user interface.\n\nThis field is case-insensitive in processing and storage, but the case entered by the user is preserved."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[a-zA-Z0-9_]+$","description":"The display username for the moderator account.\n\nThis must be unique across the platform and contain only alphanumeric characters and underscores.\n\nThis field corresponds to the username column in the community_platform_member table and is used publicly for display in posts and comments.\n\nThe username is indexed for fast lookup and must not clash with existing usernames.\n\nThis field is required and cannot contain spaces, hyphens, or special characters except underscore.\n\nThe username is case-sensitive when matched for uniqueness but displayed as entered by the user."},"password":{"type":"string","minLength":8,"maxLength":128,"pattern":"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$","description":"The plain-text password for the new moderator account.\n\nThe password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, and one digit.\n\nThis password will be securely hashed using bcrypt with a cost factor of 12 before storage in the password_hash field of the community_platform_member table.\n\nThe password is never stored, logged, or transmitted in plaintext. It must be submitted in plaintext only during registration and immediately discarded after hashing.\n\nThe system will reject passwords containing known breaches or commonly used patterns via an external password security service if available.\n\nThis field is mandatory and corresponds to the password_hash storage requirement in the schema."},"bio":{"type":"string","maxLength":400,"description":"An optional short biography or self-description for the moderator's profile.\n\nThis text will be displayed on the moderator's public profile page if provided.\n\nIt is stored in the bio field of the community_platform_user_profiles table and should provide context about the moderator's interests or expertise.\n\nMaximum length is 400 characters to ensure efficient display and avoid excessive data storage.\n\nThis field is optional; if omitted, the profile will display the username as the display name."}},"required":["email","username","password"],"description":"Request body containing registration information for a new moderator account.\n\nThis schema defines the required fields for creating a new moderator user on the communityPlatform system.\n\nModerators are classified as 'member' kind users in the system and must complete full registration including email verification and password setup.\n\nThis object corresponds to the community_platform_member and community_platform_user_profiles tables.\n\nThe required fields (email, username, password) populate the community_platform_member table directly.\n\nThe optional bio field populates the community_platform_user_profiles table after the member record is created.\n\nThe password is not stored directly; it is hashed using bcrypt before being stored in the password_hash column.\n\nThe identification (email, username) must be unique across all members, not just moderators.\n\nThe system will generate an email verification token and send it upon successful registration."},"ICommunityPlatformModerator.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated moderator.\n\nThis identifier corresponds to the member_id in the community_platform_member table and is used as the primary key for authentication sessions."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response containing JWT token and moderator identification.\n\nThis response is returned after successful authentication operations such as login, join, or token refresh for moderator accounts. It follows the standard IAuthorized pattern where the moderator's identity is combined with a JWT token that enables secure API communication."},"ICommunityPlatformModerator.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The moderator's registered email address, used for authentication.\n\nThis field corresponds to the email column in the community_platform_member table. It must be a valid email address that has been previously registered and verified in the system.\n\nThe email serves as the unique identifier for the moderator's account during the login process. It must match exactly with a record in the community_platform_member table."},"password":{"type":"string","minLength":8,"maxLength":128,"description":"The plain-text password provided during login.\n\nThis password is used by the authentication system to verify identity against the stored password_hash in the community_platform_member table. It must meet the complexity requirements: at least 8 characters with a mix of uppercase, lowercase, and digit characters.\n\nSensitive information: The password is never stored in the system in plain text and is only used temporarily during authentication verification."}},"required":["email","password"],"description":"Login request payload for moderator authentication.\n\nThis structure provides the credentials required to authenticate a moderator user. It contains exactly two fields: the email (required) and password (required), which are validated against the community_platform_member table.\n\nThis DTO is used exclusively for the login operation and should not be confused with registration (IJoin) or refresh (IRefresh) structures, which have different field requirements."},"ICommunityPlatformAdmin.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The email address for the new admin account. Must be unique and follow standard email format."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[a-zA-Z0-9_]+$","description":"The display username for the admin account. Must be unique and contain only alphanumeric characters and underscores."},"password":{"type":"string","minLength":8,"maxLength":128,"pattern":"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$","description":"The password for the new admin account. Must be at least 8 characters with at least one uppercase letter, one lowercase letter, and one digit."}},"required":["email","username","password"],"description":"Request body for the ICommunityPlatformAdmin.IJoin type, containing registration information for creating a new admin account.\n\nThis schema defines the structure of the request body for the /auth/admin/join endpoint, which allows registration of new admin accounts.\n\nThe email field represents the administrator's contact email, which must be unique across the platform and follow standard email format. The username field is the public-facing identifier for the admin account, restricted to alphanumeric characters and underscores, with a character limit between 3 and 20. The password field must meet complexity requirements to ensure security: at least 8 characters with at least one uppercase letter, one lowercase letter, and one digit.\n\nThese fields directly correspond to the community_platform_member table in the database schema, where email and username have unique constraints, and password is stored as a bcrypt hash in the password_hash field. This schema ensures data integrity and security compliance during admin account registration by enforcing proper validation at the API level.\n\nNo other fields should be included as this schema precisely matches the business requirement that admin accounts are registered through the same member model, with ownership transferred only by existing admin users."},"ICommunityPlatformModerator.IRefresh":{"type":"object","properties":{},"required":[],"description":"Request body for the ICommunityPlatformModerator.IRefresh type, containing no payload as refresh is handled via HTTP-only cookies.\n\nThis schema represents the token refresh request for moderator users. The refresh operation authenticates using a refresh token stored in an HTTP-only, Secure, SameSite=Strict cookie rather than including any body payload. This design follows security best practices to prevent token interception and CSRF attacks.\n\nThe refresh token, when presented by the client, is validated against the refresh_token_hash stored in the community_platform_user_sessions table. The associated session's is_active status and session_expiry are checked to ensure validity. A new access token is issued and returned, while the refresh token is rotated for session security.\n\nThis schema intentionally contains no properties because all necessary authentication context is contained within the HTTP request headers (specifically, the refresh token in the cookie). This approach avoids exposing refresh tokens in request bodies and maintains strict separation of concerns.\n\nFollowing the authorization model, this refresh operation is only available to moderator users, who are classified as 'member' kind users requiring the complete authentication flow, including join, login, and refresh."},"ICommunityPlatformAdmin.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated admin user.\n\nThis field corresponds to the id field in the community_platform_member table and is used to identify the admin user in subsequent requests. The value is a UUID that uniquely identifies the admin account in the system."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response containing JWT token and admin user identification.\n\nThis response is returned after successful authentication operations such as admin login or token refresh. It provides the necessary credentials for the admin user to make authenticated requests to protected endpoints.\n\nThe structure follows the standard IAuthorized pattern for authentication responses, ensuring consistency across the API. The id field uniquely identifies the admin user, and the token field contains the encrypted JWT that authenticates subsequent requests."},"ICommunityPlatformAdmin.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The email address of the admin user for authentication.\n\nThis field corresponds to the email field in the community_platform_member table and contains the registered email address of the admin user. The email must be valid and match an existing account in the system for successful authentication. This field is required for login operations."},"password":{"type":"string","description":"The plain text password for the admin user's account.\n\nThis field contains the user's password as provided during the authentication request. The system will hash this value and compare it against the stored password_hash in the community_platform_member table. The password must meet complexity requirements (minimum 8 characters with uppercase, lowercase, and digit) as defined in the business rules."}},"required":["email","password"],"description":"Request payload for admin user login containing email and password for authentication.\n\nThis object is used as the request body when an admin user attempts to log into the system. It contains the credentials needed to verify the user's identity against the stored account information in the database.\n\nThe email field must contain a valid email address that matches an existing admin account, and the password field must contain the correct password for that account. Both fields are mandatory for successful authentication.\n\nThe system uses bcrypt hashing for password verification, with a cost factor of 12. The password is never stored in plaintext in the database; only the hashed version is retained in the password_hash field."},"ICommunityPlatformAdmin.IRefresh":{"type":"object","properties":{},"required":[],"description":"Request payload for token refresh containing the refresh token (provided in cookie header).\n\nThis type represents the body of a refresh token request for admin users. It is an empty object since the refresh token is provided in an HTTP-only, Secure, SameSite=Strict cookie header rather than in the request body. This design prevents token exposure in request bodies and leverages the security features of HTTP cookies.\n\nThe operation relies on the server to extract and validate the refresh token from the cookie, comparing its hash against the stored refresh_token_hash in the community_platform_user_sessions table. The absence of fields in this schema adheres to the security requirement that authentication tokens should not be transmitted in request bodies where they could be intercepted by client-side scripts.\n\nThis schema follows the pattern established for other refresh operations where the actual token data is managed client-side via secure storage (cookies) and not included in the payload.\n\nNo additional properties are required as the authentication context is completely handled through the cookie mechanism and server-side session validation."},"ICommunityPlatformAdmin.IEmpty":{"type":"object","properties":{},"required":[],"description":"No additional payload required - moderator assignment is determined by path parameters.\n\nThis type represents an empty request body used for operations where all required parameters are provided in the URL path rather than in the request body. It is used for administration endpoints like assigning or revoking moderator roles where the target user and community are identified through path parameters (e.g., /admin/members/{memberId}/communities/{communityId}/moderator).\n\nThe schema is intentionally empty because the system derives all necessary information from the URL path and the authenticated admin session. This design pattern ensures clean, RESTful API design where actions are triggered by path-based resource identification rather than by data in the request body.\n\nThis schema adheres to the principle that only data necessary to modify state should be included in the request body, and in this case, no data modification parameters are needed beyond the path identifiers.\n\nNo additional properties are included since:\n1. The operation is purely an identity-based action\n2. The target user and community are already specified in the path\n3. No extra data or configuration options are required for this administrative action\n\nThe response body for this operation will contain confirmation of the action, but the request body remains empty as defined by this schema."},"ICommunityPlatformAdmin.IModeratorAssignment":{"type":"object","properties":{"communityId":{"type":"string","format":"uuid","description":"The unique identifier of the community for which moderator privileges were assigned.\n\nThis corresponds to the community_platform_communities.id field in the Prisma schema.\n\nThe community_id is a UUID that uniquely identifies the community in the database and is referenced in the community_platform_moderator table as the community_id foreign key."},"memberId":{"type":"string","format":"uuid","description":"The unique identifier of the member who was assigned as moderator.\n\nThis corresponds to the community_platform_member.id field in the Prisma schema.\n\nThe member_id is a UUID that uniquely identifies the member account in the database and is referenced in the community_platform_moderator table as the member_id foreign key."},"assignedAt":{"type":"string","format":"date-time","description":"The timestamp when the moderator assignment was created.\n\nThis corresponds to the created_at field in the community_platform_moderator table.\n\nThe assignedAt timestamp represents the exact moment when this moderator role was granted by an admin, recorded in UTC."}},"required":["communityId","memberId","assignedAt"],"description":"Response object indicating successful assignment of moderator privileges to a member within a community.\n\nThis DTO represents the success response from the /admin/members/{memberId}/communities/{communityId}/moderator POST endpoint.\n\nIt includes the communityId, memberId, and assignedAt fields to confirm the assignment and provide audit context.\n\nThis type is used exclusively for reporting the outcome of moderator assignment and does not include sensitive information or relationships to other entities beyond the necessary identifiers and timestamp.\n\nAll fields are sourced directly from the community_platform_moderator and community_platform_communities tables per the Prisma schema.\n\nThe type is designed to be minimal and focused on the assignment outcome, ensuring no data leakage or unnecessary payload size.\n\nExample usage:\n{\n  \"communityId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"memberId\": \"550e8400-e29b-41d4-a716-446655440001\",\n  \"assignedAt\": \"2025-01-15T10:30:00Z\"\n}","x-autobe-prisma-schema":"community_platform_moderator"},"ICommunityPlatformAdmin.IModeratorRevocation":{"type":"object","properties":{"communityId":{"type":"string","format":"uuid","description":"The unique identifier of the community from which moderator privileges were revoked.\n\nThis corresponds to the community_platform_communities.id field in the Prisma schema.\n\nThe community_id is a UUID that uniquely identifies the community in the database and is referenced in the community_platform_moderator table as the community_id foreign key."},"memberId":{"type":"string","format":"uuid","description":"The unique identifier of the member whose moderator privileges were revoked.\n\nThis corresponds to the community_platform_member.id field in the Prisma schema.\n\nThe member_id is a UUID that uniquely identifies the member account in the database and is referenced in the community_platform_moderator table as the member_id foreign key."},"revokedAt":{"type":"string","format":"date-time","description":"The timestamp when the moderator privileges were revoked.\n\nThis corresponds to the time of deletion from the community_platform_moderator table.\n\nThe revokedAt timestamp represents the exact moment when this moderator role was removed by an admin, recorded in UTC."}},"required":["communityId","memberId","revokedAt"],"description":"Response object indicating successful revocation of moderator privileges from a member within a community.\n\nThis DTO represents the success response from the /admin/members/{memberId}/communities/{communityId}/moderator DELETE endpoint.\n\nIt includes the communityId, memberId, and revokedAt fields to confirm the revocation and provide audit context.\n\nThis type is used exclusively for reporting the outcome of moderator revocation and does not include sensitive information or relationships to other entities beyond the necessary identifiers and timestamp.\n\nAll fields are sourced directly from the community_platform_moderator and community_platform_communities tables per the Prisma schema.\n\nThe type is designed to be minimal and focused on the revocation outcome, ensuring no data leakage or unnecessary payload size.\n\nExample usage:\n{\n  \"communityId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"memberId\": \"550e8400-e29b-41d4-a716-446655440001\",\n  \"revokedAt\": \"2025-01-15T10:45:00Z\"\n}","x-autobe-prisma-schema":"community_platform_moderator"},"ICommunityPlatformAdmin.IUserBanStatus":{"type":"object","properties":{"userId":{"type":"string","format":"uuid","description":"The unique identifier (UUID) of the user who was banned.\n\nThis field identifies the specific member account that has been permanently banned from the platform.\n\nThe description field requires multiple paragraphs:\n\nThis property represents the user's unique identifier in the community_platform_member table, which is the primary key for the user record. When a user is banned, this ID is used to locate and update their record in the database by setting the deleted_at timestamp.\n\nThis field is returned in the response to confirm which user account was affected by the ban operation. It must be a valid UUID conforming to RFC 4122, ensuring uniqueness and compatibility with the system's database schema.\n\nThe field is not editable by users and can only be retrieved through administrative actions, ensuring proper audit trails and preventing manipulation of ban records."},"bannedAt":{"type":"string","format":"date-time","description":"The timestamp when the user account was permanently banned.\n\nThis field records the exact moment the admin's ban action was successfully executed in the system.\n\nThe description field requires multiple paragraphs:\n\nThis property contains the DateTime value indicating when the ban operation completed successfully, set according to the system's server time in Asia/Seoul timezone (UTC+9).\n\nIt corresponds to the deleted_at field in the community_platform_member table, which is updated to this timestamp during the ban process. This field is used for auditing, reporting compliance, and determining account state change timelines.\n\nThe value is automatically generated by the server and cannot be manipulated by clients or administrators. The timestamp format adheres to ISO 8601 with timezone information (e.g., \"2025-07-20T12:34:56.789Z\") to ensure standardized representation across systems."},"isPermanentlyBanned":{"type":"boolean","description":"A flag indicating whether the user has been permanently banned from the system.\n\nThis field always returns true as this endpoint only responds to successful ban operations.\n\nThe description field requires multiple paragraphs:\n\nThis property indicates the permanence of the ban action, confirming that the user's account has been permanently deactivated with no possibility of recovery through self-service means.\n\nSince this is a response type for the ban endpoint, the value is always true — its purpose is to explicitly confirm the nature of the operation's outcome rather than to represent variable state.\n\nThis boolean ensures clients can robustly interpret the server's response state, differentiating between temporary suspensions (handled elsewhere) and permanent user removals."}},"required":["userId","bannedAt","isPermanentlyBanned"],"description":"Response body confirming the permanent ban of a user on the communityPlatform system.\n\nThis type is returned after successfully executing an admin ban operation. It contains essential information about the banned user and the ban action itself, enabling client-side feedback and audit logging.\n\nThe description field requires multiple paragraphs:\n\nThis response type represents the output of the admin ban operation, providing a standardized format for confirming the permanent removal of a user from the platform.\n\nIt includes the userId (UUID of the banned member), the precise timestamp when the ban was applied (bannedAt), and a boolean flag (isPermanentlyBanned) confirming the permanence of the action.\n\nThese fields correspond directly to the database modifications made in the community_platform_member and community_platform_audit_logs tables, ensuring data consistency between the API response and persistent storage.\n\nThe type is designed to be minimal yet complete, providing sufficient context for client UI updates (e.g., showing banner messages) and backend auditing without exposing sensitive internal details such as moderator identities or additional metadata."},"ICommunityPlatformAdmin.IBanReason":{"type":"object","properties":{"reason":{"type":"string","description":"An optional reason for the ban, which will be included in the audit log and notification."}},"required":["reason"],"description":"Request body containing an optional reason for the ban, which will be included in the audit log and notification.\n\nThis object defines the structure of the ban reason payload for admin ban operations. The reason is optional but if provided, it must be a string with sufficient context to document the administrative action for audit and compliance purposes.\n\nThe reason should clearly describe why the ban was enacted, such as 'Violation of Community Guidelines: Harassment'. This context assists moderators and legal teams in understanding the basis for the action, especially in cases of user appeals or regulatory inquiries.\n\nAccording to the Prisma schema, this information logs in the community_platform_audit_logs table with action_description field, providing an audit trail for the system's administrative actions."},"ICommunityPlatformAdmin.IUnbanReason":{"type":"object","required":[],"properties":{"reason":{"type":"string","description":"An optional reason for the unban, which will be included in the audit log and notification."}},"description":"Request payload for unban operation containing an optional reason for the action.\n\nThis object represents the data structure used when an admin initiates a user unban operation. The reason field is optional and provides context for why the unban action was taken, which is then included in the system audit log and potentially in notifications to the affected user.\n\nThe structure is intentionally minimal, following the pattern defined for similar admin operations. Only a single string field is provided to capture the administrative rationale without introducing complexity.\n\nIn compliance with the business requirements and schema design principles, this payload does not include timestamps, user identifiers or other metadata - this information is derived from the authentication context and request metadata by the system."},"ICommunityPlatformAdmin.IUserUnbanStatus":{"type":"object","required":["userId","unbannedAt","status"],"properties":{"userId":{"type":"string","format":"uuid","description":"The UUID of the user who was successfully unbanned from the system."},"unbannedAt":{"type":"string","format":"date-time","description":"The timestamp when the user's account was successfully unbanned and restored."},"status":{"type":"string","const":"unbanned","description":"The fixed status indicator confirming the unban operation was successful.\n\nThis constant field serves as a clear machine-readable indicator that the user unban operation completed successfully. The value is always \"unbanned\" when returned by this API endpoint, providing deterministic confirmation of the outcome without requiring interpretation of other fields."}},"description":"Response payload confirming successful user unban operation.\n\nThis object represents the standardized response structure returned after a system administrator successfully unbans a previously banned user from the entire communityPlatform system.\n\nThe response contains three mandatory fields:\n\n- userId: The unique identifier of the user whose account has been restored\n- unbannedAt: The exact timestamp (in ISO 8601 format) when the unban operation was completed\n- status: A constant string \"unbanned\" that provides unambiguous confirmation of operation success\n\nThis response structure follows the consistent pattern established across similar admin operations, providing clear, machine-readable confirmation while excluding sensitive information or operational details that are unnecessary for client usage.\n\nThe returned data enables the client application to update the UI state appropriately after the unban operation. The system maintains detailed audit logs of this operation in the community_platform_audit_logs table, preserving the admin's identity and any provided reason for the action, but these audit details are not exposed in this API response for security and privacy reasons."},"ICommunityPlatformAdmin.IResetPasswordNote":{"type":"object","properties":{"reason":{"type":"string","minLength":0,"maxLength":1000,"description":"An optional reason for the password reset, which will be included in the audit log and notification.\n\nThis field provides context for why the admin initiated the password reset. It helps with auditing and communication with the affected user. The reason should be concise and descriptive, explaining the operational necessity or policy compliance reason behind the action. Examples include \"User reported security incident\", \"Password expired per policy\", or \"Suspected account compromise\".\n\nThis field is optional to maintain flexibility in administrative workflows, but it is highly recommended for compliance and account recovery transparency. The description length is constrained to 1000 characters to ensure efficient storage and display in audit logs and notifications."}},"required":[],"description":"Request payload for an admin-initiated password reset, containing an optional reason.\n\nThis schema defines the structure of the body sent when an administrator triggers a password reset for another user.\n\nThere is no requirement for the reason to be provided, as this is an administrative override action that may be performed under urgent conditions where documentation is not immediately available. However, in compliance with security best practices and audit requirements, providing a reason is strongly recommended.\n\nThe reason field helps future auditors and system administrators understand the context when reviewing password reset history. It should not contain sensitive information like the user's original password, personal details beyond what is necessary, or speculative information about the user's behavior."},"ICommunityPlatformAdmin.IPasswordResetInitiated":{"type":"object","properties":{"message":{"type":"string","description":"Confirmation that the password reset request has been initiated and notification has been sent.\n\nThis is a human-readable success message indicating that the system has processed the admin's request to reset the user's password. The message confirms two key outcomes:\n\n1. The password reset token has been successfully generated and stored in the database\n2. The email notification containing the reset link has been queued for delivery\n\nThe message is intended for display to the admin user on the interface to confirm successful operation.\n\nThis response does not contain any sensitive information or tokens. It is purely informational and ensures administrative transparency."}},"required":["message"],"description":"Response payload confirming successful initiation of an admin-initiated password reset.\n\nThis schema defines the structure of the response sent after an administrator successfully triggers a password reset for another user.\n\nThe response confirms that the system has performed all necessary actions: generating a secure reset token, storing it securely in the database, and queuing a notification email to be delivered to the affected user.\n\nThis confirmation message is intentionally simple and non-technical to display clearly on administrative interfaces. It avoids exposing internal system details like token IDs, expiration times, or email delivery statuses, which are stored in audit logs but not disclosed to users for security reasons.\n\nThe message field may be localized or formatted differently based on the admin's language preference, but the content structure remains the same across all locales.\n\nNo additional metadata is returned because this operation is idempotent and does not return new state beyond confirmation."},"ICommunityPlatformAdmin.IForceVerifyNote":{"type":"object","properties":{"reason":{"type":"string","description":"An optional note explaining the reason for forcing verification, included in the audit log.","maxLength":500}},"required":[],"description":"Request payload for an admin to force email verification for a user with an optional reason note.\n\nThis schema defines the structure for an admin-initiated email verification force operation, allowing optional context about why the verification override is necessary. The reason field is intended for audit trail purposes and should contain administrative notes that explain the business justification for bypassing standard verification procedures.\n\nThe reason must be a string with a maximum length of 500 characters to ensure it remains concise while allowing sufficient detail for compliance and audit review. The field is optional because not all force verification operations will require additional explanation, but when provided, it must comply with platform audit logging standards.\n\nThis object is referenced in the admin force verification API operation and enables traceability of administrative decisions that override standard user authentication flows."},"ICommunityPlatformAdmin.IEmailVerified":{"type":"object","properties":{"message":{"type":"string","description":"Confirmation message indicating the successful email verification.\n\nThis response property provides a standardized confirmation message to users after their email verification has been successfully forced by an administrator.\n\nThe message is specifically formatted to be user-friendly and unambiguous, clearly communicating that the email verification has been completed by an administrator and the account is now fully active with posting privileges enabled. This feedback is necessary because users may not expect their verification state to be changed without their action, so a clear, simple confirmation helps prevent confusion.\n\nThe text follows platform messaging conventions and should not be translated or modified, as it is part of the standardized user experience.\n\nUnlike system logs or audit trail data, this message is designed for direct end-user consumption during the client-side experience after the admin operation completes.","const":"The user's email has been successfully verified."}},"required":["message"],"description":"Response model for confirming successful forced email verification by an administrator.\n\nThis schema defines the structure of the success response when an admin forcibly verifies a user's email address, bypassing the standard email verification workflow.\n\nThe only property in this object is a constant message that provides clear, standardized feedback to the user interface after the operation completes successfully. Having a constant string ensures consistency across the platform and prevents localization issues or inconsistent messaging.\n\nThis schema is designed to be minimal while still providing meaningful user feedback. It doesn't include status flags or other metadata because the HTTP response code (typically 200 OK) conveys success and the administrator's action is already implied by the context of the operation.\n\nBy using a constant string value, this response is deterministic and easily testable, ensuring the user-facing experience remains predictable after admin interventions."},"ICommunityPlatformCommunity.IRequest":{"type":"object","properties":{"search":{"type":"string","description":"Full-text search term to match against community names and descriptions.\n\nThis field enables users to find communities by keyword matching across both the name and description fields.\n\nBecause the Prisma schema includes trigram indexing on name and description with gin_trgm_ops, this field leverages the database's full-text search capabilities for efficient fuzzy matching.\n\nThe search term can be partial and does not need to match exactly.\n\nExample: \"gaming\" will match \"r/gaming\" and \"gaming community\" in descriptions.\n\nThis is used for community discovery and should support the \"hot\" and \"top\" list scalings defined in the business rules by allowing search across all communities rather than limiting to subscriptions only.\n\nThe implementation uses the GIN index on these fields to support fast search performance, as required by the performance requirement of under 2 seconds for 50 results.\n\nThis field corresponds directly to the name and description columns of community_platform_communities table and must not include any other fields as they are not part of the schema."},"isPublic":{"type":"boolean","description":"Filter communities by public visibility status.\n\nWhen true, returns only public communities (is_public = true). When false, returns only private communities (is_public = false). When null, returns all communities regardless of visibility.\n\nThis corresponds to the is_public boolean field in the community_platform_communities table.\n\nFor anonymous users, this parameter will be forced to true to enforce privacy, as private communities must be subscribed to be viewed. For authenticated users, the parameter can be null to return both public and private (subscribed) communities.\n\nThe filter interacts with the community_platform_subscriptions table: if the user is authenticated and the isPublic parameter is null, the system will return public communities plus any private communities from the user's subscriptions.\n\nThis design enforces the platform's privacy model as required by the business rules and security requirements."},"isNsfw":{"type":"boolean","description":"Filter communities by NSFW (Not Safe For Work) content status.\n\nWhen true, returns only NSFW communities (nsfw = true). When false, returns only non-NSFW communities (nsfw = false). When null, returns all communities without NSFW filtering.\n\nThis corresponds to the nsfw boolean field in the community_platform_communities table.\n\nWhen the parameter is true, only users with explicit NSFW content viewing enabled in their client settings will see the results, as required by business security requirements for content filtering.\n\nThis field allows users to discover communities based on content classification without having to view the community directly first.\n\nThis restriction is applied server-side and is independent of the user's subscription status or authentication."},"sortBy":{"oneOf":[{"const":"memberCount","description":"Field to sort the resulting list of communities by.\n\nValid values are: 'memberCount', 'postCount', 'createdAt'.\n\nThis controls the ordering of the returned communities in the paginated list.\n\n- 'memberCount': Sorts communities by the number of subscribers, from highest to lowest.\n- 'postCount': Sorts communities by the number of posts, from highest to lowest.\n- 'createdAt': Sorts communities chronologically by creation date, with newest first.\n\nThese sort options correspond directly to the member_count and post_count integer fields and created_at timestamp field in the community_platform_communities table.\n\nThe sort parameters drive the community discovery experience and are designed to match the \"top\" and \"hot\" ranking algorithms in the business rules. Sorting by memberCount and postCount contribute to the long-tail content distribution metric (KDE) by promoting established communities.\n\nThe order is always descending (highest to lowest, newest to oldest), as defined by the post sorting algorithm guidelines.\n\nDefault value: 'memberCount'."},{"const":"postCount","description":"Field to sort the resulting list of communities by.\n\nValid values are: 'memberCount', 'postCount', 'createdAt'.\n\nThis controls the ordering of the returned communities in the paginated list.\n\n- 'memberCount': Sorts communities by the number of subscribers, from highest to lowest.\n- 'postCount': Sorts communities by the number of posts, from highest to lowest.\n- 'createdAt': Sorts communities chronologically by creation date, with newest first.\n\nThese sort options correspond directly to the member_count and post_count integer fields and created_at timestamp field in the community_platform_communities table.\n\nThe sort parameters drive the community discovery experience and are designed to match the \"top\" and \"hot\" ranking algorithms in the business rules. Sorting by memberCount and postCount contribute to the long-tail content distribution metric (KDE) by promoting established communities.\n\nThe order is always descending (highest to lowest, newest to oldest), as defined by the post sorting algorithm guidelines.\n\nDefault value: 'memberCount'."},{"const":"createdAt","description":"Field to sort the resulting list of communities by.\n\nValid values are: 'memberCount', 'postCount', 'createdAt'.\n\nThis controls the ordering of the returned communities in the paginated list.\n\n- 'memberCount': Sorts communities by the number of subscribers, from highest to lowest.\n- 'postCount': Sorts communities by the number of posts, from highest to lowest.\n- 'createdAt': Sorts communities chronologically by creation date, with newest first.\n\nThese sort options correspond directly to the member_count and post_count integer fields and created_at timestamp field in the community_platform_communities table.\n\nThe sort parameters drive the community discovery experience and are designed to match the \"top\" and \"hot\" ranking algorithms in the business rules. Sorting by memberCount and postCount contribute to the long-tail content distribution metric (KDE) by promoting established communities.\n\nThe order is always descending (highest to lowest, newest to oldest), as defined by the post sorting algorithm guidelines.\n\nDefault value: 'memberCount'."}],"description":"Field to sort the resulting list of communities by.\n\nValid values are: 'memberCount', 'postCount', 'createdAt'.\n\nThis controls the ordering of the returned communities in the paginated list.\n\n- 'memberCount': Sorts communities by the number of subscribers, from highest to lowest.\n- 'postCount': Sorts communities by the number of posts, from highest to lowest.\n- 'createdAt': Sorts communities chronologically by creation date, with newest first.\n\nThese sort options correspond directly to the member_count and post_count integer fields and created_at timestamp field in the community_platform_communities table.\n\nThe sort parameters drive the community discovery experience and are designed to match the \"top\" and \"hot\" ranking algorithms in the business rules. Sorting by memberCount and postCount contribute to the long-tail content distribution metric (KDE) by promoting established communities.\n\nThe order is always descending (highest to lowest, newest to oldest), as defined by the post sorting algorithm guidelines.\n\nDefault value: 'memberCount'."},"page":{"type":"integer","minimum":1,"description":"The page number to retrieve, starting from 1.\n\nThis parameter controls pagination and enables clients to navigate through large result sets.\n\nCombined with the limit parameter, it determines the offset for database querying.\n\nThe implementation uses offset-limit pagination, referencing the performance requirement of under 2 seconds for 50 results, and supports infinite scrolling.\n\nThe page value is enforced to be at least 1, and any value less than 1 will be treated as 1.\n\nThis corresponds to the standard IPage<T> container type pattern.\n\nExample: page=2 and limit=50 retrieves records 51-100.\n\nThis request structure is required for the full-text community search endpoint.","default":1},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"The number of communities to return per page.\n\nThis parameter restricts the result size to prevent excessive payload sizes and maintain performance.\n\nThe limit must be between 1 and 100, as defined by the maximum allowed items per page.\n\nThis enforces the post sorting performance requirement of under 2 seconds for 50 results.\n\nThe default value is 50, matching the standard client-side loading pattern of 50 items per screen.\n\nThis corresponds to the limit field in the IPage<ICommunityPlatformCommunity.ISummary> container type.\n\nExample: limit=10 returns only the first 10 matches in the current page.\n\nIncreasing the limit beyond 50 may impact the service performance if the database indexes are not optimized for larger result sets.","default":50}},"required":["page","limit"],"description":"Search criteria and pagination parameters for community discovery.\n\nThis request body is used by the /communityPlatform/communities endpoint to retrieve a filtered, sorted, and paginated list of communities based on user preferences.\n\nIt supports advanced search capabilities including full-text search, filtering by public/private and NSFW status, and sorting by member count, post count, or creation date.\n\nThe implementation leverages database indexes on name, is_public, nsfw, member_count, and post_count for performance.\n\nThe operation is public-facing and does not require authentication for basic features, but modifies filtering behavior based on user session: authenticated users see both public and their subscribed private communities when isPublic is null, while guests see only public communities.\n\nThis request structure is consumed by the community search API endpoint to support the \"community discovery\" user journey.\n\nThe request body directly maps to the fields in the community_platform_communities table: name (searched), is_public (isPublic), nsfw (isNsfw), member_count (sortBy=memberCount), post_count (sortBy=postCount), and created_at (sortBy=createdAt).\n\nThe page and limit parameters control pagination, which is required for the performance requirement to load results under 2 seconds for the first 50 posts.\n\nAll fields must be used exactly as defined to ensure compatibility with the underlying database schema and indexes. No additional fields can be generated.","x-autobe-prisma-schema":"community_platform_communities"},"ICommunityPlatformCommunity":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the community.\n\nThis field corresponds to the id column in the community_platform_communities table, which is a UUID primary key.\n\nIt is used for all individual community reference endpoints (e.g., GET /communities/{id}), analytics, and caching.\n\nThe value is auto-generated by the database on community creation and is immutable.\n\nThis field is required for all community-related operations and is always present in responses.\n\nNo other entity in the system shares this id, ensuring uniqueness and consistency in data referencing.\n\nAccording to the Prisma schema, this is the primary key and the only mandatory field referenced across all relationships to community_platform_communities."},"name":{"type":"string","description":"The unique, case-insensitive name identifier for the community (e.g., 'technology', 'gaming').\n\nThis field corresponds to the name column in the community_platform_communities table, which is stored as a case-insensitive unique string.\n\nIt must contain only alphanumeric characters and hyphens, following the naming convention specified in business rules.\n\nIt is used as the URL slug for community access (e.g., r/{name}) and for programmatic reference in client applications.\n\nThe name is unique across the entire platform, enforced by the unique index on the name column in the database schema.\n\nThis field cannot be changed after creation, as per business rules that protect community identity.\n\nThe business rules specify that community names must be 3 to 50 characters long, with no leading or trailing hyphens, and must not be reserved keywords.\n\nThis field must be represented exactly as stored in the database without modification.","x-autobe-prisma-schema":"community_platform_communities"},"description":{"oneOf":[{"type":"string","description":"A brief description of the community's purpose and rules, displayed to users.\n\nThis field corresponds to the description column in the community_platform_communities table, which is optional (nullable).\n\nThe description provides users with context about the community's focus and guidelines before they join.\n\nLength is not strictly limited by the database schema, but display applications should truncate after 200 characters for UI consistency, as defined in the business rules.\n\nTruncation is purely a client-side concern; the full description is always returned by the API.\n\nThis field is descriptive rather than operational and is not used in any search indexing or filtering logic directly within the database.\n\nThe description is stored as plain text with no formatting allowed in the database; any rich text is rendered client-side.\n\nIf the community has no description, this field returns null, indicating absence of content rather than an empty string.\n\nThe field corresponds exactly to the Prisma schema definition and must not be determined from any other source.","x-autobe-prisma-schema":"community_platform_communities"},{"type":"null"}],"description":"A brief description of the community's purpose and rules, displayed to users.\n\nThis field corresponds to the description column in the community_platform_communities table, which is optional (nullable).\n\nThe description provides users with context about the community's focus and guidelines before they join.\n\nLength is not strictly limited by the database schema, but display applications should truncate after 200 characters for UI consistency, as defined in the business rules.\n\nTruncation is purely a client-side concern; the full description is always returned by the API.\n\nThis field is descriptive rather than operational and is not used in any search indexing or filtering logic directly within the database.\n\nThe description is stored as plain text with no formatting allowed in the database; any rich text is rendered client-side.\n\nIf the community has no description, this field returns null, indicating absence of content rather than an empty string.\n\nThe field corresponds exactly to the Prisma schema definition and must not be determined from any other source.","x-autobe-prisma-schema":"community_platform_communities"},"createdAt":{"type":"string","format":"date-time","description":"Timestamp indicating when the community was created.\n\nThis field corresponds to the created_at column in the community_platform_communities table, which is a timestamptz (timestamp with timezone) field.\n\nThe value is set by the database at the moment of creation and is immutable.\n\nThis timestamp is used for chronological sorting of communities and for calculating community age as part of the ranking algorithms.\n\nIt is presented in ISO 8601 format with timezone information, as required by the OpenAPI format definition for date-time fields.\n\nThe server operates in Asia/Seoul timezone (UTC+9), but all timestamps are stored and transmitted in UTC to ensure consistency.\n\nThis field directly corresponds to the database column and must not be inferred or calculated from any other source.\n\nIt is critical for the \"new\" sort algorithm and for reporting on new community growth trends as specified in the performance requirements.","x-autobe-prisma-schema":"community_platform_communities"},"isPublic":{"type":"boolean","description":"Flag indicating whether the community is publicly visible and joinable.\n\nThis field corresponds to the is_public column in the community_platform_communities table.\n\nIf true, the community is visible in public lists and any user can join without approval.\n\nIf false, the community is private and users can only join by invitation or subscription.\n\nThis flag is used in access control to determine whether the community can be seen by guests (non-authenticated users) or requires authentication.\n\nThe field directly corresponds to the database column and must not be derived from user subscription status alone.\n\nPublic communities are indexed for discoverability and can be found via search with isPublic=true.\n\nThis flag is set at community creation and can be changed later by moderators/owners.\n\nThe desire for visual clarity in the user interface requires this field to be present in every community object returned by the API.\n\nThis field does not affect permission to view content if the user is a subscriber, but only affects visibility of the community listing itself.","x-autobe-prisma-schema":"community_platform_communities"},"nsfw":{"type":"boolean","description":"Flag indicating whether the community contains Not Safe For Work content.\n\nThis field corresponds to the nsfw column in the community_platform_communities table.\n\nIf true, the community contains content that may be inappropriate for work or public view.\n\nThe flag triggers mandatory user settings to view such content and displays warnings when users enter the community.\n\nThis implementation complies with child protection and exposure policies defined in the compliance requirements.\n\nThis flag must be checked against user settings before content is displayed to ensure legal compliance.\n\nIt is use to implement the NSFW filtering system as outlined in the security and compliance documents.\n\nThe value is set by administrators or moderators with approval and is immutable for the lifetime of the community once set.\n\nThis field corresponds exactly to the database schema field and must not be determined from any other source such as content analysis.\n\nThe field is used in search filtering, and user profile preferences for content filtering.","x-autobe-prisma-schema":"community_platform_communities"},"postReviewMode":{"type":"boolean","description":"Flag indicating whether all new posts in this community require moderator approval before being published.\n\nThis field corresponds to the post_review_mode column in the community_platform_communities table.\n\nIf true, any new post submitted to this community must be manually approved by a moderator before it becomes visible to other users.\n\nThis feature enables community governance by allowing moderators to maintain quality control, which is important for communities with sensitive topics.\n\nWhen this flag is false, posts are published immediately upon submission.\n\nThis field interacts with the status field in community_platform_posts: if post_review_mode is true, a new post is created with status 'unreviewed'; if false, status is 'published'.\n\nIt is not a field that can be assigned or modified from outside the community settings.\n\nThe field is set during community creation and can be changed by moderators (with admin override).\n\nThe implementation follows the business rules for moderation workflows and must be stored and returned exactly as defined in the Prisma schema.","x-autobe-prisma-schema":"community_platform_communities"},"commentReviewMode":{"type":"boolean","description":"Flag indicating whether all new comments in this community require moderator approval before being published.\n\nThis field corresponds to the comment_review_mode column in the community_platform_communities table.\n\nIf true, any comment submitted to this community must be manually approved by a moderator before being visible to other users.\n\nThis feature allows greater control over discussion quality and prevents spam or harassment from appearing immediately.\n\nIf false, comments are published immediately after submission.\n\nThis field influences the status field in community_platform_comments: when true, new comments have status 'unreviewed'; when false, status is 'published'.\n\nThe value is inherited from community-specific configuration and can be adjusted by moderators.\n\nIt does not affect the user's ability to comment, only the visibility of the comment before moderation.\n\nThis field directly maps to the database schema and must be returned in its exact value without integrity checks or modification.","x-autobe-prisma-schema":"community_platform_communities"},"memberCount":{"type":"integer","description":"The current number of users subscribed to this community.\n\nThis field corresponds to the member_count column in the community_platform_communities table, which is an integer field.\n\nIt is maintained by the system using triggers or background jobs that update the count on subscription/unsubscription events (community_platform_subscriptions table).\n\nThe count is used to rank communities in the \"top\" and \"hot\" lists and influences the visibility of communities through algorithmic prioritization.\n\nThis field reflects active subscriptions, not total registered users; it is not affected by user bans or deletions, but only by subscription status.\n\nIt is capped by the platform-wide limit of max_community_members defined in community_platform_platform_settings.\n\nThe value is derived from the database and cannot be modified directly by any request or operation.\n\nIt is used both in UI display and in API ranking logic, and must be accurate to avoid publishing false information.\n\nThe implementation ensures that the count is always >= 0 and is updated in real time for performance-sensitive endpoints via caching or materialized views.","x-autobe-prisma-schema":"community_platform_communities"},"postCount":{"type":"integer","description":"The total number of posts created in this community.\n\nThis field corresponds to the post_count column in the community_platform_communities table.\n\nIt is maintained by the system using triggers or background jobs that increment the count on each published post (community_platform_posts) and decrement on deletion.\n\nThis metric is used as a key metric to determine a community's activity level and helps determine its place in top lists.\n\nThe value reflects only accepted posts that are in 'published' status; posts in 'unreviewed' or 'removed' status do not contribute to the count.\n\nIt is calculated from the query COUNT(*) FROM community_platform_posts WHERE community_platform_community_id = ? AND status = 'published'\n\nThe field is derived from the database and must not be inferred, calculated, or modified by clients or intermediate services.\n\nThe field is used in ranking logic, organic discovery, and policy enforcement.\n\nThis number is bounded by the system's performance constraints and must be kept in real time for popular communities.","x-autobe-prisma-schema":"community_platform_communities"}},"required":["id","name","createdAt","isPublic","nsfw","postReviewMode","commentReviewMode","memberCount","postCount"],"description":"Detailed information about a community on the communityPlatform.\n\nThis schema represents the full object model for a community as defined in the community_platform_communities table in the Prisma schema.\n\nIt includes the community's identifier, name, description, creation timestamp, privacy settings, moderation preferences, and activity metrics.\n\nThe object is used for displaying community details on the community page and is the source for any page that requires full community context.\n\nAll fields in this schema correspond exactly to columns in the database table and must not add any computed, derived, or inferred properties.\n\nThe response form of this schema is used for the GET /communityPlatform/communities/{communityId} endpoint.\n\nThis type has no relationship to ICommunityPlatformCommunity.ISummary; this is the detailed entity, while the summary type is a reduced subset optimized for list views.\n\nThe schema includes all fields from the Prisma schema: id, name, description, created_at, is_public, nsfw, post_review_mode, comment_review_mode, member_count, post_count.\n\nNo other fields from any other table are included; the community_platform_community_settings table is referenced separately and is not part of this schema. This ensures responsitiveness of high-volume endpoints.\n\nThe presence of x-autobe-prisma-schema identifies this as a direct table mapping, requiring audit that every property must exist in the referenced Prisma entity.\n\nThe description emphasizes the structure and constraints defined specifically by the Prisma database schema, with no deviations allowed.","x-autobe-prisma-schema":"community_platform_communities"},"ICommunityPlatformCommunity.ICreate":{"type":"object","properties":{"name":{"type":"string","minLength":3,"maxLength":50,"pattern":"^[a-zA-Z0-9-]+$","description":"The unique, case-insensitive name identifier for the community (e.g., 'technology', 'gaming'). Must be unique across the platform and follow naming conventions (alphanumeric and hyphens only).\n\nThis field corresponds to the 'name' column in the community_platform_communities table. The name is used as the primary identifier for community discovery and must be unique system-wide.\n\nBusiness rule constraints:\n- Must be at least 3 characters long\n- Must contain only alphanumeric characters and hyphens\n- Must not start or end with a hyphen\n- Must not be a reserved keyword (e.g., 'admin', 'moderator')\n- Must be unique across all existing communities\n\nThis is a required field for community creation. The system validates this field against the unique constraint in the database to prevent duplicate community names. The field is indexed for efficient search performance.\n\nExamples:\n- Valid: 'technology', 'gaming', 'nature-photography'\n- Invalid: 'Tech', 'gaming!', 'my community', '-community'","x-autobe-prisma-schema":"community_platform_communities"},"description":{"type":"string","minLength":0,"maxLength":1000,"description":"A brief description of the community's purpose and rules, displayed to users.\n\nThis field corresponds to the 'description' column in the community_platform_communities table. It provides a concise overview of what the community is about and its specific rules or guidelines.\n\nThis is an optional field that can be left empty during creation. Users can add or modify the description later through the community settings update endpoint.\n\nWhen populated, this description helps potential subscribers understand the community's focus and culture. The description supports plain text only with no HTML formatting.\n\nExample: \"A community for discussing the latest in technology trends and innovations.\"","x-autobe-prisma-schema":"community_platform_communities"}},"required":["name"],"description":"Request body schema for creating a new community.\n\nThis object defines the data structure required to create a new community on the platform. It includes the mandatory community name and an optional description field.\n\nThe schema enforces business rules around community naming conventions and provides structured data for the system to validate before creating a new community record.\n\nUpon successful creation, the system generates a unique UUID for the community (id field) and sets default values for other fields like is_public, nsfw, post_review_mode, and comment_review_mode as defined in the community_platform_communities table.\n\nThis schema directly maps to the community_platform_communities table in the Prisma schema, with only the name and description fields being specified by the user.\n\nRelated to:\n- ICommunityPlatformCommunity: The full community entity returned after creation\n- ICommunityPlatformCommunity.ISummary: A minimal representation for lists\n- community_platform_communities: The underlying database table","x-autobe-prisma-schema":"community_platform_communities"},"ICommunityPlatformCommunitySettings.IUpdate":{"type":"object","properties":{"title":{"type":"string","minLength":0,"maxLength":100,"description":"Custom display title for the community, which may differ from the public 'name'. Used for branding.\n\nThis field corresponds to the 'title' column in the community_platform_community_settings table. It allows community moderators to set a preferred display name that may be more human-readable or better branded than the technical name.\n\nThis is an optional field. When not provided, the system uses the community's public 'name' field as the display title.\n\nThe title can contain alphanumeric characters, spaces, and common punctuation. The length is capped at 100 characters to prevent excessive display content.\n\nExample:\n- If community name is 'tech-news', the title might be 'Tech News - Breaking Stories and Analysis'\n- If left empty, the community name 'tech-news' will be displayed instead","x-autobe-prisma-schema":"community_platform_community_settings"},"banner_url":{"type":"string","minLength":0,"maxLength":80000,"pattern":"^https?://","description":"URL to the community's banner image, displayed prominently on the community page.\n\nThis field corresponds to the 'banner_url' column in the community_platform_community_settings table. It allows community moderators to upload and set a custom banner image that visually represents the community's theme.\n\nThis is an optional field. If not provided, the system uses a default banner based on the community's category.\n\nThe URL must be a valid HTTP or HTTPS link. The system validates the URL format but does not verify the image's existence at the URL. The image is hosted externally (Cloudinary or S3) and the URL is stored as a reference.\n\nThe maximum length is set to 80,000 characters to accommodate long URLs from external hosting services.\n\nExample: \"https://cdn.example.com/banners/technology-banner.jpg\"","x-autobe-prisma-schema":"community_platform_community_settings"},"icon_url":{"type":"string","minLength":0,"maxLength":80000,"pattern":"^https?://","description":"URL to the community's icon/logo, used as visual identifier in lists.\n\nThis field corresponds to the 'icon_url' column in the community_platform_community_settings table. It allows community moderators to set a small icon or logo that identifies the community in listings, feeds, and search results.\n\nThis is an optional field. If not provided, the system uses a default icon based on the community's category.\n\nThe URL must be a valid HTTP or HTTPS link. The system validates the URL format but does not verify the image's existence at the URL. The image is hosted externally (Cloudinary or S3) and the URL is stored as a reference.\n\nThe maximum length is set to 80,000 characters to accommodate long URLs from external hosting services.\n\nExample: \"https://cdn.example.com/icons/technology-icon.png\"","x-autobe-prisma-schema":"community_platform_community_settings"},"rules":{"type":"string","minLength":0,"maxLength":4000,"description":"Detailed rules and guidelines for the community, more comprehensive than the basic description.\n\nThis field corresponds to the 'rules' column in the community_platform_community_settings table. It contains more detailed community guidelines, rules, and expectations for members.\n\nThis is an optional field. When provided, this text is displayed on the community's rules page and helps enforce community standards.\n\nThe field can contain up to 4,000 characters of plain text describing community norms, posting expectations, behavioral guidelines, and consequences for violations.\n\nExamples:\n- \"No self-promotion or spam. Links must be relevant to the topic and not self-serving.\"\n- \"Be respectful in all discussions. Personal attacks and harassment will result in suspension.\"\n- \"Original content only. No reposts without attribution.\"\n\nThis field is separate from the basic 'description' to provide space for comprehensive guidelines without cluttering the community summary.","x-autobe-prisma-schema":"community_platform_community_settings"},"moderator_invite_only":{"type":"boolean","description":"Flag indicating whether only admins can invite new moderators. If false, existing moderators can invite others.\n\nThis field corresponds to the 'moderator_invite_only' column in the community_platform_community_settings table. It controls the hierarchy and permission structure for community moderation.\n\nWhen set to true, only platform administrators have the ability to assign new moderators. When set to false (default), existing moderators can invite other trusted members to join their moderation team.\n\nThis setting is important for community governance and helps prevent unauthorized access to moderation tools. It balances community autonomy with platform oversight.\n\nWhen true, it enforces a more centralized control model. When false, it allows more decentralized community management.\n\nExample: If a community has a strong culture of trust among its active members, the moderator may set this to false to empower their team.","x-autobe-prisma-schema":"community_platform_community_settings"},"allow_self_post":{"type":"boolean","description":"Flag indicating whether new members can immediately create posts upon joining, or if a waiting period is required.\n\nThis field corresponds to the 'allow_self_post' column in the community_platform_community_settings table. It controls the onboarding experience for new members joining the community.\n\nWhen set to true (default), new members can immediately create posts upon joining the community. When set to false, new members must wait for a period before posting, which helps prevent spam and ensures members have reviewed community norms first.\n\nThis feature is commonly used in highly moderated communities where the quality of contributions is prioritized over volume. It can help reduce spam and improve overall discourse quality by forcing new members to engage with content before creating their own.\n\nExample: In academic or professional communities, moderators may set this to false to ensure new members understand the content standards before contributing.","x-autobe-prisma-schema":"community_platform_community_settings"}},"required":[],"description":"Request body schema for updating a community's settings.\n\nThis object defines the data structure required to update custom configuration settings for an existing community. It includes optional fields for display customization, moderation policies, and community guidelines.\n\nThis schema is specifically designed for the PUT /communities/{communityId} endpoint and is used by community moderators or platform administrators to customize the community's appearance and behavior.\n\nThe schema is a partial update object - all fields are optional and null values are permitted, allowing clients to update only specific settings without affecting others. Each field updates the corresponding column in the community_platform_community_settings table.\n\nThis object does NOT contain fields for modifying the core community structure (name, is_public, etc.) as these are handled by different endpoints and require different permissions.\n\nRelated to:\n- ICommunityPlatformCommunitySettings: The full settings entity returned after update\n- community_platform_community_settings: The underlying database table","x-autobe-prisma-schema":"community_platform_community_settings"},"ICommunityPlatformCommunitySettings":{"type":"object","x-autobe-prisma-schema":"community_platform_community_settings","properties":{"id":{"type":"string","format":"uuid","description":"Primary Key.\n\nThe unique identifier for the community settings record."},"community_platform_community_id":{"type":"string","format":"uuid","description":"The community this setting belongs to. {@link community_platform_communities.id}.\n\nThis field establishes a foreign key relationship to the parent community entity. Every community has exactly one settings record, and this relationship is enforced as a one-to-one association."},"title":{"type":"string","description":"Custom display title for the community, which may differ from the public 'name'. Used for branding.\n\nThis field is optional and allows community moderators to set a more descriptive or branded name for display purposes. If not set, the public 'name' field from the community_platform_communities table will be used."},"banner_url":{"type":"string","format":"uri","maxLength":80000,"description":"URL to the community's banner image, displayed prominently on the community page.\n\nThis field is optional and stores a URL pointing to an image hosted on an external service like Cloudinary. The maximum length of 80,000 characters allows for very long URLs, accommodating complex CDN paths."},"icon_url":{"type":"string","format":"uri","maxLength":80000,"description":"URL to the community's icon/logo, used as visual identifier in lists.\n\nThis optional field provides a small image that serves as the community's icon in directory listings and navigation menus. Like banner_url, this points to an externally hosted image."},"rules":{"type":"string","description":"Detailed rules and guidelines for the community, more comprehensive than the basic description.\n\nThis field contains additional community-specific rules and expectations that are not covered in the basic description. It is often displayed in a dedicated 'Rules' section on the community page and is limited to ensure readability and performance."},"moderator_invite_only":{"type":"boolean","description":"Flag indicating whether only admins can invite new moderators. If false, existing moderators can invite others.\n\nThis boolean setting defines the governance model of the community. When true, only platform admins can invite new moderators. When false, existing moderators can invite and promote new moderators within the community, enabling decentralized moderation."},"allow_self_post":{"type":"boolean","description":"Flag indicating whether new members can immediately create posts upon joining, or if a waiting period is required.\n\nWhen enabled, new subscribers can immediately create and publish posts in the community. When disabled, new members must wait until the community formality is complete, typically to prevent spam and ensure members understand community norms before contributing."},"created_at":{"type":"string","format":"date-time","description":"Timestamp indicating when these settings were initially configured.\n\nThis field is set automatically by the system when the settings record is first created and represents the precise moment the community's configuration was established."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp indicating when these settings were last updated.\n\nThis field is updated automatically by the system whenever any setting has been modified, providing a clear audit trail of configuration changes over time."}},"required":["community_platform_community_id","created_at","updated_at"],"description":"Configuration settings that customize the behavior and appearance of each community. These settings are specific to each community and govern moderation, visibility, and user experience. This is a subsidiary entity as it is always governed by and accessed through its parent community entity.\n\nThe community_platform_community_settings table stores optional configuration overrides for community display and behavior that extend beyond the core community attributes. It enables customization of community presentation through visual elements (title, banner, icon) and operational flexibility through moderation control (moderator_invite_only, allow_self_post). The description field provides space for detailed community guidelines separate from the basic description shown in listings.\n\nThis entity is tightly coupled with community_platform_communities through the foreign key community_platform_community_id and exists in a strict one-to-one relationship. Settings are only populated when explicitly configured by a moderator or admin, with NULL values indicating default behavior. The created_at and updated_at timestamps ensure full auditability of configuration changes.\n\nExternal integrations are referenced through the URL fields (banner_url, icon_url), which point to resources hosted by external services like Cloudinary. This design maintains separation of concerns by keeping media assets outside the database while maintaining direct associations. The platform_settings table (community_platform_platform_settings) provides global defaults that apply when these community-specific settings are not defined.\n\nSecurity considerations include ensuring only authorized moderators can modify these settings through properly authenticated API endpoints. The schema's foreign key constraints guarantee data integrity between communities and their settings, preventing orphaned records."},"ICommunityPlatformPost.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination.\n\nSpecifies which page of results to return. Must be at least 1. Default value is 1 if not provided.\n\nThis parameter enables clients to request results in manageable chunks (pagination), reducing payload size and improving performance on slow networks."},"limit":{"type":"integer","minimum":1,"maximum":50,"description":"Number of records to return per page.\n\nLimits the number of posts returned in the response. Must be between 1 and 50. Default value is 10 if not provided.\n\nThis parameter helps optimize network usage and frontend rendering by limiting the result set size."},"sort":{"oneOf":[{"const":"new","description":"Sorting algorithm to apply to the results.\n\nDetermines the order of returned posts. Possible values:\n- 'new': sorts by creation timestamp, newest first\n- 'hot': sorts by multi-factor algorithm combining recency and popularity\n- 'top': sorts by total vote count (upvotes minus downvotes)\n- 'controversial': sorts by ratio of upvotes to downvotes\n\nIf not specified, defaults to the platform's default algorithm configured in community_platform_platform_settings."},{"const":"hot","description":"Sorting algorithm to apply to the results.\n\nDetermines the order of returned posts. Possible values:\n- 'new': sorts by creation timestamp, newest first\n- 'hot': sorts by multi-factor algorithm combining recency and popularity\n- 'top': sorts by total vote count (upvotes minus downvotes)\n- 'controversial': sorts by ratio of upvotes to downvotes\n\nIf not specified, defaults to the platform's default algorithm configured in community_platform_platform_settings."},{"const":"top","description":"Sorting algorithm to apply to the results.\n\nDetermines the order of returned posts. Possible values:\n- 'new': sorts by creation timestamp, newest first\n- 'hot': sorts by multi-factor algorithm combining recency and popularity\n- 'top': sorts by total vote count (upvotes minus downvotes)\n- 'controversial': sorts by ratio of upvotes to downvotes\n\nIf not specified, defaults to the platform's default algorithm configured in community_platform_platform_settings."},{"const":"controversial","description":"Sorting algorithm to apply to the results.\n\nDetermines the order of returned posts. Possible values:\n- 'new': sorts by creation timestamp, newest first\n- 'hot': sorts by multi-factor algorithm combining recency and popularity\n- 'top': sorts by total vote count (upvotes minus downvotes)\n- 'controversial': sorts by ratio of upvotes to downvotes\n\nIf not specified, defaults to the platform's default algorithm configured in community_platform_platform_settings."}],"description":"Sorting algorithm to apply to the results.\n\nDetermines the order of returned posts. Possible values:\n- 'new': sorts by creation timestamp, newest first\n- 'hot': sorts by multi-factor algorithm combining recency and popularity\n- 'top': sorts by total vote count (upvotes minus downvotes)\n- 'controversial': sorts by ratio of upvotes to downvotes\n\nIf not specified, defaults to the platform's default algorithm configured in community_platform_platform_settings."},"q":{"type":"string","description":"Full-text search query term to filter posts by title or content.\n\nPerforms a full-text search across the title and content fields of posts using trigram indexes for matching keywords. Matches are case-insensitive and support partial word matches.\n\nThis allows users to discover posts by keyword, such as 'electron', 'python', or 'recursive'. This parameter should be URL-encoded when used in requests."},"community_id":{"type":"string","format":"uuid","description":"Filter posts by specific community identifier.\n\nIf provided, only posts belonging to the specified community will be returned. This enables targeted queries of posts within a single community rather than across the entire platform."},"author_id":{"type":"string","format":"uuid","description":"Filter posts by specific author identifier.\n\nIf provided, only posts created by the specified user will be returned. This allows retrieval of a user's own posts without requiring a profile view.","since":"1.0.0"},"min_created_at":{"type":"string","format":"date-time","description":"Filter posts created on or after this timestamp.\n\nAll posts with created_at greater than or equal to this value are included in results. Useful for retrieving posts within a specific time range (e.g., 'last 24 hours')."},"max_created_at":{"type":"string","format":"date-time","description":"Filter posts created before this timestamp.\n\nAll posts with created_at less than this value are included in results. Used in conjunction with min_created_at to define a date range."},"min_vote_count":{"type":"integer","minimum":0,"description":"Filter posts with at least this many total votes.\n\nOnly posts with vote_count greater than or equal to this value are included. Useful for filtering out low-engagement content."},"max_vote_count":{"type":"integer","minimum":0,"description":"Filter posts with at most this many total votes.\n\nOnly posts with vote_count less than or equal to this value are included. Useful for finding niche or less-popular content."},"status":{"oneOf":[{"const":"published","description":"Filter posts by moderation status.\n\nLimits the results to posts with the specified status:\n- 'published': visible to public users\n- 'unreviewed': awaiting moderator approval\n- 'removed': taken down by moderator\n- 'archived': removed from feed but possibly preserved\n\nFor unauthenticated users, only 'published' posts are ever returned, regardless of this filter."},{"const":"unreviewed","description":"Filter posts by moderation status.\n\nLimits the results to posts with the specified status:\n- 'published': visible to public users\n- 'unreviewed': awaiting moderator approval\n- 'removed': taken down by moderator\n- 'archived': removed from feed but possibly preserved\n\nFor unauthenticated users, only 'published' posts are ever returned, regardless of this filter."},{"const":"removed","description":"Filter posts by moderation status.\n\nLimits the results to posts with the specified status:\n- 'published': visible to public users\n- 'unreviewed': awaiting moderator approval\n- 'removed': taken down by moderator\n- 'archived': removed from feed but possibly preserved\n\nFor unauthenticated users, only 'published' posts are ever returned, regardless of this filter."},{"const":"archived","description":"Filter posts by moderation status.\n\nLimits the results to posts with the specified status:\n- 'published': visible to public users\n- 'unreviewed': awaiting moderator approval\n- 'removed': taken down by moderator\n- 'archived': removed from feed but possibly preserved\n\nFor unauthenticated users, only 'published' posts are ever returned, regardless of this filter."}],"description":"Filter posts by moderation status.\n\nLimits the results to posts with the specified status:\n- 'published': visible to public users\n- 'unreviewed': awaiting moderator approval\n- 'removed': taken down by moderator\n- 'archived': removed from feed but possibly preserved\n\nFor unauthenticated users, only 'published' posts are ever returned, regardless of this filter."},"nsfw":{"type":"boolean","description":"Filter posts by NSFW attribute.\n\nWhen true, includes only posts from communities marked as NSFW. When false, includes only posts from safe communities. When undefined, includes all posts regardless of NSFW status.\n\nThis filter respects user settings: users who have not explicitly enabled NSFW content still won't see NSFW posts, even if this filter is set to true."}},"required":[],"description":"Request parameters for searching and filtering posts across the platform. This structured request object enables comprehensive query capabilities for post discovery, content moderation, analytics, and personalized feed generation.\n\nThe ICommunityPlatformPost.IRequest schema defines a flexible query interface for searching community_platform_posts collection with support for pagination, filtering, and multiple sorting algorithms. It provides the complete set of parameters needed to implement the four core sorting algorithms ('new', 'hot', 'top', 'controversial') as specified in the business requirements, along with additional contextual filters for targeted content retrieval.\n\nThe pagination parameters (page, limit) are critical for performance optimization, ensuring response sizes remain manageable during high-traffic periods and mobile network conditions. The 50-item limit maximum prevents resource exhaustion and aligns with platform performance requirements of under 2 seconds for 50 posts.\n\nThe search parameter (q) leverages full-text search, enabling users to discover content based on keywords that appear anywhere in post titles or content bodies, with trigram indexing on these fields optimized for performance.\n\nThe filter parameters (community_id, author_id, min/max_created_at, min/max_vote_count, status, nsfw) allow for granular content filtering essential for moderating the platform, conducting analytics, and delivering personalized user experiences. The status filter enforces the business rule that unauthenticated users only see 'published' content while acknowledging the underlying moderation workflow.\n\nThe nsfw parameter integrates with community visibility rules, respecting user preferences for adult content while maintaining compliance with regulatory requirements. When this parameter is undefined, the system defaults to its security policy of mixing available content based on user subscription status.\n\nThis request object is designed to be stable and future-proof, allowing additional query parameters to be added without breaking existing clients, and all parameters are optional with sensible default behaviors for maximum usability in various client contexts."},"ICommunityPlatformPost.ICreate":{"type":"object","properties":{"title":{"type":"string","description":"The title of the post, limited to 300 characters. Must be present for all post types.\n\nThis field represents the main headline or subject of the user's post, serving as the primary content indicator in community feeds and search results.\n\nBusiness context: This title is the first thing users see when browsing communities, making it critical for engagement and discoverability. The 300-character limit prevents overly verbose titles while still allowing sufficient context.\n\nMust be non-empty and non-whitespace only. Trimmed before storage. Language should be clear and representative of the post's content.\n\nSafety consideration: Server-side checks prevent dangerous characters and injection attacks. Title may not contain markdown or HTML formatting as specified in business rules.","minLength":1,"maxLength":300},"post_type":{"oneOf":[{"const":"text","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},{"const":"link","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},{"const":"image","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."}],"description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},"content":{"type":"string","description":"The main body text of the post, limited to 10,000 characters. Used for text posts.\n\nThis field contains the textual content of a post when post_type is 'text'. For other post types ('link' or 'image'), this field may be null or omitted.\n\nBusiness context: This represents the user's narrative, explanation, or thoughts that provide context for their post. With a 10,000-character limit, users can provide detailed commentary while preventing abuse or performance issues.\n\nThe content is rendered as plain text without Markdown or HTML formatting per business rules. Server-side validation ensures the length constraint is strictly enforced.\n\nFor text posts, this field is required. For link and image posts, this field is optional and can be null, but should be omitted in the request when not provided.\n\nWhen provided, it should be trimmed of leading/trailing whitespace. No special characters are blocked (beyond basic injection prevention), but the content may be processed by automated moderation systems.","minLength":0,"maxLength":10000},"url":{"type":"string","description":"The full URL of the linked resource. Must be a valid HTTP/HTTPS URL.\n\nThis field contains the web address for link-type posts, preserving the original citation source.\n\nBusiness context: This allows users to share valuable external content with the community, facilitating knowledge spread and resource discovery.\n\nThe URL must:\n- Start with 'http://' or 'https://'\n- Be syntactically valid according to RFC 3986\n- Not contain encoded spaces or invalid characters\n- Not be a URI scheme other than HTTP/HTTPS\n\nServer-side validation checks URL format comprehensively. Domain blacklisting may be applied for known malicious domains. The system will not validate if the URL endpoint is accessible or returns a valid response.\n\nThis field is required when post_type is 'link'. It must be omitted when post_type is 'text' or 'image'.\n\nFor security, URL-based payloads are sanitized to prevent XSS attacks on external sites. The full text of the URL must be stored as provided without modification or encoding.","format":"uri","minLength":1,"maxLength":80000},"image_file":{"type":"string","description":"Base64 encoded string representation of the uploaded image file, or reference to uploaded image.\n\nThis field is used for image-type posts to transfer the binary image data to the server. It should contain the Base64-encoded representation of the image file. The implementation may handle file uploads differently, but the schema must include this field for image type posts.\n\nBusiness context: Image posts enable visual expression, memes, diagrams, screenshots, and other graphical content critical to community engagement.\n\nThis field should contain the base64-encoded string representation of the image, including data URI prefix as needed (e.g., \"data:image/jpeg;base64,base64encodedstring\").\n\nRequired when post_type is 'image'. Must be omitted when post_type is 'text' or 'link'.\n\nClient-side: Image file must be ≤ 10MB before encoding or upload.\nServer-side: The system will verify the format (JPG, PNG, GIF, WebP only) and perform content moderation checks, as defined in the community_platform_platform_settings.image_upload_max_size_mb property. The image size will be compared against the 10MB limit defined in the platform settings.\n\nThe system transforms the base64 string into binary and validates the image metadata using external image hosting integration services as documented in 08-external-integrations.md.","minLength":1,"maxLength":134217728}},"required":["title","post_type"],"description":"Request payload for creating a new post in a community.\n\nThis schema defines the fields required to submit a new post on the communityPlatform. Every post must have a title and a type. The type determines which additional fields (content, url, or image_file) must be included.\n\nRequired fields: title and post_type. Post type must be one of: 'text', 'link', or 'image'.\n\nConditional fields:\n- If post_type is 'text': content field is required\n- If post_type is 'link': url field is required\n- If post_type is 'image': image_file field is required\n\nAll fields must be handled according to their validation rules as defined in the Prisma schema. No other fields are permitted in the request body.\n\nThe encoding of image_file must follow Base64 standards compatible with server expectations. url field must be a valid URI. content field must be trimmed and not exceed character limits.\n\nNever include a community_id field in this request. The community association is determined by the API endpoint path, not by this request body. This ensures security and prevents unauthorized posting to incorrect communities.\n\nThis schema mirrors exactly the fields present in the community_platform_posts table in the Prisma schema. Do not add fields that don't exist in the database schema, such as author_id or community_id, as these are assigned by the system based on authentication context and endpoint routing.","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost":{"type":"object","properties":{"id":{"type":"string","description":"Primary Key.\n\nThe UUID identifier assigned by the system to the post upon creation. This immutable identifier allows precise referencing of the post in all API interactions.\n\nBusiness context: This UUID is the definitive identifier for the post throughout its lifecycle in the system. It is used in all URLs, database joins, audit logs, and notifications. Users never see this value unless they are developers or administrators - it is a system-level identifier.\n\nThis field is generated by the server upon successful creation and is never provided by users. It must always be returned by the server in response to creation or retrieval operations.\n\nFormat: Must be a valid UUID version 4 (randomly generated) according to RFC 4122 specification.\n\nThis field exists in the community_platform_posts table as the primary key and is referenced by all related tables (comments, votes, reports, audit_logs, etc.) via foreign keys. No other field can uniquely identify a post.\n\nRequired in response for all post representations including summaries and detailed views. Never accept or process this field from client requests as it's system-generated.","format":"uuid"},"community_platform_community_id":{"type":"string","description":"The community this post belongs to. {@link community_platform_communities.id}.\n\nThis is the foreign key linking the post to its parent community entity. This ID ensures proper content organization and enables aggregation of content by community.\n\nBusiness context: Each post belongs to exactly one community, which defines its context, audience, and moderation policies. This relationship is fundamental to the platform's structure.\n\nThis field must be a valid UUID that corresponds to an existing community_platform_communities.id. The system enforces referential integrity through database foreign key constraints.\n\nThe post's community determines:\n- Which moderation rules apply (post_review_mode)\n- Which users see it in their feeds\n- Which moderators can edit or delete it\n\nThis field is assigned automatically by the server based on the endpoint path during creation and is never provided by the client in POST requests. It must be returned in responses to help clients know which community the post belongs to.\n\nAlways returned in detailed post responses. Must be included in API responses to support client-side community context and \"back to community\" navigation.","format":"uuid"},"author_id":{"type":"string","description":"The user who created this post. {@link community_platform_member.id}.\n\nThis foreign key links the post to its creating user, establishing ownership and accountability.\n\nBusiness context: Posting rights and authorship tracking are core to community trust and reputation systems. This field enables user profile pages to display their posted content and enables karma calculations based on upvotes received.\n\nThis field must be a valid UUID that corresponds to an existing community_platform_member.id. The system enforces referential integrity through database foreign key constraints.\n\nThe author_id is automatically set by the server based on the authenticated user's identity in the JWT token during POST requests. It cannot be manipulated by clients.\n\nThis field is returned in all post responses to display the author's username and profile in UI components. It is necessary for displaying authorship context and determining if the current user is the post's owner (for edit/delete permissions).","format":"uuid"},"title":{"type":"string","description":"The title of the post, limited to 300 characters. Must be present for all post types.\n\nThis field represents the main headline or subject of the user's post, serving as the primary content indicator in community feeds and search results.\n\nBusiness context: This title is the first thing users see when browsing communities, making it critical for engagement and discoverability. The 300-character limit prevents overly verbose titles while still allowing sufficient context.\n\nMust be non-empty and non-whitespace only. Trimmed before storage. Language should be clear and representative of the post's content.\n\nSafety consideration: Server-side checks prevent dangerous characters and injection attacks. Title may not contain markdown or HTML formatting as specified in business rules.","minLength":1,"maxLength":300},"content":{"type":"string","description":"The main body text of the post, limited to 10,000 characters. Used for text posts.\n\nThis field contains the textual content of a post when post_type is 'text'. For other post types ('link' or 'image'), this field may be null or omitted.\n\nBusiness context: This represents the user's narrative, explanation, or thoughts that provide context for their post. With a 10,000-character limit, users can provide detailed commentary while preventing abuse or performance issues.\n\nThe content is rendered as plain text without Markdown or HTML formatting per business rules. Server-side validation ensures the length constraint is strictly enforced.\n\nFor text posts, this field is required. For link and image posts, this field is optional and can be null, but should be omitted in the request when not provided.\n\nWhen provided, it should be trimmed of leading/trailing whitespace. No special characters are blocked (beyond basic injection prevention), but the content may be processed by automated moderation systems.","minLength":0,"maxLength":10000},"post_type":{"oneOf":[{"const":"text","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},{"const":"link","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},{"const":"image","description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."}],"description":"The type of post: 'text', 'link', or 'image'. Determines which additional fields are relevant.\n\nThis discriminator field determines the nature of the post content and which associated data properties will be populated in the database.\n\nBusiness context: Different content types serve distinct user needs.\n- 'text': Contains written narrative or opinion\n- 'link': Shares external resources with context\n- 'image': Visual content for expression and engagement\n\nThis field must be exactly one of the three allowed values as strictly defined in the community_platform_posts.post_type schema field, and its value determines the required fields in the request:\n- For 'text': content field is required\n- For 'link': url field is required\n- For 'image': image file upload is required\n\nOnly these three values are permitted. No alternatives or variations are acceptable."},"vote_count":{"type":"integer","description":"The total vote score calculated as upvotes minus downvotes for ranking purposes.\n\nThis field represents the net engagement score of the post, calculated as the sum of all upvotes minus the sum of all downvotes. This score drives sorting algorithms like 'hot' and 'top'.\n\nBusiness context: This score directly influences a post's visibility in community feeds and search results, creating a feedback loop where high-quality content receives increased exposure.\n\nThis value is calculated from the community_platform_post_votes table by server-side background jobs or database triggers that sum up votes and subtract downvotes. It should never be modified directly by client requests.\n\nThe value can range from negative infinity to positive infinity, but business rules impose a limit on the maximum number of votes counted per post (max_post_votes in community_platform_platform_settings) to prevent karma inflation.\n\nMust be returned in all post responses and update dynamically as votes are cast.\n\nImportant note: Unlike karma scores, vote_count can be negative. This reflects genuine community disapproval and is part of the platform's democratic content moderation system.","minimum":-2147483648,"maximum":2147483647},"comment_count":{"type":"integer","description":"The total number of direct comments on this post.\n\nThis field tracks the number of top-level comments on the post, providing a measure of community engagement and discussion depth.\n\nBusiness context: High comment counts indicate active discussion and community interest, making this a key metric for both users and administrators.\n\nThis count is updated by server-side database triggers or background jobs whenever a new top-level comment is created in the community_platform_comments table or when a comment is deleted (in which case it decrements).\n\nThis field strictly counts direct comments attached directly to the post (with parent_comment_id = null). Replies to comments (with parent_comment_id set) are not counted in this total but are counted in their parent comment's reply count.\n\nMust be returned in all post responses to show users the level of discussion surrounding the post.\n\nMaintained by the system; client requests should never provide or modify this value. Values can range from 0 to 2147483647, but practical limits are determined by system performance, not schema.","minimum":0,"maximum":2147483647},"status":{"oneOf":[{"const":"published","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether and how the post is displayed to users, forming the basis of content moderation on the platform.\n\nBusiness context: This status field ensures community guidelines are maintained while preserving user-generated content history for audit purposes.\n\nPermitted values:\n- 'published': Visible to all users (default for posts in communities without review mode)\n- 'unreviewed': Not visible to non-moderators until approved by a moderator (used in post_review_mode communities)\n- 'removed': Deleted by moderator due to violation of guidelines; visible only to moderators and administrators\n- 'archived': Content is intentionally archived by the user or system and not visible to the public\n\nThis status reflects the moderation decision and determines whether the post appears in feeds, search results, or user timelines.\n\nThis field is updated automatically by the system based on community settings (when posting) or manually by moderators and admins. Never accept this field from client requests as it's managed by the platform's moderation system.\n\nThis field is referenced in all content rendering and API response filtering logic, including page feeds and user timeline rendering."},{"const":"unreviewed","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether and how the post is displayed to users, forming the basis of content moderation on the platform.\n\nBusiness context: This status field ensures community guidelines are maintained while preserving user-generated content history for audit purposes.\n\nPermitted values:\n- 'published': Visible to all users (default for posts in communities without review mode)\n- 'unreviewed': Not visible to non-moderators until approved by a moderator (used in post_review_mode communities)\n- 'removed': Deleted by moderator due to violation of guidelines; visible only to moderators and administrators\n- 'archived': Content is intentionally archived by the user or system and not visible to the public\n\nThis status reflects the moderation decision and determines whether the post appears in feeds, search results, or user timelines.\n\nThis field is updated automatically by the system based on community settings (when posting) or manually by moderators and admins. Never accept this field from client requests as it's managed by the platform's moderation system.\n\nThis field is referenced in all content rendering and API response filtering logic, including page feeds and user timeline rendering."},{"const":"removed","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether and how the post is displayed to users, forming the basis of content moderation on the platform.\n\nBusiness context: This status field ensures community guidelines are maintained while preserving user-generated content history for audit purposes.\n\nPermitted values:\n- 'published': Visible to all users (default for posts in communities without review mode)\n- 'unreviewed': Not visible to non-moderators until approved by a moderator (used in post_review_mode communities)\n- 'removed': Deleted by moderator due to violation of guidelines; visible only to moderators and administrators\n- 'archived': Content is intentionally archived by the user or system and not visible to the public\n\nThis status reflects the moderation decision and determines whether the post appears in feeds, search results, or user timelines.\n\nThis field is updated automatically by the system based on community settings (when posting) or manually by moderators and admins. Never accept this field from client requests as it's managed by the platform's moderation system.\n\nThis field is referenced in all content rendering and API response filtering logic, including page feeds and user timeline rendering."},{"const":"archived","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether and how the post is displayed to users, forming the basis of content moderation on the platform.\n\nBusiness context: This status field ensures community guidelines are maintained while preserving user-generated content history for audit purposes.\n\nPermitted values:\n- 'published': Visible to all users (default for posts in communities without review mode)\n- 'unreviewed': Not visible to non-moderators until approved by a moderator (used in post_review_mode communities)\n- 'removed': Deleted by moderator due to violation of guidelines; visible only to moderators and administrators\n- 'archived': Content is intentionally archived by the user or system and not visible to the public\n\nThis status reflects the moderation decision and determines whether the post appears in feeds, search results, or user timelines.\n\nThis field is updated automatically by the system based on community settings (when posting) or manually by moderators and admins. Never accept this field from client requests as it's managed by the platform's moderation system.\n\nThis field is referenced in all content rendering and API response filtering logic, including page feeds and user timeline rendering."}],"description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether and how the post is displayed to users, forming the basis of content moderation on the platform.\n\nBusiness context: This status field ensures community guidelines are maintained while preserving user-generated content history for audit purposes.\n\nPermitted values:\n- 'published': Visible to all users (default for posts in communities without review mode)\n- 'unreviewed': Not visible to non-moderators until approved by a moderator (used in post_review_mode communities)\n- 'removed': Deleted by moderator due to violation of guidelines; visible only to moderators and administrators\n- 'archived': Content is intentionally archived by the user or system and not visible to the public\n\nThis status reflects the moderation decision and determines whether the post appears in feeds, search results, or user timelines.\n\nThis field is updated automatically by the system based on community settings (when posting) or manually by moderators and admins. Never accept this field from client requests as it's managed by the platform's moderation system.\n\nThis field is referenced in all content rendering and API response filtering logic, including page feeds and user timeline rendering."},"created_at":{"type":"string","description":"The timestamp when the post was submitted.\n\nThis field records the exact date and time when the post was created and saved to the database. It is the primary basis for sorting posts in 'new' order.\n\nBusiness context: Timeliness is critical for community engagement. This timestamp allows users to understand context through chronological ordering, especially in trending topics.\n\nMust be in ISO 8601 format with timezone information, as specified by the database schema parameter @db.Timestamptz.\n\nThis field is auto-generated by the server when the post is created and never modified throughout the post's lifetime.\n\nIt's used for:\n- 'New' sort algorithm in post rankings\n- Calculating 'Hot' score with time decay formula\n- Determining edit window eligibility\n- Creating audit trail records\n- Calculating the lifespan of a post for various analytical purposes\n\nAll operations and interfaces must respect read-only nature of this field. Never set or modify this field through API requests.","format":"date-time"},"updated_at":{"type":"string","description":"The timestamp when the post was last modified (e.g., edit, promotion).\n\nThis field tracks the most recent change to the post's content or state, enabling display of \"last updated\" information to users.\n\nBusiness context: When a post is edited, the updated_at timestamp changes to reflect the modification, signaling to users that the content has been revised since the original posting.\n\nModified when:\n- The title or content fields are updated\n- A moderator changes the post's status\n- The post is promoted to front-page status\n\nThis field remains unchanged if only votes or comments are added, as those are separate entities. The field represents changes to the post itself, not its interactions.\n\nMust be in ISO 8601 format with timezone information, as specified by the database schema.\n\nIt is auto-generated and maintained by the server. Never provide this field in client requests. This field is critical for frontend display of edits and for administrative audit trails.","format":"date-time"},"deleted_at":{"type":"string","description":"The timestamp when the post was soft-deleted. Null if still active.\n\nThis field implements soft deletion to preserve content history while removing posts from public view.\n\nBusiness context: Soft deletion supports platform compliance, moderation audit trails, and forensic analysis while giving users a sense of permanence in their contributions. It prevents complete data loss while enforcing content governance.\n\nWhen a post is \"deleted\" by the user or moderator:\n- The deleted_at field is set to the current timestamp\n- The status field is set to 'removed'\n- The post becomes invisible to regular users\n- The post remains in the database for audit and analytics\n- The post can be restored using admin operations if needed\n\nConcurrency consideration: This field can only be set once (immutable after setting). Reverting deleted_at to null restores the post.\n\nThis field exists as part of the platform's data integrity and compliance practices. By keeping the record, we maintain the audit trail and prevent data tampering.\n\nIn most responses where the post is visible, this field will be null. Only when the post has been removed and requires audit visibility will this field have a value.\n\nCare must be taken in API responses: When deleted_at is not null and the requester is not an admin or moderator, the post should not be returned at all (404 Not Found). This field must never be set through client-side requests.","format":"date-time"},"image_url":{"type":"string","description":"The CDN URL where the image is hosted. Generated by external service (e.g., Cloudinary).\n\nThis field is not part of the post table but is derived from the relationship with community_platform_post_images.\n\nBusiness context: This field provides the direct rendering URL for image posts, enabling immediate display in web and mobile browsers.\n\nThis field is not stored in the community_platform_posts table. When creating a response, this value must be derived from joining with the community_platform_post_images table and selecting the image_url field.\n\nIt must be null if the post is not an image type or if the image upload failed or was deleted.\n\nThis URL must be publicly accessible and is served through a CDN for performance. It follows the structure defined in the third-party image hosting service integrated with the platform (as specified in 08-external-integrations.md).\n\nThe URL path may include versioning or transformations (e.g., resize, quality compression) as generated by the image hosting service.\n\nNOTE: This field exists as an extension to the base community_platform_posts schema due to the one-to-one relationship with community_platform_post_images. It's derived from a related table and included in the ICommunityPlatformPost schema as a computed field for convenience.","format":"uri","maxLength":80000},"link_url":{"type":"string","description":"The full URL of the linked resource. Must be a valid HTTP/HTTPS URL.\n\nThis field is not part of the post table but is derived from the relationship with community_platform_post_links.\n\nBusiness context: This field provides the destination URL for link-type posts, allowing users to navigate to external content with one click.\n\nThis field is not stored in the community_platform_posts table. When creating a response, this value must be derived from joining with the community_platform_post_links table and selecting the url field.\n\nIt must be null if the post is not a link type or if no link was provided.\n\nThis field is saved as provided by the user during creation and validated for proper URI format. It is intended for direct user navigation and must be preserved exactly as submitted (subject to any security sanitization).\n\nNOTE: This field exists as an extension to the base community_platform_posts schema due to the one-to-one relationship with community_platform_post_links. It's derived from a related table and included in the ICommunityPlatformPost schema as a computed field for convenience.","format":"uri","maxLength":80000}},"required":["id","community_platform_community_id","author_id","title","post_type","vote_count","comment_count","status","created_at"],"description":"Detailed information about a post on the communityPlatform system.\n\nThis schema represents the full post entity as stored in the database and returned in API responses for individual post displays. It combines fields directly from community_platform_posts with data derived from related tables to provide a comprehensive view.\n\nCore fields are stored in the community_platform_posts table:\n- id (PK)\n- community_platform_community_id (FK)\n- author_id (FK)\n- title\n- content\n- post_type\n- vote_count\n- comment_count\n- status\n- created_at\n- updated_at\n- deleted_at\n\nThe following fields are derived from relationships:\n- image_url: from community_platform_post_images.table\n- link_url: from community_platform_post_links.table\n\nThe schema maps exactly to the Prisma schema definition for community_platform_posts, with relations handled in the response composition.\n\nThe response always includes all fields for completeness and consistency with the platform's public-facing data model. System-generated fields like id, created_at are immutable and read-only.\n\nThis entity represents a Post as defined in the business requirements section 3.3 for post creation, and 10.1 for post ranking algorithms, and stylesheet display standards.","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost.IUpdate":{"type":"object","properties":{"title":{"type":"string","minLength":1,"maxLength":300,"description":"The title of the post, limited to 300 characters. Must be present for all post types.\n\nThis field is required and must contain at least one non-whitespace character. It serves as the primary identifier for the post in feeds and search results. The title must not contain markdown or HTML formatting.\n\nBusiness rule: The title is immutable after 15 minutes of posting. This field must contain only plain text with no special characters beyond standard punctuation.\n\nThis property directly maps to the 'title' column in the community_platform_posts table in the Prisma schema."},"content":{"type":"string","minLength":1,"maxLength":10000,"description":"The main body text of the post, limited to 10,000 characters. Used for text posts.\n\nThis field contains the textual content of the post when post_type is 'text'. It supports plain text only - no markdown, HTML, or formatting is allowed.\n\nThe maximum length of 10,000 characters ensures performance and usability. Posts exceeding this limit will be truncated on the server side before persistence.\n\nIf the post_type is 'link' or 'image', this field should be null or omitted as it is not applicable.\n\nThis property directly maps to the 'content' column in the community_platform_posts table in the Prisma schema."}},"x-autobe-prisma-schema":"community_platform_posts","required":["title"],"description":"Update request body for a post.\n\nThis schema defines the allowable fields that can be updated for an existing post. Only the title and content can be modified; the post_type cannot be changed after creation. The operation is restricted to the original author and must occur within the 15-minute edit window defined by community_platform_platform_settings.post_edit_window_minutes.\n\nThis type is used exclusively in the PUT /communityPlatform/member/posts/{postId} endpoint.\n\nAll validation rules are enforced server-side based on the business requirements. The response will include the full updated post object. This object must be used ONLY for update operations, not for creation or retrieval.\n\nThis schema directly corresponds to the community_platform_posts table in the Prisma schema, specifically permitting updates to the title and content columns while preventing modification of other fields like author_id, community_platform_community_id, created_at, etc."},"ICommunityPlatformComment":{"type":"object","x-autobe-prisma-schema":"community_platform_comments","properties":{"id":{"type":"string","format":"uuid","description":"Primary Key.\n\nThe unique identifier for the comment, generated by the system upon creation. This UUID is used to reference the comment in URLs and API operations.\n\nThis field is auto-generated when the comment is created and cannot be modified by users. It is used in all operations that target a specific comment (GET, PUT, DELETE).\n\nThis property directly maps to the 'id' column in the community_platform_comments table in the Prisma schema."},"community_platform_post_id":{"type":"string","format":"uuid","description":"The post this comment belongs to. {@link community_platform_posts.id}.\n\nThis foreign key links the comment to its parent post. It must reference an existing, valid post ID in the community_platform_posts table.\n\nThis field is required and auto-populated during comment creation based on the target post in the API request. It cannot be changed after creation.\n\nThis property directly maps to the 'community_platform_post_id' column in the community_platform_comments table in the Prisma schema."},"author_id":{"type":"string","format":"uuid","description":"The user who created this comment. {@link community_platform_member.id}.\n\nThis foreign key links the comment to its author. It must reference an existing, valid member ID in the community_platform_member table.\n\nThis field is required and auto-populated during comment creation based on the authenticated user's session. It cannot be changed after creation.\n\nThis property directly maps to the 'author_id' column in the community_platform_comments table in the Prisma schema."},"parent_comment_id":{"type":"string","format":"uuid","description":"The parent comment this is a reply to. {@link community_platform_comments.id}. Null for top-level comments.\n\nThis field indicates whether this comment is a reply to another comment, enabling nested comment threads. When null, this comment is a top-level response to the post. When set, this comment is a reply to another comment, visible in comment threading.\n\nThis field enforces the 8-level maximum depth limit as defined in the community_platform_platform_settings, with each reply incrementing depth_level by 1.\n\nThis property directly maps to the 'parent_comment_id' column in the community_platform_comments table in the Prisma schema."},"parent_post_snapshot_id":{"type":"string","format":"uuid","description":"Reference to the post's snapshot at time of comment. {@link community_platform_post_snapshots.id}.\n\nThis optional field stores a reference to the state of the post at the moment the comment was created, capturing the title, content, and status of the post at creation time for audit purposes.\n\nThis field ensures that even if the post is later edited or deleted, the context of the comment remains consistent.\n\nThis property directly maps to the 'parent_post_snapshot_id' column in the community_platform_comments table in the Prisma schema."},"content":{"type":"string","minLength":1,"maxLength":2000,"description":"The text content of the comment, limited to 2,000 characters.\n\nThis field contains the actual text of the comment. It must be between 1 and 2,000 characters and cannot be empty or contain only whitespace.\n\nThe system validates this field on submission and truncates it if it exceeds 2,000 characters. This field is indexed for full-text search.\n\nThis property directly maps to the 'content' column in the community_platform_comments table in the Prisma schema."},"vote_count":{"type":"integer","description":"The total vote score calculated as upvotes minus downvotes for ranking purposes.\n\nThis field represents the net score of the comment based on all upvotes and downvotes received. It is automatically calculated and updated by the system every time a user votes.\n\nThis field must be kept in sync with community_platform_comment_votes records. It can never be updated directly by users - only by the system's vote management logic.\n\nThis property directly maps to the 'vote_count' column in the community_platform_comments table in the Prisma schema."},"depth_level":{"type":"integer","description":"The nesting depth of this comment, with 1 being top-level and 8 being maximum allowed.\n\nThis field indicates how deeply nested the comment is in the reply thread. Top-level comments have depth_level = 1, replies to top-level comments have depth_level = 2, and so on.\n\nThis field is auto-calculated by the system based on the parent_comment_id value (depth_level = parent.depth_level + 1). The maximum depth is 8 as defined in community_platform_platform_settings.max_comment_depth.\n\nThis property directly maps to the 'depth_level' column in the community_platform_comments table in the Prisma schema."},"status":{"oneOf":[{"const":"published","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether the comment is visible to users. Comments with status 'published' are visible to everyone. 'unreviewed' comments are visible only to moderators and the author until approved. 'removed' comments are hidden from all users except moderators. 'archived' comments are hidden from public view but preserved for audit.\n\nStatus transitions follow strict rules: only moderators or admins can change status from 'unreviewed' to 'published' or 'removed'. Authors can only delete comments (which sets status to 'removed').\n\nThis property directly maps to the 'status' column in the community_platform_comments table in the Prisma schema."},{"const":"unreviewed","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether the comment is visible to users. Comments with status 'published' are visible to everyone. 'unreviewed' comments are visible only to moderators and the author until approved. 'removed' comments are hidden from all users except moderators. 'archived' comments are hidden from public view but preserved for audit.\n\nStatus transitions follow strict rules: only moderators or admins can change status from 'unreviewed' to 'published' or 'removed'. Authors can only delete comments (which sets status to 'removed').\n\nThis property directly maps to the 'status' column in the community_platform_comments table in the Prisma schema."},{"const":"removed","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether the comment is visible to users. Comments with status 'published' are visible to everyone. 'unreviewed' comments are visible only to moderators and the author until approved. 'removed' comments are hidden from all users except moderators. 'archived' comments are hidden from public view but preserved for audit.\n\nStatus transitions follow strict rules: only moderators or admins can change status from 'unreviewed' to 'published' or 'removed'. Authors can only delete comments (which sets status to 'removed').\n\nThis property directly maps to the 'status' column in the community_platform_comments table in the Prisma schema."},{"const":"archived","description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether the comment is visible to users. Comments with status 'published' are visible to everyone. 'unreviewed' comments are visible only to moderators and the author until approved. 'removed' comments are hidden from all users except moderators. 'archived' comments are hidden from public view but preserved for audit.\n\nStatus transitions follow strict rules: only moderators or admins can change status from 'unreviewed' to 'published' or 'removed'. Authors can only delete comments (which sets status to 'removed').\n\nThis property directly maps to the 'status' column in the community_platform_comments table in the Prisma schema."}],"description":"The moderation status: 'published', 'unreviewed', 'removed', or 'archived'. Determines visibility.\n\nThis field controls whether the comment is visible to users. Comments with status 'published' are visible to everyone. 'unreviewed' comments are visible only to moderators and the author until approved. 'removed' comments are hidden from all users except moderators. 'archived' comments are hidden from public view but preserved for audit.\n\nStatus transitions follow strict rules: only moderators or admins can change status from 'unreviewed' to 'published' or 'removed'. Authors can only delete comments (which sets status to 'removed').\n\nThis property directly maps to the 'status' column in the community_platform_comments table in the Prisma schema."},"created_at":{"type":"string","format":"date-time","description":"The timestamp when the comment was submitted.\n\nThis field records the exact datetime when the comment was first created in the system. It is set by the server and cannot be modified by users or APIs.\n\nThis timestamp is used for sorting comments in chronological order and calculating time-based metrics like comment age.\n\nThis property directly maps to the 'created_at' column in the community_platform_comments table in the Prisma schema."},"updated_at":{"type":"string","format":"date-time","description":"The timestamp when the comment was last modified (e.g., edit).\n\nThis field records the last time the comment was edited by its author. It is updated only when the content is modified within the 10-minute edit window.\n\nAfter the edit window expires, this field is no longer updated even if the comment is deleted or has its status changed by a moderator. This ensures that edits are separately tracked from moderation actions.\n\nThis property directly maps to the 'updated_at' column in the community_platform_comments table in the Prisma schema."},"deleted_at":{"type":"string","format":"date-time","description":"The timestamp when the comment was soft-deleted. Null if still active.\n\nThis field is used only in systems with soft deletion. However, in communityPlatform, comments are subject to hard deletion as there is no soft delete requirement in the schema.\n\nTherefore, this field is present in the schema purely for potential future use or database consistency, but is always null in practice. Deletion of comments is implemented as hard deletion.\n\nThis property directly maps to the 'deleted_at' column in the community_platform_comments table in the Prisma schema."}},"required":["id","community_platform_post_id","author_id","content","vote_count","depth_level","status","created_at"],"description":"Complete comment entity returned by the system for a single comment detail view.\n\nThis object represents a single comment as stored in the community_platform_comments table of the Prisma schema. It is used in the GET /communityPlatform/posts/{postId}/comments/{commentId} endpoint to return full comment information.\n\nAll fields are present and required (except where optional, as noted). This response includes all meta-data required for display including sentiment, hierarchy, and moderation status.\n\nThis entity directly maps to the Prisma schema definition and does not include any inferred or additional properties.\n\nThe comment's relationship to its parent post is established via community_platform_post_id, and its nesting level is established via depth_level and parent_comment_id. The content field is the only user-modifiable field after creation, subject to a 10-minute update window.\n\nNo fields that do not exist in the Prisma schema are included."},"ICommunityPlatformComment.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination. Must be a positive integer starting from 1."},"limit":{"type":"integer","minimum":1,"maximum":50,"default":20,"description":"Number of comments to return per page. Must be between 1 and 50. Defaults to 20."},"sort":{"oneOf":[{"const":"created_at","description":"Sorting criteria for the comments. Must be either 'created_at' for newest first or 'vote_count' for most popular first. Defaults to 'created_at'."},{"const":"vote_count","description":"Sorting criteria for the comments. Must be either 'created_at' for newest first or 'vote_count' for most popular first. Defaults to 'created_at'."}],"description":"Sorting criteria for the comments. Must be either 'created_at' for newest first or 'vote_count' for most popular first. Defaults to 'created_at'."},"order":{"oneOf":[{"const":"asc","description":"Sorting order. Must be 'asc' for ascending or 'desc' for descending. Defaults to 'desc'."},{"const":"desc","description":"Sorting order. Must be 'asc' for ascending or 'desc' for descending. Defaults to 'desc'."}],"description":"Sorting order. Must be 'asc' for ascending or 'desc' for descending. Defaults to 'desc'."},"status":{"oneOf":[{"const":"published","description":"Filter comments by their moderation status. Options are 'published', 'unreviewed', 'removed', or 'archived'. If omitted, only 'published' comments are returned."},{"const":"unreviewed","description":"Filter comments by their moderation status. Options are 'published', 'unreviewed', 'removed', or 'archived'. If omitted, only 'published' comments are returned."},{"const":"removed","description":"Filter comments by their moderation status. Options are 'published', 'unreviewed', 'removed', or 'archived'. If omitted, only 'published' comments are returned."},{"const":"archived","description":"Filter comments by their moderation status. Options are 'published', 'unreviewed', 'removed', or 'archived'. If omitted, only 'published' comments are returned."}],"description":"Filter comments by their moderation status. Options are 'published', 'unreviewed', 'removed', or 'archived'. If omitted, only 'published' comments are returned."},"minDepth":{"type":"integer","minimum":1,"maximum":8,"description":"Minimum depth level for comments. Filters to show only comments at this depth or deeper. Range is 1 to 8, as defined by platform settings."},"maxDepth":{"type":"integer","minimum":1,"maximum":8,"description":"Maximum depth level for comments. Filters to show only comments at this depth or shallower. Range is 1 to 8, as defined by platform settings."}},"required":[],"description":"Request parameters for searching and filtering comments.\n\nThis object defines the criteria for retrieving a paginated, filtered list of comments.\n\nThe parameters allow for comprehensive querying based on pagination limits, sorting preferences, and status filters to support the comment thread loading experience.\n\nFor advanced use cases, depth-level filtering enables users to control the complexity of nested comment threads they wish to view, aligning with platform constraints on maximum nesting depth.\n\nThe properties map directly to database fields in the community_platform_comments table, ensuring strict schema compliance with the Prisma model."},"ICommunityPlatformComment.ICreate":{"type":"object","properties":{"content":{"type":"string","minLength":1,"maxLength":2000,"description":"The text content of the comment, limited to 2,000 characters.\n\nThis field contains the user's message that will be posted as a comment on a post.\n\nThe content must be non-empty (at least 1 character) and must not exceed 2,000 characters to ensure performance and readability.\n\nText formatting is restricted to plain text with no HTML or markdown to maintain consistency and security.\n\nThis field corresponds directly to the 'content' column in the community_platform_comments database table.\n\nValidation rules from the business requirements mandate this character limit to prevent excessive resource usage and ensure predictable rendering in comment threads."}},"required":["content"],"description":"Request payload for creating a new comment.\n\nThis schema represents the input data required to create a new comment on a post.\n\nThe only necessary property is 'content', which must contain the text of the comment following the business rule of being between 1 and 2,000 characters.\n\nThis design follows the Prisma schema definition of the community_platform_comments table, which only requires the content field as mandatory input for comment creation.\n\nNo other fields are accepted in this request because:\n- author_id is automatically inferred from the authenticated user\n- created_at and updated_at are system-generated timestamps\n- parent_comment_id and parent_post_snapshot_id are populated based on context within the API service\n- depth_level is calculated automatically based on the reply hierarchy\n- status is determined by the community's comment_review_mode setting\n- vote_count is initialized to zero\n\nThe schema enforces the business requirement that comment content must be non-empty and have a maximum length of 2,000 characters.\n\nAll other properties are handled server-side based on validated context and constraints from the database schema, ensuring complete alignment with the Prisma model definition."},"ICommunityPlatformComment.IUpdate":{"type":"object","properties":{"content":{"type":"string","maxLength":2000,"description":"The updated content of the comment, limited to 2,000 characters as defined in the Prisma schema. This replaces the existing comment content. Must contain only plain text with no HTML or markdown formatting.\n\nThis property corresponds to the content field in the community_platform_comments table in the Prisma schema, which stores the text of a comment.\n\nThe comment content must be between 1 and 2,000 characters as per the business rules and schema definition. Any content exceeding 2,000 characters must be truncated as per the platform's truncation rules.\n\nThe edit operation is only allowed within a 10-minute window after comment creation, as defined in the community_platform_platform_settings.comment_edit_window_minutes field. This constraint ensures content stability while allowing for minor corrections immediately after posting.\n\nThe content field must not contain any HTML or markdown formatting, maintaining a plain text format that is consistent with the platform's security and simplicity requirements. This restriction prevents potential XSS attacks and ensures consistent rendering across different clients.\n\nThe content field is required for update operations - a comment cannot be updated without specifying new content to replace the existing content. The system will validate that the content field is present and meets the character requirements before processing the update.\n\nDuring an edit operation, the system creates a snapshot of the original comment state in the community_platform_comment_snapshots table to preserve audit history. This snapshot captures the comment's content before modification, ensuring complete traceability for moderation and compliance purposes."}},"required":["content"],"description":"Request payload for updating an existing comment.\n\nThis schema defines the structure of the request body for updating a comment in the communityPlatform system. It includes the updated content field that replaces the existing comment content.\n\nAccording to the business rules and Prisma schema, this update operation is subject to strict constraints: the comment content must be limited to 2,000 characters, and the update can only occur within a 10-minute edit window after the comment's creation. The operation requires authentication to verify the user is the original author of the comment.\n\nThe platform implements a hard update - the original comment is replaced entirely, and the previous version is preserved in an audit trail via the community_platform_comment_snapshots table. The status and moderation state of the comment remain unchanged during an edit operation.\n\nThis update payload is used exclusively with the PUT /communityPlatform/member/posts/{postId}/comments/{commentId} endpoint and cannot be used for other operations. The comment's author and post relationships are determined by the path parameters, not by the request payload.\n\nThis schema must be carefully implemented to comply with the schema constraints of the community_platform_comments table, especially regarding content length limits and timing restrictions."},"ICommunityPlatformSubscription.IRequest":{"type":"object","properties":{"status":{"oneOf":[{"const":"active","description":"Filter subscriptions by their active status to retrieve only active or inactive subscriptions.\n\nThis property is used to filter the list of subscriptions based on whether they are currently active (true) or inactive (false). This corresponds to the active field in the community_platform_subscriptions table.\n\nWhen set to \"active\", the operation returns only subscriptions where active: true (deleted_at is null), filtering out any previously unsubscribed or soft-deleted subscriptions. When set to \"inactive\", the operation returns subscriptions where active: false (deleted_at is not null), showing subscriptions that have been removed by the user.\n\nThis filtering capability is essential for user interfaces that display different views for active subscriptions versus past subscriptions. It allows users to focus on current communities they are subscribed to or review their history of previous subscriptions.\n\nWhen this property is not provided, the default behavior should be to return only active subscriptions, as this is the most common use case.\n\nThis filter directly maps to the active boolean field in the community_platform_subscriptions table, and the system should use this property to apply WHERE conditions in the SQL query for optimal performance.\n\nThe field must exactly match one of the allowed values: \"active\" or \"inactive\". Any other value will result in a validation error."},{"const":"inactive","description":"Filter subscriptions by their active status to retrieve only active or inactive subscriptions.\n\nThis property is used to filter the list of subscriptions based on whether they are currently active (true) or inactive (false). This corresponds to the active field in the community_platform_subscriptions table.\n\nWhen set to \"active\", the operation returns only subscriptions where active: true (deleted_at is null), filtering out any previously unsubscribed or soft-deleted subscriptions. When set to \"inactive\", the operation returns subscriptions where active: false (deleted_at is not null), showing subscriptions that have been removed by the user.\n\nThis filtering capability is essential for user interfaces that display different views for active subscriptions versus past subscriptions. It allows users to focus on current communities they are subscribed to or review their history of previous subscriptions.\n\nWhen this property is not provided, the default behavior should be to return only active subscriptions, as this is the most common use case.\n\nThis filter directly maps to the active boolean field in the community_platform_subscriptions table, and the system should use this property to apply WHERE conditions in the SQL query for optimal performance.\n\nThe field must exactly match one of the allowed values: \"active\" or \"inactive\". Any other value will result in a validation error."}],"description":"Filter subscriptions by their active status to retrieve only active or inactive subscriptions.\n\nThis property is used to filter the list of subscriptions based on whether they are currently active (true) or inactive (false). This corresponds to the active field in the community_platform_subscriptions table.\n\nWhen set to \"active\", the operation returns only subscriptions where active: true (deleted_at is null), filtering out any previously unsubscribed or soft-deleted subscriptions. When set to \"inactive\", the operation returns subscriptions where active: false (deleted_at is not null), showing subscriptions that have been removed by the user.\n\nThis filtering capability is essential for user interfaces that display different views for active subscriptions versus past subscriptions. It allows users to focus on current communities they are subscribed to or review their history of previous subscriptions.\n\nWhen this property is not provided, the default behavior should be to return only active subscriptions, as this is the most common use case.\n\nThis filter directly maps to the active boolean field in the community_platform_subscriptions table, and the system should use this property to apply WHERE conditions in the SQL query for optimal performance.\n\nThe field must exactly match one of the allowed values: \"active\" or \"inactive\". Any other value will result in a validation error."},"sortBy":{"oneOf":[{"const":"created_at","description":"Define the field to sort the subscription list by."},{"const":"community_name","description":"Define the field to sort the subscription list by."}],"description":"Define the field to sort the subscription list by."},"sortOrder":{"oneOf":[{"const":"asc","description":"Define the sort order for the subscription list, either ascending (asc) or descending (desc). \n\nThis parameter controls the ordering of subscriptions in the returned list. When set to \"asc\", the results will be ordered from oldest to newest. When set to \"desc\", the results will be ordered from newest to oldest.\n\nThis parameter works in conjunction with the sortBy parameter to determine the final ordering of results. For example, if sortBy is \"created_at\" and sortOrder is \"desc\", the most recently created subscriptions will appear first in the response.\n\nThe default value should be \"desc\" to show recent subscriptions first, which is the most intuitive experience for users.\n\nThe valid values are \"asc\" (ascending) and \"desc\" (descending). Any other value will result in a validation error. This parameter is optional and can be omitted to use the default order."},{"const":"desc","description":"Define the sort order for the subscription list, either ascending (asc) or descending (desc). \n\nThis parameter controls the ordering of subscriptions in the returned list. When set to \"asc\", the results will be ordered from oldest to newest. When set to \"desc\", the results will be ordered from newest to oldest.\n\nThis parameter works in conjunction with the sortBy parameter to determine the final ordering of results. For example, if sortBy is \"created_at\" and sortOrder is \"desc\", the most recently created subscriptions will appear first in the response.\n\nThe default value should be \"desc\" to show recent subscriptions first, which is the most intuitive experience for users.\n\nThe valid values are \"asc\" (ascending) and \"desc\" (descending). Any other value will result in a validation error. This parameter is optional and can be omitted to use the default order."}],"description":"Define the sort order for the subscription list, either ascending (asc) or descending (desc). \n\nThis parameter controls the ordering of subscriptions in the returned list. When set to \"asc\", the results will be ordered from oldest to newest. When set to \"desc\", the results will be ordered from newest to oldest.\n\nThis parameter works in conjunction with the sortBy parameter to determine the final ordering of results. For example, if sortBy is \"created_at\" and sortOrder is \"desc\", the most recently created subscriptions will appear first in the response.\n\nThe default value should be \"desc\" to show recent subscriptions first, which is the most intuitive experience for users.\n\nThe valid values are \"asc\" (ascending) and \"desc\" (descending). Any other value will result in a validation error. This parameter is optional and can be omitted to use the default order."},"page":{"type":"integer","minimum":1,"description":"The page number to retrieve from the subscription list.\n\nThis parameter specifies which page of results should be returned in the paginated response. Page numbering starts at 1 (not 0), and each page contains a fixed number of items based on the limit parameter.\n\nThis parameter is essential for implementing infinite scrolling or pagination in the user interface, allowing clients to load subscription lists in manageable chunks rather than retrieving all subscriptions at once.\n\nIf the specified page number exceeds the total number of available pages, the system should return an empty data array. Negative page numbers or zero are invalid and should return a validation error.\n\nThe default page value is 1, meaning the first page of results is returned when this parameter is not provided.\n\nNote that this parameter works in combination with the limit parameter to define the pagination mechanism: page * limit determines the offset of results."},"limit":{"type":"integer","minimum":1,"maximum":100,"default":50,"description":"The number of subscriptions to include per page.\n\nThis parameter controls how many subscription records are returned in each response page. It determines the pagination size and impacts both network performance and user experience.\n\nThe maximum value for limit is 100 to prevent excessive data transfer and maintain response time efficiency. The default value is 50, which provides a good balance between reducing pagination frequency and minimizing payload size.\n\nIf a client requests a limit greater than 100, the system should use 100 as the effective limit.\n\nIf a client requests a limit less than 1, the system should use 1 as the effective limit.\n\nMinimizing the limit value increases the number of requests required to retrieve all subscriptions but reduces network payload size per request. Maximizing the limit reduces the number of requests but increases the data transfer per request.\n\nThe value should be chosen based on mobile and desktop performance considerations and the typical screen size for displaying subscription data."},"search":{"type":"string","minLength":1,"maxLength":100,"description":"Text to search for in community names or descriptions.\n\nThis parameter enables full-text search across community names and descriptions to help users find relevant communities among their subscriptions.\n\nThe search term should be matched against the community name from the community_platform_communities table and the community description field. The search should be case-insensitive and support partial matches.\n\nThis filtering capability is particularly useful for users with large numbers of subscriptions (up to 1,000) who need to quickly locate specific communities.\n\nIf the search term is longer than 100 characters, it should be truncated to 100 characters before processing.\n\nThe system should implement efficient text search using database indexes on the community name and description fields to maintain performance even with large datasets."}},"required":[],"description":"Request parameters for searching and filtering a user's list of subscriptions.\n\nThis schema defines the optional parameters that can be provided to filter and sort the response from the GET /communityPlatform/member/subscriptions endpoint.\n\nThe request is designed to be flexible, allowing users to customize their subscription list view based on various criteria. All parameters are optional, and if not provided, the system will return all subscriptions in the default order.\n\nThe status parameter allows filtering subscriptions based on their active/inactive state, which is particularly useful for reviewing subscription history.\n\nThe sortBy and sortOrder parameters enable users to arrange subscriptions in meaningful ways, such as by creation date or community name.\n\nThe page and limit parameters provide pagination control, allowing clients to efficiently load large lists of subscriptions without performance degradation.\n\nThe search parameter enables full-text search across community names and descriptions, helping users quickly find specific communities within their subscription list.\n\nThis request structure aligns with the user journey steps 6.5 and 8.1 of the requirements documentation, supporting the \"My Subscribed Communities\" panel functionality.\n\nThe system must properly validate all parameters against their schemas before processing the request. Invalid parameters should result in appropriate error responses."},"ICommunityPlatformSubscription":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary Key.\n\nUnique identifier of the subscription record in the database.\n\nThis field is generated automatically by the system upon subscription creation and is used as the primary key for the community_platform_subscriptions table.\n\nThe UUID format ensures global uniqueness and prevents collisions across distributed systems.\n\nThis identifier is used in API endpoints to reference the specific subscription record for operations like retrieval, status update, or deletion.\n\nAll subscription-related interactions in the system must reference this unique ID for accurate record targeting."},"member_id":{"type":"string","format":"uuid","description":"Reference to the subscribing member.\n\nThis field links the subscription record to the community_platform_member table, identifying which user has subscribed to the community.\n\nThis relationship is enforced through a foreign key constraint to maintain referential integrity.\n\nThe member_id cannot be null and must correspond to a valid, active member account.\n\nThis field enables the system to track user-specific subscription history and enforce subscription limits per user.\n\nAccess control rules ensure that users can only view and modify their own subscriptions by validating the member_id against the authenticated user."},"community_id":{"type":"string","format":"uuid","description":"Reference to the subscribed community.\n\nThis field links the subscription record to the community_platform_communities table, identifying which community the user has subscribed to.\n\nThis relationship is enforced through a foreign key constraint to maintain referential integrity.\n\nThe community_id cannot be null and must correspond to a valid, active community.\n\nThis field enables the system to determine which community's content should be prioritized in the user's feed.\n\nIt also allows efficient querying of all users subscribed to a specific community, which is critical for content distribution and community metrics."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the subscription was created.\n\nThis field records the exact moment when the user successfully subscribed to the community.\n\nThe timestamp is set by the server at the time of subscription creation and is immutable.\n\nThis field is used for sorting subscriptions by recency and for calculating user engagement metrics.\n\nThe data type is stored as a timezone-aware timestamp (Timestamptz) in the database to ensure consistency across time zones, with all timestamps normalized to UTC for storage and comparison."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the subscription was last updated.\n\nThis field records the most recent modification to the subscription record, such as when the status is changed from active to inactive.\n\nThe timestamp is automatically updated by the system whenever the subscription state changes.\n\nThis field enables tracking of when subscriptions were reactivated or deactivated, providing insight into user engagement patterns.\n\nThe data type is stored as a timezone-aware timestamp (Timestamptz) in the database to ensure consistency across time zones, with all timestamps normalized to UTC for storage and comparison."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft delete timestamp.\n\nWhen this field contains a timestamp, it indicates that the subscription was deactivated or cancelled by the user.\n\nWhen null, the subscription is considered active and the user can receive content from the community.\n\nThis field implements a soft delete pattern to preserve subscription history for metrics and audit purposes, rather than permanently removing the record.\n\nThe system excludes subscriptions with a non-null deleted_at value from active feed queries, effectively un-subscribing the user without losing historical data.\n\nThis design allows users to re-subscribe to a community and restore their previous subscription state if desired."},{"type":"null"}],"description":"Soft delete timestamp.\n\nWhen this field contains a timestamp, it indicates that the subscription was deactivated or cancelled by the user.\n\nWhen null, the subscription is considered active and the user can receive content from the community.\n\nThis field implements a soft delete pattern to preserve subscription history for metrics and audit purposes, rather than permanently removing the record.\n\nThe system excludes subscriptions with a non-null deleted_at value from active feed queries, effectively un-subscribing the user without losing historical data.\n\nThis design allows users to re-subscribe to a community and restore their previous subscription state if desired."},"active":{"type":"boolean","description":"Current status of the subscription.\n\nWhen true, the subscription is active and the user can receive content from the community in their feed.\n\nWhen false, the subscription is deactivated - the user will not receive new content from this community, but the subscription record remains in the database.\n\nThis field is a performance optimization to enable efficient filtering of active subscriptions without needing to check the deleted_at field for every query.\n\nThe active flag can be toggled independently of the deleted_at field: a subscription can have a non-null deleted_at but still have active: true (a state that should not occur), or deleted_at: null and active: false (a standard inactive state).\n\nThe system ensures data consistency by setting active: false when deleted_at is set and vice versa."},"metadata":{"oneOf":[{"type":"string","description":"JSON string containing additional context about the subscription.\n\nThis optional field stores structured metadata about the subscription in JSON format, such as the source of the subscription (e.g., \"referal\", \"promotion\", \"auto_follow\"), or any system-generated flags.\n\nThis field is extensible and can be used by the platform to track subscription-specific behavior without requiring schema changes.\n\nExamples of potential values: {\"source\": \"recommended\"}, {\"auto_followed\": true}, {\"earned_by_karma\": 1000}.\n\nThis field is not currently used by the core system but is reserved for future extensibility and analytics purposes."},{"type":"null"}],"description":"JSON string containing additional context about the subscription.\n\nThis optional field stores structured metadata about the subscription in JSON format, such as the source of the subscription (e.g., \"referal\", \"promotion\", \"auto_follow\"), or any system-generated flags.\n\nThis field is extensible and can be used by the platform to track subscription-specific behavior without requiring schema changes.\n\nExamples of potential values: {\"source\": \"recommended\"}, {\"auto_followed\": true}, {\"earned_by_karma\": 1000}.\n\nThis field is not currently used by the core system but is reserved for future extensibility and analytics purposes."}},"required":["id","member_id","community_id","created_at","updated_at","active"],"description":"Represents a user's subscription to a specific community on the platform.\n\nThis entity establishes the many-to-many relationship between users and communities, allowing members to follow communities of interest and receive their content in personalized feeds.\n\nEach subscription record links a member_id to a community_id, creating a direct association that governs content visibility and feed prioritization.\n\nThe subscription model supports both active and inactive states through the use of a soft delete pattern (deleted_at) and a status flag (active), enabling users to temporarily deactivate subscriptions without losing their subscription history.\n\nThe system enforces a maximum of 1,000 subscriptions per user as defined in community_platform_platform_settings, preventing excessive resource consumption and maintaining performance.\n\nThis entity integrates with other core tables: community_platform_member for user context, community_platform_communities for community context, and community_platform_posts for content delivery.\n\nThe data from this table is used to power the \"My Subscribed Communities\" feature, determine content ranking in home feeds, and calculate user engagement metrics for platform analytics.\n\nThe design ensures efficient querying for both \"all subscriptions by user\" and \"all users by community\" patterns, utilizing appropriate database indexes on member_id, community_id, and deleted_at."},"ICommunityPlatformSubscription.ICreate":{"type":"object","properties":{"community_id":{"type":"string","format":"uuid","description":"Reference to the community to subscribe to.\n\nThis field must reference an existing and active community in the community_platform_communities table.\n\nThe community_id identifies the specific community the user wishes to follow and is a required field for subscription creation.\n\nThe system validates that the community exists and is not suspended or deleted before allowing the subscription.\n\nThis field cannot be null and must correspond to a valid UUID format.\n\nThe association is one-way: the user subscribes to the community, but the community does not have direct knowledge of its subscribers beyond the subscription record."}},"required":["community_id"],"description":"Request payload for creating a new community subscription.\n\nThis schema defines the minimal data required to initiate a subscription to a community.\n\nOnly the community_id field is required, as all other necessary data (user ID, timestamps, status flags) is determined by the system based on the authenticated user's session and predefined defaults.\n\nThe subscription is created as active by default, with created_at and updated_at set to the current time and deleted_at set to null.\n\nThis type is used exclusively for POST requests to create new subscriptions and must not include any fields that are system-generated (such as id, member_id, or timestamps).\n\nThe system validates that the user has not exceeded their subscription limit of 1,000 communities before allowing creation.\n\nThis schema ensures a clean separation between client-provided data and system-managed data, preventing potential tampering with subscription state."},"ICommunityPlatformSubscription.IUpdate":{"type":"object","properties":{"active":{"type":"boolean","description":"The new subscription status to set. True enables the subscription, false deactivates it without deleting the record.\n\nThis corresponds to the `active` boolean field in the community_platform_subscriptions table.\n\nThis flag controls whether the subscription is active and visible in the user's feed. When set to false, the user will no longer receive content from the community in personalized feeds. The subscription record remains in the database with its `deleted_at` field unchanged, preserving the subscription history for potential re-subscription.\n\nThe `active` field is updated using the PUT /member/subscriptions/{subscriptionId} endpoint. This operation does not delete the record from the database, unlike the DELETE endpoint which performs a hard deletion.\n\nThe business rules specify that users can subscribe to a maximum of 1,000 communities. Setting `active` to false for a subscription reduces the number of active subscriptions for the user, but does not affect the maximum limit.\n\nThe system validates that only the authenticated user can change their own subscription status.\n\nThe `active` field is required in the request body, since it is the only field allowed to be updated. It is directly mapped to the database field in the community_platform_subscriptions table."}},"required":["active"],"description":"Update request payload for a community subscription.\n\nThis object represents the data required to update an existing community subscription for an authenticated user. The system allows only one field to be modified: the active status of the subscription.\n\nThis corresponds to the community_platform_subscriptions table in the Prisma schema, which manages the many-to-many relationship between users and communities. The table contains fields including member_id, community_platform_communities_id, created_at, updated_at, deleted_at, and active.\n\nThe implementation requires that only the `active` flag can be modified. When the subscription is created, the `active` flag is set to true and `deleted_at` is null. This object allows a user to toggle the subscription between active and inactive states.\n\nAll other fields from the community_platform_subscriptions table (such as member_id, community_platform_communities_id, created_at, updated_at, and deleted_at) are immutable after creation and cannot be modified by this update object. The `updated_at` timestamp is automatically managed by the database and will be updated when this request is processed.\n\nThis operation is different from the DELETE endpoint, which completely removes the subscription record from the database. This update operation preserves the subscription history and allows for future re-subscription without requiring a new invitation or approval.\n\nThe field is named 'active' to align with the Prisma schema's field name directly, following the naming convention that properties in DTOs should mirror their underlying database entities when possible. No additional validation is needed beyond confirming the boolean type and presence of the field.\n\nThe object is also linked to other entities through its relationship context:\n- The subscription is associated with a community_platform_member (user) via the member_id foreign key\n- The subscription is associated with a community_platform_communities (community) via the community_platform_communities_id foreign key\n\nChanges to the active flag may trigger notifications to the user and update the community's member_count in the community_platform_communities table as a side effect."},"ICommunityPlatformReport":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the report, conforming to RFC 4122.\n\nThis field corresponds to the `id` primary key field in the community_platform_reports table.\n\nThe report ID is generated by the database upon creation and is not modifiable thereafter. It serves as the primary mechanism to uniquely identify and reference each report in the system for all subsequent operations, including viewing, updating, and deleting reports.\n\nThis UUID is used in all API endpoints that reference reports, such as GET /reports/{reportId}, PUT /reports/{reportId}/actions, and DELETE /reports/{reportId}.\n\nThe generation of this ID is handled by the database with UUID type, ensuring global uniqueness across all server instances and database replicas. This supports the stateless nature of the API, as clients can use this ID to reference specific reports without needing to maintain session state.\n\nThe field is required in all responses containing report data to enable clients to perform follow-up operations on the reported content."},"reported_content_id":{"type":"string","format":"uuid","description":"The unique identifier of the post being reported.\n\nThis is a foreign key reference to the `id` field in the community_platform_posts table. One of either reported_content_id or reported_comment_id must be provided to identify the target of the report, but not both.\n\nThis field indicates that the report is targeting a post. It connects the report to the specific post entity that is being flagged, enabling moderators to locate, review, and take action on the content.\n\nThe reported_content_id is stored as a string UUID in the database and is not null when reporting a post. System logic enforces that exactly one of reported_content_id or reported_comment_id must be provided with each report, ensuring there is always one clear target for moderation.\n\nThe integrity of this relationship is maintained through database foreign key constraints from the community_platform_reports table to the community_platform_posts table, ensuring that a report cannot be created against a non-existent post.\n\nThe field is included in all report responses and is used to link the report to its content context, allowing for audit tracking across the entire content lifecycle."},"reported_comment_id":{"type":"string","format":"uuid","description":"The unique identifier of the comment being reported.\n\nThis is a foreign key reference to the `id` field in the community_platform_comments table. One of either reported_content_id or reported_comment_id must be provided to identify the target of the report, but not both.\n\nThis field indicates that the report is targeting a comment. It connects the report to the specific comment entity that is being flagged, enabling moderators to locate, review, and take action on the content.\n\nThe reported_comment_id is stored as a string UUID in the database and is not null when reporting a comment. System logic enforces that exactly one of reported_content_id or reported_comment_id must be provided with each report, ensuring there is always one clear target for moderation.\n\nThe integrity of this relationship is maintained through database foreign key constraints from the community_platform_reports table to the community_platform_comments table, ensuring that a report cannot be created against a non-existent comment.\n\nThe field is included in all report responses and is used to link the report to its content context, allowing for audit tracking across the entire comment thread lifecycle."},"reporter_id":{"type":"string","format":"uuid","description":"The ID of the user who submitted the report.\n\nThis is a foreign key reference to the `id` field in the community_platform_member table. This field records the identity of the person who reported the content for audit purposes, but does not expose this identity to the content author for privacy and protection against retaliation.\n\nThe reporter_id is required in every report and cannot be null, as every report must have an originating user. This enables system administrators to track reporting patterns, identify potential abuse of the reporting system, and implement rate limiting per user as defined in community_platform_platform_settings.max_reports_per_day.\n\nWhile the reporter_id is stored and accessible to administrators and moderators, it is not included in public responses to the content author. This anonymization protects reporters while still allowing for accountability and investigation of misuse.\n\nThis relationship ties the report to a verified member account, ensuring that anonymous guests cannot submit reports. The reporter's identity is preserved in database audit logs and can be referenced for compliance or investigation purposes."},"target_type":{"type":"string","description":"Discriminator indicating whether the report targets a 'post' or 'comment'.\n\nThis field must be one of the literal strings 'post' or 'comment'. It is used to disambiguate which child entity (post or comment) is being targeted by the report when paired with the foreign key fields reported_content_id or reported_comment_id.\n\nThe discriminator is required for every report submission, and the value is automatically derived from the presence of reported_content_id or reported_comment_id in the input. For example:\n- If reported_content_id is provided, target_type is set to 'post'\n- If reported_comment_id is provided, target_type is set to 'comment'\n\nThe target_type field is persisted in the community_platform_reports table and is referenced by the system when retrieving report details or applying moderation actions. It ensures that the correct data type is acted upon without requiring the system to infer from the foreign key fields, improving clarity and robustness in code.\n\nThis field supports the design principle that a report can only target one type of content at a time, maintaining single responsibility in the reporting workflow."},"status":{"type":"string","description":"Current status of the report, determining its position in the moderation workflow.\n\nThis field must be one of the following enumerated values: 'pending', 'dismissed', 'removed', or 'escalated'.\n\nThe status field governs the lifecycle of a report:\n- 'pending': Report has been submitted and is awaiting review by a moderator.\n- 'dismissed': Moderator has reviewed the report and determined no action is necessary.\n- 'removed': Moderator has taken action to remove the reported content, so it is no longer visible to users.\n- 'escalated': Report has been flagged by moderators or automated systems as requiring attention from system administrators.\n\nThe status value is updated by moderators or administrators using the PUT /reports/{reportId}/actions endpoint. It is immutable from client-side requests to prevent bypassing moderation.\n\nThe field directly maps to the status column in the community_platform_reports table and influences the visibility and handling of the reported content. The status must be validated against allowed values in the system to maintain data integrity."},"report_reason":{"type":"string","description":"The category of reason selected by the reporter for the issue reported.\n\nThis field must correspond to one of the valid values in the community_platform_report_categories.name field, such as: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThe report_reason is selected from predefined options presented to the user during the report submission flow. This categorization helps moderators triage and prioritize reports based on severity.\n\nThe system validates that the report_reason provided matches exactly one existing record in the community_platform_report_categories table. This ensures consistency and enables future filtering and analytics based on reason categories.\n\nThis field does not accept free-form text; any additional context from the reporter is stored separately in the report_notes field. The report_reason serves as machine-readable categorization for automation and reporting purposes.\n\nThe report_reason is required and cannot be null when submitting a report, ensuring every report has at least a basic classification."},"report_notes":{"type":"string","description":"Optional additional context provided by the reporter about why they are reporting the content.\n\nThis field can contain up to 500 characters of free-form text, allowing reporters to provide specific details or evidence that may assist moderators in their review. Examples include referencing specific posts in the comment thread, describing the context of harassment, or providing links to additional violated content.\n\nThe field is optional and may be null if the reporter submits a report without additional context.\n\nThis field maps to the report_notes column in the community_platform_reports table and is displayed only to moderators and administrators, never to the content author or other users. It serves as a private augmentation to the report_reason field for detailed case analysis.\n\nThe system enforces a 500-character limit to prevent long-form submissions from overwhelming moderation workflows or causing string overflow in the database. This respects the field's design as a short-note adjunct to the structured reason field."},"created_at":{"type":"string","format":"date-time","description":"Timestamp indicating when the report was initially submitted by the user.\n\nThis value is automatically generated by the system at the time of report creation and is immutable. It is stored in the created_at column of the community_platform_reports table and is provided in ISO 8601 date-time format.\n\nThis field is used for audit trail purposes, allowing moderators to determine the order in which reports were submitted and to assess report timing for patterns such as coordinated abuse or burst activity.\n\nThe timestamp is recorded in UTC and reflects the system's current time when the report is created. The system guarantees that this field cannot be spoofed by the client and is strictly handled server-side based on the system clock.\n\nThis field is required in all report responses to enable proper sorting, pagination, and historical analysis of reports, and is used to calculate metrics like average response time for report resolution."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of the last status update to this report.\n\nThis value is automatically updated by the system whenever the report's status is changed by a moderator or administrator. It is stored in the updated_at column of the community_platform_reports table and is provided in ISO 8601 date-time format.\n\nThis field reflects when the report last transitioned in its workflow — for instance, from 'pending' to 'removed' or 'dismissed'. It does not change if only the report_notes field is updated, as that is not considered a status change. The field is used to monitor the time between report submission and resolution.\n\nThe system ensures that updated_at is derived from server time to prevent client-side manipulation. This field is required in all report responses and plays a critical role in reporting KPIs such as report resolution time. In combination with created_at, it helps determine how long a report has been pending and whether it requires escalation."}},"required":["id","reporter_id","target_type","status","report_reason","created_at","updated_at"],"description":"Complete report object as stored in the system, including metadata about the reported content, the reporter, and its status.\n\nThis schema defines the structure of a content report entity as it exists in the database (community_platform_reports table). It represents a complete record of a user-submitted report, including identifying information for both the reported content and the reporter, the reason for the report, and its processing status.\n\nThe report captures:\n- Exactly which content (post or comment) was reported via reported_content_id or reported_comment_id\n- Who made the report via reporter_id\n- What category of violation was chosen via report_reason\n- The current state of the report's lifecycle via status\n- When the report was submitted and last updated\n\nThis structure ensures all necessary information for moderation decisions, audit purposes, and user notifications is retained. The schema strictly adheres to the Prisma schema (community_platform_reports) and includes no inferred or unsupported fields.\n\nThe response excludes the reporter's personal identifying information (email, username) at the API level to protect reporter anonymity as required by privacy regulations. Only the internal ID (reporter_id) is exposed, which is meaningless without database access.\n\nThe ‘target_type’ discriminator field is essential to interpret which of the two foreign key fields (reported_content_id or reported_comment_id) is active. The system does not allow both or neither to be populated, ensuring data integrity.\n\nThis type forms the foundational data object for all report-related operations: viewing, filtering, and acting on reports.\n\nAll fields are either required or formally nullable with precise semantics as documented. Dates are in consistent ISO 8601 format to ensure interoperability across clients and platforms."},"ICommunityPlatformReport.IRequest":{"type":"object","properties":{"reporterId":{"type":"string","format":"uuid","description":"The unique identifier of the user who submitted the report. This field allows filtering reports by their originator. It corresponds to the reporter_id field in the community_platform_reports table from the Prisma schema. When provided, only reports submitted by this specific user will be included in results.\n\nThis property is optional and when omitted, reports from all reporters will be returned.\n\nThe UUID format ensures consistency with the platform's data model and provides unique identification for users."},"targetType":{"oneOf":[{"const":"post","description":"The type of content being reported. This field allows filtering reports by target type between 'post' and 'comment'. It corresponds to the target_type field in the community_platform_reports table from the Prisma schema.\n\nWhen specified, only reports related to the designated type will be included in results. This enables moderators to quickly filter between the two main content types on the platform.\n\nAccording to the schema, this field is a discriminator that must be one of the predefined values ('post' or 'comment') to properly identify the report's target content type."},{"const":"comment","description":"The type of content being reported. This field allows filtering reports by target type between 'post' and 'comment'. It corresponds to the target_type field in the community_platform_reports table from the Prisma schema.\n\nWhen specified, only reports related to the designated type will be included in results. This enables moderators to quickly filter between the two main content types on the platform.\n\nAccording to the schema, this field is a discriminator that must be one of the predefined values ('post' or 'comment') to properly identify the report's target content type."}],"description":"The type of content being reported. This field allows filtering reports by target type between 'post' and 'comment'. It corresponds to the target_type field in the community_platform_reports table from the Prisma schema.\n\nWhen specified, only reports related to the designated type will be included in results. This enables moderators to quickly filter between the two main content types on the platform.\n\nAccording to the schema, this field is a discriminator that must be one of the predefined values ('post' or 'comment') to properly identify the report's target content type."},"status":{"oneOf":[{"const":"pending","description":"The current moderation status of the report. This field allows filtering reports by their processing state. It corresponds to the status field in the community_platform_reports table from the Prisma schema.\n\nThe allowed values are:\n- 'pending': The report has been submitted but not yet reviewed\n- 'dismissed': A moderator has reviewed the report and determined no action is needed\n- 'removed': The reported content has been removed by a moderator\n- 'escalated': The report has been escalated for administrative review\n\nThis property is optional and when omitted, reports with any status will be returned."},{"const":"dismissed","description":"The current moderation status of the report. This field allows filtering reports by their processing state. It corresponds to the status field in the community_platform_reports table from the Prisma schema.\n\nThe allowed values are:\n- 'pending': The report has been submitted but not yet reviewed\n- 'dismissed': A moderator has reviewed the report and determined no action is needed\n- 'removed': The reported content has been removed by a moderator\n- 'escalated': The report has been escalated for administrative review\n\nThis property is optional and when omitted, reports with any status will be returned."},{"const":"removed","description":"The current moderation status of the report. This field allows filtering reports by their processing state. It corresponds to the status field in the community_platform_reports table from the Prisma schema.\n\nThe allowed values are:\n- 'pending': The report has been submitted but not yet reviewed\n- 'dismissed': A moderator has reviewed the report and determined no action is needed\n- 'removed': The reported content has been removed by a moderator\n- 'escalated': The report has been escalated for administrative review\n\nThis property is optional and when omitted, reports with any status will be returned."},{"const":"escalated","description":"The current moderation status of the report. This field allows filtering reports by their processing state. It corresponds to the status field in the community_platform_reports table from the Prisma schema.\n\nThe allowed values are:\n- 'pending': The report has been submitted but not yet reviewed\n- 'dismissed': A moderator has reviewed the report and determined no action is needed\n- 'removed': The reported content has been removed by a moderator\n- 'escalated': The report has been escalated for administrative review\n\nThis property is optional and when omitted, reports with any status will be returned."}],"description":"The current moderation status of the report. This field allows filtering reports by their processing state. It corresponds to the status field in the community_platform_reports table from the Prisma schema.\n\nThe allowed values are:\n- 'pending': The report has been submitted but not yet reviewed\n- 'dismissed': A moderator has reviewed the report and determined no action is needed\n- 'removed': The reported content has been removed by a moderator\n- 'escalated': The report has been escalated for administrative review\n\nThis property is optional and when omitted, reports with any status will be returned."},"reportReason":{"type":"string","description":"The category of violation reported by the user. This field allows filtering reports by the reason category selected during submission. It maps to the report_reason field in the community_platform_reports table and corresponds to the name values in the community_platform_report_categories table.\n\nThis property is optional. When provided, it should match the exact name used in the report categories table (e.g., 'spam', 'harassment', 'inappropriate', 'other'). This ensures accurate filtering based on the predefined report reason types defined in the system."},"page":{"type":"integer","minimum":1,"description":"The page number for pagination. This parameter controls which page of results to return.\n\nThe minimum value is 1, representing the first page. Subsequent pages increment from this value.\n\nWhen omitted, this parameter defaults to 1, returning the first page of results.\n\nThis field aligns with the pagination requirements in the platform's performance specifications, which limit results to 25 reports per page for optimal response times."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"The number of reports to return per page. This parameter controls the size of each pagination chunk.\n\nThe minimum value is 1, ensuring at least one report is returned. The maximum value is 100 to prevent performance degradation and excessive response sizes, aligning with the platform's performance requirements.\n\nWhen omitted, the default value is 25, which aligns with the standard pagination size specified in the moderator interface requirements."},"sortBy":{"oneOf":[{"const":"created_at","description":"The field by which to sort the results. This parameter determines the ordering of reports in the response.\n\nThe available sorting options are:\n- 'created_at': Sorts reports by their creation timestamp, newest first\n- 'updated_at': Sorts reports by their last update timestamp, newest first\n- 'target_popularity': Sorts reports by the popularity (vote count) of the reported content\n- 'moderator_actions': Sorts reports by the number of moderator actions taken on them\n\nWhen omitted, results are sorted by created_at (newest first) as the default behavior."},{"const":"updated_at","description":"The field by which to sort the results. This parameter determines the ordering of reports in the response.\n\nThe available sorting options are:\n- 'created_at': Sorts reports by their creation timestamp, newest first\n- 'updated_at': Sorts reports by their last update timestamp, newest first\n- 'target_popularity': Sorts reports by the popularity (vote count) of the reported content\n- 'moderator_actions': Sorts reports by the number of moderator actions taken on them\n\nWhen omitted, results are sorted by created_at (newest first) as the default behavior."},{"const":"target_popularity","description":"The field by which to sort the results. This parameter determines the ordering of reports in the response.\n\nThe available sorting options are:\n- 'created_at': Sorts reports by their creation timestamp, newest first\n- 'updated_at': Sorts reports by their last update timestamp, newest first\n- 'target_popularity': Sorts reports by the popularity (vote count) of the reported content\n- 'moderator_actions': Sorts reports by the number of moderator actions taken on them\n\nWhen omitted, results are sorted by created_at (newest first) as the default behavior."},{"const":"moderator_actions","description":"The field by which to sort the results. This parameter determines the ordering of reports in the response.\n\nThe available sorting options are:\n- 'created_at': Sorts reports by their creation timestamp, newest first\n- 'updated_at': Sorts reports by their last update timestamp, newest first\n- 'target_popularity': Sorts reports by the popularity (vote count) of the reported content\n- 'moderator_actions': Sorts reports by the number of moderator actions taken on them\n\nWhen omitted, results are sorted by created_at (newest first) as the default behavior."}],"description":"The field by which to sort the results. This parameter determines the ordering of reports in the response.\n\nThe available sorting options are:\n- 'created_at': Sorts reports by their creation timestamp, newest first\n- 'updated_at': Sorts reports by their last update timestamp, newest first\n- 'target_popularity': Sorts reports by the popularity (vote count) of the reported content\n- 'moderator_actions': Sorts reports by the number of moderator actions taken on them\n\nWhen omitted, results are sorted by created_at (newest first) as the default behavior."},"order":{"oneOf":[{"const":"asc","description":"The sort order direction. This parameter determines whether results are sorted in ascending or descending order based on the sortBy field.\n\nThe available values are:\n- 'asc': Ascending order (oldest to newest)\n- 'desc': Descending order (newest to oldest)\n\nWhen omitted, the default value is 'desc', which presents the most recent reports first, aligning with moderator workflow expectations."},{"const":"desc","description":"The sort order direction. This parameter determines whether results are sorted in ascending or descending order based on the sortBy field.\n\nThe available values are:\n- 'asc': Ascending order (oldest to newest)\n- 'desc': Descending order (newest to oldest)\n\nWhen omitted, the default value is 'desc', which presents the most recent reports first, aligning with moderator workflow expectations."}],"description":"The sort order direction. This parameter determines whether results are sorted in ascending or descending order based on the sortBy field.\n\nThe available values are:\n- 'asc': Ascending order (oldest to newest)\n- 'desc': Descending order (newest to oldest)\n\nWhen omitted, the default value is 'desc', which presents the most recent reports first, aligning with moderator workflow expectations."},"startDate":{"type":"string","format":"date-time","description":"The start date for filtering reports by creation time. Only reports created on or after this timestamp will be included in results.\n\nThis field allows moderation workflows to focus on recent reports during active review periods. The format must follow the ISO 8601 date-time standard (UTC) for consistency across the system.\n\nThis property is optional and when omitted, reports from the beginning of time will be considered."},"endDate":{"type":"string","format":"date-time","description":"The end date for filtering reports by creation time. Only reports created on or before this timestamp will be included in results.\n\nThis field allows moderation workflows to focus on reports from specific time periods, such as daily or weekly review cycles. The format must follow the ISO 8601 date-time standard (UTC) for consistency across the system.\n\nThis property is optional and when omitted, reports up to the current time will be considered."}},"required":[],"description":"Request parameters for searching and filtering content reports. This schema is used when the system needs to query a list of reports with criteria-based filtering and pagination.\n\nThis object represents the search/query parameters for the reports search functionality, enabling advanced discovery and triage of reported content by moderators and administrators.\n\nThe schema reflects the business requirements for report management, particularly the need for comprehensive filtering by reporter, target type, status, and reason category, along with pagination and sorting capabilities.\n\nEach property corresponds directly to fields in the community_platform_reports table of the Prisma schema or to pagination/sorting parameters defined in the platform's performance requirements.\n\nThis request object is designed to be used in combination with the PATCH /reports endpoint to retrieve customized slices of the complete report dataset."},"ICommunityPlatformReport.ICreate":{"type":"object","properties":{"reportedContentId":{"type":"string","format":"uuid","description":"The unique identifier of the post being reported. This field is mandatory when reporting a post.\n\nThis property corresponds to the reported_content_id field in the community_platform_reports table from the Prisma schema. It links the report to the specific post content that has been flagged.\n\nExactly one of reportedContentId or reportedCommentId must be provided, but not both. This field is used to establish the relationship between the report and the target content, ensuring the system can locate and process the reported item.\n\nWhen submitting a report on a post, this field must be provided with a valid UUID that references an existing post in the community_platform_posts table."},"reportedCommentId":{"type":"string","format":"uuid","description":"The unique identifier of the comment being reported. This field is mandatory when reporting a comment.\n\nThis property corresponds to the reported_comment_id field in the community_platform_reports table from the Prisma schema. It links the report to the specific comment content that has been flagged.\n\nExactly one of reportedContentId or reportedCommentId must be provided, but not both. This field is used to establish the relationship between the report and the target content, ensuring the system can locate and process the reported item.\n\nWhen submitting a report on a comment, this field must be provided with a valid UUID that references an existing comment in the community_platform_comments table."},"reportReason":{"oneOf":[{"const":"spam","description":"The category of violation reported by the user, as defined in the community_platform_report_categories table.\n\nThis property corresponds to the report_reason field in the community_platform_reports table from the Prisma schema. It must be one of the predefined values from the report categories: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThis field is mandatory and cannot be omitted. It is used to categorize the report for triage and moderation purposes, and its value is validated against the allowed enum set defined in the schema.\n\nThe predefined categories map directly to the 'name' field values in the community_platform_report_categories table, ensuring consistency across the system."},{"const":"harassment","description":"The category of violation reported by the user, as defined in the community_platform_report_categories table.\n\nThis property corresponds to the report_reason field in the community_platform_reports table from the Prisma schema. It must be one of the predefined values from the report categories: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThis field is mandatory and cannot be omitted. It is used to categorize the report for triage and moderation purposes, and its value is validated against the allowed enum set defined in the schema.\n\nThe predefined categories map directly to the 'name' field values in the community_platform_report_categories table, ensuring consistency across the system."},{"const":"inappropriate","description":"The category of violation reported by the user, as defined in the community_platform_report_categories table.\n\nThis property corresponds to the report_reason field in the community_platform_reports table from the Prisma schema. It must be one of the predefined values from the report categories: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThis field is mandatory and cannot be omitted. It is used to categorize the report for triage and moderation purposes, and its value is validated against the allowed enum set defined in the schema.\n\nThe predefined categories map directly to the 'name' field values in the community_platform_report_categories table, ensuring consistency across the system."},{"const":"other","description":"The category of violation reported by the user, as defined in the community_platform_report_categories table.\n\nThis property corresponds to the report_reason field in the community_platform_reports table from the Prisma schema. It must be one of the predefined values from the report categories: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThis field is mandatory and cannot be omitted. It is used to categorize the report for triage and moderation purposes, and its value is validated against the allowed enum set defined in the schema.\n\nThe predefined categories map directly to the 'name' field values in the community_platform_report_categories table, ensuring consistency across the system."}],"description":"The category of violation reported by the user, as defined in the community_platform_report_categories table.\n\nThis property corresponds to the report_reason field in the community_platform_reports table from the Prisma schema. It must be one of the predefined values from the report categories: 'spam', 'harassment', 'inappropriate', or 'other'.\n\nThis field is mandatory and cannot be omitted. It is used to categorize the report for triage and moderation purposes, and its value is validated against the allowed enum set defined in the schema.\n\nThe predefined categories map directly to the 'name' field values in the community_platform_report_categories table, ensuring consistency across the system."},"reportNotes":{"type":"string","maxLength":500,"description":"Additional context provided by the reporter about why they are reporting the content. This field is optional and allows users to provide detailed explanations for their report.\n\nThis property corresponds to the report_notes field in the community_platform_reports table from the Prisma schema. It can contain up to 500 characters of additional context to help moderators understand the nature of the violation.\n\nThe length restriction ensures that additional context remains concise and manageable for moderators to review quickly.\n\nWhen omitted, this field will be null in the database, indicating no additional context was provided by the reporter.\n\nThe description mentions the limit of 500 characters as specified in the Prisma schema, which aligns with the business requirement for maintaining sufficient context without allowing overly verbose submissions."}},"required":["reportReason"],"description":"Request payload for creating a new content report on the platform. This schema defines the data structure for submitting reports on posts or comments in the communityPlatform system.\n\nThis object is used in the POST /reports endpoint to initiate the reporting workflow. It captures essential information needed to process user-submitted reports, including identification of the reported content, reporting reason, and optional additional context.\n\nThe schema is designed based on the community_platform_reports table structure from the Prisma schema, which provides the data model for storing reports. It specifically references the required fields: reported_content_id, reported_comment_id, reporter_id (auto-populated from authentication), target_type (determined from which ID field is provided), status (set to 'pending' by default), report_reason, report_notes, created_at, and updated_at.\n\nKey constraints:\n- Either reportedContentId or reportedCommentId must be provided (never both)\n- reportReason is mandatory and must be one of the predefined enum values from the report categories\n- reportNotes is optional and has a 500-character limit\n- The reporter's identity is derived from the authentication system, not included in this payload\n\nThe schema ensures complete compliance with the Prisma data model while supporting the business requirements for reporting content on the platform. It enables users to report violations accurately while maintaining appropriate validation and data integrity."},"ICommunityPlatformCommunity.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the community.\n\nThis UUID is the primary key and uniquely identifies each community on the platform. It is generated by the system upon creation and remains immutable throughout the community's lifecycle.\n\nThe id is used in all API endpoints to reference the specific community for operations such as retrieval, updates, and moderation actions.\n\nStrictly follows the Prisma schema definition where the id field is a String with @id and @db.Uuid annotations.\n\nNo additional fields can be inferred or added as they would require database schema changes."},"name":{"type":"string","description":"The unique, case-insensitive name identifier for the community.\n\nThis serves as the community's public handle and is used in URLs (e.g., /r/communityname). It must be unique across the platform and follow naming conventions (alphanumeric and hyphens only).\n\nThis field corresponds to the 'name' column in the community_platform_communities table and has a unique constraint in the database.\n\nThe name should be kept concise, descriptive, and relevant to the community's topic. It cannot contain spaces or special characters except hyphens, and must be between 3 and 20 characters long as per business rules.\n\nChanges to the name are not permitted after creation, and any attempt to modify this field will be rejected. This ensures permanent, stable URLs and avoids confusion in community discovery."},"description":{"oneOf":[{"type":"string","description":"A brief description of the community's purpose and rules.\n\nThis field provides a concise summary of the community's focus and guidelines. It is visible to all users on the community listing and detail pages.\n\nIt is optional and may be null if no description has been provided by the creator. When present, it is limited to 400 characters for display purposes.\n\nThis field maps directly to the 'description' column in the community_platform_communities table and has no constraints beyond length limits defined in business rules.\n\nThe description' is intended for discoverability and onboarding, not for detailed rules, which are stored in the separate community_platform_community_settings.rules field."},{"type":"null"}],"description":"A brief description of the community's purpose and rules.\n\nThis field provides a concise summary of the community's focus and guidelines. It is visible to all users on the community listing and detail pages.\n\nIt is optional and may be null if no description has been provided by the creator. When present, it is limited to 400 characters for display purposes.\n\nThis field maps directly to the 'description' column in the community_platform_communities table and has no constraints beyond length limits defined in business rules.\n\nThe description' is intended for discoverability and onboarding, not for detailed rules, which are stored in the separate community_platform_community_settings.rules field."},"is_public":{"type":"boolean","description":"Flag indicating whether the community is publicly visible and joinable.\n\nWhen true, the community appears in public listings, search results, and feeds to all users. When false, it is a private or restricted community that can only be accessed by invited or subscribed members.\n\nThis field corresponds to the 'is_public' column in the community_platform_communities table.\n\nAll communities are created as public by default. The creator or admin can change this setting later based on moderation needs. Private communities require subscription for access and are hidden from public views.\n\nFor authenticated users, both public and subscribed private communities are included in personalized feeds, but unauthenticated guests can only view public communities."},"nsfw":{"type":"boolean","description":"Flag indicating whether the community contains Not Safe For Work content.\n\nWhen true, the community contains adult, explicit, or sensitive material that may not be appropriate for all users. When false, all content is considered safe for general viewing.\n\nThis field corresponds to the 'nsfw' column in the community_platform_communities table.\n\nUsers must explicitly enable NSFW content viewing for their account to see content from these communities. This flag does not restrict access to members—those who are subscribed to the community can view its content regardless of their NSFW settings. The flag primarily controls content filtering in feeds and listings for non-subscribers."},"member_count":{"type":"integer","description":"The current number of users subscribed to this community.\n\nThis count represents active subscriptions maintained in the community_platform_subscriptions table where deleted_at is null and active is true.\n\nIt is updated automatically on subscription and unsubscription and serves as a key metric for community popularity and activity.\n\nThis field corresponds exactly to the 'member_count' column in the community_platform_communities table and is denormalized for performance optimization to avoid expensive real-time calculation during feed rendering.\n\nThe count is capped at the system limit defined in community_platform_platform_settings.max_community_members (default 1,000) to prevent performance degradation in large communities."},"post_count":{"type":"integer","description":"The total number of posts created in this community.\n\nThis count includes all published posts that have not been removed or archived and is updated automatically upon each post creation or deletion.\n\nIt serves as a measure of community activity and helps users gauge the level of engagement within a community.\n\nThis field corresponds to the 'post_count' column in the community_platform_communities table and is denormalized for efficient display in listing views.\n\nThis count does not include posts with 'unreviewed', 'removed', or 'archived' status; only 'published' posts are counted."}},"required":["id","name","is_public","nsfw","member_count","post_count"],"description":"A summary representation of a community for list views and discovery.\n\nThis schema is designed to provide minimal, optimized data for displaying communities in search results, home feeds, and community lists. It includes only the fields essential for user identification and decision-making when choosing which communities to explore.\n\nThe summary excludes detailed information such as community rules, avatar, banner, or moderator lists to minimize payload size and improve performance during large-scale listing operations.\n\nThis type directly maps to the community_platform_communities table in the Prisma schema, and every property corresponds to an actual field in that table. No additional properties are included that would require new database columns.\n\nUse this type when paginating over hundreds of communities or showing community summaries in a feed.\n\nFor full details about a community, use the ICommunityPlatformCommunity type.\n\nBusiness logic ensures that for private communities (is_public=false), the member_count is not disclosed to unauthenticated users or non-subscribers. The full set of data is only returned when the user is authenticated and subscribed to the community.","x-autobe-prisma-schema":"community_platform_communities"},"ICommunityPlatformPost.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the post.\n\nThis UUID is the primary key and uniquely identifies each post on the platform. It is generated by the system upon creation and remains immutable throughout the post's lifecycle.\n\nThe id is used in all API endpoints to reference the specific post for operations such as retrieval, updates, voting, and commenting.\n\nStrictly follows the Prisma schema definition where the id field is a String with @id and @db.Uuid annotations.\n\nNo additional fields can be inferred or added as they would require database schema changes."},"title":{"type":"string","description":"The title of the post, limited to 300 characters.\n\nThis is the primary headline of the post, visible to all users in listings and feeds. It must be between 1 and 300 characters and serves as the first point of engagement for readers.\n\nThis field corresponds to the 'title' column in the community_platform_posts table and is mandatory for all post types.\n\nThe title should be clear, descriptive, and click-worthy while avoiding spammy or misleading language. It is indexed for full-text search to enable users to discover posts by keyword.\n\nChanges to the title are restricted to 15 minutes after posting, as defined in the platform settings, to prevent manipulative edit behavior."},"content":{"oneOf":[{"type":"string","description":"The main body text of the post, if the post type is 'text'.\n\nThis field contains the primary written content of a text post. It is optional for link or image posts and is null for those post types.\n\nWhen present, content is limited to 10,000 characters. It is intended for longer-form engagement beyond the title and is formatted as plain text (no HTML).\n\nThis field maps directly to the 'content' column in the community_platform_posts table.\n\nFor performance reasons, only the first 800 characters are shown in feed summaries, with a 'Read more' toggle to expand the full content on demand.\n\nIn community_platform_posts, this field is nullable and may be null when the post type is 'link' or 'image'.\n\nNo rich text or formatting is supported; this is strictly a plaintext field."},{"type":"null"}],"description":"The main body text of the post, if the post type is 'text'.\n\nThis field contains the primary written content of a text post. It is optional for link or image posts and is null for those post types.\n\nWhen present, content is limited to 10,000 characters. It is intended for longer-form engagement beyond the title and is formatted as plain text (no HTML).\n\nThis field maps directly to the 'content' column in the community_platform_posts table.\n\nFor performance reasons, only the first 800 characters are shown in feed summaries, with a 'Read more' toggle to expand the full content on demand.\n\nIn community_platform_posts, this field is nullable and may be null when the post type is 'link' or 'image'.\n\nNo rich text or formatting is supported; this is strictly a plaintext field."},"post_type":{"type":"string","description":"The type of post: 'text', 'link', or 'image'.\n\nThis field determines how the post is displayed and what additional content fields are relevant. It must be one of the three static values defined in the schema.\n\nThis field corresponds to the 'post_type' column in the community_platform_posts table.\n\n- 'text': Post contains body text in the content field\n- 'link': Post contains a URL in the community_platform_post_links table\n- 'image': Post contains an image in the community_platform_post_images table\n\nThe post type is immutable after creation and determines the rendering behavior on the client side. It is a discriminator for the unified post model.\n\nNo other values are allowed as they are not defined in any schema table."},"vote_count":{"type":"integer","description":"The total vote score calculated as upvotes minus downvotes for ranking purposes.\n\nThis field represents the net popularity of the post, calculated as (upvotes - downvotes) as defined in the business rules. It is used as the primary sorting metric in the 'top' and 'hot' algorithms.\n\nIt is updated atomically when any vote is cast and may be negative if the post receives more downvotes than upvotes.\n\nThis field corresponds exactly to the 'vote_count' column in the community_platform_posts table and is denormalized for performance optimization to avoid expensive real-time calculation during feed rendering.\n\nNote that the calculated karma for the author is based on the same values but stored separately in community_platform_user_karma."},"comment_count":{"type":"integer","description":"The total number of direct comments on this post.\n\nThis count includes all published comments on this post, regardless of depth level, excluding any that have been removed or deleted.\n\nIt is updated automatically when a comment is created or deleted and serves as an indicator of engagement on the post.\n\nThis field corresponds to the 'comment_count' column in the community_platform_posts table and is denormalized for efficient display in listing views.\n\nThis count does not include nested replies to comments—it reflects only top-level comment threads directly attached to the post."},"status":{"type":"string","description":"The moderation status of the post: 'published', 'unreviewed', 'removed', or 'archived'.\n\nThis field determines whether the post is visible to users and appears in feeds and search results.\n\n- 'published': Visible to all users. This is the default status after creation unless the community requires review.\n- 'unreviewed': Hidden from public view until moderated. Applies to communities with post_review_mode enabled.\n- 'removed': Hidden due to moderator/admin action. Content is not accessible to users.\n- 'archived': Historical post that is no longer active but preserved for audit; typically not returned in normal request.\n\nThis field corresponds exactly to the 'status' column in the community_platform_posts table and is critical for content moderation workflow.\n\nOnly posts with 'published' status are included in rankings and feeds for authenticated and guest users. 'unreviewed' posts are visible only to moderators and the author. 'removed' and 'archived' posts are not returned by the API except under admin privileges."},"created_at":{"type":"string","format":"date-time","description":"The timestamp when the post was submitted.\n\nThis field records the exact moment the post was saved to the database and is used for sorting in the 'new' ranking algorithm. It is set server-side and cannot be edited by users.\n\nThis field corresponds exactly to the 'created_at' column in the community_platform_posts table and is stored in the database as a timestamp with time zone.\n\nPost ranking algorithms (hot, top, controversial) use this field to calculate time decay, and the system uses UTC time for all comparisons but stores values in the Asia/Seoul timezone (UTC+9) as required by the business rules.\n\nNo client-side clock value is accepted—the server timestamp is authoritative."}},"required":["id","title","post_type","vote_count","comment_count","status","created_at"],"description":"A summary representation of a post for display in feeds and lists.\n\nThis schema is designed to optimize performance and data transfer for showing posts in community feeds, search results, and home pages. It only includes the fields necessary for rendering a post item in a list—excluding full text, images, links, author details, or comment threads.\n\nEvery property in this schema directly maps to a field in the community_platform_posts table from the Prisma schema. No additional properties or inferred fields are included that would require new database columns.\n\nFor example, the content field is included but is nullable because it only applies to text posts. The image or link details are not included here—they are accessed through separate endpoints.\n\nThe output of this type is paged using IPageICommunityPlatformPost.ISummary, which allows clients to efficiently render hundreds of post summaries without latency or bandwidth issues.\n\nThis type supports the performance requirement of loading a feed of 50 posts in under 2 seconds by minimizing payload size and leveraging indexed database fields.\n\nFor detailed view of a single post, use the ICommunityPlatformPost type.","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformComment.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the comment.\n\nThis UUID serves as the primary key for the comment in the database, ensuring unique identification across the system.\n\nThe comment ID is exposed in API responses to allow clients to reference specific comments when performing operations like replies, votes, or reports.\n\nThis field is system-generated upon comment creation and is immutable throughout the comment's lifecycle."},"content":{"type":"string","maxLength":500,"description":"Preview of the comment content, truncated for display in lists.\n\nThis field contains the first 500 characters of the comment's full content, providing a summary view for comment listings and feeds.\n\nThe truncation is performed server-side before sending the response to minimize payload size while still conveying the essence of the comment.\n\nIf the original comment exceeds 500 characters, an ellipsis (\"...\") is appended to indicate that content has been truncated.\n\nThis field complements the full-content field in the detailed ICommunityPlatformComment type by providing an optimized view for list rendering and performance.\n\nThe content is plain text without HTML or markdown since rich formatting is not supported in summaries.\n\nThis field is directly derived from the content field in the community_platform_comments table."},"vote_count":{"type":"integer","description":"Total net vote count for the comment, calculated as upvotes minus downvotes.\n\nThis field represents the weighted satisfaction of the community with the comment, where upvotes contribute +1 and downvotes contribute -1;\n\nThe calculation is aggregated server-side in real-time to ensure accurate, current values.\n\nThis field is displayed prominently in comment listings to indicate community feedback.\n\nValues are never negative due to the business rule that karma cannot be negative, but this field can show negative values if the comment has more downvotes than upvotes.\n\nThis field is populated from the vote_count column in the community_platform_comments table."},"created_at":{"type":"string","format":"date-time","description":"Timestamp indicating when the comment was originally created.\n\nThis field is automatically set to the current server time (Asia/Seoul timezone) when the comment is first persisted to the database.\n\nThis timestamp is used for sorting comments by age in chronological order and for calculating comment longevity in ranking algorithms.\n\nThe field is immutable and does not change even if the comment is edited later.\n\nThis field corresponds to the created_at column in the community_platform_comments table.\n\nThe format follows ISO 8601 standard with timezone information to ensure global consistency."},"author_id":{"type":"string","format":"uuid","description":"Unique identifier of the user who authored the comment.\n\nThis field references the community_platform_member table's id field to identify the comment's creator.\n\nIn summary responses, the author's username is not included for privacy reasons, but this ID is used internally to retrieve additional information if needed.\n\nThis field acts as a foreign key relationship with the user table and is populated at comment creation.\n\nThis field is system-generated and cannot be modified after creation.\n\nThe field is required for every comment in the system regardless of visibility or deletion status."},"author_username":{"type":"string","description":"Display username of the comment's author.\n\nThis field provides a human-readable identifier for the comment's creator by fetching the display username from the community_platform_member table's username field.\n\nThe username is displayed in comment listings to denote who made the comment, following a community culture where authorship is recognized.\n\nThis is not the email address or private identifier but the public-facing username chosen by the member during registration.\n\nThis field complements author_id by providing a memorable, readable name while preserving privacy of email addresses.\n\nThe username field is derived from the corresponding community_platform_member record based on the author_id foreign key."},"depth_level":{"type":"integer","description":"Nesting level of the comment in the thread hierarchy.\n\nThis field indicates the comment's depth within the recursive comment tree, where 1 represents a top-level comment and higher numbers represent replies to replies.\n\nThe depth is calculated server-side based on the parent_comment_id reference; top-level comments have depth_level = 1;\n\nDeeper comments have depth_level = parent.depth_level + 1, up to a maximum of 8 levels defined in community_platform_platform_settings.max_comment_depth.\n\nThis field is essential for determining visual indentation in the frontend and controlling comment display logic.\n\nIt allows clients to render comment threads correctly, collapsing or expanding nested reply levels as needed.\n\nThis field is derived from the depth_level column in the community_platform_comments table."},"status":{"oneOf":[{"const":"published","description":"Moderation status of the comment, controlling its visibility and accessibility.\n\nValid values are:\n\n- 'published': The comment is visible to all users\n- 'unreviewed': The comment is awaiting moderator approval\n- 'removed': The comment has been censored or deleted by a moderator\n- 'archived': The comment has been retired and is no longer visible or editable\n\nThis field directly maps to the status column in the community_platform_comments table.\n\nThe accessibility of a comment depends on this status and the viewer's permissions.\n\nPublic users can only see 'published' comments, while moderators may view some 'unreviewed' comments depending on their role.\n\nThis status field is central to enforcing community guidelines and moderation policies."},{"const":"unreviewed","description":"Moderation status of the comment, controlling its visibility and accessibility.\n\nValid values are:\n\n- 'published': The comment is visible to all users\n- 'unreviewed': The comment is awaiting moderator approval\n- 'removed': The comment has been censored or deleted by a moderator\n- 'archived': The comment has been retired and is no longer visible or editable\n\nThis field directly maps to the status column in the community_platform_comments table.\n\nThe accessibility of a comment depends on this status and the viewer's permissions.\n\nPublic users can only see 'published' comments, while moderators may view some 'unreviewed' comments depending on their role.\n\nThis status field is central to enforcing community guidelines and moderation policies."},{"const":"removed","description":"Moderation status of the comment, controlling its visibility and accessibility.\n\nValid values are:\n\n- 'published': The comment is visible to all users\n- 'unreviewed': The comment is awaiting moderator approval\n- 'removed': The comment has been censored or deleted by a moderator\n- 'archived': The comment has been retired and is no longer visible or editable\n\nThis field directly maps to the status column in the community_platform_comments table.\n\nThe accessibility of a comment depends on this status and the viewer's permissions.\n\nPublic users can only see 'published' comments, while moderators may view some 'unreviewed' comments depending on their role.\n\nThis status field is central to enforcing community guidelines and moderation policies."},{"const":"archived","description":"Moderation status of the comment, controlling its visibility and accessibility.\n\nValid values are:\n\n- 'published': The comment is visible to all users\n- 'unreviewed': The comment is awaiting moderator approval\n- 'removed': The comment has been censored or deleted by a moderator\n- 'archived': The comment has been retired and is no longer visible or editable\n\nThis field directly maps to the status column in the community_platform_comments table.\n\nThe accessibility of a comment depends on this status and the viewer's permissions.\n\nPublic users can only see 'published' comments, while moderators may view some 'unreviewed' comments depending on their role.\n\nThis status field is central to enforcing community guidelines and moderation policies."}],"description":"Moderation status of the comment, controlling its visibility and accessibility.\n\nValid values are:\n\n- 'published': The comment is visible to all users\n- 'unreviewed': The comment is awaiting moderator approval\n- 'removed': The comment has been censored or deleted by a moderator\n- 'archived': The comment has been retired and is no longer visible or editable\n\nThis field directly maps to the status column in the community_platform_comments table.\n\nThe accessibility of a comment depends on this status and the viewer's permissions.\n\nPublic users can only see 'published' comments, while moderators may view some 'unreviewed' comments depending on their role.\n\nThis status field is central to enforcing community guidelines and moderation policies."},"is_reply":{"type":"boolean","description":"Indicates whether the comment is a reply to another comment (rather than a top-level comment).\n\nThis field is derived from the parent_comment_id field in the community_platform_comments table: it is true if parent_comment_id is not null, false if it is null.\n\nThis field helps frontend clients determine whether to display the comment with a reply indentation style and whether to prompt for improved context when replying.\n\nIt also influences backend query behavior, such as whether to show reply counters or additional iconography.\n\nThe field is calculated server-side and not stored in the database, but returned as a convenience for frontend rendering.\n\nThis field is always boolean, with no null values allowed."},"topic_id":{"type":"string","format":"uuid","description":"The unique identifier of the post this comment belongs to.\n\nThis field references the community_platform_posts table's id field to establish the relationship between comments and their parent posts.\n\nThe topic_id ensures that comments are correctly associated with their context and allows queries to fetch all comments under a specific post.\n\nThis field is immutable and established at comment creation time based on the postId provided in the request.\n\nThe topic_id is required for every comment and is a foreign key constraint in the database schema.\n\nWhile the comment can be viewed independently, its relationship with the post is fundamental to its purpose and display context."},"karma_point":{"type":"integer","description":"User's karma contribution from this comment, representing the net upvotes minus downvotes received.\n\nThis field calculates the individual karma impact of this comment on the author's total karma score, based on all votes received.\n\nKarma is calculated as Upvotes - Downvotes and is capped at a max of 1,000,000 as per business rules.\n\nThe value is negative if the comment received more downvotes than upvotes, but the author's total karma is never displayed as negative.\n\nThis field is derived from the vote_count for this comment and used in analytics and reputation systems.\n\nIt is not a standalone calculation but a component derived directly from the comment's vote_count in the database."},"preview_links":{"type":"array","items":{"type":"string","format":"uri","description":"URLs of featured links contained in the comment content, extracted for metadata preview.\n\nThis field identifies and extracts any valid HTTP/HTTPS URLs present in the comment's content for display as rich link previews.\n\nThe URLs are parsed from plain text using URI regex patterns and are limited to a maximum of 5 for performance and clarity.\n\nEach URL in the array represents the full canonical form of the target website, not a truncated or hidden form.\n\nThis field is optional and will be empty if the comment contains no valid links.\n\nThe presence of a link in this field does not guarantee the link will be rendered — clients are responsible for rendering markdown or rich content if enabled."},"description":"List of URLs discovered in the comment content for rich link preview rendering.\n\nThis array provides a machine-readable list of web links embedded within the comment's text.\n\nClients may use these URIs to fetch and display website metadata such as titles and images, enhancing the readability of commented links.\n\nThis feature is optional and does not affect comment visibility or moderation — it is purely an enhancement for user experience on supporting clients.\n\nThese links are extracted server-side using content analysis and are distinct from the post links field which handles explicit link posts."},"preview_images":{"type":"array","items":{"type":"string","format":"uri","description":"URLs of images embedded in the comment content, extracted for visual display.\n\nThis field identifies and extracts direct image URLs from the comment's plain text content, supporting JPEG, PNG, GIF, and WebP formats.\n\nImages are parsed from URLs following the specified format with no validation of content type beyond URL extension.\n\nEach URL is resolved to ensure it points to a real image file, and no image previews are generated if the URL is invalid, blocked, or inaccessible.\n\nThis field is optional and will be empty if the comment contains no image URLs.\n\nImage URLs are not embedded as HTML or markdown here — this field is purely functional for clients implementing media preview."},"description":"List of image URLs embedded in the comment text for visual rendering in summaries.\n\nThis array provides direct URLs to images referenced within the comment, allowing clients to fetch and display visual content without requiring additional API calls.\n\nThese images are extracted from the comment content using URL detection patterns, with validation of format (JPEG, PNG, WebP, GIF).\n\nThe resulting preview_images array is used by frontend interfaces to render inline image thumbnails or placeholders without loading the full post data.\n\nOnly direct image URLs are included — placeholder text, image attachments, or moderated content are not included in this list."}},"required":["id","content","vote_count","created_at","author_id","author_username","depth_level","status","is_reply","topic_id","karma_point"],"description":"A summarized view of a comment for display in listings and feed views.\n\nThis type provides a lean, optimized representation of a comment designed for performance in list and stream displays. It omits detailed content, editing history, and personal metadata, while preserving core information for user engagement.\n\nThe schema includes minimal fields to reduce payload size: a truncated content preview, vote count, author username, and time of creation — each directly mapped from the community_platform_comments table.\n\nThis type corresponds to a client's requirement to display many comments at once without overloading network resources or frontend rendering engines.\n\nFields like avatar_url, full content, and nested replies are excluded to improve load speed and simplify rendering.\n\nAny additional metadata such as link previews, image previews, or karma points are derived from the core replacement fields.\n\nThe summary does not include moderator notes, deletion status details, or audit information — those are reserved for the detailed comment type.\n\nThis type serves as the item type in paginated collections via IPageICommunityPlatformComment.ISummary.\n\nBehavioral rules:\n- The content field is truncated to 500 characters for quick scanning\n- The author_username is shown instead of email for privacy\n- Only published comments are returned\n- Every field must have a value, no nulls allowed for required fields\n- If the comment has been removed, it is excluded entirely\n\nDesign philosophy: This schema emphasizes speed, clarity, and usability for all device types — mobile, tablet, and desktop."}}}}