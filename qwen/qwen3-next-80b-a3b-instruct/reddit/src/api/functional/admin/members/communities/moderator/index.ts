import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdmin } from "../../../../../structures/ICommunityPlatformAdmin";

/**
 * Assign moderator role to a member within a specific community.
 *
 * This API operation enables a system administrator to assign moderator
 * privileges to a member within a specific community. The root admin
 * authenticates and calls this endpoint to grant moderation rights to another
 * user. The system validates that the requester has admin privileges via the
 * community_platform_admin table, the target user exists as an active member in
 * the community_platform_member table (deleted_at is null), and the target
 * community exists in the community_platform_communities table and is not
 * suspended.
 *
 * The operation creates a new record in the community_platform_moderator table
 * with the member_id from the target user and the community_id from the target
 * community, setting created_at to the current timestamp. The operation ensures
 * no duplicate moderator assignments exist by validating against the unique
 * constraint [member_id, community_id]. No new tokens are issued as this is a
 * resource modification rather than an authentication operation.
 *
 * For audit purposes, the operation logs the action in the
 * community_platform_audit_logs table with actor_user_id as the admin
 * performing the action, target_user_id as the member being assigned,
 * target_community_id as the community, and action_description set to 'Admin
 * assigned moderator role'. The description references the key
 * community_platform_admin, community_platform_member,
 * community_platform_communities, and community_platform_moderator tables and
 * their fields to ensure compliance with schema constraints.
 *
 * The operation may fail with specific error codes if the requester is
 * unauthorized, user does not exist, community does not exist, or the
 * assignment duplicate. These failure conditions ensure data integrity
 * according to schema constraints.
 *
 * @param props.connection
 * @param props.memberId The UUID of the member to be assigned as moderator.
 * @param props.communityId The UUID of the community for which the member is
 *   assigned as moderator.
 * @param props.body No additional payload required - moderator assignment is
 *   determined by path parameters.
 * @path /admin/members/:memberId/communities/:communityId/moderator
 * @accessor api.functional.admin.members.communities.moderator.assignModerator
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function assignModerator(
  connection: IConnection,
  props: assignModerator.Props,
): Promise<assignModerator.Response> {
  return true === connection.simulate
    ? assignModerator.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...assignModerator.METADATA,
          path: assignModerator.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace assignModerator {
  export type Props = {
    /** The UUID of the member to be assigned as moderator. */
    memberId: string & tags.Format<"uuid">;

    /**
     * The UUID of the community for which the member is assigned as
     * moderator.
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * No additional payload required - moderator assignment is determined
     * by path parameters.
     */
    body: ICommunityPlatformAdmin.IEmpty;
  };
  export type Body = ICommunityPlatformAdmin.IEmpty;
  export type Response = ICommunityPlatformAdmin.IModeratorAssignment;

  export const METADATA = {
    method: "POST",
    path: "/admin/members/:memberId/communities/:communityId/moderator",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/admin/members/${encodeURIComponent(props.memberId ?? "null")}/communities/${encodeURIComponent(props.communityId ?? "null")}/moderator`;
  export const random = (): ICommunityPlatformAdmin.IModeratorAssignment =>
    typia.random<ICommunityPlatformAdmin.IModeratorAssignment>();
  export const simulate = (
    connection: IConnection,
    props: assignModerator.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: assignModerator.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("memberId")(() => typia.assert(props.memberId));
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke moderator role from a member within a specific community.
 *
 * This API operation enables a system administrator to remove moderator
 * privileges from a member within a specified community. The admin
 * authenticates with valid credentials and sends a request to delete the
 * relationship between the member and community from the
 * community_platform_moderator table.
 *
 * The system first confirms the requester has admin privileges using the
 * community_platform_admin table. Then it verifies that a moderator record
 * exists in community_platform_moderator for the given member_id and
 * community_id pair. If the record exists, it is deleted. Concurrently, the
 * system logs this change in the community_platform_audit_logs table with
 * actor_user_id as the revoking admin, target_user_id as the removed moderator,
 * target_community_id as the affected community, and action_description set to
 * 'Admin revoked moderator role'.
 *
 * The operation ensures data integrity through schema enforcement, including
 * foreign key constraints from community_platform_moderator to
 * community_platform_member and community_platform_communities. This operation
 * completes successfully only if the target relationship exists; if the
 * moderator record does not exist, the system returns a 404. The request does
 * not affect the target user's basic member status or community subscriptions.
 *
 * The description references community_platform_admin,
 * community_platform_moderator, and community_platform_audit_logs tables to
 * ensure all referenced fields and relationships are properly verified
 * according to the schema.
 *
 * @param props.connection
 * @param props.memberId The UUID of the member whose moderator privileges are
 *   to be revoked.
 * @param props.communityId The UUID of the community from which the member's
 *   moderator privileges are to be revoked.
 * @param props.body No additional payload required - moderator revocation is
 *   determined by path parameters.
 * @path /admin/members/:memberId/communities/:communityId/moderator
 * @accessor api.functional.admin.members.communities.moderator.revokeModerator
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function revokeModerator(
  connection: IConnection,
  props: revokeModerator.Props,
): Promise<revokeModerator.Response> {
  return true === connection.simulate
    ? revokeModerator.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...revokeModerator.METADATA,
          path: revokeModerator.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace revokeModerator {
  export type Props = {
    /** The UUID of the member whose moderator privileges are to be revoked. */
    memberId: string & tags.Format<"uuid">;

    /**
     * The UUID of the community from which the member's moderator
     * privileges are to be revoked.
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * No additional payload required - moderator revocation is determined
     * by path parameters.
     */
    body: ICommunityPlatformAdmin.IEmpty;
  };
  export type Body = ICommunityPlatformAdmin.IEmpty;
  export type Response = ICommunityPlatformAdmin.IModeratorRevocation;

  export const METADATA = {
    method: "DELETE",
    path: "/admin/members/:memberId/communities/:communityId/moderator",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/admin/members/${encodeURIComponent(props.memberId ?? "null")}/communities/${encodeURIComponent(props.communityId ?? "null")}/moderator`;
  export const random = (): ICommunityPlatformAdmin.IModeratorRevocation =>
    typia.random<ICommunityPlatformAdmin.IModeratorRevocation>();
  export const simulate = (
    connection: IConnection,
    props: revokeModerator.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: revokeModerator.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("memberId")(() => typia.assert(props.memberId));
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
