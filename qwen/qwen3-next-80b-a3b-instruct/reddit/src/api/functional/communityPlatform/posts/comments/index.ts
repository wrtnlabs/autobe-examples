import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../../structures/ICommunityPlatformComment";
import { IPageICommunityPlatformComment } from "../../../../structures/IPageICommunityPlatformComment";

/**
 * Retrieve a specific comment by its ID within a post.
 *
 * Retrieve a specific comment by its unique identifier within a post. This
 * operation targets the community_platform_comments table in the database,
 * returning the full details of a single comment including its content, vote
 * count, creation timestamp, and moderation status. The comment must be
 * associated with the specified post via the community_platform_post_id foreign
 * key relationship and must have a status of 'published' to be returned.
 * Comments with status 'removed', 'archived', or 'unreviewed' are excluded from
 * results and will return a 404 error.
 *
 * Security considerations include ensuring that only authenticated users can
 * retrieve comments, although visibility of the comment is based on its
 * moderation status rather than user permissions. The operation does not
 * require any special role privileges beyond authentication, as comment content
 * is generally public-facing. The response includes the comment's depth_level,
 * which determines its visual nesting in the thread, and its updated_at
 * timestamp to reflect any recent edits.
 *
 * This operation integrates with the community_platform_comments table as
 * defined in the Prisma schema, incorporating all available comment fields and
 * relationships. The implementation follows the business rule that comment
 * content cannot be edited after 10 minutes, so the updated_at field may be
 * identical to the created_at field for older comments. This endpoint is
 * typically called after a user navigates to a specific comment from a post
 * listing or from an external link, making fast response time critical for user
 * experience.
 *
 * Related API operations include PATCH /posts/{postId}/comments to retrieve a
 * paginated list of comments for a specific post, and DELETE
 * /posts/{postId}/comments/{commentId} to remove a comment (only permitted for
 * authors or moderators). Error handling follows the platform-wide pattern,
 * returning 404 for non-existent or inaccessible comments and 403 for
 * unauthorized access.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post that contains the
 *   comment
 * @param props.commentId Unique identifier of the target comment to retrieve
 * @path /communityPlatform/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPlatform.posts.comments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target post that contains the comment */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target comment to retrieve */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformComment;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPlatformComment =>
    typia.random<ICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filtered list of comments for a post.
 *
 * Retrieve a paginated, filtered, and sorted list of comments associated with a
 * specific post. This operation targets the community_platform_comments table
 * in the database and supports complex querying to filter comments by
 * moderation status, sort by creation date or vote count, and paginate results
 * with customizable page sizes. The operation returns only comments with status
 * 'published', excluding those with 'removed', 'archived', or 'unreviewed'
 * statuses. This ensures users only see finalized, approved content.
 *
 * Security considerations include ensuring that only authenticated users can
 * request comments, although the visibility of comments themselves is
 * determined by their moderation status rather than the requesting user's role.
 * The operation supports sorting by created_at (descending) for a 'newest
 * first' view, or vote_count (descending) for a 'most popular' view, aligning
 * with business rules that promote high-quality discussion. The limit parameter
 * defaults to 20 comments per page (matching client-side loading patterns) and
 * can be increased up to a maximum of 50 to prevent performance degradation.
 *
 * This operation integrates with the community_platform_comments table as
 * defined in the Prisma schema, incorporating all available comment fields and
 * relationships. The response returns a paginated structure with metadata
 * including total count, current page, and page size, optimized for efficient
 * client-side rendering. Related API operations include GET
 * /posts/{postId}/comments/{commentId} to retrieve a single comment by ID and
 * POST /posts/{postId}/comments to create a new comment within the post.
 * Implementation follows the platform-wide constraint that comment depth is
 * limited to a maximum of 8 levels as defined in
 * community_platform_platform_settings.max_comment_depth, but this operation
 * does not filter by depth level itself.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post for which to
 *   retrieve comments
 * @param props.body Search criteria, sorting preferences, and pagination
 *   parameters for filtering comments
 * @path /communityPlatform/posts/:postId/comments
 * @accessor api.functional.communityPlatform.posts.comments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target post for which to retrieve comments */
    postId: string & tags.Format<"uuid">;

    /**
     * Search criteria, sorting preferences, and pagination parameters for
     * filtering comments
     */
    body: ICommunityPlatformComment.IRequest;
  };
  export type Body = ICommunityPlatformComment.IRequest;
  export type Response = IPageICommunityPlatformComment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): IPageICommunityPlatformComment.ISummary =>
    typia.random<IPageICommunityPlatformComment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
