import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../structures/ICommunityPlatformPost";
import { IPageICommunityPlatformPost } from "../../../structures/IPageICommunityPlatformPost";
export * as comments from "./comments/index";

/**
 * Search and retrieve paginated posts with filtering and sorting options.
 *
 * This operation retrieves a paginated list of posts from the platform with
 * advanced filtering, searching, and sorting capabilities. It supports querying
 * across all communities or a specific community, filtering by author, time
 * ranges, and applying different ranking algorithms for sorting.
 *
 * The operation supports pagination with configurable page size and
 * cursor/offset-based navigation. Users can search posts by keyword across the
 * title and content fields using full-text search capabilities (GIN indexes on
 * title and content). Sorting can be performed using the four algorithms
 * defined in the business rules: 'new', 'hot', 'top', and 'controversial'. The
 * default sort algorithm can be overridden by the request parameter.
 *
 * Security considerations include restricting sensitive post data based on
 * visibility settings (nsfw posts require explicit user settings) and
 * respecting community visibility (public vs private communities). The
 * operation returns summarized post data optimized for display in feeds rather
 * than full-post details.
 *
 * This operation integrates with the community_platform_posts table as defined
 * in the Prisma schema and is the primary mechanism for content discovery on
 * the platform. It does not return individual post images or links - instead,
 * it returns metadata pointers to these resources. The operation is designed to
 * handle high request volumes efficiently through proper indexing (created_at,
 * community_platform_community_id, status, vote_count).
 *
 * Related operations: This operation can be preceded by GET /communities to
 * discover communities to search within, and can be followed by GET
 * /posts/{postId} to retrieve detailed post information.
 *
 * @param props.connection
 * @param props.body Search criteria, pagination parameters, and sorting
 *   preferences for post filtering
 * @path /communityPlatform/posts
 * @accessor api.functional.communityPlatform.posts.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Search criteria, pagination parameters, and sorting preferences for
     * post filtering
     */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = IPageICommunityPlatformPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/posts";
  export const random = (): IPageICommunityPlatformPost.ISummary =>
    typia.random<IPageICommunityPlatformPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific post by its ID.
 *
 * This operation allows a user to retrieve detailed information about a single,
 * specific post by providing its unique UUID identifier. When a client requests
 * a post by its ID, the system performs a direct lookup in the
 * community_platform_posts table to fetch the complete record. The response
 * includes all critical post information: the title, the content body (if
 * text), the URL (if a link post), the image reference (if an image post), the
 * author's ID, the community ID, the current vote score (calculation of upvotes
 * minus downvotes), the number of comments on the post, and its moderation
 * status (e.g., 'published', 'unreviewed', 'removed').
 *
 * The system ensures that only posts with a status of 'published' or
 * 'unreviewed' are returned to users who do not have moderator or admin
 * privileges. Posts with a status of 'removed' or 'archived' are excluded from
 * the response for security and policy compliance. For users with appropriate
 * permissions (moderator or admin), additional metadata may be included, such
 * as the deletion timestamp. This operation supports the core web flow where
 * users click on a post title from a feed to view it in isolation.
 *
 * The operation is designed to be fast and efficient for single-item retrieval,
 * and it directly references the community_platform_posts table's structure,
 * ensuring that the returned schema is a complete representation of the
 * underlying entity. This endpoint is fundamental for the detailed post view,
 * enabling the display of the post and its related content, including any
 * linked images or URLs, and serving as the foundation for user interaction
 * like commenting and voting.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post to retrieve, formatted
 *   as a UUID.
 * @path /communityPlatform/posts/:postId
 * @accessor api.functional.communityPlatform.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier of the post to retrieve, formatted as a UUID. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
