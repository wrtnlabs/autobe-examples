import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

/**
 * Permanently delete a community by its unique identifier.
 *
 * This operation permanently deletes a community from the platform. The
 * community is removed from the system entirely, including all associated
 * posts, comments, subscriptions, settings, and audit records.
 *
 * This is a hard delete operation that cannot be undone, as there is no
 * soft_delete_column defined in the community_platform_communities schema. The
 * deletion affects the entire community hierarchy: all community_platform_posts
 * records with the matching community_platform_community_id are deleted, all
 * community_platform_subscriptions linking users to this community are removed,
 * all community_platform_community_settings for this community are removed, and
 * all community_platform_audit_logs related to this community are preserved for
 * audit purposes but the community itself is removed.
 *
 * Security considerations require that only users with admin privileges can
 * execute this operation, as deleting a community is a high-impact
 * administrative action. The caller must have admin role, and this operation
 * will be enforced through the authorizationRoles field. The operation returns
 * a 204 status code on success with no content response body.
 *
 * Business logic: This operation must trigger cascading deletion of all
 * children records in the database relationships, which is handled at the
 * database level with ON DELETE CASCADE constraints on the related tables. This
 * prevents orphaned records across the system.
 *
 * Related operations: This should only be called after confirming with the
 * community moderators and when no further relevance exists for the topic. It
 * should not be used for suspending communities; for suspension, use the
 * community status update to inactive instead.
 *
 * @param props.connection
 * @param props.communityId The UUID identifier of the community to be
 *   permanently deleted.
 * @path /communityPlatform/admin/communities/:communityId
 * @accessor api.functional.communityPlatform.admin.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID identifier of the community to be permanently deleted. */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
