import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformSubscription } from "../../../../structures/ICommunityPlatformSubscription";
import { IPageICommunityPlatformSubscription } from "../../../../structures/IPageICommunityPlatformSubscription";

/**
 * Subscribe to a community.
 *
 * Subscribe the authenticated user to a specified community. This operation
 * creates a new subscription record in the community_platform_subscriptions
 * table, establishing the many-to-many relationship between a user and a
 * community.
 *
 * The request body must include the community_id field specifying the target
 * community. The operation validates that the community exists, the user is not
 * already subscribed to it, and the user has not exceeded the maximum
 * subscription limit of 1,000 communities as defined in the
 * community_platform_platform_settings table. The operation also checks that
 * the community is not deleted or inactive.
 *
 * Upon success, the operation creates the subscription with active: true,
 * created_at and updated_at timestamps set to the current time, and deleted_at
 * set to null. The member_id is automatically populated from the authenticated
 * user's profile.
 *
 * The authorizationRoles include only "member" since only authenticated members
 * can subscribe to communities. This operation does not allow guest access and
 * does not require administrative privileges. Enabling a subscription triggers
 * notifications to the user and updates the community's member_count field in
 * the community_platform_communities table as a side effect.
 *
 * This operation complements the GET /subscriptions endpoint for listing
 * subscriptions and the DELETE /subscriptions/{subscriptionId} endpoint for
 * unsubscribing.
 *
 * @param props.connection
 * @param props.body Information required to create a new community subscription
 * @path /communityPlatform/member/subscriptions
 * @accessor api.functional.communityPlatform.member.subscriptions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Information required to create a new community subscription */
    body: ICommunityPlatformSubscription.ICreate;
  };
  export type Body = ICommunityPlatformSubscription.ICreate;
  export type Response = ICommunityPlatformSubscription;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/subscriptions";
  export const random = (): ICommunityPlatformSubscription =>
    typia.random<ICommunityPlatformSubscription>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of user subscriptions.
 *
 * Retrieve a paginated and filtered list of the authenticated user's community
 * subscriptions. This operation allows users to view all their subscribed
 * communities with options to filter by the subscription's active status, sort
 * by subscription creation date (asc/desc), and retrieve a specific page of
 * results.
 *
 * According to the business requirements, users can subscribe to up to 1,000
 * communities. This operation respects the subscription limit and only returns
 * subscriptions where the deleted_at field is null and the active flag is true.
 * The response includes the community name, subscription creation date, and a
 * flag indicating whether the community is publicly visible.
 *
 * Security considerations ensure that only the authenticated user (represented
 * by user_id) can query their own subscription list. The system does not rely
 * solely on JWT token validation but validates the user_id against the
 * subscription records. No admin access is required as this is a user-specific
 * data endpoint.
 *
 * This operation integrates with the community_platform_subscriptions table as
 * defined in the Prisma schema, incorporating all available subscription fields
 * and relationships. The response includes community summary information
 * optimized for list displays, with links to the full community details via the
 * community/Id endpoint.
 *
 * This operation is essential for the user profile and subscription management
 * flow, as described in user journey steps 6.5 and 8.1 of the requirements. It
 * supports the "My Subscribed Communities" panel functionality.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters filtering user
 *   subscriptions
 * @path /communityPlatform/member/subscriptions
 * @accessor api.functional.communityPlatform.member.subscriptions.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Search criteria and pagination parameters filtering user
     * subscriptions
     */
    body: ICommunityPlatformSubscription.IRequest;
  };
  export type Body = ICommunityPlatformSubscription.IRequest;
  export type Response = IPageICommunityPlatformSubscription;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/subscriptions";
  export const random = (): IPageICommunityPlatformSubscription =>
    typia.random<IPageICommunityPlatformSubscription>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific community subscription by ID.
 *
 * Retrieve a specific community subscription by its unique identifier. This
 * operation fetches the subscription record from the database using the
 * subscriptionId path parameter, returning details about the user's
 * subscription status, creation date, and associated community. This operation
 * supports both authenticated users viewing their own subscriptions and
 * administrators viewing any subscription.
 *
 * The operation corresponds to the community_platform_subscriptions table in
 * the Prisma schema, which tracks the many-to-many relationship between users
 * and communities. The subscription record contains the member_id (user who
 * subscribed), community_platform_communities_id (the community being
 * subscribed to), created_at timestamp, updated_at timestamp, deleted_at
 * soft-delete timestamp, and active boolean status flag.
 *
 * Security considerations require proper authorization: authenticated users may
 * only view their own subscriptions, while administrators may view any
 * subscription. The operation validates that the subscription exists and
 * returns 404 if not found. Concurrency issues are handled by the database
 * engine through standard locking mechanisms.
 *
 * This operation complements the POST /subscriptions endpoint for creating new
 * subscriptions and the GET /subscriptions endpoint for listing all
 * subscriptions. It enables targeted retrieval of subscription details for user
 * profile displays, subscription management interfaces, and administrative
 * dashboards.
 *
 * @param props.connection
 * @param props.subscriptionId Unique identifier of the subscription to
 *   retrieve. Must be a valid UUID.
 * @path /communityPlatform/member/subscriptions/:subscriptionId
 * @accessor api.functional.communityPlatform.member.subscriptions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the subscription to retrieve. Must be a valid
     * UUID.
     */
    subscriptionId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformSubscription;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/member/subscriptions/:subscriptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/subscriptions/${encodeURIComponent(props.subscriptionId ?? "null")}`;
  export const random = (): ICommunityPlatformSubscription =>
    typia.random<ICommunityPlatformSubscription>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("subscriptionId")(() => typia.assert(props.subscriptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update subscription status for a specific community.
 *
 * Update the subscription status for a specific community by setting the active
 * flag in the community_platform_subscriptions table.
 *
 * This operation allows users to re-enable a previously disabled subscription
 * or modify the subscription status. When called with active: true, the
 * subscription becomes active and the user will begin receiving content from
 * the community in their feed. When called with active: false, the subscription
 * is deactivated and the user will no longer see posts from this community in
 * their feed.
 *
 * The operation requires the subscriptionId path parameter to identify which
 * subscription to modify. This ID corresponds to the primary key in the
 * community_platform_subscriptions table.
 *
 * The request body must contain the active boolean flag to specify the desired
 * subscription state. If the subscription ID does not exist or belongs to a
 * different user, the operation will return a 404 error. Only authenticated
 * users can update their own subscriptions.
 *
 * This operation does not delete the subscription record from the database - it
 * only toggles the active flag. This preserves the subscription history and
 * allows users to re-subscribe without losing their subscription preferences.
 * The updated_at timestamp will be automatically updated to reflect when the
 * change occurred.
 *
 * This operation is related to the DELETE /subscriptions/{subscriptionId}
 * endpoint which permanently removes the subscription record from the
 * database.
 *
 * @param props.connection
 * @param props.subscriptionId Unique identifier of the subscription to update
 * @param props.body Subscription status update information
 * @path /communityPlatform/member/subscriptions/:subscriptionId
 * @accessor api.functional.communityPlatform.member.subscriptions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the subscription to update */
    subscriptionId: string & tags.Format<"uuid">;

    /** Subscription status update information */
    body: ICommunityPlatformSubscription.IUpdate;
  };
  export type Body = ICommunityPlatformSubscription.IUpdate;
  export type Response = ICommunityPlatformSubscription;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/subscriptions/:subscriptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/subscriptions/${encodeURIComponent(props.subscriptionId ?? "null")}`;
  export const random = (): ICommunityPlatformSubscription =>
    typia.random<ICommunityPlatformSubscription>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("subscriptionId")(() => typia.assert(props.subscriptionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a user's subscription to a community.
 *
 * Permanently delete a user's subscription to a specific community from the
 * database by removing the record from the community_platform_subscriptions
 * table.
 *
 * This operation completely removes the subscription record from the database
 * when a user wants to permanently erase their subscription history. Unlike the
 * PUT /subscriptions/{subscriptionId} endpoint which toggles the active flag,
 * this operation performs a hard delete that removes all trace of the
 * subscription.
 *
 * The operation requires the subscriptionId path parameter to identify which
 * subscription to delete. This ID corresponds to the primary key in the
 * community_platform_subscriptions table. When successfully deleted, the
 * operation returns a 204 No Content response with no body.
 *
 * The user must be authenticated and the subscription must belong to them.
 * Attempting to delete a subscription that doesn't exist or belongs to another
 * user will return a 404 error.
 *
 * This operation is meant for users who want to completely remove their
 * subscription history from the system rather than just deactivating it. After
 * deletion, the user would need to subscribe again to rejoin the community.
 *
 * This operation is related to the PUT /subscriptions/{subscriptionId} endpoint
 * which updates the active status of a subscription without deleting it.
 *
 * @param props.connection
 * @param props.subscriptionId Unique identifier of the subscription to delete
 * @path /communityPlatform/member/subscriptions/:subscriptionId
 * @accessor api.functional.communityPlatform.member.subscriptions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the subscription to delete */
    subscriptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/subscriptions/:subscriptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/subscriptions/${encodeURIComponent(props.subscriptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("subscriptionId")(() => typia.assert(props.subscriptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
