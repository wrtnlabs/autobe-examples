import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as comments from "./comments/index";

/**
 * Create a new post in a community.
 *
 * This operation allows an authenticated member to create a new post within a
 * specific community on the platform. When a user submits a post, the system
 * validates the input according to strict business rules: the title must be
 * between 1 and 300 characters, and the content body (if text type) must be
 * between 1 and 10,000 characters; for link posts, a valid HTTP/HTTPS URL is
 * required; for image posts, a valid image file (under 10MB) must be uploaded.
 * The post's author is automatically inferred from the authenticated user's
 * session, and the community is specified in the request.
 *
 * The post's metadata is initialized with zero upvotes and downvotes, zero
 * comments, and a timestamp of creation. Based on the community's
 * configuration, the post's visibility status is determined: if the community
 * requires post review mode, the status is set to 'unreviewed' and the post
 * will not be visible to other users until approved by a moderator; otherwise,
 * the status is set to 'published' immediately. This behavior ensures that
 * communities can maintain content quality control while allowing public
 * communities to enable immediate posting.
 *
 * The operation persists the post data in the community_platform_posts table,
 * linking it to the author's user ID and the community's identifier. A related
 * audit log is automatically generated to track the creation event. The
 * response returns the full created post object, including its unique ID,
 * enabling the client to reference or manage the newly created post. The system
 * enforces a rate limit of five posts per hour per user to prevent spam.
 *
 * @param props.connection
 * @param props.body The data required to create a new post, including its
 *   title, content type, and the specific content (text body, URL, or image).
 * @path /communityPlatform/member/posts
 * @accessor api.functional.communityPlatform.member.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * The data required to create a new post, including its title, content
     * type, and the specific content (text body, URL, or image).
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post by ID within edit window.
 *
 * This operation allows authenticated members to update their own posts by
 * providing a new title and/or content. The post must be owned by the
 * authenticated user and can only be modified within the 15-minute edit window
 * defined by the platform settings.
 *
 * The operation requires the postId to be a valid UUID reference to an existing
 * post. The user must be the original author, and the post must not have been
 * deleted or removed. Only the title and content fields can be updated; the
 * post_type field cannot be modified after creation.
 *
 * The update operation validates character limits: title must be between 1 and
 * 300 characters, and content must be between 1 and 10,000 characters for text
 * posts. If the post type is link or image, the content field may be updated
 * but complete URL or image specifications cannot be modified.
 *
 * The operation updates the post's updated_at timestamp to the current
 * datetime. All updates are logged in the community_platform_post_snapshots
 * table for audit purposes, capturing the state of the post before
 * modification.
 *
 * Authentication is required to perform this operation. Membership verification
 * is enforced through the JWT token, and post ownership is validated against
 * community_platform_posts.author_id. Users attempting to update posts they
 * don't own receive a 403 Forbidden response.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post to be updated. Must be
 *   a valid UUID that exists in the community_platform_posts table.
 * @param props.body The updated content for the post, including title and
 *   optional content fields. Must be valid JSON object with appropriate
 *   constraints.
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * The unique identifier of the post to be updated. Must be a valid UUID
     * that exists in the community_platform_posts table.
     */
    postId: string & tags.Format<"uuid">;

    /**
     * The updated content for the post, including title and optional
     * content fields. Must be valid JSON object with appropriate
     * constraints.
     */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a post by ID.
 *
 * This operation permanently removes a post from the system and its associated
 * data. The post must be owned by the authenticated user making the request,
 * with ownership verified against community_platform_posts.author_id.
 *
 * This is a hard delete operation that completely removes the post from the
 * database without soft deletion markers. The operation cascades to delete all
 * associated comments in the community_platform_comments table, post votes in
 * community_platform_post_votes, post images in community_platform_post_images,
 * post links in community_platform_post_links, and related audit logs. This
 * ensures complete data removal from the system.
 *
 * After deletion, the post cannot be recovered. The deleted_at field is not
 * utilized for posts since this is a hard delete operation as defined by the
 * database schema, which lacks a deleted_at column for posts.
 *
 * Authentication is required to perform this operation. The user must be the
 * post owner. Users attempting to delete posts they don't own receive a 403
 * Forbidden response. The operation will succeed even if the post has received
 * many votes or has been reported.
 *
 * The deletion triggers an audit log entry in the community_platform_audit_logs
 * table, recording the deletion action with the user's ID and timestamp. No
 * response body is returned upon success, consistent with REST conventions for
 * delete operations.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post to be deleted. Must be
 *   a valid UUID that exists in the community_platform_posts table and is owned
 *   by the authenticated user.
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * The unique identifier of the post to be deleted. Must be a valid UUID
     * that exists in the community_platform_posts table and is owned by the
     * authenticated user.
     */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
