import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformModerator } from "../../../structures/ICommunityPlatformModerator";

/**
 * Register a new moderator user account with email verification required,
 * matching the member kind in the Prisma schema.
 *
 * This API operation handles the registration (join) process for moderator
 * users. When a new user registers as a moderator, this endpoint creates a new
 * account in the community_platform_member table with is_verified set to false
 * by default, as per the schema definition. The operation requires email
 * address, username, and password_hash fields, all of which exist in the schema
 * and are mandatory for member accounts. After registration, the system sends a
 * verification email to the provided email address (using the
 * community_platform_email_verifications table) as shown in the schema
 * relationships. The endpoint returns a temporary access token and refresh
 * token as specified in the response body type
 * ICommunityPlatformModerator.IAuthorized. Authentication is always required
 * for moderator registration since they are classified as 'member' kind users,
 * not guest users. This is different from guest users who do not require
 * authentication flows.
 *
 * The operation is closely tied to the community_platform_member and
 * community_platform_email_verifications tables. The registration process
 * creates a record in community_platform_member with is_verified = false, and
 * simultaneously creates a corresponding entry in
 * community_platform_email_verifications with a unique token that expires in 24
 * hours. This ensures email ownership before granting full privileges. The
 * schema clearly defines these tables and their FK relationships, confirming
 * this exact flow must be implemented. Passwords are stored as hashes in the
 * password_hash column, as required by the schema.
 *
 * This operation integrates with the authentication system defined in the
 * Prisma schema, where moderator accounts are classified as 'member' kind with
 * full authentication requirements. The operation follows the JWT-based session
 * management pattern established in the schema with
 * community_platform_user_sessions table for managing active sessions. When
 * authentication succeeds, the system generates access and refresh tokens that
 * are hashed and stored in the community_platform_user_sessions table as
 * access_token_hash and refresh_token_hash, respectively.
 *
 * From a security perspective, the operation must validate all input against
 * the schema's field constraints: email must be unique in
 * community_platform_member table (unique index), username must be unique
 * (unique index), and password must meet complexity requirements as documented
 * in business rules (though these are application-level, not schema-level). The
 * password_hash field must be properly salted and hashed with bcrypt before
 * storage, as required by the schema.
 *
 * This operation is related to other authentication flows: refresh_token must
 * be provided for subsequent refresh operations, and login must be used for
 * authentication after registration. The join operation is the first step in
 * the moderator authentication lifecycle, which progresses to login and refresh
 * as defined by the role type.
 *
 * @param props.connection
 * @param props.body Request body containing registration information for a new
 *   moderator account.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Request body containing registration information for a new moderator
     * account.
     */
    body: ICommunityPlatformModerator.ICreate;
  };
  export type Body = ICommunityPlatformModerator.ICreate;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a moderator user and issue access/refresh tokens based on
 * email/password credentials from the member table.
 *
 * This API operation handles the login process for moderator users,
 * authenticating them by validating their email and password against the
 * community_platform_member table. This is a core authentication operation that
 * follows the schema-defined data model, where the moderator account extends
 * from the community_platform_member table with its email, password_hash, and
 * is_verified fields.
 *
 * When a moderator attempts to log in, the system verifies that the provided
 * email exists in the community_platform_member table and that the
 * bcrypt-hashed password matches the stored password_hash. The is_verified
 * field must be true for login to succeed, as per schema requirements and
 * business rules. The schema clearly defines these fields, confirming this
 * exact verification process. Authentication failure results in appropriate
 * error handling without exposing whether email or password was incorrect,
 * adhering to security best practices.
 *
 * For successful authentication, the service generates a short-lived access
 * token and refresh token. These are stored as hashed values (access_token_hash
 * and refresh_token_hash) in the community_platform_user_sessions table, along
 * with the IP address, user agent, and session expiration timestamp. The schema
 * relationships show this table is directly linked to
 * community_platform_member, ensuring session tracking aligns with user
 * identity.
 *
 * The login operation is specifically designed for moderator (member) users as
 * defined by the role kind property. Unlike guest users who do not
 * authenticate, moderators require this flow. This operation is the second step
 * in the authentication lifecycle after join, followed by refresh when tokens
 * expire. The operation returns an ICommunityPlatformModerator.IAuthorized
 * response object as specified in the naming convention, consistent with the
 * role and service prefix.
 *
 * From a security perspective, the operation must respect the schema's field
 * limitations and constraints. The password_hash field stores encrypted
 * credentials, preventing plaintext exposure. Sessions are managed through the
 * community_platform_user_sessions table, which includes connection-specific
 * data (ip_address and user_agent) for forensic auditing as required by the
 * schema's security design. This authentication flow is fundamental to the
 * platform's access control system, ensuring only verified moderator users can
 * access moderator-specific functionality.
 *
 * @param props.connection
 * @param props.body Request body containing login credentials for moderator
 *   authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Request body containing login credentials for moderator
     * authentication.
     */
    body: ICommunityPlatformModerator.ILogin;
  };
  export type Body = ICommunityPlatformModerator.ILogin;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access token for moderator users using a valid refresh token from the
 * user sessions table.
 *
 * This API operation handles the refresh token flow for moderator users,
 * allowing them to obtain new access tokens without re-authentication using
 * their refresh token stored in the community_platform_user_sessions table. As
 * moderators are classified as 'member' kind users, they require the refresh
 * operation as part of their full authentication lifecycle.
 *
 * The operation validates the refresh token provided by the client by matching
 * its hash against the refresh_token_hash field in the
 * community_platform_user_sessions table. This field exists in the schema,
 * confirming the required storage mechanism. The operation checks that the
 * session is still active (is_active = true) and that the session has not
 * expired (session_expiry > current time), directly using the available schema
 * fields. If validation succeeds, the system generates a new access token and
 * refresh token. The new refresh token is stored with a new hash in the
 * refresh_token_hash field of the same session record, and the old refresh
 * token is effectively invalidated.
 *
 * The refresh flow follows the schema's session management design, where the
 * community_platform_user_sessions table tracks tokens and session states. This
 * design ensures security by preventing token replay and ensuring proper token
 * rotation. The refresh token expiration policy aligns with the schema design,
 * where session_expiry controls the maximum lifetime of the refresh token (7
 * days according to business requirements), though the actual expiration value
 * is stored per session.
 *
 * This operation is essential for maintaining authorization state after the
 * short-lived access token expires (after 15 minutes). It is only available to
 * moderator ('member') users, not guest users. The response returns updated
 * authentication data in ICommunityPlatformModerator.IAuthorized format,
 * consistent with the naming convention for authentication responses. This
 * operation is directly related to the join and login operations, completing
 * the three-part authentication flow required for all member users per the role
 * kind specification.
 *
 * The operation includes an authorization mechanism that prevents authenticated
 * users from using refresh tokens on unauthorized devices. The link between the
 * refresh token and the specific session (identified by its hash and associated
 * user ID) ensures that refresh requests are validated against the original
 * authentication context, as the schema enables through the
 * community_platform_user_sessions and community_platform_member relationship.
 *
 * @param props.connection
 * @param props.body Request body containing refresh token to exchange for a new
 *   access token.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Request body containing refresh token to exchange for a new access
     * token.
     */
    body: ICommunityPlatformModerator.IRefresh;
  };
  export type Body = ICommunityPlatformModerator.IRefresh;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
