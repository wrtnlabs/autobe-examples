import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconomicBoardTopic } from "../../../../structures/IEconomicBoardTopic";
import { IPageIEconomicBoardTopic } from "../../../../structures/IPageIEconomicBoardTopic";

/**
 * Create a new economic topic category.
 *
 * This operation creates a new topic category for organizing economic and
 * political discussions on the platform. All topics must be registered in the
 * economic_board_topics table, which maintains a controlled vocabulary of
 * exactly seven predefined categories: "Inflation", "Tax Policy", "Elections",
 * "Global Trade", "Monetary Policy", "Labor Markets", "Fiscal Policy".
 *
 * The system requires that topic names be exact, case-sensitive matches to
 * these predefined values. When a new topic is created, the system
 * automatically assigns the current UTC timestamp to created_at and updated_at
 * fields, and sets is_active to true by default. A description can optionally
 * be provided to clarify the scope of the topic.
 *
 * Administrative privileges are required to execute this operation, as it
 * affects the core content organization structure of the system. Creating
 * custom topics outside the predefined set is prohibited by system policy, so
 * this endpoint validates against the allowed values before persistence.
 *
 * Since topic names are immutable once created, this endpoint does not support
 * renaming or updating existing topics. To modify a topic's description or
 * activation status, a separate endpoint would be required. The system does not
 * allow soft deletion of topics; instead, topics are deactivated through the
 * is_active field to preserve historical post integrity.
 *
 * @param props.connection
 * @param props.body Specification of new topic category to be created,
 *   including name and optional description.
 * @path /economicBoard/admin/topics
 * @accessor api.functional.economicBoard.admin.topics.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Specification of new topic category to be created, including name and
     * optional description.
     */
    body: IEconomicBoardTopic.ICreate;
  };
  export type Body = IEconomicBoardTopic.ICreate;
  export type Response = IEconomicBoardTopic;

  export const METADATA = {
    method: "POST",
    path: "/economicBoard/admin/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/economicBoard/admin/topics";
  export const random = (): IEconomicBoardTopic =>
    typia.random<IEconomicBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated list of economic board topics.
 *
 * Retrieve a paginated list of economic board topics with detailed information
 * for system navigation and administrative purposes. This operation queries the
 * economic_board_topics table from the Prisma schema and supports filtering by
 * the is_active status field to show either active or inactive topics.
 *
 * The operation implements pagination with configurable page size and offset
 * parameters to handle potentially large collections of topic categories.
 * Results are organized by creation date descending to prioritize newer topics,
 * but can be sorted by name or other metadata fields.
 *
 * For system administrators, this operation provides critical visibility into
 * topic availability, allowing them to identify inactive topics that may be
 * candidates for deprecation. The description field provides additional context
 * about each topic's scope and purpose.
 *
 * Security considerations include restricting topic modification to admin users
 * while allowing read access to all authenticated users. Rate limiting is
 * applied to prevent brute-force enumeration of topic categories. The response
 * includes only non-sensitive metadata, avoiding exposure of internal
 * identifiers or system configuration details.
 *
 * This operation integrates directly with the economic_board_topics entity as
 * defined in the Prisma schema, incorporating all available fields including
 * id, name, created_at, updated_at, is_active, and description. The
 * implementation ensures compatibility with the system's predefined topic
 * categories: "Inflation", "Tax Policy", "Elections", "Global Trade", "Monetary
 * Policy", "Labor Markets", and "Fiscal Policy".
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for topic
 *   filtering
 * @path /economicBoard/admin/topics
 * @accessor api.functional.economicBoard.admin.topics.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search criteria and pagination parameters for topic filtering */
    body: IEconomicBoardTopic.IRequest;
  };
  export type Body = IEconomicBoardTopic.IRequest;
  export type Response = IPageIEconomicBoardTopic;

  export const METADATA = {
    method: "PATCH",
    path: "/economicBoard/admin/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/economicBoard/admin/topics";
  export const random = (): IPageIEconomicBoardTopic =>
    typia.random<IPageIEconomicBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific economic board topic.
 *
 * Retrieve comprehensive details about a specific economic board topic
 * identified by its UUID. This operation targets the economic_board_topics
 * table from the Prisma schema and returns the full record for the requested
 * topic, including the topic name, creation timestamp, last updated timestamp,
 * activity status, and description.
 *
 * The operation validates that the topicId parameter corresponds to an existing
 * record in the economic_board_topics table. If the topic does not exist, the
 * system returns a 404 Not Found response. The operation does not require any
 * request body since the topic is uniquely identified by its path parameter.
 *
 * This endpoint supports both public access for general users and privileged
 * access for administrators. The response includes all topic metadata available
 * in the schema, including the is_active flag, which allows users to determine
 * whether the topic is currently available for new post creation.
 *
 * Security is maintained by ensuring no sensitive information is exposed in the
 * response. The topic description is included to provide context about the
 * scope and purpose of each category, helping users understand appropriate
 * posting topics.
 *
 * The operation integrates directly with the economic_board_topics entity as
 * defined in the Prisma schema, returning exactly the fields: id, name,
 * created_at, updated_at, is_active, and description. This ensures alignment
 * with the system's requirement to support exactly seven predefined topic
 * categories with immutable names.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the economic board topic to
 *   retrieve
 * @path /economicBoard/admin/topics/:topicId
 * @accessor api.functional.economicBoard.admin.topics.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the economic board topic to retrieve */
    topicId: string & tags.Format<"uuid">;
  };
  export type Response = IEconomicBoardTopic;

  export const METADATA = {
    method: "GET",
    path: "/economicBoard/admin/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/economicBoard/admin/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IEconomicBoardTopic =>
    typia.random<IEconomicBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update economic topic metadata.
 *
 * This operation enables administrative modification of non-identity properties
 * of a topic category in the economic_board_topics table. The system permits
 * updates to the description field to clarify topic scope, and the is_active
 * field to temporarily disable a topic from new post creation without deleting
 * historical references.
 *
 * The topic id, which is the primary key and immutable, is specified in the URL
 * path as {topicId}. Update requests cannot modify the topic name, created_at
 * timestamp, or any other identity fields—attempted changes to these fields are
 * ignored by the system.
 *
 * Administrative privileges are required for this operation, as it controls the
 * content taxonomy of the platform. When is_active is set to false, the topic
 * remains visible in historical posts but is hidden from topic selection
 * dropdowns for new submissions. This design preserves data integrity while
 * allowing system-level control over content discoverability.
 *
 * The system records the modification timestamp in updated_at, reflecting when
 * the metadata change occurred. This operation does not affect posts already
 * associated with the topic, ensuring that historical content remains
 * accurately categorized despite administrative changes to topic metadata.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the topic category to be updated.
 * @param props.body Partial update specification for topic metadata fields
 *   (description and/or is_active).
 * @path /economicBoard/admin/topics/:topicId
 * @accessor api.functional.economicBoard.admin.topics.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the topic category to be updated. */
    topicId: string & tags.Format<"uuid">;

    /**
     * Partial update specification for topic metadata fields (description
     * and/or is_active).
     */
    body: IEconomicBoardTopic.IUpdate;
  };
  export type Body = IEconomicBoardTopic.IUpdate;
  export type Response = IEconomicBoardTopic;

  export const METADATA = {
    method: "PUT",
    path: "/economicBoard/admin/topics/:topicId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/economicBoard/admin/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IEconomicBoardTopic =>
    typia.random<IEconomicBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a topic category.
 *
 * This operation permanently removes a topic category from the
 * economic/political discussion board system entirely. Unlike merely
 * deactivating a topic, this action eliminates the topic from the system's
 * catalog of available categories. This is a hard delete operation, as there is
 * no soft_delete_column defined in the economic_board_topics Prisma schema,
 * meaning the topic record will be completely removed from the database with no
 * possibility of recovery.
 *
 * This operation is strictly reserved for administrators who have been granted
 * explicit moderation privileges. The business rules require that a topic must
 * not have any associated posts (neither published nor pending) before it can
 * be deleted. This ensures historical integrity and prevents orphaning of
 * existing content. Prior to deletion, the system will validate that no
 * economic_board_posts records reference the given topicId.
 *
 * The operation does not require any request body since the target topic is
 * fully identified by the topicId path parameter. Upon successful deletion, the
 * system returns a 204 No Content response. If the topic has existing posts, a
 * 409 Conflict response will be returned with an error message indicating that
 * the topic is in use. If the topic does not exist, a 404 Not Found response
 * will be returned.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the topic category to be deleted.
 *   Must correspond to an existing economic_board_topics id.
 * @path /economicBoard/admin/topics/:topicId
 * @accessor api.functional.economicBoard.admin.topics.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the topic category to be deleted. Must
     * correspond to an existing economic_board_topics id.
     */
    topicId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/economicBoard/admin/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/economicBoard/admin/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
