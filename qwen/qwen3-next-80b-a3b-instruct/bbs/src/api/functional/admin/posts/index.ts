import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconomicBoardPosts } from "../../../structures/IEconomicBoardPosts";

/**
 * Approve a pending post and transition its status to 'published' in the
 * economic_board_posts table.
 *
 * This API operation allows an admin to approve a post that is currently in
 * 'pending' status, transitioning it to 'published' and making it visible to
 * all users.
 *
 * The operation requires the admin to be properly authenticated via JWT. The
 * post must exist and have a status of 'pending' in the economic_board_posts
 * table. The admin's ID is recorded in the admin_id field for audit purposes.
 *
 * Before the update, the system validates that the requested post_id
 * corresponds to a legitimate post and that the admin has sufficient
 * permissions. The subject, content, and creation timestamp are preserved
 * unchanged.
 *
 * Once approved, the post appears in all topic feeds and search results. A
 * system notification can be triggered to notify the original author that their
 * post is now public.
 *
 * This operation must be used in conjunction with post rejection or deletion to
 * complete the moderation workflow. Only an authenticated admin can perform
 * this action.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be approved.
 * @path /admin/posts/:postId/approve
 * @accessor api.functional.admin.posts.approve
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function approve(
  connection: IConnection,
  props: approve.Props,
): Promise<approve.Response> {
  return true === connection.simulate
    ? approve.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...approve.METADATA,
          path: approve.path(props),
          status: null,
        },
      );
}
export namespace approve {
  export type Props = {
    /** Unique identifier of the post to be approved. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IEconomicBoardPosts;

  export const METADATA = {
    method: "PATCH",
    path: "/admin/posts/:postId/approve",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/posts/${encodeURIComponent(props.postId ?? "null")}/approve`;
  export const random = (): IEconomicBoardPosts =>
    typia.random<IEconomicBoardPosts>();
  export const simulate = (
    connection: IConnection,
    props: approve.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: approve.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Reject a pending post with a reason, changing its status to 'rejected' in
 * economic_board_posts.
 *
 * This API operation allows an admin to reject a post that is currently in
 * 'pending' status, preventing it from becoming public.
 *
 * The operation requires an admin to be authenticated and provides a mandatory
 * reason for rejection (e.g., 'inappropriate content', 'off-topic',
 * 'duplicate'). This reason is stored in the moderation_reason field of the
 * economic_board_posts table.
 *
 * The post status is updated from 'pending' to 'rejected'. The original
 * content, timestamp, and author information are preserved for audit purposes
 * but are no longer visible to any user.
 *
 * The reject operation triggers a notification to the original author of the
 * post, informing them of the rejection and the reason provided by the admin.
 *
 * Rejection is a soft action; the post remains in the database for moderation
 * logs and compliance. An admin's rejection decision can be overridden only by
 * a higher-privilege admin or system owner.
 *
 * This operation respects the business rule that rejected posts must always
 * have a reason provided, ensuring accountability in moderation decisions.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be rejected.
 * @param props.body Reason for rejecting the post, required for audit and
 *   notification purposes.
 * @path /admin/posts/:postId/reject
 * @accessor api.functional.admin.posts.reject
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function reject(
  connection: IConnection,
  props: reject.Props,
): Promise<reject.Response> {
  return true === connection.simulate
    ? reject.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...reject.METADATA,
          path: reject.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace reject {
  export type Props = {
    /** Unique identifier of the post to be rejected. */
    postId: string & tags.Format<"uuid">;

    /**
     * Reason for rejecting the post, required for audit and notification
     * purposes.
     */
    body: IEconomicBoardPosts.IReject;
  };
  export type Body = IEconomicBoardPosts.IReject;
  export type Response = IEconomicBoardPosts;

  export const METADATA = {
    method: "PATCH",
    path: "/admin/posts/:postId/reject",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reject`;
  export const random = (): IEconomicBoardPosts =>
    typia.random<IEconomicBoardPosts>();
  export const simulate = (
    connection: IConnection,
    props: reject.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: reject.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a post using hard delete, as economic_board_posts lacks a
 * soft_delete_column.
 *
 * This API operation allows an admin to permanently delete a post from the
 * database using a hard delete.
 *
 * Since the economic_board_posts table has no soft delete column (e.g.,
 * deleted_at), deletion is permanent and irreversible. The operation removes
 * both the post record and all associated replies from the database.
 *
 * The admin must be authenticated, and the specified post_id must exist. The
 * deletion cannot be undone, and no trace of the post is retained in the main
 * table.
 *
 * The system logs all deletions in an internal audit table including the
 * admin's ID, timestamp, and requested post_id, but this audit log is separate
 * from the economic_board_posts table and not accessible through normal API
 * endpoints.
 *
 * The deletion triggers no notification to the original author, per the
 * business rule that admin deletions are handled confidentially.
 *
 * The operation ensures that once a post is deleted, it cannot be recovered,
 * maintaining data integrity for moderation purposes.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be permanently deleted.
 * @path /admin/posts/:postId
 * @accessor api.functional.admin.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<erase.Response> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post to be permanently deleted. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IEconomicBoardPosts.IDelete;

  export const METADATA = {
    method: "DELETE",
    path: "/admin/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IEconomicBoardPosts.IDelete =>
    typia.random<IEconomicBoardPosts.IDelete>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
