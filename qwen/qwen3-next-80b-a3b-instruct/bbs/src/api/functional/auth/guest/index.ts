import { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { IEconomicBoardGuest } from "../../../structures/IEconomicBoardGuest";

/**
 * Creates temporary guest session with system-generated identifier for
 * anonymous access.
 *
 * This operation enables anonymous visitors to interact with the
 * economic/political discussion board by creating a temporary guest session.
 * When a guest accesses the system, this endpoint generates a new entry in the
 * economic_board_guest table with a unique UUID, a system-generated session_id
 * for persistence, and an optional ip_hash derived from the visitor's IP
 * address for security monitoring.
 *
 * The operation maps directly to the economic_board_guest model, which contains
 * the necessary fields: id (UUID), created_at (timestamp), session_id (unique
 * string), ip_hash (optional cryptographic hash), and last_active (timestamp).
 * No additional fields from other models are referenced since guest sessions do
 * not require email, passwords, or any permanent identity.
 *
 * This operation is critical for the platform's design philosophy of anonymous
 * participation. Guests can view content and are tracked for moderation
 * purposes only through their session_id and ip_hash, maintaining privacy while
 * allowing abuse detection. The guest session exists solely to provide
 * temporary access to public content, with all interaction capabilities still
 * restricted to registered members and admins.
 *
 * The operation is stateless in nature but generates a persistent server-side
 * record that can be maintained for up to 30 days based on inactivity
 * thresholds defined in business rules. This alignment with the
 * economic_board_guest schema ensures full compatibility with the system's
 * architecture.
 *
 * This operation is required for all unauthenticated users and serves as the
 * foundational entry point for the platform's anonymous interaction model,
 * complementing the authentication flows for members and admins.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(connection: IConnection): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Response = IEconomicBoardGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): IEconomicBoardGuest.IAuthorized =>
    typia.random<IEconomicBoardGuest.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Refreshes temporary authentication token for guest sessions to extend access
 * duration.
 *
 * This operation enables guest users to renew their temporary access without
 * re-registration. When guests interact with the system, they receive a
 * temporary JWT with a limited lifespan. When this expires, this endpoint
 * validates their existing session against the economic_board_guest table and
 * issues a new token with an updated expiration while preserving the same
 * session_id and guest context.
 *
 * The refresh operation is tied to the economic_board_guest entity, checking
 * the existing session_id and last_active fields to validate the guest's
 * identity. It then updates the last_active timestamp as part of the refresh
 * process, which satisfies the business rule requiring session heartbeat for
 * inactivity tracking.
 *
 * Because guest sessions are managed entirely through the economic_board_guest
 * model and do not use password_hash, auth_jwt_id, or any authentication fields
 * from economic_board_member or economic_board_admin, this operation uses only
 * the fields present in the guest table: session_id for identification and
 * created_at for session origin determination.
 *
 * This operation maintains the system's privacy by avoiding any email or
 * user-specific authentication mechanisms while extending session duration as
 * permitted by the business policy. It is the only mechanism for guests to
 * obtain prolonged access without becoming registered members.
 *
 * The response uses the consistent IAuthorized pattern for authentication
 * responses, specifically IEconomicBoardGuest.IAuthorized to distinguish guest
 * tokens from member and admin tokens, despite the guest role having no
 * traditional authentication strength.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Response = IEconomicBoardGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): IEconomicBoardGuest.IAuthorized =>
    typia.random<IEconomicBoardGuest.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
