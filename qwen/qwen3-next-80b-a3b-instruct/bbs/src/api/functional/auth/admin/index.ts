import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconomicBoardAdmin } from "../../../structures/IEconomicBoardAdmin";

/**
 * Register a new admin account in the economic_board_admin table with email and
 * password.
 *
 * This API operation registers a new system administrator account for the
 * economic/political discussion board.
 *
 * The operation creates a record in the economic_board_admin table with the
 * provided email and securely hashed password. It generates a new auth_jwt_id
 * for session management and sets created_at and last_login timestamps to the
 * current time. The is_active flag is initialized to true to enable immediate
 * login.
 *
 * Since admin accounts are pre-configured by system owners, this endpoint is
 * intended for initial setup or authorized administrative onboarding. It must
 * not be exposed to public users.
 *
 * The operation validates that the email is not already registered in the
 * economic_board_admin table. Multiple admins can exist, each with unique email
 * addresses. A password must be provided and is never stored in plain text.
 *
 * After successful creation, an initial JWT access token and refresh token are
 * generated and returned to the client for future authentication.
 *
 * This endpoint should be called only by system administrators or during
 * initial deployment, not by regular users or guests.
 *
 * @param props.connection
 * @param props.body Input data required to create a new admin account.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Input data required to create a new admin account. */
    body: IEconomicBoardAdmin.IJoin;
  };
  export type Body = IEconomicBoardAdmin.IJoin;
  export type Response = IEconomicBoardAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): IEconomicBoardAdmin.IAuthorized =>
    typia.random<IEconomicBoardAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin user by email and password, returning JWT access and
 * refresh tokens.
 *
 * This API operation authenticates an admin user by verifying their email and
 * password against the economic_board_admin table.
 *
 * The system compares the provided password against the stored password_hash
 * using a secure hashing algorithm. If validation succeeds, the last_login
 * timestamp is updated to the current time, and a new JWT access token is
 * generated with the admin's role and user identifier.
 *
 * The operation enforces that only accounts with is_active = true can login.
 * Suspended accounts cannot authenticate.
 *
 * The authentication token includes the admin's role and UUID, allowing
 * downstream services to enforce role-based access control. The refresh token
 * is returned in an httpOnly cookie for secure storage.
 *
 * Multiple concurrent sessions for the same admin are supported, with each
 * session having its own auth_jwt_id. The auth_jwt_id in the
 * economic_board_admin table is updated to the new token's UUID.
 *
 * This endpoint should be used for all admin authentication attempts, including
 * initial login and session resumption after token expiration.
 *
 * @param props.connection
 * @param props.body Credentials required for admin authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials required for admin authentication. */
    body: IEconomicBoardAdmin.ILogin;
  };
  export type Body = IEconomicBoardAdmin.ILogin;
  export type Response = IEconomicBoardAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): IEconomicBoardAdmin.IAuthorized =>
    typia.random<IEconomicBoardAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin's access token using a valid refresh token, extending the
 * session.
 *
 * This API operation allows an admin user to obtain a new access token using a
 * valid refresh token.
 *
 * The refresh token must be stored in an httpOnly cookie and cannot be accessed
 * by client-side JavaScript. The server verifies the token's validity,
 * expiration, and association with an active admin account.
 *
 * Upon successful validation, a new JWT access token is issued, and the refresh
 * token may be rotated for enhanced security (fresh token generation). The
 * last_login timestamp in the economic_board_admin table is updated to maintain
 * login history.
 *
 * This mechanism allows long-lived sessions while minimizing exposure of access
 * tokens. The refresh token's expiration is set to 30 days from the first
 * authentication, after which a full re-login is required.
 *
 * The system enforces strict token validation and invalidates all previous
 * tokens when a refresh occurs. An admin can have only one active session with
 * a valid refresh token at a time.
 *
 * @param props.connection
 * @param props.body Refresh token provided to renew access credentials.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token provided to renew access credentials. */
    body: IEconomicBoardAdmin.IRefresh;
  };
  export type Body = IEconomicBoardAdmin.IRefresh;
  export type Response = IEconomicBoardAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): IEconomicBoardAdmin.IAuthorized =>
    typia.random<IEconomicBoardAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
