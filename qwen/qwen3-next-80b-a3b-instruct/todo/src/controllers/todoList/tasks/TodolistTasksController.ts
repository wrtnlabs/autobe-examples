import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { getTodoListTasks } from "../../../providers/getTodoListTasks";
import { postTodoListTasks } from "../../../providers/postTodoListTasks";
import { deleteTodoListTasksTaskId } from "../../../providers/deleteTodoListTasksTaskId";

import { ITodoListTaskArray } from "../../../api/structures/ITodoListTaskArray";
import { ITodoListTask } from "../../../api/structures/ITodoListTask";

@Controller("/todoList/tasks")
export class TodolistTasksController {
  /**
   * Retrieve all todo list tasks.
   *
   * This operation retrieves the complete set of tasks from the user's personal
   * todo list. When the application loads or refreshes, the system queries the
   * todo_list_task table to fetch all records associated with the current user
   * session.
   *
   * The operation returns all tasks, regardless of their completion status,
   * ordered by creation time (newest first). Each task includes its unique
   * identifier, title, completion boolean status, and creation timestamp. Since
   * this is a single-user application with no authentication, the system
   * retrieves tasks based on the existing local storage context rather than
   * user credentials.
   *
   * The response includes all tasks in the user's list to satisfy the 'view all
   * tasks' requirement in the functional specifications. This operation is
   * called during application initialization and any time the user needs to
   * refresh their task list.
   *
   * No pagination is required as the application is designed for personal use
   * with minimal task volumes. Error handling is minimal since a zero-task
   * result is a valid state when the user has no tasks.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async index(): Promise<ITodoListTaskArray> {
    try {
      return await getTodoListTasks();
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Create a new todo list task.
   *
   * This operation creates a new task in the user's personal todo list. When a
   * user enters text in the task input field and submits it, the system creates
   * a new todo_list_task record associated with their user account.
   *
   * The operation requires only the task title as input, which must be a string
   * between 1 and 500 characters. The system automatically assigns a unique
   * UUID identifier, sets the completion status to false (incomplete), and
   * records the creation timestamp using the server's current time.
   *
   * Security considerations are minimal since this is a single-user application
   * with no authentication required. The system assumes the person accessing
   * the application is the legitimate owner of the task list. The new task is
   * immediately persisted in the database and will be available across browser
   * sessions through local storage persistence.
   *
   * This operation is the primary way users add new items to their task list
   * and is critical for the core functionality of the application.
   *
   * @param connection
   * @param body Creation data for a new todo list task
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TypedBody()
    body: ITodoListTask.ICreate,
  ): Promise<ITodoListTask> {
    try {
      return await postTodoListTasks({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a todo list task.
   *
   * This operation performs a hard delete of a specific todo list task by
   * permanently removing its record from the todo_list_task table in the
   * database. The operation takes a task ID as a path parameter to identify the
   * specific task to be deleted and does not require a request body.
   *
   * The Prisma schema does not include any soft-delete fields such as
   * 'deleted_at', 'is_deleted', or similar status flags, therefore this
   * operation implements permanent deletion. Once a task is deleted, it cannot
   * be recovered through the API and no archive or backup mechanism exists.
   * This aligns with the minimalistic design of the personal todo list
   * application where users are expected to manage their tasks explicitly.
   *
   * The operation is idempotent: if a user attempts to delete a task that has
   * already been deleted (or never existed), the system will return a 204 No
   * Content response without error. This prevents cascading failures due to
   * race conditions or UI state mismatches.
   *
   * Only tasks that belong to the current user session can be deleted. The
   * client-side application only sends delete requests for tasks that it has
   * loaded from or created in the user's context, ensuring users cannot delete
   * tasks that do not belong to them. No authentication or authorization token
   * is used at the API layer as the user model is device-bound.
   *
   * Related operations: GET /tasks to view all active tasks before deletion;
   * PATCH /tasks/{taskId}/complete to mark a task as completed instead of
   * deleting it; POST /tasks to create new tasks in the list.
   *
   * @param connection
   * @param taskId Unique identifier of the task to delete permanently
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":taskId")
  public async erase(
    @TypedParam("taskId")
    taskId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteTodoListTasksTaskId({
        taskId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
