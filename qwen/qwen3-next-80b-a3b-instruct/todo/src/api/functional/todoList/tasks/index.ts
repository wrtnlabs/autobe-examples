import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTaskArray } from "../../../structures/ITodoListTaskArray";
import { ITodoListTask } from "../../../structures/ITodoListTask";
export * as complete from "./complete/index";

/**
 * Retrieve all todo list tasks.
 *
 * This operation retrieves the complete set of tasks from the user's personal
 * todo list. When the application loads or refreshes, the system queries the
 * todo_list_task table to fetch all records associated with the current user
 * session.
 *
 * The operation returns all tasks, regardless of their completion status,
 * ordered by creation time (newest first). Each task includes its unique
 * identifier, title, completion boolean status, and creation timestamp. Since
 * this is a single-user application with no authentication, the system
 * retrieves tasks based on the existing local storage context rather than user
 * credentials.
 *
 * The response includes all tasks in the user's list to satisfy the 'view all
 * tasks' requirement in the functional specifications. This operation is called
 * during application initialization and any time the user needs to refresh
 * their task list.
 *
 * No pagination is required as the application is designed for personal use
 * with minimal task volumes. Error handling is minimal since a zero-task result
 * is a valid state when the user has no tasks.
 *
 * @param props.connection
 * @path /todoList/tasks
 * @accessor api.functional.todoList.tasks.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = ITodoListTaskArray;

  export const METADATA = {
    method: "GET",
    path: "/todoList/tasks",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/tasks";
  export const random = (): ITodoListTaskArray =>
    typia.random<ITodoListTaskArray>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new todo list task.
 *
 * This operation creates a new task in the user's personal todo list. When a
 * user enters text in the task input field and submits it, the system creates a
 * new todo_list_task record associated with their user account.
 *
 * The operation requires only the task title as input, which must be a string
 * between 1 and 500 characters. The system automatically assigns a unique UUID
 * identifier, sets the completion status to false (incomplete), and records the
 * creation timestamp using the server's current time.
 *
 * Security considerations are minimal since this is a single-user application
 * with no authentication required. The system assumes the person accessing the
 * application is the legitimate owner of the task list. The new task is
 * immediately persisted in the database and will be available across browser
 * sessions through local storage persistence.
 *
 * This operation is the primary way users add new items to their task list and
 * is critical for the core functionality of the application.
 *
 * @param props.connection
 * @param props.body Creation data for a new todo list task
 * @path /todoList/tasks
 * @accessor api.functional.todoList.tasks.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Creation data for a new todo list task */
    body: ITodoListTask.ICreate;
  };
  export type Body = ITodoListTask.ICreate;
  export type Response = ITodoListTask;

  export const METADATA = {
    method: "POST",
    path: "/todoList/tasks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/tasks";
  export const random = (): ITodoListTask => typia.random<ITodoListTask>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a todo list task.
 *
 * This operation performs a hard delete of a specific todo list task by
 * permanently removing its record from the todo_list_task table in the
 * database. The operation takes a task ID as a path parameter to identify the
 * specific task to be deleted and does not require a request body.
 *
 * The Prisma schema does not include any soft-delete fields such as
 * 'deleted_at', 'is_deleted', or similar status flags, therefore this operation
 * implements permanent deletion. Once a task is deleted, it cannot be recovered
 * through the API and no archive or backup mechanism exists. This aligns with
 * the minimalistic design of the personal todo list application where users are
 * expected to manage their tasks explicitly.
 *
 * The operation is idempotent: if a user attempts to delete a task that has
 * already been deleted (or never existed), the system will return a 204 No
 * Content response without error. This prevents cascading failures due to race
 * conditions or UI state mismatches.
 *
 * Only tasks that belong to the current user session can be deleted. The
 * client-side application only sends delete requests for tasks that it has
 * loaded from or created in the user's context, ensuring users cannot delete
 * tasks that do not belong to them. No authentication or authorization token is
 * used at the API layer as the user model is device-bound.
 *
 * Related operations: GET /tasks to view all active tasks before deletion;
 * PATCH /tasks/{taskId}/complete to mark a task as completed instead of
 * deleting it; POST /tasks to create new tasks in the list.
 *
 * @param props.connection
 * @param props.taskId Unique identifier of the task to delete permanently
 * @path /todoList/tasks/:taskId
 * @accessor api.functional.todoList.tasks.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the task to delete permanently */
    taskId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/tasks/:taskId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/tasks/${encodeURIComponent(props.taskId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("taskId")(() => typia.assert(props.taskId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
