import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardTopic } from "../../../structures/IDiscussionBoardTopic";
import { IPageIDiscussionBoardTopic } from "../../../structures/IPageIDiscussionBoardTopic";
export * as replies from "./replies/index";

/**
 * Search and retrieve a paginated list of discussion board topics
 * (discussion_board_topics table) for browsing or keyword search.
 *
 * Retrieve a list of discussion topics from the discussion_board_topics table,
 * supporting keyword search, sorting by date or relevance, and pagination.
 * Users can search by topic subject, content, or author, and the returned data
 * includes essential fields for rapid browsing and search interface display.
 *
 * The operation is available to all user roles, including guests, without
 * requiring authentication. Sensitive user information is filtered out,
 * exposing only display names, topic subjects, timestamps, and summary content.
 * Pagination strategies prevent loading delays when many topics exist, while
 * robust indexing in the underlying schema ensures search performance.
 *
 * Validation addresses search query length, pagination limits, and boundary
 * conditions such as out-of-range page numbers. If no topics match the search,
 * the response clearly indicates no results. Security checks ensure only public
 * data is returned, and all inputs are sanitized to prevent abuse or
 * injection.
 *
 * This endpoint supports seamless integration with public discussion landing
 * pages, search interfaces, and infinite-scroll browsing. It has no
 * dependencies on other API operations, requiring only optional search/query
 * parameters in the request body.
 *
 * @param props.connection
 * @param props.body Request parameters for searching, filtering, and paginating
 *   the discussion topics list.
 * @path /discussionBoard/topics
 * @accessor api.functional.discussionBoard.topics.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Request parameters for searching, filtering, and paginating the
     * discussion topics list.
     */
    body: IDiscussionBoardTopic.IRequest;
  };
  export type Body = IDiscussionBoardTopic.IRequest;
  export type Response = IPageIDiscussionBoardTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/topics";
  export const random = (): IPageIDiscussionBoardTopic.ISummary =>
    typia.random<IPageIDiscussionBoardTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full information and replies for a specific discussion board topic
 * (discussion_board_topics table) by topicId.
 *
 * Fetch full details of a specific topic by its unique topicId from the
 * discussion_board_topics table, including subject, content, author display
 * name, timestamps, and all public replies. Each reply includes the reply
 * content, reply author (member or admin), and respective timestamps,
 * supporting fluid engagement and reading for both guests and authenticated
 * users.
 *
 * The endpoint enforces strict parameter validation, ensuring a valid UUID
 * topicId is provided. If the topic does not exist, has been deleted, or the id
 * is invalid, the operation returns a clear not found error. Replies are always
 * presented in ascending chronological order to match discussion thread reading
 * conventions.
 *
 * All roles (guests, members, admins) may access this endpoint without
 * authentication. Sensitive author information (such as emails) is never
 * disclosed; only safe display data is included. This endpoint is integral to
 * the topic view page and reply workflows, and it has no dependency on prior
 * endpoint calls beyond needing a valid topicId.
 *
 * @param props.connection
 * @param props.topicId Unique identifier for the target topic to retrieve.
 * @path /discussionBoard/topics/:topicId
 * @accessor api.functional.discussionBoard.topics.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target topic to retrieve. */
    topicId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardTopic;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IDiscussionBoardTopic =>
    typia.random<IDiscussionBoardTopic>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
