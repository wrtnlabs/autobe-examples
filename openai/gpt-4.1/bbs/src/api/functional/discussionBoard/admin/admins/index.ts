import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAdmin } from "../../../../structures/IDiscussionBoardAdmin";
import { IPageIDiscussionBoardAdmin } from "../../../../structures/IPageIDiscussionBoardAdmin";
import { IDiscussionBoardAdmins } from "../../../../structures/IDiscussionBoardAdmins";

/**
 * Search and retrieve a filtered, paginated list of discussion board
 * administrators (discussion_board_admins table).
 *
 * Retrieves a paginated and filtered list of administrator accounts
 * (discussion_board_admins) to support management and oversight of privileged
 * users.
 *
 * Administrators are special accounts with elevated rights (user management,
 * system moderation), and can login and perform privileged functions beyond
 * normal members. Each admin has a unique email, username, hashed password, and
 * verification status, along with timestamps for registration, last update, and
 * possible soft-deletion.
 *
 * Security and permissions: This operation must only be accessible to currently
 * authenticated admins, as it exposes privileged account data. The response
 * omits sensitive password hashes and only includes fields necessary for admin
 * oversight.
 *
 * Flexible filtering and sorting allows admins to quickly locate accounts by
 * specific criteria such as creation date or email. Error handling covers
 * invalid parameters or unauthorized attempts, preventing exposure of sensitive
 * admin data. Responses include pagination metadata for user-friendly UI
 * navigation.
 *
 * This operation is part of the core admin management flow and is typically
 * used together with detail retrieval (GET /admins/{adminId}), creation,
 * modification, and soft/hard deletion APIs for administrative accounts.
 *
 * @param props.connection
 * @param props.body Criteria for searching administrators, including filters
 *   and pagination settings.
 * @path /discussionBoard/admin/admins
 * @accessor api.functional.discussionBoard.admin.admins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Criteria for searching administrators, including filters and
     * pagination settings.
     */
    body: IDiscussionBoardAdmin.IRequest;
  };
  export type Body = IDiscussionBoardAdmin.IRequest;
  export type Response = IPageIDiscussionBoardAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/admins";
  export const random = (): IPageIDiscussionBoardAdmin.ISummary =>
    typia.random<IPageIDiscussionBoardAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific administrator account
 * (discussion_board_admins table) by adminId.
 *
 * Fetches all public and administrative metadata for a specified administrator
 * account (discussion_board_admins) identified by adminId.
 *
 * Admins have unique email addresses, usernames, password hashes (not
 * returned), verification statuses, and timestamps for creation, registration
 * completion, and possible soft-deletion. This detailed view supports auditing,
 * profile inspection, or administrative action tracing.
 *
 * Only admins are allowed to execute this operation due to the sensitivity of
 * account data. Security considerations include ensuring the adminId parameter
 * is validated as a UUID, verifying permissions, and safely omitting
 * confidential fields such as password hashes in the response.
 *
 * This operation is critical for managing privileged accounts in the discussion
 * board, facilitating review, edit, or (if supported) deletion and recovery
 * functionality. Errors such as invalid adminId or missing records return
 * appropriate error responses, ensuring data security.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the administrator account to
 *   retrieve.
 * @path /discussionBoard/admin/admins/:adminId
 * @accessor api.functional.discussionBoard.admin.admins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the administrator account to retrieve. */
    adminId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAdmin;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IDiscussionBoardAdmin =>
    typia.random<IDiscussionBoardAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an administrator profile in the discussion board
 * (discussion_board_admins table).
 *
 * This API endpoint enables administrators to update the profile information
 * for a specific admin account in the discussion board.
 *
 * The operation directly maps to the discussion_board_admins table, allowing
 * privileged modification of admin information such as email address, display
 * username, password hash (securely hashed), and verification/completion
 * status. Each update is recorded with audit-relevant timestamps for compliance
 * and traceability.
 *
 * Security and validation are critical. Only authenticated admin users can
 * access this endpoint; attempts to access by non-admins are explicitly denied.
 * Input fields must be validated: email and username are unique and required,
 * password_hash must be securely processed before storage, and changes to
 * verification fields must be business-authorized. Input and field constraints
 * must match those specified in the schema, with clear validation errors
 * communicated to the user for any invalid update requests.
 *
 * If either email or username is already in use by another admin, the operation
 * should return a descriptive conflict error. For password changes, strong
 * password policies and secure hashing are enforced outside this API but must
 * be consistently documented as system requirements. All successful updates are
 * timestamped, and the updated admin profile is returned in the response.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin account to update.
 * @param props.body Fields to update in the admin profile (email, username,
 *   password hash, and verification status) following required schema
 *   constraints.
 * @path /discussionBoard/admin/admins/:adminId
 * @accessor api.functional.discussionBoard.admin.admins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the admin account to update. */
    adminId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the admin profile (email, username, password
     * hash, and verification status) following required schema
     * constraints.
     */
    body: IDiscussionBoardAdmins.IUpdate;
  };
  export type Body = IDiscussionBoardAdmins.IUpdate;
  export type Response = IDiscussionBoardAdmins;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/admins/:adminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IDiscussionBoardAdmins =>
    typia.random<IDiscussionBoardAdmins>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an administrator account (discussion_board_admins table) for
 * privileged admin user lifecycle management.
 *
 * This API endpoint allows an admin user to perform a soft delete (set the
 * deleted_at timestamp) on an administrator account, as defined in the
 * discussion_board_admins Prisma schema table.
 *
 * The targeted adminId must correspond to an existing, active admin record;
 * otherwise, the system returns a not found error. Soft-deletion preserves the
 * integrity of audit trails and historical administrative actions, in line with
 * compliance requirements.
 *
 * Only users authenticated with the admin role are allowed to access this
 * endpoint. Authorization must be verified before processing, with all
 * unauthorized or insufficient privilege attempts receiving a clear, secure
 * denial response.
 *
 * Once soft-deleted, the admin account is excluded from standard admin
 * operations and authentication but can be restored or audited by super-admin
 * workflows if such are implemented in the future. This operation never
 * permanently erases records or their associated system activity.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin account to delete.
 * @path /discussionBoard/admin/admins/:adminId
 * @accessor api.functional.discussionBoard.admin.admins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the admin account to delete. */
    adminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
