import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardMember } from "../../../structures/IDiscussionBoardMember";

/**
 * Register a new member (discussion_board_members) account for posting topics
 * or replies.
 *
 * This API operation allows a guest to register as a member by providing a
 * unique email address, a display username, and a password. Only fields
 * actually present in the 'discussion_board_members' table are accepted:
 * 'email', 'username', and 'password_hash' (which is computed and stored
 * securely). The user must verify their email; until then, the 'email_verified'
 * flag is false, and account activation is not complete. This operation
 * supports initial account creation, but does not finalize email verification
 * or session token issuance.
 *
 * Only users with unique email and username values may register; duplicate
 * attempts are prevented using database constraints. No moderation or admin
 * approval is enforced at registration for members. Upon registration, audit
 * fields 'created_at' and 'registration_completed_at' capture creation time,
 * while 'deleted_at' is unused at this phase. All authentication logic,
 * including password hashing and email validation, must reference these schema
 * fields only.
 *
 * Security: Passwords are hashed (never stored in plaintext), and
 * email/username must conform to uniqueness and format requirements. The member
 * cannot log in until email verification is completed. This operation does not
 * grant posting rights until account is verified.
 *
 * The operation is mandatory for users wishing to create topics or replies;
 * guests may not register multiple times with the same email/username. Failed
 * registration attempts provide error messages based on actual DB constraint
 * violations.
 *
 * This endpoint is always used before login or other authentication steps. It
 * does not generate JWT tokens until email is verified.
 *
 * @param props.connection
 * @param props.body Registration information containing email, username, and
 *   password for new member account creation.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration information containing email, username, and password for
     * new member account creation.
     */
    body: IDiscussionBoardMember.ICreate;
  };
  export type Body = IDiscussionBoardMember.ICreate;
  export type Response = IDiscussionBoardMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): IDiscussionBoardMember.IAuthorized =>
    typia.random<IDiscussionBoardMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate as a member ('discussion_board_members') and obtain an access
 * JWT for posting/replying.
 *
 * This endpoint processes login attempts for registered members. Input is
 * matched solely against schema fields: 'email' and 'password_hash'. The
 * password submitted by the user is securely hashed before comparison.
 * Authentication fails if either a matching email is not found, the hashed
 * password does not match, or 'email_verified' is not true. Only after passing
 * these conditions does the user receive a session and associated authorization
 * tokens.
 *
 * On success, the system generates and returns a new JWT token referencing the
 * member's 'id', role ('member'), and appropriate permissions for posting and
 * interaction on the board. Failed attempts do not leak user existence: all
 * error messages are generic for invalid credentials or unverified accounts.
 * Account lockout on repeated failures would reference only 'email' and lockout
 * business logic, not implemented directly in this table.
 *
 * Registration, email verification, and password recovery/lockout are handled
 * via separate flows. This login operation is required before performing any
 * other member-only actions. Audit fields such as 'created_at', 'updated_at',
 * and 'deleted_at' are not used directly in this authentication step.
 *
 * @param props.connection
 * @param props.body Login form with member email and password for
 *   authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login form with member email and password for authentication. */
    body: IDiscussionBoardMember.ILogin;
  };
  export type Body = IDiscussionBoardMember.ILogin;
  export type Response = IDiscussionBoardMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): IDiscussionBoardMember.IAuthorized =>
    typia.random<IDiscussionBoardMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh an authenticated member ('discussion_board_members') session and
 * extend access token.
 *
 * This endpoint allows a member with a valid refresh token to renew their
 * authenticated session, using only data present in the access/refresh payload
 * (typically 'id'). It looks up the member in 'discussion_board_members' and
 * verifies the account is active ('deleted_at' is null), and that the email has
 * been verified ('email_verified' is true). If all checks pass, a new JWT is
 * issued for ongoing participation.
 *
 * The API does not use or reference any fields not present in the actual
 * schema: it relies on 'id', 'deleted_at', and 'email_verified' as available.
 * Expired, revoked, or invalid tokens are rejected with generic error messages.
 * The operation is required for seamless posting and reply functionality during
 * long sessions.
 *
 * No session event/audit logging fields are present in the member schema, so
 * history is handled outside this operation. This step is mandatory before
 * continuing any protected operations (create, update, delete topics/replies)
 * when the access token nears expiry.
 *
 * @param props.connection
 * @param props.body Refresh token request referencing existing member session
 *   for renewal.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request referencing existing member session for
     * renewal.
     */
    body: IDiscussionBoardMember.IRefresh;
  };
  export type Body = IDiscussionBoardMember.IRefresh;
  export type Response = IDiscussionBoardMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): IDiscussionBoardMember.IAuthorized =>
    typia.random<IDiscussionBoardMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
