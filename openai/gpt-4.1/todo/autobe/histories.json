[{"id":"0199bf4b-32bd-749a-95d6-348ac122d191","type":"userMessage","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit."}],"created_at":"2025-10-07T15:30:00.509Z"},{"type":"analyze","id":"0199bf51-0303-73b2-8c90-9c4bf8f463b5","instruction":"Create a requirements analysis report for a minimal Todo list application. Only include the most essential features and functionalities required to provide basic Todo list functionality. The report should reflect a simple user scenario without any advanced or additional options.","prefix":"todoList","roles":[{"name":"user","description":"A registered user who can authenticate via API and manage their own Todo items, including creating, viewing, updating, and deleting their own tasks. Cannot access other users’ Todos or admin functions.","kind":"member"}],"files":[{"reason":"To provide a complete overview of the documentation structure and ensure easy navigation for developers and stakeholders. Also to house the developer autonomy note required by project standards.","filename":"00-toc.md","documentType":"table-of-contents","outline":["Document Structure","Document Relationships","How to Use this Documentation"],"audience":"general","content":"# Functional Requirements for Minimal Todo List Application\n\n## Essential Features\n\n### Minimal Scope & Feature Set\n- THE system SHALL allow authenticated users to create Todo items describing tasks they wish to track.\n- THE system SHALL allow each user to retrieve a list of all their current Todo items.\n- THE system SHALL allow users to mark any Todo item as completed or not completed.\n- THE system SHALL allow users to update the title/description of any of their existing Todo items.\n- THE system SHALL allow users to delete any of their own Todo items.\n- THE system SHALL require user authentication for any access or action with a Todo item.\n\n### Explicit Functional Requirements (EARS)\n1. WHEN a user submits a request to create a Todo, THE system SHALL save the new Todo item, associating it with that user.\n2. WHEN a user requests their Todo list, THE system SHALL return a complete list of the user's active Todo items, in descending order of creation time (newest first).\n3. WHEN a user updates a Todo item, THE system SHALL save only if the Todo belongs to that user and provided data passes validation.\n4. WHEN a user deletes a Todo, THE system SHALL remove that Todo from their list, provided the user is the creator.\n5. WHEN a user toggles the completion status of a Todo, THE system SHALL update the Todo's status accordingly and persist the updated state for that user only.\n6. WHERE a user is not authenticated, THE system SHALL deny all Todo-related operations and report authentication required.\n7. IF a user attempts to access, update, or delete a Todo they do not own, THEN THE system SHALL prevent the action and inform the user that resource does not exist.\n8. THE system SHALL provide accurate counts of total Todos and completed Todos upon request.\n9. WHEN a Todo is created or updated, THE system SHALL timestamp the operation for audit and business record-keeping.\n\n## Business Rules\n\n### Ownership & Access\n- THE system SHALL restrict each user to accessing only Todo items created by that user.\n- WHERE a Todo item does not belong to the requesting user, THE system SHALL treat it as non-existent for all business purposes.\n- THE system SHALL require all operations (create, update, delete, mark complete/incomplete, retrieve) to occur only within the authenticated user session scope.\n\n### Data Lifecycle\n- THE system SHALL retain deleted Todos only long enough to complete the business process (no restore/undo requirements for minimal system).\n- THE system SHALL store a creation timestamp and last modification timestamp for every Todo item.\n- THE system SHALL initialize every new Todo as not completed by default.\n\n### Functional Integrity\n- THE system SHALL not allow batch actions (all operations are single-Todo at a time).\n- THE system SHALL not support subtasks, labels, priorities, deadlines, or attachments.\n- THE system SHALL not allow edit or delete operations on another user's Todo item under any circumstance.\n\n## Validation Requirements\n\n### Input Field Validation\n- WHEN a user creates or updates a Todo, THE system SHALL validate that the title/description is a non-empty UTF-8 string with a length between 1 and 255 characters.\n- IF the title/description is blank, THEN THE system SHALL reject the request with a message explaining the requirement.\n- IF input exceeds maximum length, THEN THE system SHALL reject the request with a message indicating the maximum allowed size.\n- WHERE an input contains only whitespace, THE system SHALL treat it as invalid.\n\n### Identity Validation\n- WHEN performing any action, THE system SHALL confirm the authenticated user identity and only allow operations on their own Todo items.\n\n### State Validation\n- IF a requested Todo to update or delete does not exist under the authenticated user, THEN THE system SHALL return a not-found response (without specifying whether the ID exists globally for security).\n- WHEN a Todo status is toggled to completed or not completed, THE system SHALL accept only boolean state values.\n\n## Performance Expectations\n\n- THE system SHALL respond to all user actions (create, read, update, delete, mark complete/incomplete) within 1 second under normal operating conditions.\n- THE system SHALL process and reflect changes instantly to the user experience (i.e., user observes the updated Todo state upon operation success without delay).\n- THE system SHALL support at least 10 requests per second per authenticated user for Todo CRUD operations, with no noticeable performance degradation.\n- THE system SHALL ensure that user authentication/authorization checks add at most 100ms to any action on their own Todos.\n\n## Core Functional Flow Diagram\n\n```mermaid\ngraph LR\n    subgraph \"Todo List Minimal Feature Workflow\"\n        A[\"User Authenticated?\"] -->|\"No\"| B[\"Reject: Auth Required\"]\n        A -->|\"Yes\"| C[\"Perform Operation Request\"]\n        C --> D{\"Action Type\"}\n        D -->|\"Create\"| E[\"Validate Field\"]\n        E -->|\"Valid\"| F[\"Create Todo, Timestamp, Set Owner\"]\n        E -->|\"Invalid\"| G[\"Reject: Invalid Field\"]\n        D -->|\"Retrieve\"| H[\"List User's Todos (Newest First)\"]\n        D -->|\"Update/Delete\"| I[\"Confirm Ownership & Existence\"]\n        I -->|\"OK\"| J[\"Validate & Apply Change\"]\n        J -->|\"Success\"| K[\"Persist Change\"]\n        J -->|\"Fail\"| L[\"Reject: Not Found/Invalid\"]\n        I -->|\"Not Owner/Not Found\"| L\n        D -->|\"Toggle Complete\"| M[\"Validate Ownership & Boolean\"]\n        M -->|\"Valid\"| N[\"Update State\"]\n        M -->|\"Invalid\"| O[\"Reject: Invalid State\"]\n    end\n```\n\n## Summary Table: Essential Features\n\n| Feature                      | Description                                                      |\n|------------------------------|------------------------------------------------------------------|\n| Create Todo                  | User can create a new Todo item with basic text/description      |\n| List Todos                   | User can view all their Todos (newest first)                     |\n| Mark As Complete/Incomplete  | User can toggle completion status for a Todo                     |\n| Update Todo                  | User can edit text/description of their own Todo                 |\n| Delete Todo                  | User can remove their own Todo item                              |\n\n## Key Business Constraints (for minimal system)\n- Single user type: only registered users manage own Todos via API\n- No sharing, no collaborative features, no labels/priorities/deadlines\n- No admin, no moderation; user can only interact with own data\n- Only core CRUD and toggle complete operations are allowed\n- All error messages must avoid exposing existence of other users’ data or Todo items\n\n## Compliance with Related Documents\nFor broader operational, error-handling, and business process requirements, refer to:\n- [Service Overview](./01-service-overview.md)\n- [User Roles and Authentication](./04-user-roles-and-authentication.md)\n- [Business Rules and Validation](./07-business-rules-and-validation.md)\n- [Exception Handling and Error Scenarios](./08-exception-handling-and-error-scenarios.md)"},{"reason":"To establish the overall business vision, purpose, and market rationale for the minimal Todo list application before specifying any requirements or user journeys.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Service Vision","Problem Statement","Core Value Proposition","Business Model","Success Metrics"],"audience":"business stakeholders, development team","content":"# Service Overview for Minimal Todo List Application\n\n## Service Vision\nThe vision of the minimal Todo list application is to offer individuals a simple, distraction-free way to organize and track daily tasks, empowering users to maintain focus and manage their productivity efficiently. The application prioritizes ease of use, absolute clarity, reliability, and minimalism, supporting users who wish for a frictionless, no-nonsense method to remember and complete their tasks.\n\n## Problem Statement\nPeople often lose track of what needs to be done because task management tools can be overly complex, filled with unnecessary features, subscription demands, or intrusive notifications. The lack of a truly lightweight, user-controlled Todo app leaves a significant market gap for those who simply want to write down, check off, and delete tasks, without the onboarding burden or decision fatigue caused by bloatware.\n\n## Core Value Proposition\n- Simplicity: A single-purpose tool—creating and managing simple Todo lists with no extraneous features.\n- Privacy: User tasks are only accessible by the user; no public sharing or social features are built in.\n- Speed: Users can add, view, edit, and delete tasks quickly, with no distractions or multi-step forms.\n- Minimal Onboarding: Users register via API and immediately begin using the core Todo functions with only essential fields collected, and no advertisement or upsell interruptions.\n\n## Business Model\n\n### Why This Service Exists\nThere is a persistent segment of users frustrated by complex, feature-bloated task apps. This service fills a market gap by offering a truly minimal, private Todo list app with only the essentials, lowering the cognitive load for users and removing the friction of competing apps that prioritize monetization or virality over actual usability. By stripping away non-core features, the app can attract users seeking a trustworthy productivity companion that \"just works.\"\n\n### Revenue Strategy\nIn its minimal version, the app does not include any paid features, advertisements, or monetization mechanisms. The long-term vision may include optional, non-intrusive paid upgrades (such as backup, multi-device sync, or pro support), but such elements are excluded from the MVP and roadmap until a loyal user base demands them. No user data is sold or shared under any circumstances.\n\n### Growth Plan\nInitial user acquisition focuses on word-of-mouth and developer communities who value minimalism. Open-source exposure and social proof from satisfied users serve as primary acquisition channels. No marketing budget is allocated for ads or paid placement in the MVP phase.\n\n### Success Metrics\n- Daily and Monthly Active Users (DAU, MAU)\n- Task completion rate per user\n- User retention metrics over 7/30 days\n- Average tasks created/checked-off per active user\n- Zero reported privacy/data-leak incidents\n\n## How this Document Informs Other Documents\nThis overview serves as the anchoring reference for all requirements, features, and user journeys documented elsewhere, such as the [Functional Requirements Document](./05-functional-requirements.md), [User Roles and Authentication](./04-user-roles-and-authentication.md), [User Journey](./06-user-journey.md), and [Business Rules and Validation](./07-business-rules-and-validation.md). All future development must adhere to the values, principles, and user-first bias established in this document.\n"},{"reason":"To clearly define the specific problem the Todo list application addresses for its core user audience, ensuring the solution provides actual value and meeting user pain points.","filename":"02-problem-definition.md","documentType":"requirement","outline":["User Pain Points","Market Needs","Existing Solutions and Gaps","Key Challenges"],"audience":"business stakeholders, product managers","content":"# Problem Definition for Minimal Todo List Application\n\n## User Pain Points\n- Many individuals struggle daily to organize, remember, and keep track of tasks—both personal and professional. WHEN a user relies on memory alone or scattered notes (physical or digital), THE likelihood of missed tasks, forgotten deadlines, or duplicated efforts SHALL increase.\n- Existing digital solutions often present too many features, resulting in decision fatigue, confusion, or a time-consuming setup before the user can begin tracking tasks.\n- WHEN users attempt to use overcomplicated task management apps for simple lists, THE system SHALL cause frustration by forcing unnecessary categorization, prioritization, or context selection.\n- IF a user wishes only to record a task and mark it complete, THEN many current solutions SHALL create barriers by requiring additional fields or navigation through menus.\n- For users seeking minimal distractions, any requirement to configure, learn, or ignore irrelevant features reduces engagement and persistence in using the tool. THE system SHALL provide an experience that addresses this minimalism.\n\n## Market Needs\n- The primary market segment addressed is users who require only basic Todo list functions: capturing, viewing, marking as done, and removing tasks, with no advanced options.\n- These users need quick access from any device and expect data to persist reliably between sessions, regardless of where they start or pick up their work.\n- Security is a concern, as each user's Todo list may include private or personal content. THE system SHALL protect access to personal Todos by ensuring only authenticated users can manage their own lists.\n- Users express a need for zero-friction onboarding; minimal registration and account management are essential to ensure quick adoption and immediate productivity.\n- Performance expectation: THE system SHALL allow users to add, edit, view, or delete tasks instantly (sub-second perceived delay for core actions).\n\n## Existing Solutions and Gaps\n- Although many digital Todo list applications exist (including well-known productivity and note apps), most target users seeking complex workflows, integrations, or advanced prioritization.\n- WHEN a user seeks a truly minimal application, THE market mostly offers pen-and-paper solutions or repurposes other apps, both of which lack digital persistence, backup, and cross-device syncing.\n- Existing \"simple\" solutions often still require extensive onboarding, default priority, due date, label settings, or push non-essential options into the primary workflow, violating the \"minimal effort, maximum utility\" requirement for this audience.\n- There is presently a gap for an application that serves only the most stripped-down user need: authenticated access, minimal input (just the task itself), and instant feedback on every action, with no optional features.\n\n## Key Challenges\n- The core challenge is constructing a system that, WHILE remaining minimal, SHALL ensure reliability and data integrity—no user should ever lose or fail to update their Todo list, regardless of device or network interruptions.\n- Adoption and sustained usage depend on initial and ongoing absence of obstacles: registration/log-in must not be a burden, and user flows must remain frictionless (from first launch to repeated daily use).\n- It is critical to avoid any feature creep; mistakenly adding \"helpful\" options risks undermining the product’s core value—simplicity.\n- Performance benchmark: THE system SHALL return all lists and process all task edits in perceived real time, to keep pace with quick user expectations (action results visible within 1 second in normal network conditions).\n- Privacy and security are paramount, even with limited user data; THE system SHALL enforce access barriers so that no user can ever read or modify another's tasks."},{"reason":"To describe the essential business logic, workflows, and system behaviors, providing a clear foundation of what the application does at a high level, before diving into detailed journeys and requirements.","filename":"03-service-operation-overview.md","documentType":"requirement","outline":["System Overview","Main Features","Business Processes","Primary User Flows"],"audience":"general","content":"# Service Operation Overview for Minimal Todo List Application\n\n## 1. System Overview\nThe minimal Todo list application enables a single user (role: user) to manage personal tasks securely, with authentication enforced at every interaction. The system avoids any non-essential features and focuses on the core business purpose: allowing a user to track, update, and remove their own tasks reliably. Each user operates in isolation, and no collaboration or advanced feature set is included.\n\n- Only one user role exists: \"user\". All operations are self-service for this role alone.\n- No priorities, labels, deadlines, or sharable lists are supported.\n- Simplicity and reliability are prioritized for all main process flows.\n\n## 2. Main Features\n\n| Feature              | Business Description                                        |\n|----------------------|-----------------------------------------------------------|\n| User Signup/Login    | Users register and authenticate before using the service  |\n| View Todos           | Users see a list of all their Todos                       |\n| Add Todo             | Users add a single Todo with required text content        |\n| Edit Todo            | Users update the text or completion flag of their Todos   |\n| Delete Todo          | Users remove their Todos permanently                      |\n\nThe business model limits features strictly to those above. All other feature requests are out of scope for minimal Todo list operation.\n\n## 3. Business Processes\n\n### Todo Lifecycle\nEach Todo is created by its owner. Only the creator (authenticated user) can view, edit, complete, or delete the Todo.\n\nProcess Steps:\n- Todo Creation: User submits text; system validates content is non-empty.\n- Viewing: User requests list; returns only own Todos in most-recent or last-edited order.\n- Editing: User updates text or toggles \"complete\"; only own Todos can be updated.\n- Deleting: User issues remove request; Todo disappears from their list instantly.\n\n#### Mermaid State Diagram\n```mermaid\ngraph LR\n  A[\"New Todo Created\"] --> B{\"Is Todo Modified?\"}\n  B -->|\"Yes\"| C[\"Todo Updated\"]\n  B -->|\"No\"| D{\"Marked Complete?\"}\n  D -->|\"Yes\"| E[\"Todo Marked Complete\"]\n  D -->|\"No\"| F{\"Deleted?\"}\n  F -->|\"Yes\"| G[\"Todo Deleted\"]\n  F -->|\"No\"| H[\"Todo Remains Active\"]\n```\n\n### Authentication Process\n- Users must log in or register to use any feature.\n- Every feature, including viewing, requires re-verification of user identity (active session).\n- No unauthenticated access is possible.\n\n### Data Consistency and Security\n- User actions immediately reflect in the service’s state.\n- Each operation strictly verifies ownership before mutating any data.\n\n\n## 4. Primary User Flows\n\n### End-to-End Minimal Journey\n1. Signup/Login: User creates an account or signs in using credentials.\n2. View Todos: After login, user is shown current tasks; if empty, an empty state appears.\n3. Add Todo: User adds a new Todo (must have non-empty text); it immediately appears in list.\n4. Edit Todo: User modifies content or toggles completion; changes are saved instantly.\n5. Delete Todo: User removes a Todo; list reflects the removal at once.\n6. Logout: User logs out, ending access to all operations until re-authenticated.\n\n#### Mermaid Flow Diagram\n```mermaid\ngraph LR\n  login[\"User Login\"] --> view[\"View Todo List\"]\n  view --> create[\"Create New Todo\"]\n  create --> view\n  view --> edit[\"Edit Existing Todo\"]\n  edit --> view\n  view --> delete[\"Delete Todo\"]\n  delete --> view\n  view --> logout[\"Logout\"]\n```\n\n## EARS Requirements Summary\n- WHEN a user is not authenticated, THE system SHALL not display, create, edit, or delete any Todos.\n- WHEN a user is authenticated, THE system SHALL allow full CRUD only for that user's own Todos.\n- WHEN a Todo is created, THE system SHALL require the content field to be non-empty.\n- WHEN a Todo is edited or deleted, THE system SHALL check user ownership before any change occurs.\n- IF a user attempts to act upon another user's Todo, THEN THE system SHALL reject the request and show a standard access error.\n- WHILE a user’s session is active, THE system SHALL persist all Todo updates instantly.\n\n## References\nFurther details are available in the [Functional Requirements Document](./05-functional-requirements.md) and [Business Rules and Validation](./07-business-rules-and-validation.md), which expand on each operation and edge-case validation."},{"reason":"To define the only user role (user), describe authentication requirements, and specify permissions and access at the business level for API-authenticated usage.","filename":"04-user-roles-and-authentication.md","documentType":"requirement","outline":["User Role Definition","Role Permissions and Restrictions","Authentication Flow","Session Management and Security"],"audience":"development team, product managers","content":"# User Role and Authentication Requirements for Minimal Todo List Application\n\n## Introduction\nThis document provides a comprehensive specification for user roles, authentication processes, and session management requirements for the minimal Todo List application. The scope is business-oriented, specifying only the minimum set of permissions and flows needed to support authenticated users managing their own Todos via API. All requirements are written to remove ambiguity for backend development and follow EARS (Easy Approach to Requirements Syntax) where possible.\n\n## User Role Definition\nThere is only one user role in this application: the \"user\" role. This role represents a registered individual who can manage their own Todo items and perform essential account operations via API. No administrative or special roles exist in this minimal version.\n\n| Role Name | Description                                                       |\n|-----------|-------------------------------------------------------------------|\n| user      | Registered individual managing their own Todo items via API.       |\n\n### Role Scope\n- \"user\" role is assigned upon successful registration.\n- Users represent real individuals with unique credentials.\n- No guest or anonymous actions are permitted; all business logic assumes an authenticated \"user\".\n\n## Role Permissions and Restrictions\nThe following matrix defines what actions a user can and cannot perform from a business logic perspective.\n\n| Feature                               | user |\n|---------------------------------------|:----:|\n| Register account                      |  ✅  |\n| Authenticate (Login)                  |  ✅  |\n| Logout (terminate session)            |  ✅  |\n| Create Todo items                     |  ✅  |\n| View own Todo items                   |  ✅  |\n| Edit own Todo items                   |  ✅  |\n| Delete own Todo items                 |  ✅  |\n| View, edit, or delete others' Todos   |  ❌  |\n| Access administrative features        |  ❌  |\n| Perform batch operations              |  ❌  |\n| Reset password                        |  ✅  |\n\n- Users can ONLY access and manage their own Todo resources.\n- Access to any resource not created or owned by the authenticated user is strictly forbidden at the business logic level.\n\n## Authentication Flow\nThe authentication process is required for all interactions with Todo resources. The requirements below define registration, login, and session management, consistently using EARS format.\n\n### Registration and Account Creation\n- THE system SHALL allow new users to register using a valid email and password.\n- IF the registration email is already in use, THEN THE system SHALL notify the user of the duplication.\n- IF the password does not meet minimum security criteria (minimum 8 characters), THEN THE system SHALL reject the registration with an appropriate message.\n\n### Login\n- WHEN a user submits valid credentials, THE system SHALL authenticate the user and start a new session.\n- IF the user provides invalid credentials, THEN THE system SHALL deny login and present an error message without revealing whether the email is registered or not.\n- THE system SHALL enforce rate limiting on failed login attempts to prevent brute force attacks.\n\n### Password Management\n- THE system SHALL allow users to reset their password via a secure email-based process.\n- IF the user enters the wrong email for password reset, THEN THE system SHALL not disclose whether the email is registered, but SHALL complete the request with a generic success or failure notice.\n- THE system SHALL require current password confirmation before accepting a password change request from authenticated users.\n\n### Logout\n- WHEN a user requests to logout, THE system SHALL terminate their session and invalidate their authentication token.\n- THE system SHALL allow users to logout from all devices.\n\n## Session Management and Security\n- THE system SHALL use token-based authentication (e.g., JWT) for all API requests after login.\n- THE system SHALL ensure each token is uniquely bound to the user identity and cannot be used to access other users’ data under any circumstance.\n- THE system SHALL set a session (access token) expiration time of no more than 30 minutes after last activity.\n- THE system SHALL provide a secure mechanism for refreshing expired tokens using a refresh token, valid for up to 30 days.\n- IF a session token is expired or invalid, THEN THE system SHALL require the user to login again.\n- WHEN a user logs out, THE system SHALL invalidate all outstanding tokens for that account if requested.\n- THE system SHALL not permit any action on any Todo resource without a valid and active session.\n\n### Security\n- THE system SHALL require HTTPS for all authentication and user-related data transmission.\n- THE system SHALL store user credentials securely using one-way cryptographic hashing.\n- THE system SHALL implement protections against common vulnerabilities (e.g., brute force, session hijacking, token leakage).\n- IF suspicious activity is detected (such as too many failed login attempts), THEN THE system SHALL temporarily lock the account and require further verification.\n- THE system SHALL log all authentication-related events for audit and troubleshooting purposes.\n\n## Flow Diagram: Authentication and Permission Process\n\n```mermaid\ngraph LR\n  A[\"User Registers\"] --> B[\"Account Created\"]\n  B --> C[\"User Logs In\"]\n  C --> D[\"Credentials Valid?\"]\n  D -->|\"Yes\"| E[\"Token Issued\"]\n  D -->|\"No\"| F[\"Show Error Message\"]\n  E --> G[\"User Requests Todo API\"]\n  G --> H[\"Token Valid?\"]\n  H -->|\"Yes\"| I[\"Perform Todo Action (Own Data Only)\"]\n  H -->|\"No\"| J[\"Reject, Require Re-authentication\"]\n  I --> K[\"User Requests Logout\"]\n  K --> L[\"Tokens Invalidated\"]\n```\n\n## Summary\nThis document defines the sole user role, all allowed business-level actions, and all authentication/business security requirements for the minimal Todo List application. There are no additional roles or elevated permissions. All access and actions are restricted to the authenticated user's own data. \n\nBackend implementation is at the discretion of the development team subject to these business requirements. All technical details, including token storage, JWT claim structure, or underlying infrastructure, fall outside the scope of this document.\n"},{"reason":"To document the central functional requirements of the Todo list application, ensuring that only essential features needed for minimal operation are specified in full business language.","filename":"05-functional-requirements.md","documentType":"requirement","outline":["Essential Features","Business Rules","Validation Requirements","Performance Expectations"],"audience":"development team","constraints":["Focus strictly on core functionality only"],"content":"# Functional Requirements for Minimal Todo List Application\n\n## Essential Features\n\n### Minimal Scope & Feature Set\n- THE system SHALL allow authenticated users to create Todo items describing tasks they wish to track.\n- THE system SHALL allow each user to retrieve a list of all their current Todo items.\n- THE system SHALL allow users to mark any Todo item as completed or not completed.\n- THE system SHALL allow users to update the title/description of any of their existing Todo items.\n- THE system SHALL allow users to delete any of their own Todo items.\n- THE system SHALL require user authentication for any access or action with a Todo item.\n\n### Explicit Functional Requirements (EARS)\n1. WHEN a user submits a request to create a Todo, THE system SHALL save the new Todo item, associating it with that user.\n2. WHEN a user requests their Todo list, THE system SHALL return a complete list of the user's active Todo items, in descending order of creation time (newest first).\n3. WHEN a user updates a Todo item, THE system SHALL save only if the Todo belongs to that user and provided data passes validation.\n4. WHEN a user deletes a Todo, THE system SHALL remove that Todo from their list, provided the user is the creator.\n5. WHEN a user toggles the completion status of a Todo, THE system SHALL update the Todo's status accordingly and persist the updated state for that user only.\n6. WHERE a user is not authenticated, THE system SHALL deny all Todo-related operations and report authentication required.\n7. IF a user attempts to access, update, or delete a Todo they do not own, THEN THE system SHALL prevent the action and inform the user that resource does not exist.\n8. THE system SHALL provide accurate counts of total Todos and completed Todos upon request.\n9. WHEN a Todo is created or updated, THE system SHALL timestamp the operation for audit and business record-keeping.\n\n## Business Rules\n\n### Ownership & Access\n- THE system SHALL restrict each user to accessing only Todo items created by that user.\n- WHERE a Todo item does not belong to the requesting user, THE system SHALL treat it as non-existent for all business purposes.\n- THE system SHALL require all operations (create, update, delete, mark complete/incomplete, retrieve) to occur only within the authenticated user session scope.\n\n### Data Lifecycle\n- THE system SHALL retain deleted Todos only long enough to complete the business process (no restore/undo requirements for minimal system).\n- THE system SHALL store a creation timestamp and last modification timestamp for every Todo item.\n- THE system SHALL initialize every new Todo as not completed by default.\n\n### Functional Integrity\n- THE system SHALL not allow batch actions (all operations are single-Todo at a time).\n- THE system SHALL not support subtasks, labels, priorities, deadlines, or attachments.\n- THE system SHALL not allow edit or delete operations on another user's Todo item under any circumstance.\n\n## Validation Requirements\n\n### Input Field Validation\n- WHEN a user creates or updates a Todo, THE system SHALL validate that the title/description is a non-empty UTF-8 string with a length between 1 and 255 characters.\n- IF the title/description is blank, THEN THE system SHALL reject the request with a message explaining the requirement.\n- IF input exceeds maximum length, THEN THE system SHALL reject the request with a message indicating the maximum allowed size.\n- WHERE an input contains only whitespace, THE system SHALL treat it as invalid.\n\n### Identity Validation\n- WHEN performing any action, THE system SHALL confirm the authenticated user identity and only allow operations on their own Todo items.\n\n### State Validation\n- IF a requested Todo to update or delete does not exist under the authenticated user, THEN THE system SHALL return a not-found response (without specifying whether the ID exists globally for security).\n- WHEN a Todo status is toggled to completed or not completed, THE system SHALL accept only boolean state values.\n\n## Performance Expectations\n\n- THE system SHALL respond to all user actions (create, read, update, delete, mark complete/incomplete) within 1 second under normal operating conditions.\n- THE system SHALL process and reflect changes instantly to the user experience (i.e., user observes the updated Todo state upon operation success without delay).\n- THE system SHALL support at least 10 requests per second per authenticated user for Todo CRUD operations, with no noticeable performance degradation.\n- THE system SHALL ensure that user authentication/authorization checks add at most 100ms to any action on their own Todos.\n\n## Core Functional Flow Diagram\n\n```mermaid\ngraph LR\n    subgraph \"Todo List Minimal Feature Workflow\"\n        A[\"User Authenticated?\"] -->|\"No\"| B[\"Reject: Auth Required\"]\n        A -->|\"Yes\"| C[\"Perform Operation Request\"]\n        C --> D{\"Action Type\"}\n        D -->|\"Create\"| E[\"Validate Field\"]\n        E -->|\"Valid\"| F[\"Create Todo, Timestamp, Set Owner\"]\n        E -->|\"Invalid\"| G[\"Reject: Invalid Field\"]\n        D -->|\"Retrieve\"| H[\"List User's Todos (Newest First)\"]\n        D -->|\"Update/Delete\"| I[\"Confirm Ownership & Existence\"]\n        I -->|\"OK\"| J[\"Validate & Apply Change\"]\n        J -->|\"Success\"| K[\"Persist Change\"]\n        J -->|\"Fail\"| L[\"Reject: Not Found/Invalid\"]\n        I -->|\"Not Owner/Not Found\"| L\n        D -->|\"Toggle Complete\"| M[\"Validate Ownership & Boolean\"]\n        M -->|\"Valid\"| N[\"Update State\"]\n        M -->|\"Invalid\"| O[\"Reject: Invalid State\"]\n    end\n```\n\n## Summary Table: Essential Features\n\n| Feature                      | Description                                                      |\n|------------------------------|------------------------------------------------------------------|\n| Create Todo                  | User can create a new Todo item with basic text/description      |\n| List Todos                   | User can view all their Todos (newest first)                     |\n| Mark As Complete/Incomplete  | User can toggle completion status for a Todo                     |\n| Update Todo                  | User can edit text/description of their own Todo                 |\n| Delete Todo                  | User can remove their own Todo item                              |\n\n## Key Business Constraints (for minimal system)\n- Single user type: only registered users manage own Todos via API\n- No sharing, no collaborative features, no labels/priorities/deadlines\n- No admin, no moderation; user can only interact with own data\n- Only core CRUD and toggle complete operations are allowed\n- All error messages must avoid exposing existence of other users’ data or Todo items\n\n## Compliance with Related Documents\nFor broader operational, error-handling, and business process requirements, refer to:\n- [Service Overview](./01-service-overview.md)\n- [User Roles and Authentication](./04-user-roles-and-authentication.md)\n- [Business Rules and Validation](./07-business-rules-and-validation.md)\n- [Exception Handling and Error Scenarios](./08-exception-handling-and-error-scenarios.md)"},{"reason":"To describe the typical user journey and interactions, ensuring developers understand end-to-end flows with the system and user perspective is preserved in every feature.","filename":"06-user-journey.md","documentType":"user-story","outline":["Typical Day-in-the-Life Scenario","Onboarding and First Use","Workflow for Managing Todos","Logout and End Session"],"audience":"development team, product managers","content":"# User Journey for Minimal Todo List Application\n\n## Typical Day-in-the-Life Scenario\nA registered user with active credentials interacts with the Todo list application during a typical day to keep track of essential personal tasks. The user expects to securely log in, manage their list of Todos (including creating, viewing, marking as complete, updating, and deleting), and log out securely at the end of their session. All actions are performed individually and only impact their own data. There are no advanced or collaborative functions.\n\n---\n\n## Onboarding and First Use\n### Registration\nWHEN a new user wishes to use the Todo list, THE system SHALL provide a way to register using a unique identifier (such as email) and password. \nWHEN registration is successful, THE system SHALL create a new user account and allow immediate login.\nIF registration fails (e.g., duplicate email or missing data), THEN THE system SHALL return a clear error message indicating the reason for failure without exposing technical details.\n\n### Login\nWHEN a user attempts to log in with email and password, THE system SHALL authenticate credentials and grant access to the Todo management features if valid.\nIF login credentials are invalid, THEN THE system SHALL return a clear error message and not grant access.\n\n\n---\n\n## Workflow for Managing Todos\n\n### View Todos\nWHEN a user logs in, THE system SHALL display the user’s current list of Todos (if any exist) in a consistent order (most recent first).\nIF no Todos exist, THEN THE system SHALL display an empty state indicating that no Todos have been created.\n\n### Add Todo\nWHEN a user submits a new Todo entry (containing, at minimum, a text description), THE system SHALL add it to the user’s list and make it immediately visible upon success.\nIF the Todo entry is invalid (e.g., missing text), THEN THE system SHALL return an error and not create the Todo.\n\n### Edit Todo\nWHEN a user edits an existing Todo, THE system SHALL validate the changes and update the Todo only if the user is the creator and the data meets all requirements.\nIF the updated data is invalid, THEN THE system SHALL return an appropriate error message.\n\n### Mark Todo as Complete\nWHEN a user marks a Todo as complete, THE system SHALL update the completion status so it is visually and logically distinct from incomplete Todos.\n\n### Delete Todo\nWHEN a user initiates deletion of a Todo, THE system SHALL remove the Todo from the list only if it belongs to the user. THE system SHALL confirm deletion or return an error if action is invalid (e.g., Todo does not exist or does not belong to user).\n\n### Safety and Ownership\nTHE system SHALL ensure that users can view, modify, mark complete, and delete ONLY their own Todos.\n\n---\n\n## Logout and End Session\nWHEN a user initiates logout, THE system SHALL immediately terminate the session and prevent further access to Todo management features until login occurs again.\n\n---\n\n## User Journey Workflow Diagram\n\n```mermaid\ngraph LR\n    subgraph \"User Authentication\"\n        A[\"Registration\"] --> B[\"Login\"]\n        B --> C[\"Access Todo List\"]\n    end\n\n    subgraph \"Todo Management\"\n        C --> D[\"View Todos\"]\n        D --> E[\"Add Todo\"]\n        D --> F[\"Edit Todo\"]\n        D --> G[\"Mark Todo Complete\"]\n        D --> H[\"Delete Todo\"]\n    end\n\n    subgraph \"Session Management\"\n        H --> I[\"Logout\"]\n        G --> I\n        F --> I\n        E --> I\n        D --> I\n    end\n```\n\n---\n\n## Additional Notes\n- This user journey describes the absolute minimum steps required for a functional Todo list application.\n- Sessions must be handled securely; all operations are scoped to individual users.\n- There are no advanced features such as sharing, tagging, due dates, notifications, or subtasks in this workflow.\n\nFor a detailed breakdown of feature-by-feature requirements, refer to the [Functional Requirements Document](./05-functional-requirements.md)."},{"reason":"To document detailed business rules and process validation logic, so that developers implement correct behavior in every user interaction without ambiguity.","filename":"07-business-rules-and-validation.md","documentType":"requirement","outline":["Todo Creation Rules","Editing and Deletion Rules","Completion and Filtering Rules","Error States and Recovery"],"audience":"development team","constraints":["No implementation or technical details"],"content":"# Business Rules and Validation for Minimal Todo List Application\n\n## Todo Creation Rules\n\n### Data Content and Structure\n- THE minimal Todo item SHALL consist of:\n  - A required \"title\" as a concise summary of the task\n  - An optional \"description\" field for further details\n  - A completion status (boolean, defaulting to false when created)\n\n- THE \"title\" field SHALL require non-empty text, and SHALL be limited to a maximum of 100 characters.\n- THE \"description\" field, if provided, SHALL be limited to a maximum of 500 characters.\n- THE completion status SHALL always be a boolean (true/false).\n- WHEN a user submits a request to create a Todo, THE system SHALL associate the Todo only with that user's identity.\n\n### EARS Format: Creation\n- WHEN a user attempts to create a Todo, THE system SHALL reject creation IF the \"title\" field is empty or exceeds maximum length.\n- WHEN a user attempts to create a Todo, THE system SHALL reject creation IF the \"description\" field, if provided, exceeds maximum length.\n- WHEN a user creates a Todo, THE system SHALL initialize the completion status to false by default.\n- WHEN a user creates a Todo, THE system SHALL record the creation timestamp for auditing purposes.\n- WHEN a user creates a Todo, THE system SHALL store only the user's identity, title, optional description, completion status, and timestamps (created, updated, completed if applicable).\n\n## Editing and Deletion Rules\n\n### Editing Rules\n- WHEN a user attempts to edit a Todo, THE system SHALL permit modifications only if the Todo belongs to the authenticated user.\n- WHEN editing a Todo, THE system SHALL apply all validation rules from the creation logic (title and description).\n- WHEN a user modifies a Todo, THE system SHALL update the 'last updated' timestamp.\n- WHEN a user attempts to edit a non-existent or unauthorized Todo, THEN THE system SHALL deny the operation and return an appropriate error.\n\n### Deletion Rules\n- WHEN a user requests deletion of a Todo, THE system SHALL allow deletion only if the Todo belongs to the requesting user.\n- WHEN a Todo is deleted, THE system SHALL permanently remove the item and all related data from that user's list.\n- WHEN a user attempts to delete a non-existent or unauthorized Todo, THEN THE system SHALL deny the operation and return an appropriate error.\n\n## Completion and Filtering Rules\n\n### Marking as Complete/Incomplete\n- WHEN a user toggles the completion status of a Todo, THE system SHALL allow this action only if the Todo belongs to the authenticated user.\n- WHEN the completion status is changed, THE system SHALL update the 'completed at' timestamp (only if status is set to complete; null or removed if incomplete).\n- THE system SHALL maintain the most recent state for each Todo.\n\n### Filtering and Listing\n- WHEN listing Todos, THE system SHALL return only Todos belonging to the requesting user.\n- THE system SHALL support filtering by completion status:\n  - WHERE a user requests to view only completed tasks, THE system SHALL return all Todos with completion status true.\n  - WHERE a user requests to view only incomplete tasks, THE system SHALL return all Todos with completion status false.\n  - WHERE no filter is applied, THE system SHALL return all Todos for that user regardless of completion status.\n\n## Error States and Recovery\n\n### Unwanted Behavior (EARS Format)\n- IF a user attempts any action (view, edit, delete, toggle completion) on a Todo that does not exist or does not belong to them, THEN THE system SHALL reject the request and return a clear error indicating lack of permission or resource not found.\n- IF a user submits invalid data (empty or too-long title/description), THEN THE system SHALL return a validation error with a descriptive message specifying the problematic field.\n- IF a request is malformed or required parameters are missing, THEN THE system SHALL return an error indicating the missing or incorrect field.\n\n### Recovery\n- WHEN a user receives an error due to invalid input, THE system SHALL provide guidance in the error message to help the user correct it.\n- WHEN an action is rejected for lack of permissions or non-ownership, THE system SHALL return an error message indicating either resource not found or access denied (to avoid information disclosure about existence of other users' data).\n- WHEN a deletion or edit operation is successful, THE system SHALL return the updated list of Todos (or confirmation of deletion) to the user.\n\n## Business Rule Summary Table\n\n| Operation                | Rule Description                                                                                                                                   |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| Create Todo              | Title required, max 100 chars; optional description max 500 chars; default status = false; link only to creator                                      |\n| Edit Todo                | Only owner may edit; all fields re-validated; updates timestamp                                                                                     |\n| Delete Todo              | Only owner may delete; permanent removal; error if not found/not owned                                                                              |\n| Toggle Completion        | Only owner may change; updates 'completed at' (if status true)                                                                                      |\n| List Todos               | Only user’s own Todos visible; supports filter by completed/incomplete/all                                                                          |\n| Invalid Input            | Error with field-specific message; clarifies what must be corrected                                                                                |\n| Unauthorized/Not Found   | Error indicating access denied or not found, never leaks other users' information                                                                   |\n\n## Example Business Rule Flow Chart\n\n```mermaid\ngraph LR\n  subgraph \"User Action Flow\"\n    A[\"User requests action on Todo\"] --> B{\"Does Todo exist?\"}\n    B -->|\"No\"| H[\"Reject: not found\"]\n    B -->|\"Yes\"| C{\"Is Todo owned by user?\"}\n    C -->|\"No\"| I[\"Reject: forbidden\"]\n    C -->|\"Yes\"| D{\"Is action creation or edit?\"}\n    D -->|\"Yes\"| F[\"Validate title/description\"]\n    F --> J{\"Input valid?\"}\n    J -->|\"No\"| K[\"Reject: validation error\"]\n    J -->|\"Yes\"| G[\"Apply action, update timestamps\"]\n    D -->|\"No\"| G[\"Apply action, update timestamps\"]\n    G --> L[\"Return success response\"]\n  end\n```\n\n## Constraints and Implementation Notes\n- No Todo can ever be accessed, edited, or deleted by a user other than its creator\n- All state-changing actions (edit, deletion, completion) require strict owner validation\n- All logic covers only essential Todo management functionality (no advanced features, no additional fields or labels, no sharing, no prioritization)\n- No technical details, APIs, or data model descriptions are included — business logic only\n- For further technical guidance, developers should reference the [Functional Requirements Document](./05-functional-requirements.md) and [Exception and Error Handling Scenarios](./08-exception-handling-and-error-scenarios.md)\n"},{"reason":"To cover error handling, how undesired scenarios are managed from a user and business perspective, and recovery processes needed for reliable user experience.","filename":"08-exception-handling-and-error-scenarios.md","documentType":"requirement","outline":["Error Categories","User-Facing Error Messages","Business-Level Recovery Paths"],"audience":"development team","content":"# Exception Handling and Error Scenarios\n\n## Introduction\nThis document defines the comprehensive requirements for managing exceptions and error scenarios in the minimal Todo list application. The focus is on ensuring clarity, reliability, and a seamless user experience when errors occur. All requirements use EARS format where appropriate, in professional English, to remove ambiguity and ensure backend implementation meets business expectations.\n\n## Error Categories\n### 1. Validation Errors\n- WHEN a user submits incomplete or invalid Todo data (e.g., missing title), THE system SHALL reject the request and return a descriptive error message.\n- WHEN a request payload contains invalid data types or exceeds allowed field lengths, THE system SHALL return an error specifying the exact field and violation.\n\n### 2. Authentication and Access Errors\n- WHEN a user attempts an operation without valid authentication, THE system SHALL reject the action and provide a clear message that login is required.\n- WHEN a user tries to access or manipulate a Todo item that does not belong to them, THE system SHALL deny access and return a message indicating insufficient permissions.\n\n### 3. Resource Existence Errors\n- WHEN a user requests a Todo item by an id not present in the system, THE system SHALL return a not-found error informing the user the item does not exist or was already deleted.\n\n### 4. System-Level Errors\n- IF an unexpected server error occurs, THEN THE system SHALL return a generic message apologizing for the temporary problem and instructing the user to retry later.\n\n### 5. Business Logic Errors\n- WHEN a user attempts to complete, update, or delete a Todo that is already in the desired state (e.g., marking an already-completed Todo as complete), THE system SHALL prevent redundant action and inform the user.\n\n## User-Facing Error Messages\nAll error messages must be clear, actionable, and avoid technical jargon, reflecting the actual business problem encountered. For each error category:\n\n| Error Category             | Example User Message                                     |\n|---------------------------|---------------------------------------------------------|\n| Validation                | \"Title cannot be empty.\"                                |\n| Authentication            | \"Please log in to continue.\"                            |\n| Permission                | \"You do not have permission to modify this Todo.\"       |\n| Not Found                 | \"The requested Todo does not exist or was already deleted.\" |\n| System                    | \"An unexpected error occurred. Please try again later.\"   |\n| Redundant Action          | \"This Todo is already marked as completed.\"             |\n\n- THE system SHALL always return user-friendly error messages in response payloads, matching the context and root cause.\n\n## Business-Level Recovery Paths\n### Validation Errors\n- WHEN a validation error occurs, THE system SHALL return explicit details about the violation, enabling users to correct and resubmit.\n- THE system SHALL NOT process or store invalid data under any circumstance.\n\n### Authentication and Access Errors\n- WHEN authentication fails, THE system SHALL not provide access to personal data and SHALL prompt for (re-)login.\n- WHERE permission is lacking, THE system SHALL not disclose any information about restricted items, only indicate lack of access.\n\n### Not Found Handling\n- WHEN a resource is not found, THE system SHALL plainly state the missing resource nature and suggest a valid navigation step (e.g., \"Return to your Todo list.\").\n\n### System-Level Recovery\n- WHEN system-level errors occur, THE system SHALL log the incident for maintenance purposes and instruct the user to retry at a later time.\n- THE system SHALL NOT disclose internal error details or stack traces to the user.\n\n### Redundant or Invalid State Changes\n- WHEN redundant operations are attempted, THE system SHALL simply reassure the user of the current state and prevent double-modification.\n\n## Visual Error and Recovery Workflow\n```mermaid\ngraph LR\n  subgraph \"User Request Error Flow\"\n    A[\"User Action (e.g. create/update/delete)\"] --> B{\"Error Detected?\"}\n    B -->|\"Validation Error\"| C[\"Return Validation Error Message\"]\n    B -->|\"Authentication Error\"| D[\"Request Login/Return Auth Error\"]\n    B -->|\"Permission Error\"| E[\"Deny Access and Return Message\"]\n    B -->|\"Not Found\"| F[\"Resource Not Found Message\"]\n    B -->|\"Redundant Action\"| G[\"Inform Already in Desired State\"]\n    B -->|\"System Error\"| H[\"Show Generic System Error\"]\n    B -->|\"No Error\"| I[\"Proceed With Request\"]\n  end\n  C --> J[\"User Corrects Input and Retries\"]\n  D --> K[\"User Logs In and Retries\"]\n  E --> L[\"User Returns to Todo List\"]\n  F --> L\n  G --> L\n  H --> M[\"User Retries Later\"]\n  I --> N[\"Operation Successful\"]\n```\n\n## Summary\nThis document specifies error categories, user-facing messages, and required recovery paths for the minimal Todo list application. Adherence to these rules ensures that all error conditions are predictable, actionable, and maintain business logic integrity. All requirements are formalized using EARS syntax and provide explicit expectations for backend responses in every error scenario."},{"reason":"To specify performance, security, and privacy requirements so that developers achieve acceptable standards for user experience, data protection, and compliance.","filename":"09-non-functional-requirements.md","documentType":"requirement","outline":["Performance Standards","Data Security and Privacy","Business Constraints"],"audience":"development team","content":"# Non-Functional Requirements for Minimal Todo List Application\n\n## Performance Standards\n\n- THE system SHALL respond to any user request (including viewing, adding, editing, or deleting a Todo item) within 1 second during normal usage conditions.\n- THE system SHALL support at least 100 concurrent user sessions without degradation of response time beyond 1 second per action.\n- WHEN peak load occurs (e.g., brief spikes in usage), THE system SHALL maintain response times under 3 seconds for all core operations.\n- THE system SHALL provide a minimum uptime of 99.5% (excluding scheduled maintenance), ensuring availability for users at all times.\n- THE system SHALL process all successful Todo create, update, and delete requests reliably, ensuring data consistency without loss or duplication.\n\n## Data Security and Privacy\n\n- THE system SHALL use HTTPS/TLS encryption for all API communication between clients and the backend to protect data in transit.\n- THE system SHALL use token-based authentication, implementing short-lived JWT access tokens (expiring within 30 minutes) and longer-lived refresh tokens as defined in the [User Roles and Authentication Guide](./04-user-roles-and-authentication.md).\n- THE system SHALL restrict data access so that authenticated users can only access their own Todo items. IF a user attempts to access another user's data, THEN THE system SHALL deny access and return an appropriate error.\n- ALL user credentials (such as passwords) SHALL be stored as salted, one-way hashes—never in plaintext—following current security best practices.\n- THE system SHALL not log sensitive data (such as raw passwords, access tokens, or personally identifiable information) in system logs. Only aggregate, non-personal usage metrics and error traces may be stored.\n- IF a session token is stolen, THEN THE system SHALL provide a mechanism for immediate revocation through the account security endpoint.\n- THE system SHALL comply with applicable privacy laws regarding minimal data collection (only username/email and password), and SHALL provide mechanisms for user-initiated account deletion with all associated Todos.\n- WHEN user-initiated account deletion occurs, THE system SHALL permanently erase the user’s data within 24 hours.\n\n## Business Constraints\n\n- THE application SHALL operate with a single user role (“user”), solely for managing personal Todo items via API authentication.\n- THE system SHALL not expose any administrative or multi-user features.\n- THE application SHALL be designed for minimal, essential Todo list functionality only; new features outside the core must not be implemented without explicit approval and documented requirements.\n- THE application SHALL be platform-agnostic, supporting secure and efficient operation when accessed by standard browsers or API clients.\n- THE system SHALL provide API-level audit logging for destructive actions (delete/clear all) for troubleshooting and accountability, without exposing personal data.\n- THE application SHALL NOT retain any user data for longer than necessary for operational purposes—data retention policy aligns with privacy principles of user control and data minimization.\n\n[Functional Requirements Document](./05-functional-requirements.md) and [User Roles and Authentication Guide](./04-user-roles-and-authentication.md) contain further supporting context."},{"reason":"To provide space for additional guidance regarding business assumptions, constraints, or clarifications that may arise, and to future-proof documentation for minimal extensions or compliance needs.","filename":"10-additional-business-constraints.md","documentType":"requirement","outline":["Assumptions","Compliance Requirements","Potential Extensions (Minimal)"],"audience":"development team, product managers","content":"# Additional Business Constraints and Assumptions for Minimal Todo List Application\n\n## Assumptions\n- THE application SHALL operate exclusively with a single authenticated user role (\"user\"), who is limited to managing only their own Todos, reflecting a personal-use scenario.\n- THE application SHALL provide only the essential features necessary for managing a Todo list: create, read, update, and delete (CRUD) Todo items for the authenticated user. No extra functionalities or options are included by default.\n- THE system ASSUMES all users are individuals; shared Todos, group functions, or any team/collaborative features are explicitly out of scope.\n- THE backend SHALL serve solely as a minimal API persistence layer. No frontend, notification systems, or advanced automation logic are assumed or implied by the business requirements.\n- THE environment presupposes a modern, publicly accessible RESTful API over HTTPS, but there is no commitment to mobile, offline-first, or desktop-specific functionality.\n\n## Compliance Requirements\n- WHERE user data is stored, THE system SHALL limit all personal data collection to what is strictly necessary for account authentication and Todo management (typically: username, email, password hash). No additional PII SHALL be collected without explicit future business justification.\n- IF privacy laws such as GDPR or local regulations apply, THEN THE system SHALL enable each user to permanently delete their account as well as all related Todo data, upon authenticated request, with no retention of deleted content.\n- THE system SHALL support basic export of a user's Todo items as plain text or CSV, to the extent necessary to comply with minimal data portability obligations or reasonable user demand.\n- THE application SHALL avoid tracking, logging, or storing of any non-essential metadata related to user actions, Todo item locations, or device information.\n- WHERE heightened compliance requirements arise, THE development team SHALL treat this section as the primary location to document any new business-driven mandates regarding data retention, data subject rights, or audit operations.\n\n## Potential Extensions (Minimal)\n- THE business MAY someday support marking multiple Todos as complete in a single operation, provided this does not violate the \"minimal\" scope principle.\n- WHERE justified by clear user feedback or business need, THE system MAY permit basic sorting or filtering (e.g., by completion status), but only if it remains within the boundaries of minimal functionality.\n- WHERE limited user personalization (e.g., dark/light mode preference) is justified, THE system SHALL store only the absolute minimal data needed to deliver the feature.\n- WHERE integration with third-party tools or calendar systems is ever proposed, THE business SHALL require proper documented rationale and limit any such feature to exporting a user's Todos in a standard format (plain text or CSV).\n- CHANGES to requirements in this section SHALL require explicit business case documentation in order to preserve the minimal, reliable scope of the Todo application.\n"}],"created_at":"2025-10-07T15:30:02.814Z","completed_at":"2025-10-07T15:36:21.507Z","step":0},{"id":"0199bf51-0356-73be-a840-17c1cf33bd63","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-10-07T15:36:21.590Z"},{"type":"prisma","id":"0199bf55-faa6-71ae-a806-72205c32b381","instruction":"Design a minimal database schema for a Todo list application. Only include the essential entities and attributes necessary for users to create, view, update, and delete Todo items. Focus on simplicity—each Todo should have a title, an optional description, completion status, and a creation date. No additional features or advanced structures are needed.","schemas":{"schema-01-actors.prisma":"/// Authentication and identity table for all application users. Holds\n/// essential user credentials, identification, and minimal auditing\n/// information. Used for user registration, login, and ownership association\n/// with {@link todo_list_todos} (in other component). Each user record is\n/// uniquely identified by email and manages its own password. Deletion or\n/// modification of user accounts is audited via timestamps. Email uniqueness\n/// enforces single identity. No advanced roles exist; this is the only actor\n/// type in the system. No PII beyond minimal required for authentication is\n/// stored. This table does not directly reference any business data tables,\n/// but is referenced by them for ownership.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Unique user email address for identification and login. Must be unique;\n  /// serves as user identity within the service.\n  email String\n  \n  /// Secure hash of the user password (never stores plaintext password). Used\n  /// for login verification only. Application must enforce proper hashing\n  /// algorithms.\n  password_hash String\n  \n  /// Timestamp when the user account was created (registration time). Used for\n  /// auditing and account lifecycle tracking.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of most recent profile or credential update for auditing and\n  /// compliance.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp of the user's most recent successful login. Used for security,\n  /// analytics, and notification of suspicious activity.\n  last_login DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_list_todos todo_list_todos[]\n  \n  @@unique([email])\n  @@index([created_at])\n}","schema-02-todos.prisma":"/// Represents a single task in the user's todo list. Each todo item belongs\n/// to exactly one user, and all CRUD operations are scoped to the owner.\n/// Fields include required title (100 char max), optional description (500\n/// char max), completed status, timestamps for creation, last update, and\n/// completion. Enforces strict user ownership via foreign key to {@link\n/// todo_list_users.id}. Supports efficient retrieval by user and order of\n/// creation.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Belonged user's {@link todo_list_users.id}. Enforces per-user ownership\n  /// of each todo.\n  todo_list_user_id String @db.Uuid\n  \n  /// Concise summary of the task. Required. 1-100 characters; validated by\n  /// application upon CRUD operations.\n  title String\n  \n  /// Optional detailed description of the task. Maximum 500 characters; may be\n  /// null if not provided.\n  description String?\n  \n  /// Whether the todo is currently marked as complete or not. Default is false\n  /// upon creation.\n  completed Boolean\n  \n  /// Timestamp of when the todo was created. Used for audit and list ordering.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of the last update to the todo (including completion\n  /// toggle/edit).\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the todo was marked completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n  \n  @@index([todo_list_user_id, created_at])\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-actors.prisma","namespace":"Actors","models":[{"name":"todo_list_users","description":"Authentication and identity table for all application users. Holds essential user credentials, identification, and minimal auditing information. Used for user registration, login, and ownership association with {@link todo_list_todos} (in other component). Each user record is uniquely identified by email and manages its own password. Deletion or modification of user accounts is audited via timestamps. Email uniqueness enforces single identity. No advanced roles exist; this is the only actor type in the system. No PII beyond minimal required for authentication is stored. This table does not directly reference any business data tables, but is referenced by them for ownership.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","description":"Unique user email address for identification and login. Must be unique; serves as user identity within the service.","nullable":false},{"name":"password_hash","type":"string","description":"Secure hash of the user password (never stores plaintext password). Used for login verification only. Application must enforce proper hashing algorithms.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp when the user account was created (registration time). Used for auditing and account lifecycle tracking.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp of most recent profile or credential update for auditing and compliance.","nullable":false},{"name":"last_login","type":"datetime","description":"Timestamp of the user's most recent successful login. Used for security, analytics, and notification of suspicious activity.","nullable":true}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-02-todos.prisma","namespace":"Todos","models":[{"name":"todo_list_todos","description":"Represents a single task in the user's todo list. Each todo item belongs to exactly one user, and all CRUD operations are scoped to the owner. Fields include required title (100 char max), optional description (500 char max), completed status, timestamps for creation, last update, and completion. Enforces strict user ownership via foreign key to {@link todo_list_users.id}. Supports efficient retrieval by user and order of creation.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_list_user_id","type":"uuid","description":"Belonged user's {@link todo_list_users.id}. Enforces per-user ownership of each todo.","relation":{"name":"user","targetModel":"todo_list_users"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","description":"Concise summary of the task. Required. 1-100 characters; validated by application upon CRUD operations.","nullable":false},{"name":"description","type":"string","description":"Optional detailed description of the task. Maximum 500 characters; may be null if not provided.","nullable":true},{"name":"completed","type":"boolean","description":"Whether the todo is currently marked as complete or not. Default is false upon creation.","nullable":false},{"name":"created_at","type":"datetime","description":"Timestamp of when the todo was created. Used for audit and list ordering.","nullable":false},{"name":"updated_at","type":"datetime","description":"Timestamp of the last update to the todo (including completion toggle/edit).","nullable":false},{"name":"completed_at","type":"datetime","description":"Timestamp when the todo was marked completed. Null if not completed.","nullable":true}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["todo_list_user_id","created_at"]}],"ginIndexes":[]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-actors.prisma":"/// Authentication and identity table for all application users. Holds\n/// essential user credentials, identification, and minimal auditing\n/// information. Used for user registration, login, and ownership association\n/// with {@link todo_list_todos} (in other component). Each user record is\n/// uniquely identified by email and manages its own password. Deletion or\n/// modification of user accounts is audited via timestamps. Email uniqueness\n/// enforces single identity. No advanced roles exist; this is the only actor\n/// type in the system. No PII beyond minimal required for authentication is\n/// stored. This table does not directly reference any business data tables,\n/// but is referenced by them for ownership.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Unique user email address for identification and login. Must be unique;\n  /// serves as user identity within the service.\n  email String\n\n  /// Secure hash of the user password (never stores plaintext password). Used\n  /// for login verification only. Application must enforce proper hashing\n  /// algorithms.\n  password_hash String\n\n  /// Timestamp when the user account was created (registration time). Used for\n  /// auditing and account lifecycle tracking.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of most recent profile or credential update for auditing and\n  /// compliance.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp of the user's most recent successful login. Used for security,\n  /// analytics, and notification of suspicious activity.\n  last_login DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_list_todos todo_list_todos[]\n\n  @@unique([email])\n  @@index([created_at])\n}\n","schema-02-todos.prisma":"/// Represents a single task in the user's todo list. Each todo item belongs\n/// to exactly one user, and all CRUD operations are scoped to the owner.\n/// Fields include required title (100 char max), optional description (500\n/// char max), completed status, timestamps for creation, last update, and\n/// completion. Enforces strict user ownership via foreign key to {@link\n/// todo_list_users.id}. Supports efficient retrieval by user and order of\n/// creation.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged user's {@link todo_list_users.id}. Enforces per-user ownership\n  /// of each todo.\n  todo_list_user_id String @db.Uuid\n\n  /// Concise summary of the task. Required. 1-100 characters; validated by\n  /// application upon CRUD operations.\n  title String\n\n  /// Optional detailed description of the task. Maximum 500 characters; may be\n  /// null if not provided.\n  description String?\n\n  /// Whether the todo is currently marked as complete or not. Default is false\n  /// upon creation.\n  completed Boolean\n\n  /// Timestamp of when the todo was created. Used for audit and list ordering.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of the last update to the todo (including completion\n  /// toggle/edit).\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp when the todo was marked completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user todo_list_users @relation(fields: [todo_list_user_id], references: [id], onDelete: Cascade)\n\n  @@index([todo_list_user_id, created_at])\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model todo_list_users\n * Authentication and identity table for all application users. Holds\n * essential user credentials, identification, and minimal auditing\n * information. Used for user registration, login, and ownership association\n * with {@link todo_list_todos} (in other component). Each user record is\n * uniquely identified by email and manages its own password. Deletion or\n * modification of user accounts is audited via timestamps. Email uniqueness\n * enforces single identity. No advanced roles exist; this is the only actor\n * type in the system. No PII beyond minimal required for authentication is\n * stored. This table does not directly reference any business data tables,\n * but is referenced by them for ownership.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_users = $Result.DefaultSelection<Prisma.$todo_list_usersPayload>\n/**\n * Model todo_list_todos\n * Represents a single task in the user's todo list. Each todo item belongs\n * to exactly one user, and all CRUD operations are scoped to the owner.\n * Fields include required title (100 char max), optional description (500\n * char max), completed status, timestamps for creation, last update, and\n * completion. Enforces strict user ownership via foreign key to {@link\n * todo_list_users.id}. Supports efficient retrieval by user and order of\n * creation.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_todos = $Result.DefaultSelection<Prisma.$todo_list_todosPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Todo_list_users\n * const todo_list_users = await prisma.todo_list_users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Todo_list_users\n   * const todo_list_users = await prisma.todo_list_users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.todo_list_users`: Exposes CRUD operations for the **todo_list_users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_users\n    * const todo_list_users = await prisma.todo_list_users.findMany()\n    * ```\n    */\n  get todo_list_users(): Prisma.todo_list_usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_todos`: Exposes CRUD operations for the **todo_list_todos** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_todos\n    * const todo_list_todos = await prisma.todo_list_todos.findMany()\n    * ```\n    */\n  get todo_list_todos(): Prisma.todo_list_todosDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    todo_list_users: 'todo_list_users',\n    todo_list_todos: 'todo_list_todos'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"todo_list_users\" | \"todo_list_todos\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      todo_list_users: {\n        payload: Prisma.$todo_list_usersPayload<ExtArgs>\n        fields: Prisma.todo_list_usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          update: {\n            args: Prisma.todo_list_usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_usersPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_usersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_users>\n          }\n          groupBy: {\n            args: Prisma.todo_list_usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_usersCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_usersCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_todos: {\n        payload: Prisma.$todo_list_todosPayload<ExtArgs>\n        fields: Prisma.todo_list_todosFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_todosFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_todosFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_todosFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_todosFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_todosFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_todosCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_todosCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_todosCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_todosDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          update: {\n            args: Prisma.todo_list_todosUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_todosDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_todosUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_todosUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_todosUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_todosPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_todosAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_todos>\n          }\n          groupBy: {\n            args: Prisma.todo_list_todosGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_todosCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_todosCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    todo_list_users?: todo_list_usersOmit\n    todo_list_todos?: todo_list_todosOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Todo_list_usersCountOutputType\n   */\n\n  export type Todo_list_usersCountOutputType = {\n    todo_list_todos: number\n  }\n\n  export type Todo_list_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | Todo_list_usersCountOutputTypeCountTodo_list_todosArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_usersCountOutputType\n     */\n    select?: Todo_list_usersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_usersCountOutputType without action\n   */\n  export type Todo_list_usersCountOutputTypeCountTodo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model todo_list_users\n   */\n\n  export type AggregateTodo_list_users = {\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_usersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    last_login: Date | null\n  }\n\n  export type Todo_list_usersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    last_login: Date | null\n  }\n\n  export type Todo_list_usersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    last_login: number\n    _all: number\n  }\n\n\n  export type Todo_list_usersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    last_login?: true\n  }\n\n  export type Todo_list_usersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    last_login?: true\n  }\n\n  export type Todo_list_usersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    last_login?: true\n    _all?: true\n  }\n\n  export type Todo_list_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to aggregate.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_users\n    **/\n    _count?: true | Todo_list_usersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_usersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type GetTodo_list_usersAggregateType<T extends Todo_list_usersAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_users]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_users[P]>\n      : GetScalarType<T[P], AggregateTodo_list_users[P]>\n  }\n\n\n\n\n  export type todo_list_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_usersWhereInput\n    orderBy?: todo_list_usersOrderByWithAggregationInput | todo_list_usersOrderByWithAggregationInput[]\n    by: Todo_list_usersScalarFieldEnum[] | Todo_list_usersScalarFieldEnum\n    having?: todo_list_usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_usersCountAggregateInputType | true\n    _min?: Todo_list_usersMinAggregateInputType\n    _max?: Todo_list_usersMaxAggregateInputType\n  }\n\n  export type Todo_list_usersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date\n    updated_at: Date\n    last_login: Date | null\n    _count: Todo_list_usersCountAggregateOutputType | null\n    _min: Todo_list_usersMinAggregateOutputType | null\n    _max: Todo_list_usersMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_usersGroupByPayload<T extends todo_list_usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_usersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_usersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_usersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_login?: boolean\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_login?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_login?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_users\"]>\n\n  export type todo_list_usersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_login?: boolean\n  }\n\n  export type todo_list_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"created_at\" | \"updated_at\" | \"last_login\", ExtArgs[\"result\"][\"todo_list_users\"]>\n  export type todo_list_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_todos?: boolean | todo_list_users$todo_list_todosArgs<ExtArgs>\n    _count?: boolean | Todo_list_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_list_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_list_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_users\"\n    objects: {\n      todo_list_todos: Prisma.$todo_list_todosPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Unique user email address for identification and login. Must be unique;\n       * serves as user identity within the service.\n       */\n      email: string\n      /**\n       * Secure hash of the user password (never stores plaintext password). Used\n       * for login verification only. Application must enforce proper hashing\n       * algorithms.\n       */\n      password_hash: string\n      /**\n       * Timestamp when the user account was created (registration time). Used for\n       * auditing and account lifecycle tracking.\n       */\n      created_at: Date\n      /**\n       * Timestamp of most recent profile or credential update for auditing and\n       * compliance.\n       */\n      updated_at: Date\n      /**\n       * Timestamp of the user's most recent successful login. Used for security,\n       * analytics, and notification of suspicious activity.\n       */\n      last_login: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_users\"]>\n    composites: {}\n  }\n\n  type todo_list_usersGetPayload<S extends boolean | null | undefined | todo_list_usersDefaultArgs> = $Result.GetResult<Prisma.$todo_list_usersPayload, S>\n\n  type todo_list_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_usersCountAggregateInputType | true\n    }\n\n  export interface todo_list_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_users'], meta: { name: 'todo_list_users' } }\n    /**\n     * Find zero or one Todo_list_users that matches the filter.\n     * @param {todo_list_usersFindUniqueArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_usersFindUniqueArgs>(args: SelectSubset<T, todo_list_usersFindUniqueArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_usersFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_usersFindFirstArgs>(args?: SelectSubset<T, todo_list_usersFindFirstArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindFirstOrThrowArgs} args - Arguments to find a Todo_list_users\n     * @example\n     * // Get one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany()\n     * \n     * // Get first 10 Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_usersFindManyArgs>(args?: SelectSubset<T, todo_list_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_users.\n     * @param {todo_list_usersCreateArgs} args - Arguments to create a Todo_list_users.\n     * @example\n     * // Create one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.create({\n     *   data: {\n     *     // ... data to create a Todo_list_users\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_usersCreateArgs>(args: SelectSubset<T, todo_list_usersCreateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_users.\n     * @param {todo_list_usersCreateManyArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_usersCreateManyArgs>(args?: SelectSubset<T, todo_list_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_users and returns the data saved in the database.\n     * @param {todo_list_usersCreateManyAndReturnArgs} args - Arguments to create many Todo_list_users.\n     * @example\n     * // Create many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_users.\n     * @param {todo_list_usersDeleteArgs} args - Arguments to delete one Todo_list_users.\n     * @example\n     * // Delete one Todo_list_users\n     * const Todo_list_users = await prisma.todo_list_users.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_users\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_usersDeleteArgs>(args: SelectSubset<T, todo_list_usersDeleteArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_users.\n     * @param {todo_list_usersUpdateArgs} args - Arguments to update one Todo_list_users.\n     * @example\n     * // Update one Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_usersUpdateArgs>(args: SelectSubset<T, todo_list_usersUpdateArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_users.\n     * @param {todo_list_usersDeleteManyArgs} args - Arguments to filter Todo_list_users to delete.\n     * @example\n     * // Delete a few Todo_list_users\n     * const { count } = await prisma.todo_list_users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_usersDeleteManyArgs>(args?: SelectSubset<T, todo_list_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_usersUpdateManyArgs>(args: SelectSubset<T, todo_list_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_users and returns the data updated in the database.\n     * @param {todo_list_usersUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_users.\n     * @example\n     * // Update many Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_users and only return the `id`\n     * const todo_list_usersWithIdOnly = await prisma.todo_list_users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_users.\n     * @param {todo_list_usersUpsertArgs} args - Arguments to update or create a Todo_list_users.\n     * @example\n     * // Update or create a Todo_list_users\n     * const todo_list_users = await prisma.todo_list_users.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_usersUpsertArgs>(args: SelectSubset<T, todo_list_usersUpsertArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersCountArgs} args - Arguments to filter Todo_list_users to count.\n     * @example\n     * // Count the number of Todo_list_users\n     * const count = await prisma.todo_list_users.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_users we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_usersCountArgs>(\n      args?: Subset<T, todo_list_usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_usersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_usersAggregateArgs>(args: Subset<T, Todo_list_usersAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_usersAggregateType<T>>\n\n    /**\n     * Group by Todo_list_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_usersGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_users model\n   */\n  readonly fields: todo_list_usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_list_todos<T extends todo_list_users$todo_list_todosArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_users$todo_list_todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_users model\n   */\n  interface todo_list_usersFieldRefs {\n    readonly id: FieldRef<\"todo_list_users\", 'String'>\n    readonly email: FieldRef<\"todo_list_users\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_users\", 'String'>\n    readonly created_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_users\", 'DateTime'>\n    readonly last_login: FieldRef<\"todo_list_users\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_users findUnique\n   */\n  export type todo_list_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findUniqueOrThrow\n   */\n  export type todo_list_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users findFirst\n   */\n  export type todo_list_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findFirstOrThrow\n   */\n  export type todo_list_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_users.\n     */\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users findMany\n   */\n  export type todo_list_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_users to fetch.\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_users to fetch.\n     */\n    orderBy?: todo_list_usersOrderByWithRelationInput | todo_list_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_users.\n     */\n    cursor?: todo_list_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_users.\n     */\n    skip?: number\n    distinct?: Todo_list_usersScalarFieldEnum | Todo_list_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users create\n   */\n  export type todo_list_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_users.\n     */\n    data: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_users createMany\n   */\n  export type todo_list_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users createManyAndReturn\n   */\n  export type todo_list_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_users.\n     */\n    data: todo_list_usersCreateManyInput | todo_list_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_users update\n   */\n  export type todo_list_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_users to update.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users updateMany\n   */\n  export type todo_list_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users updateManyAndReturn\n   */\n  export type todo_list_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_users.\n     */\n    data: XOR<todo_list_usersUpdateManyMutationInput, todo_list_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_users to update\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users upsert\n   */\n  export type todo_list_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_users to update in case it exists.\n     */\n    where: todo_list_usersWhereUniqueInput\n    /**\n     * In case the todo_list_users found by the `where` argument doesn't exist, create a new todo_list_users with this data.\n     */\n    create: XOR<todo_list_usersCreateInput, todo_list_usersUncheckedCreateInput>\n    /**\n     * In case the todo_list_users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_usersUpdateInput, todo_list_usersUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_users delete\n   */\n  export type todo_list_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_users to delete.\n     */\n    where: todo_list_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_users deleteMany\n   */\n  export type todo_list_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_users to delete\n     */\n    where?: todo_list_usersWhereInput\n    /**\n     * Limit how many todo_list_users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_users.todo_list_todos\n   */\n  export type todo_list_users$todo_list_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    cursor?: todo_list_todosWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_users without action\n   */\n  export type todo_list_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_users\n     */\n    select?: todo_list_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_users\n     */\n    omit?: todo_list_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_todos\n   */\n\n  export type AggregateTodo_list_todos = {\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_todosMinAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    title: string | null\n    description: string | null\n    completed: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    completed_at: Date | null\n  }\n\n  export type Todo_list_todosMaxAggregateOutputType = {\n    id: string | null\n    todo_list_user_id: string | null\n    title: string | null\n    description: string | null\n    completed: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    completed_at: Date | null\n  }\n\n  export type Todo_list_todosCountAggregateOutputType = {\n    id: number\n    todo_list_user_id: number\n    title: number\n    description: number\n    completed: number\n    created_at: number\n    updated_at: number\n    completed_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_todosMinAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    description?: true\n    completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n  }\n\n  export type Todo_list_todosMaxAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    description?: true\n    completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n  }\n\n  export type Todo_list_todosCountAggregateInputType = {\n    id?: true\n    todo_list_user_id?: true\n    title?: true\n    description?: true\n    completed?: true\n    created_at?: true\n    updated_at?: true\n    completed_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_todosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to aggregate.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_todos\n    **/\n    _count?: true | Todo_list_todosCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_todosMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type GetTodo_list_todosAggregateType<T extends Todo_list_todosAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_todos]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n      : GetScalarType<T[P], AggregateTodo_list_todos[P]>\n  }\n\n\n\n\n  export type todo_list_todosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_todosWhereInput\n    orderBy?: todo_list_todosOrderByWithAggregationInput | todo_list_todosOrderByWithAggregationInput[]\n    by: Todo_list_todosScalarFieldEnum[] | Todo_list_todosScalarFieldEnum\n    having?: todo_list_todosScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_todosCountAggregateInputType | true\n    _min?: Todo_list_todosMinAggregateInputType\n    _max?: Todo_list_todosMaxAggregateInputType\n  }\n\n  export type Todo_list_todosGroupByOutputType = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    description: string | null\n    completed: boolean\n    created_at: Date\n    updated_at: Date\n    completed_at: Date | null\n    _count: Todo_list_todosCountAggregateOutputType | null\n    _min: Todo_list_todosMinAggregateOutputType | null\n    _max: Todo_list_todosMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_todosGroupByPayload<T extends todo_list_todosGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_todosGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_todosGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_todosGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_todosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    description?: boolean\n    completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    description?: boolean\n    completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    description?: boolean\n    completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n\n  export type todo_list_todosSelectScalar = {\n    id?: boolean\n    todo_list_user_id?: boolean\n    title?: boolean\n    description?: boolean\n    completed?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    completed_at?: boolean\n  }\n\n  export type todo_list_todosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_list_user_id\" | \"title\" | \"description\" | \"completed\" | \"created_at\" | \"updated_at\" | \"completed_at\", ExtArgs[\"result\"][\"todo_list_todos\"]>\n  export type todo_list_todosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_todosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_usersDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_list_todosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_todos\"\n    objects: {\n      user: Prisma.$todo_list_usersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Belonged user's {@link todo_list_users.id}. Enforces per-user ownership\n       * of each todo.\n       */\n      todo_list_user_id: string\n      /**\n       * Concise summary of the task. Required. 1-100 characters; validated by\n       * application upon CRUD operations.\n       */\n      title: string\n      /**\n       * Optional detailed description of the task. Maximum 500 characters; may be\n       * null if not provided.\n       */\n      description: string | null\n      /**\n       * Whether the todo is currently marked as complete or not. Default is false\n       * upon creation.\n       */\n      completed: boolean\n      /**\n       * Timestamp of when the todo was created. Used for audit and list ordering.\n       */\n      created_at: Date\n      /**\n       * Timestamp of the last update to the todo (including completion\n       * toggle/edit).\n       */\n      updated_at: Date\n      /**\n       * Timestamp when the todo was marked completed. Null if not completed.\n       */\n      completed_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_todos\"]>\n    composites: {}\n  }\n\n  type todo_list_todosGetPayload<S extends boolean | null | undefined | todo_list_todosDefaultArgs> = $Result.GetResult<Prisma.$todo_list_todosPayload, S>\n\n  type todo_list_todosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_todosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_todosCountAggregateInputType | true\n    }\n\n  export interface todo_list_todosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_todos'], meta: { name: 'todo_list_todos' } }\n    /**\n     * Find zero or one Todo_list_todos that matches the filter.\n     * @param {todo_list_todosFindUniqueArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_todosFindUniqueArgs>(args: SelectSubset<T, todo_list_todosFindUniqueArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_todos that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_todosFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_todosFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_todosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_todosFindFirstArgs>(args?: SelectSubset<T, todo_list_todosFindFirstArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_todos that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindFirstOrThrowArgs} args - Arguments to find a Todo_list_todos\n     * @example\n     * // Get one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_todosFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_todosFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany()\n     * \n     * // Get first 10 Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_todosFindManyArgs>(args?: SelectSubset<T, todo_list_todosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_todos.\n     * @param {todo_list_todosCreateArgs} args - Arguments to create a Todo_list_todos.\n     * @example\n     * // Create one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.create({\n     *   data: {\n     *     // ... data to create a Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_todosCreateArgs>(args: SelectSubset<T, todo_list_todosCreateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_todos.\n     * @param {todo_list_todosCreateManyArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_todosCreateManyArgs>(args?: SelectSubset<T, todo_list_todosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_todos and returns the data saved in the database.\n     * @param {todo_list_todosCreateManyAndReturnArgs} args - Arguments to create many Todo_list_todos.\n     * @example\n     * // Create many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_todosCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_todosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_todos.\n     * @param {todo_list_todosDeleteArgs} args - Arguments to delete one Todo_list_todos.\n     * @example\n     * // Delete one Todo_list_todos\n     * const Todo_list_todos = await prisma.todo_list_todos.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_todos\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_todosDeleteArgs>(args: SelectSubset<T, todo_list_todosDeleteArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_todos.\n     * @param {todo_list_todosUpdateArgs} args - Arguments to update one Todo_list_todos.\n     * @example\n     * // Update one Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_todosUpdateArgs>(args: SelectSubset<T, todo_list_todosUpdateArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_todos.\n     * @param {todo_list_todosDeleteManyArgs} args - Arguments to filter Todo_list_todos to delete.\n     * @example\n     * // Delete a few Todo_list_todos\n     * const { count } = await prisma.todo_list_todos.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_todosDeleteManyArgs>(args?: SelectSubset<T, todo_list_todosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_todosUpdateManyArgs>(args: SelectSubset<T, todo_list_todosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_todos and returns the data updated in the database.\n     * @param {todo_list_todosUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_todos.\n     * @example\n     * // Update many Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_todos and only return the `id`\n     * const todo_list_todosWithIdOnly = await prisma.todo_list_todos.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_todosUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_todosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_todos.\n     * @param {todo_list_todosUpsertArgs} args - Arguments to update or create a Todo_list_todos.\n     * @example\n     * // Update or create a Todo_list_todos\n     * const todo_list_todos = await prisma.todo_list_todos.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_todos\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_todosUpsertArgs>(args: SelectSubset<T, todo_list_todosUpsertArgs<ExtArgs>>): Prisma__todo_list_todosClient<$Result.GetResult<Prisma.$todo_list_todosPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosCountArgs} args - Arguments to filter Todo_list_todos to count.\n     * @example\n     * // Count the number of Todo_list_todos\n     * const count = await prisma.todo_list_todos.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_todos we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_todosCountArgs>(\n      args?: Subset<T, todo_list_todosCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_todosCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_todosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_todosAggregateArgs>(args: Subset<T, Todo_list_todosAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_todosAggregateType<T>>\n\n    /**\n     * Group by Todo_list_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_todosGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_todosGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_todosGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_todosGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_todosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_todosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_todos model\n   */\n  readonly fields: todo_list_todosFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_todos.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_todosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends todo_list_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_usersDefaultArgs<ExtArgs>>): Prisma__todo_list_usersClient<$Result.GetResult<Prisma.$todo_list_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_todos model\n   */\n  interface todo_list_todosFieldRefs {\n    readonly id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly todo_list_user_id: FieldRef<\"todo_list_todos\", 'String'>\n    readonly title: FieldRef<\"todo_list_todos\", 'String'>\n    readonly description: FieldRef<\"todo_list_todos\", 'String'>\n    readonly completed: FieldRef<\"todo_list_todos\", 'Boolean'>\n    readonly created_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n    readonly completed_at: FieldRef<\"todo_list_todos\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_todos findUnique\n   */\n  export type todo_list_todosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findUniqueOrThrow\n   */\n  export type todo_list_todosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos findFirst\n   */\n  export type todo_list_todosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findFirstOrThrow\n   */\n  export type todo_list_todosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_todos.\n     */\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos findMany\n   */\n  export type todo_list_todosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_todos to fetch.\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_todos to fetch.\n     */\n    orderBy?: todo_list_todosOrderByWithRelationInput | todo_list_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_todos.\n     */\n    cursor?: todo_list_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_todos.\n     */\n    skip?: number\n    distinct?: Todo_list_todosScalarFieldEnum | Todo_list_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_todos create\n   */\n  export type todo_list_todosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_todos.\n     */\n    data: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_todos createMany\n   */\n  export type todo_list_todosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_todos createManyAndReturn\n   */\n  export type todo_list_todosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_todos.\n     */\n    data: todo_list_todosCreateManyInput | todo_list_todosCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos update\n   */\n  export type todo_list_todosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_todos to update.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos updateMany\n   */\n  export type todo_list_todosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos updateManyAndReturn\n   */\n  export type todo_list_todosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_todos.\n     */\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_todos to update\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_todos upsert\n   */\n  export type todo_list_todosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_todos to update in case it exists.\n     */\n    where: todo_list_todosWhereUniqueInput\n    /**\n     * In case the todo_list_todos found by the `where` argument doesn't exist, create a new todo_list_todos with this data.\n     */\n    create: XOR<todo_list_todosCreateInput, todo_list_todosUncheckedCreateInput>\n    /**\n     * In case the todo_list_todos was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_todosUpdateInput, todo_list_todosUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_todos delete\n   */\n  export type todo_list_todosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_todos to delete.\n     */\n    where: todo_list_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_list_todos deleteMany\n   */\n  export type todo_list_todosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_todos to delete\n     */\n    where?: todo_list_todosWhereInput\n    /**\n     * Limit how many todo_list_todos to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_todos without action\n   */\n  export type todo_list_todosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_todos\n     */\n    select?: todo_list_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_todos\n     */\n    omit?: todo_list_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_todosInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Todo_list_usersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    last_login: 'last_login'\n  };\n\n  export type Todo_list_usersScalarFieldEnum = (typeof Todo_list_usersScalarFieldEnum)[keyof typeof Todo_list_usersScalarFieldEnum]\n\n\n  export const Todo_list_todosScalarFieldEnum: {\n    id: 'id',\n    todo_list_user_id: 'todo_list_user_id',\n    title: 'title',\n    description: 'description',\n    completed: 'completed',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    completed_at: 'completed_at'\n  };\n\n  export type Todo_list_todosScalarFieldEnum = (typeof Todo_list_todosScalarFieldEnum)[keyof typeof Todo_list_todosScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type todo_list_usersWhereInput = {\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    id?: UuidFilter<\"todo_list_users\"> | string\n    email?: StringFilter<\"todo_list_users\"> | string\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    last_login?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    todo_list_todos?: Todo_list_todosListRelationFilter\n  }\n\n  export type todo_list_usersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_login?: SortOrderInput | SortOrder\n    todo_list_todos?: todo_list_todosOrderByRelationAggregateInput\n  }\n\n  export type todo_list_usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    OR?: todo_list_usersWhereInput[]\n    NOT?: todo_list_usersWhereInput | todo_list_usersWhereInput[]\n    password_hash?: StringFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_users\"> | Date | string\n    last_login?: DateTimeNullableFilter<\"todo_list_users\"> | Date | string | null\n    todo_list_todos?: Todo_list_todosListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_list_usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_login?: SortOrderInput | SortOrder\n    _count?: todo_list_usersCountOrderByAggregateInput\n    _max?: todo_list_usersMaxOrderByAggregateInput\n    _min?: todo_list_usersMinOrderByAggregateInput\n  }\n\n  export type todo_list_usersScalarWhereWithAggregatesInput = {\n    AND?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    OR?: todo_list_usersScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_usersScalarWhereWithAggregatesInput | todo_list_usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_users\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_users\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_users\"> | Date | string\n    last_login?: DateTimeNullableWithAggregatesFilter<\"todo_list_users\"> | Date | string | null\n  }\n\n  export type todo_list_todosWhereInput = {\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    description?: StringNullableFilter<\"todo_list_todos\"> | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n  }\n\n  export type todo_list_todosOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    user?: todo_list_usersOrderByWithRelationInput\n  }\n\n  export type todo_list_todosWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    OR?: todo_list_todosWhereInput[]\n    NOT?: todo_list_todosWhereInput | todo_list_todosWhereInput[]\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    description?: StringNullableFilter<\"todo_list_todos\"> | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n    user?: XOR<Todo_list_usersScalarRelationFilter, todo_list_usersWhereInput>\n  }, \"id\">\n\n  export type todo_list_todosOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    _count?: todo_list_todosCountOrderByAggregateInput\n    _max?: todo_list_todosMaxOrderByAggregateInput\n    _min?: todo_list_todosMinOrderByAggregateInput\n  }\n\n  export type todo_list_todosScalarWhereWithAggregatesInput = {\n    AND?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    OR?: todo_list_todosScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_todosScalarWhereWithAggregatesInput | todo_list_todosScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidWithAggregatesFilter<\"todo_list_todos\"> | string\n    title?: StringWithAggregatesFilter<\"todo_list_todos\"> | string\n    description?: StringNullableWithAggregatesFilter<\"todo_list_todos\"> | string | null\n    completed?: BoolWithAggregatesFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_todos\"> | Date | string | null\n  }\n\n  export type todo_list_usersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_login?: Date | string | null\n    todo_list_todos?: todo_list_todosCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_login?: Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_todos?: todo_list_todosUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_usersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_login?: Date | string | null\n  }\n\n  export type todo_list_usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosCreateInput = {\n    id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n    user: todo_list_usersCreateNestedOneWithoutTodo_list_todosInput\n  }\n\n  export type todo_list_todosUncheckedCreateInput = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    user?: todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput\n  }\n\n  export type todo_list_todosUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosCreateManyInput = {\n    id: string\n    todo_list_user_id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type Todo_list_todosListRelationFilter = {\n    every?: todo_list_todosWhereInput\n    some?: todo_list_todosWhereInput\n    none?: todo_list_todosWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type todo_list_todosOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_list_usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_login?: SortOrder\n  }\n\n  export type todo_list_usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_login?: SortOrder\n  }\n\n  export type todo_list_usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_login?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type Todo_list_usersScalarRelationFilter = {\n    is?: todo_list_usersWhereInput\n    isNot?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_todosCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n  }\n\n  export type todo_list_todosMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n  }\n\n  export type todo_list_todosMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    completed?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    completed_at?: SortOrder\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type todo_list_todosCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type todo_list_todosUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput> | todo_list_todosCreateWithoutUserInput[] | todo_list_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_todosCreateOrConnectWithoutUserInput | todo_list_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_todosUpsertWithWhereUniqueWithoutUserInput | todo_list_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_todosCreateManyUserInputEnvelope\n    set?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    disconnect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    delete?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    connect?: todo_list_todosWhereUniqueInput | todo_list_todosWhereUniqueInput[]\n    update?: todo_list_todosUpdateWithWhereUniqueWithoutUserInput | todo_list_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_todosUpdateManyWithWhereWithoutUserInput | todo_list_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n  }\n\n  export type todo_list_usersCreateNestedOneWithoutTodo_list_todosInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type todo_list_usersUpdateOneRequiredWithoutTodo_list_todosNestedInput = {\n    create?: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    connectOrCreate?: todo_list_usersCreateOrConnectWithoutTodo_list_todosInput\n    upsert?: todo_list_usersUpsertWithoutTodo_list_todosInput\n    connect?: todo_list_usersWhereUniqueInput\n    update?: XOR<XOR<todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput, todo_list_usersUpdateWithoutTodo_list_todosInput>, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type todo_list_todosCreateWithoutUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n  }\n\n  export type todo_list_todosUncheckedCreateWithoutUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n  }\n\n  export type todo_list_todosCreateOrConnectWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosCreateManyUserInputEnvelope = {\n    data: todo_list_todosCreateManyUserInput | todo_list_todosCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_todosUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    update: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_list_todosCreateWithoutUserInput, todo_list_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_list_todosWhereUniqueInput\n    data: XOR<todo_list_todosUpdateWithoutUserInput, todo_list_todosUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_list_todosUpdateManyWithWhereWithoutUserInput = {\n    where: todo_list_todosScalarWhereInput\n    data: XOR<todo_list_todosUpdateManyMutationInput, todo_list_todosUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_list_todosScalarWhereInput = {\n    AND?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    OR?: todo_list_todosScalarWhereInput[]\n    NOT?: todo_list_todosScalarWhereInput | todo_list_todosScalarWhereInput[]\n    id?: UuidFilter<\"todo_list_todos\"> | string\n    todo_list_user_id?: UuidFilter<\"todo_list_todos\"> | string\n    title?: StringFilter<\"todo_list_todos\"> | string\n    description?: StringNullableFilter<\"todo_list_todos\"> | string | null\n    completed?: BoolFilter<\"todo_list_todos\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_todos\"> | Date | string\n    completed_at?: DateTimeNullableFilter<\"todo_list_todos\"> | Date | string | null\n  }\n\n  export type todo_list_usersCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_login?: Date | string | null\n  }\n\n  export type todo_list_usersUncheckedCreateWithoutTodo_list_todosInput = {\n    id: string\n    email: string\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_login?: Date | string | null\n  }\n\n  export type todo_list_usersCreateOrConnectWithoutTodo_list_todosInput = {\n    where: todo_list_usersWhereUniqueInput\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_usersUpsertWithoutTodo_list_todosInput = {\n    update: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n    create: XOR<todo_list_usersCreateWithoutTodo_list_todosInput, todo_list_usersUncheckedCreateWithoutTodo_list_todosInput>\n    where?: todo_list_usersWhereInput\n  }\n\n  export type todo_list_usersUpdateToOneWithWhereWithoutTodo_list_todosInput = {\n    where?: todo_list_usersWhereInput\n    data: XOR<todo_list_usersUpdateWithoutTodo_list_todosInput, todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput>\n  }\n\n  export type todo_list_usersUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_usersUncheckedUpdateWithoutTodo_list_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosCreateManyUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    completed: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    completed_at?: Date | string | null\n  }\n\n  export type todo_list_todosUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_todosUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    completed?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Actors](#actors)\n- [Todos](#todos)\n\n## Actors\n\n```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  DateTime last_login \"nullable\"\n}\n```\n\n### `todo_list_users`\n\nAuthentication and identity table for all application users. Holds\nessential user credentials, identification, and minimal auditing\ninformation. Used for user registration, login, and ownership association\nwith [todo_list_todos](#todo_list_todos) (in other component). Each user record is\nuniquely identified by email and manages its own password. Deletion or\nmodification of user accounts is audited via timestamps. Email uniqueness\nenforces single identity. No advanced roles exist; this is the only actor\ntype in the system. No PII beyond minimal required for authentication is\nstored. This table does not directly reference any business data tables,\nbut is referenced by them for ownership.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`\n  > Unique user email address for identification and login. Must be unique;\n  > serves as user identity within the service.\n- `password_hash`\n  > Secure hash of the user password (never stores plaintext password). Used\n  > for login verification only. Application must enforce proper hashing\n  > algorithms.\n- `created_at`\n  > Timestamp when the user account was created (registration time). Used for\n  > auditing and account lifecycle tracking.\n- `updated_at`\n  > Timestamp of most recent profile or credential update for auditing and\n  > compliance.\n- `last_login`\n  > Timestamp of the user's most recent successful login. Used for security,\n  > analytics, and notification of suspicious activity.\n\n## Todos\n\n```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String title\n  String description \"nullable\"\n  Boolean completed\n  DateTime created_at\n  DateTime updated_at\n  DateTime completed_at \"nullable\"\n}\n```\n\n### `todo_list_todos`\n\nRepresents a single task in the user's todo list. Each todo item belongs\nto exactly one user, and all CRUD operations are scoped to the owner.\nFields include required title (100 char max), optional description (500\nchar max), completed status, timestamps for creation, last update, and\ncompletion. Enforces strict user ownership via foreign key to {@link\ntodo_list_users.id}. Supports efficient retrieval by user and order of\ncreation.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_list_user_id`\n  > Belonged user's [todo_list_users.id](#todo_list_users). Enforces per-user ownership\n  > of each todo.\n- `title`\n  > Concise summary of the task. Required. 1-100 characters; validated by\n  > application upon CRUD operations.\n- `description`\n  > Optional detailed description of the task. Maximum 500 characters; may be\n  > null if not provided.\n- `completed`\n  > Whether the todo is currently marked as complete or not. Default is false\n  > upon creation.\n- `created_at`: Timestamp of when the todo was created. Used for audit and list ordering.\n- `updated_at`\n  > Timestamp of the last update to the todo (including completion\n  > toggle/edit).\n- `completed_at`: Timestamp when the todo was marked completed. Null if not completed.\n","diagrams":{"Actors":"```mermaid\nerDiagram\n\"todo_list_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  DateTime last_login \"nullable\"\n}\n```","Todos":"```mermaid\nerDiagram\n\"todo_list_todos\" {\n  String id PK\n  String todo_list_user_id FK\n  String title\n  String description \"nullable\"\n  Boolean completed\n  DateTime created_at\n  DateTime updated_at\n  DateTime completed_at \"nullable\"\n}\n```"}},"created_at":"2025-10-07T15:36:26.219Z","completed_at":"2025-10-07T15:41:47.046Z","step":0},{"id":"0199bf55-fc39-774b-97fd-3f8fec0a890e","type":"userMessage","contents":[{"type":"text","text":"Create the API interface specification."}],"created_at":"2025-10-07T15:41:47.449Z"},{"type":"interface","id":"0199bf5c-eb0d-707a-9813-d811ae6816e2","instruction":"Create a minimal RESTful API interface for a Todo list application. Include only the essential endpoints to support creating, reading, updating, and deleting Todo items. Each Todo should have a title, optional description, completion status, and creation date. The API design should be as simple as possible, focusing on the minimum functionality for manipulating Todo items.","authorizations":[{"role":"user","operations":[{"specification":"This operation handles new user registration for the minimal Todo List application. It creates a new user record in the todo_list_users table, requiring a unique email and a password (stored securely as password_hash), as defined in the Prisma schema. The application enforces email uniqueness and secure password storage via hashing. Upon successful registration, the response includes authentication tokens for authorized API use. Account creation records the created_at and updated_at timestamps, with last_login remaining null until the first login. Only email and password fields are required for registration; extraneous data is not accepted. If the email is already in use, the endpoint returns a duplication error. This endpoint is public and does not require prior authentication. It is the entry point for all user access to Todo features, as all other interactions require a registered and authenticated user. Registration must meet email uniqueness and password policy constraints. Related operations include login (for authentication) and refresh (for token renewal).","authorizationType":"join","description":"This endpoint registers a new user in the todo_list_users table by accepting an email and password. The Prisma schema ensures email is unique, and password_hash is used to securely store the credential. Upon creation, created_at and updated_at are stamped with the current time. last_login remains null. Registration is mandatory for all further Todo operations, as the application does not support guest or admin roles. Security is enforced by hashing the password and checking for duplicate emails. Only core authentication fields are supported; no extra user data is accepted. The endpoint is public and does not require authentication. Error handling includes clear feedback on email duplication and password requirements. Related authentication endpoints are provided for login and token refresh.","summary":"Register new user in todo_list_users (user role) and return authentication tokens.","parameters":[],"requestBody":{"description":"Email and password for user registration (used to create todo_list_users entry).","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"Authentication tokens and user information after registration.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This operation authenticates an existing user in the todo_list_users table using their email and password. Successful authentication requires finding a user with the provided email and matching the password to the stored password_hash using secure comparison. Upon login, the user's last_login field is updated to the current timestamp for audit purposes. If the credentials are invalid, the endpoint returns a generic error message (not indicating which field was incorrect, for security). On success, the user is issued JWT-based access and refresh tokens, with token payload scoped to the assigned user identity. This operation is a public authorization endpoint (no prior authentication required), and all further business operations require token authentication obtained here. It is rate-limited and logs authentication events as per schema capabilities. Related operations are join (for registration) and refresh (for token renewal).","authorizationType":"login","description":"Authenticates a user by verifying email against a record in todo_list_users and matching password using password_hash. Updates last_login to timestamp of successful authentication. Only users with valid credentials can access the system; failed attempts return generic errors to avoid credential enumeration. Tokens issued allow access to CRUD Todo operations. Email and password are the only accepted inputs. Security and auditing rely on accurate maintenance of last_login and secure credential comparison. Account must have been created via join. Related endpoint: refresh for token renewal.","summary":"Authenticate user in todo_list_users (user role) and return authentication tokens.","parameters":[],"requestBody":{"description":"User email and password for login authentication.","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"Authentication tokens and user identity after successful login.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This operation provides JWT access token renewal for authenticated users of the todo_list_users table. A valid refresh token must be supplied (in accordance with security policy). The application verifies the refresh token corresponds to a valid user, and then issues a new set of tokens without requiring re-authentication with credentials. If the refresh token is invalid or expired, the system denies the operation. Refresh tokens are valid for up to 30 days and are securely managed per the authentication requirements. This endpoint supports seamless, secure session continuation, as outlined in the business requirements. last_login is not updated on token refresh, only on login. This is a public endpoint that only requires the refresh token. Related operations are join (register) and login (authenticate). All underlying user identification and security validation reference todo_list_users schema.","authorizationType":"refresh","description":"Renews access/refresh tokens for authenticated user by validating the provided refresh token. Maps to todo_list_users, but only accepts a valid refresh token for an active user session. Does not change last_login (which is only updated on login). All further application actions require an active, valid token issued via this endpoint or login. Security policy limits refresh token lifetime and scope. Error handling is strict for expired or invalid tokens. Related endpoints: join, login. No other data required except the refresh token.","summary":"Refresh JWT tokens for authenticated user in todo_list_users (user role).","parameters":[],"requestBody":{"description":"Refresh token to renew user session.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"Newly issued authentication tokens for continued session.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"}]}],"document":{"operations":[{"specification":"This operation handles new user registration for the minimal Todo List application. It creates a new user record in the todo_list_users table, requiring a unique email and a password (stored securely as password_hash), as defined in the Prisma schema. The application enforces email uniqueness and secure password storage via hashing. Upon successful registration, the response includes authentication tokens for authorized API use. Account creation records the created_at and updated_at timestamps, with last_login remaining null until the first login. Only email and password fields are required for registration; extraneous data is not accepted. If the email is already in use, the endpoint returns a duplication error. This endpoint is public and does not require prior authentication. It is the entry point for all user access to Todo features, as all other interactions require a registered and authenticated user. Registration must meet email uniqueness and password policy constraints. Related operations include login (for authentication) and refresh (for token renewal).","authorizationType":"join","description":"This endpoint registers a new user in the todo_list_users table by accepting an email and password. The Prisma schema ensures email is unique, and password_hash is used to securely store the credential. Upon creation, created_at and updated_at are stamped with the current time. last_login remains null. Registration is mandatory for all further Todo operations, as the application does not support guest or admin roles. Security is enforced by hashing the password and checking for duplicate emails. Only core authentication fields are supported; no extra user data is accepted. The endpoint is public and does not require authentication. Error handling includes clear feedback on email duplication and password requirements. Related authentication endpoints are provided for login and token refresh.","summary":"Register new user in todo_list_users (user role) and return authentication tokens.","parameters":[],"requestBody":{"description":"Email and password for user registration (used to create todo_list_users entry).","typeName":"ITodoListUser.IJoin"},"responseBody":{"description":"Authentication tokens and user information after registration.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This operation authenticates an existing user in the todo_list_users table using their email and password. Successful authentication requires finding a user with the provided email and matching the password to the stored password_hash using secure comparison. Upon login, the user's last_login field is updated to the current timestamp for audit purposes. If the credentials are invalid, the endpoint returns a generic error message (not indicating which field was incorrect, for security). On success, the user is issued JWT-based access and refresh tokens, with token payload scoped to the assigned user identity. This operation is a public authorization endpoint (no prior authentication required), and all further business operations require token authentication obtained here. It is rate-limited and logs authentication events as per schema capabilities. Related operations are join (for registration) and refresh (for token renewal).","authorizationType":"login","description":"Authenticates a user by verifying email against a record in todo_list_users and matching password using password_hash. Updates last_login to timestamp of successful authentication. Only users with valid credentials can access the system; failed attempts return generic errors to avoid credential enumeration. Tokens issued allow access to CRUD Todo operations. Email and password are the only accepted inputs. Security and auditing rely on accurate maintenance of last_login and secure credential comparison. Account must have been created via join. Related endpoint: refresh for token renewal.","summary":"Authenticate user in todo_list_users (user role) and return authentication tokens.","parameters":[],"requestBody":{"description":"User email and password for login authentication.","typeName":"ITodoListUser.ILogin"},"responseBody":{"description":"Authentication tokens and user identity after successful login.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This operation provides JWT access token renewal for authenticated users of the todo_list_users table. A valid refresh token must be supplied (in accordance with security policy). The application verifies the refresh token corresponds to a valid user, and then issues a new set of tokens without requiring re-authentication with credentials. If the refresh token is invalid or expired, the system denies the operation. Refresh tokens are valid for up to 30 days and are securely managed per the authentication requirements. This endpoint supports seamless, secure session continuation, as outlined in the business requirements. last_login is not updated on token refresh, only on login. This is a public endpoint that only requires the refresh token. Related operations are join (register) and login (authenticate). All underlying user identification and security validation reference todo_list_users schema.","authorizationType":"refresh","description":"Renews access/refresh tokens for authenticated user by validating the provided refresh token. Maps to todo_list_users, but only accepts a valid refresh token for an active user session. Does not change last_login (which is only updated on login). All further application actions require an active, valid token issued via this endpoint or login. Security policy limits refresh token lifetime and scope. Error handling is strict for expired or invalid tokens. Related endpoints: join, login. No other data required except the refresh token.","summary":"Refresh JWT tokens for authenticated user in todo_list_users (user role).","parameters":[],"requestBody":{"description":"Refresh token to renew user session.","typeName":"ITodoListUser.IRefresh"},"responseBody":{"description":"Newly issued authentication tokens for continued session.","typeName":"ITodoListUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"},{"specification":"This operation provides authenticated users with a filtered and paginated list of their own Todo items. It operates on the todo_list_todos table and supports advanced searching, filtering by completion status, and sorting by creation or completion time, but always within the constraint that only the requesting user's Todos are accessible. The endpoint allows for minimal list options, with default ordering by most recently created. Search parameters such as completion status and optional text search on title and description are supported for a streamlined experience aligned with business requirements.","path":"/todoList/user/todos","method":"patch","summary":"Search and retrieve a paginated list of the authenticated user's Todo items.","description":"This operation enables an authenticated user to retrieve a filtered and paginated list of their Todo items from the system. The API allows searching by completion status (completed/incomplete/all), keyword filtering on the title and description, and supports ordering by creation date in descending order by default. The business logic strictly ensures that only Todos owned by the current user are included in the result, even if additional filter parameters are provided.\n\nPagination parameters such as page number and size control the volume of results returned. Search and filtering operate only within the authenticated user's dataset; attempts to access other users' Todos are blocked at the business logic layer. The response contains summary details for each Todo, including its id, title, description (if any), completed status, and timestamps for creation, last update, and completed time where relevant.\n\nSecurity is enforced by requiring a valid user token, and all business logic prevents enumeration or disclosure of other users' data. Error scenarios include authentication failure (session/token missing or expired), invalid pagination/filter parameters, and unexpected server errors.\n\nClients should use this endpoint to present Todo lists, filtered views, or search within the user's own tasks. Deeper details can be retrieved using the single-Todo endpoint if required.","parameters":[],"requestBody":{"description":"Search criteria including optional completion status, text keyword, and pagination options for filtering the user's Todos.","typeName":"ITodoListTodo.IRequest"},"responseBody":{"description":"Paginated list of the authenticated user's Todo summary objects matching filter criteria.","typeName":"IPageITodoListTodo.ISummary"},"authorizationRoles":["user"],"name":"index","authorizationRole":"user","authorizationType":null,"prerequisites":[]},{"specification":"This operation retrieves detailed information about a single Todo item belonging to the authenticated user. It operates on the todo_list_todos table and returns all available fields from the Todo, including title, optional description, completion status, and associated timestamps (creation, updated, completed). The endpoint strictly enforces user ownership; only the creator of the Todo can access its details. The response enables clients to load complete details of a specific Todo for display or further actions (such as update or delete).","path":"/todoList/user/todos/{todoId}","method":"get","summary":"Retrieve the full details of a single Todo item owned by the authenticated user.","description":"This operation returns comprehensive details about a specified Todo item, but only if it is owned by the requesting (authenticated) user. The endpoint is designed for use cases where a client application needs to present all attributes of a selected Todo, including id, title, optional description, completion status, timestamps for creation, last update, and completion (if applicable).\n\nAuthorization is strictly enforced: if the Todo does not exist or is not owned by the user, the operation returns a not-found or access denied error (without confirming the existence of others' Todos). This ensures privacy and data isolation in line with both business rules and security best practices. No modification occurs with this request. All fields correspond exactly to the todo_list_todos Prisma table definition, assuring that code and documentation stay in sync.\n\nClients should use this operation when a user wishes to view all attributes of a Todo, such as on a detail page or before editing. Error handling includes authentication failure, nonexistent or non-owned resource, and generic internal errors.","parameters":[{"name":"todoId","description":"Unique identifier of the Todo item to retrieve. Must refer to a Todo belonging to the authenticated user.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details of the Todo item if found and owned by the requesting user.","typeName":"ITodoListTodo"},"authorizationRoles":["user"],"name":"at","authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"A Todo must be created before it can be retrieved by its unique ID."}]},{"specification":"This operation creates a new Todo item for the authenticated user. It works on the todo_list_todos table from the Prisma schema and allows users to provide a concise title (1-100 characters), an optional description (up to 500 characters), and automatically sets completion to false and timestamps to now. The operation strictly associates the Todo with the requesting user (ownership enforced by the backend using the user identity from the session/context). No system-generated fields such as deletion auditing are managed, and only essential fields defined in the Prisma schema (title, description, completed, created_at, etc.) are included.","description":"Allows an authenticated user to create a new Todo item to track a personal task. The title is required and must be meaningful, ranging from 1 to 100 characters; a description is optional but, if provided, cannot exceed 500 characters. When a Todo is created, the system sets the completion status to false and fills in current \"created_at\" and \"updated_at\" timestamps. The created Todo is associated with the requesting user for future ownership validation.\n\nSecurity checks require the user to be authenticated. The system uses the active user session for ownership linkage (todo_list_user_id). The backend enforces data validation as per the schema: empty or whitespace-only titles or overlength fields are not permitted. Description is optional but must respect the character limit when supplied.\n\nAll fields not present in the Prisma schema (such as deleted_at, restored_at, etc.) are intentionally excluded; only the essential minimal fields (title, description, created_at, user-owned) are included. In case of validation failures or attempted creation without proper authentication, the system returns an error response without exposing internal details.","summary":"Create a new Todo item owned by the authenticated user (todo_list_todos table).","parameters":[],"requestBody":{"description":"Information for creating a new Todo item, including title (mandatory), optional description (up to 500 chars); completion is set to false by default; all other fields default to system.","typeName":"ITodoListTodo.ICreate"},"responseBody":{"description":"The complete Todo item with all persisted schema fields after creation, including owner, timestamps, and completion status.","typeName":"ITodoListTodo"},"authorizationType":null,"authorizationRole":"user","path":"/todoList/user/todos","method":"post","name":"create","prerequisites":[]},{"specification":"This operation updates an existing Todo item for the authenticated user, as identified by the Todo's unique id. Operates on the todo_list_todos table in the Prisma schema. Users can update the title (1-100 characters), optional description (up to 500 characters), and completion status (boolean). The updated_at timestamp will be set to the current time. Ownership and existence are enforced: only the owner can update the Todo. Fields not found in the schema are not accessible or modifiable.","description":"Allows the authenticated user to update the properties of an existing Todo item that they own. The user provides a new title (mandatory, 1-100 chars), an optional description (up to 500 chars), and/or a new completion status (boolean). The request is only validated and performed if the Todo exists and belongs to the requesting user. Upon successful update, the updated_at timestamp is refreshed to current time, and the completion state (and completed_at timestamp) is modified according to the change.\n\nAll inputs are strictly validated: title cannot be empty or exceed the character limit; description is optional but must respect the 500 character restriction; completed must be boolean. Attempting to modify a Todo not owned by the user, or not in the database, results in a not found or forbidden error (no information about other users' data is leaked). Only the fields defined in the todo_list_todos schema are updatable; no hidden or system fields are present or updatable.\n\nOnly authenticated users can call this operation. No batch or cross-user updates are supported. Any field provided must satisfy minimal field constraints. Error messages are business-contextual and avoid leaking privileged information.","summary":"Update an existing Todo item, verifying ownership and field validation (todo_list_todos table).","parameters":[{"name":"todoId","description":"Unique identifier (UUID) of the Todo item to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to update in an owned Todo item: must include new title (1-100 chars), optional description (up to 500 chars), and/or completion status; updated_at is system-set.","typeName":"ITodoListTodo.IUpdate"},"responseBody":{"description":"The full, updated Todo item resource reflecting all current schema fields after the change.","typeName":"ITodoListTodo"},"authorizationType":null,"authorizationRole":"user","path":"/todoList/user/todos/{todoId}","method":"put","name":"update","prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"A Todo item must exist before it can be updated. Creating the Todo ensures that the referenced todoId belongs to the authenticated user and has all required fields initialized."}]},{"specification":"This operation permanently deletes a specific Todo item identified by its unique ID from the todo_list_todos table. It enforces strict ownership, allowing only the authenticated user who owns the Todo to perform this action. This ensures compliance with the application's business rules and data lifecycle policies, as described in both the functional requirements and the Prisma schema.\n\nThe Todo deletion process validates that the Todo exists and is owned by the requesting user, preventing access to or deletion of Todos belonging to other users. The operation does not perform a soft delete; the record is removed completely from the database without retention.\n\nThis endpoint is directly associated with the todo_list_todos table. Security is enforced by requiring user authentication and verifying Todo ownership before deletion. No request body is needed, and a successful operation returns no data. If the Todo ID does not exist or does not belong to the user, a standard 'not found or forbidden' response will be returned, protecting user privacy.\n\nRelated operations include creation (POST /todos), retrieval (GET/PATCH /todos), and update (PUT /todos/{todoId}) endpoints. All other manipulations of Todo items are governed by their respective endpoints, while this operation is solely responsible for permanent removal. This operation ensures that user data is only accessible and modifiable by its rightful owner, and no batch deletions are permitted as per business constraints.","description":"Permanently delete a specific Todo item from the system, ensuring that only the authenticated owner can remove their own Todo. The operation begins by confirming the user's authentication status and validating that the Todo exists and is owned by the requester.\n\nIn compliance with the Prisma schema, each Todo is identified by a UUID, and deletion is allowed only if the requesting user's ID matches the todo_list_user_id foreign key of the target record. No soft-deletion or archival is performed; the Todo is removed from the database entirely.\n\nError handling is strict—if the Todo does not exist, or if ownership validation fails, the operation returns a not-found response to avoid leaking any information about other users' Todos. The endpoint does not accept a request body, nor does it return a data payload on success. Operation is idempotent: repeated deletion requests for the same nonexistent Todo will always return the same error message.\n\nSecurity is enforced by requiring the \"user\" role. Appropriate audit logging for data deletion should be considered at the service provider layer, in accordance with non-functional requirements and business rules.","summary":"Permanently delete a Todo item from the user's list (todo_list_todos table).","parameters":[{"name":"todoId","description":"The unique identifier of the Todo item to be deleted (UUID format)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"user","name":"erase","path":"/todoList/user/todos/{todoId}","method":"delete","prerequisites":[{"endpoint":{"path":"/todoList/user/todos","method":"post"},"description":"Todo item must be created before it can be deleted; ensures the Todo with the specified ID exists for the authenticated user."}]}],"components":{"authorization":[{"name":"user","description":"A registered user who can authenticate via API and manage their own Todo items, including creating, viewing, updating, and deleting their own tasks. Cannot access other users’ Todos or admin functions.","kind":"member"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageITodoListTodo.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListTodo.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ITodoListUser.IJoin":{"type":"object","x-autobe-prisma-schema":"todo_list_users","properties":{"email":{"type":"string","format":"email","description":"Unique user email address for registration and login. Must be in valid email format. This field is required and serves as a unique identifier in the minimal Todo List application. Email uniqueness is enforced as per the business rules and Prisma schema constraints.\n\nReference: Prisma todo_list_users.email column. Email is never exposed or used for any purpose other than authentication and account recovery."},"password":{"type":"string","minLength":8,"maxLength":72,"description":"Plain text password supplied for user registration. Must be between 8 and 72 characters for both security and technical compliance, even though only the hash is stored in the database. This field is used for login and never persisted in plain form. Password complexity (minimum length) is enforced by business rules.\n\nReference: Only a password_hash is stored in Prisma schema (column: password_hash), but plain password is required during registration and login. The application handles hashing before storage. Always treat as confidential input."}},"required":["email","password"],"description":"User registration DTO for minimal Todo List. Used as the request body in the /auth/user/join endpoint. Includes only the minimum required authentication fields—email and password. Extraneous fields are ignored. Upon submission, email is checked for uniqueness and password is securely hashed before storage.\n\nThis type directly corresponds to user registration use cases and enforces business constraints from the requirements analysis and Prisma schema for todo_list_users."},"ITodoListUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The unique identifier of the registered user in the todo_list_users table. Returned after successful authentication or registration. Used as primary key for associating Todos and session information.\n\nReference: Prisma todo_list_users.id column, which serves as the user's identity throughout the application."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response DTO returned after user registration, login, or token refresh. Contains both the unique user ID (corresponding to todo_list_users.id in the Prisma schema) and the issued authentication tokens for secure session use. All operations after authentication require this token.\n\nFulfills minimal business and security requirements for session/auth response as described in the requirements documentation and schema definitions."},"ITodoListUser.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"User's email address for login.\n\nRequired for authentication and serves as the unique identifier within the system. Must comply with RFC 5322 specifications for email format. Enforced uniqueness in the underlying database by the todo_list_users table, preventing duplicate accounts."},"password":{"type":"string","minLength":8,"maxLength":72,"description":"User's secret password in plain text (for login only, never stored directly).\n\nRequired for login; will be hashed before comparison to the password_hash field. Password must meet minimum length constraints and is subject to password policy checks. Not returned in responses or logs for security reasons."}},"required":["email","password"],"description":"Login request payload for authenticating a user in the Todo List application.\n\nContains both user email (unique identifier) and plain text password (never hashed).\n\nThis schema reflects core authentication logic for the login endpoint referencing the todo_list_users Prisma model. Entry is required to begin any authenticated session. Both fields undergo validation and strict type enforcement."},"ITodoListUser.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token value issued upon previous authentication, used to obtain new JWT access/refresh tokens.\n\nMust be presented as an opaque token string issued by the backend and managed securely on the client. Token is validated by the system and, if valid and unexpired, a new access/refresh token pair is granted. Required for token renewal workflows. Never stored in plain text on the server side."}},"required":["refresh_token"],"description":"Refresh token request body for obtaining a new access token in the Todo List application.\n\nThis schema is required for session extension via the /auth/user/refresh endpoint and is validated against issued refresh tokens. Only a valid, non-expired refresh_token will result in new JWT credentials."},"ITodoListTodo.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Current page number for Todo list pagination. Must be a positive integer (1-based). Allows clients to request a specific page of results. Default is usually 1 if not provided."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Number of Todo items per page for paginated listing. Must be between 1 and 100. Controls result volume to avoid overwhelming clients or saturating system resources. Default is typically 20-50 if not provided."},"completed":{"type":"boolean","description":"Optional filter to only return Todos that are completed (true) or not completed (false). If omitted, returns all Todos regardless of completion status."},"search":{"type":"string","maxLength":100,"description":"Optional case-insensitive search string to match against the title or description of the Todo. Allows quick keyword filtering. Search is performed only within the user's own Todos. Maximum 100 characters; longer values are truncated or rejected."},"sort_by":{"oneOf":[{"const":"created_at","description":"Sorting field for Todo list. Acceptable values: 'created_at' (default, newest first), or 'completed_at' (when filtering by completion). Determines primary order of results."},{"const":"completed_at","description":"Sorting field for Todo list. Acceptable values: 'created_at' (default, newest first), or 'completed_at' (when filtering by completion). Determines primary order of results."}],"description":"Sorting field for Todo list. Acceptable values: 'created_at' (default, newest first), or 'completed_at' (when filtering by completion). Determines primary order of results."},"order":{"oneOf":[{"const":"asc","description":"Sort direction for Todo list. Use 'desc' for descending order (newest first) or 'asc' for ascending order. Default is 'desc'."},{"const":"desc","description":"Sort direction for Todo list. Use 'desc' for descending order (newest first) or 'asc' for ascending order. Default is 'desc'."}],"description":"Sort direction for Todo list. Use 'desc' for descending order (newest first) or 'asc' for ascending order. Default is 'desc'."}},"required":[],"description":"Search and filter criteria for listing the authenticated user's Todo items. All filtering is performed only within the list of Todos owned by the authenticated user. Supports pagination, completion status filtering, keyword search, and result sorting. No external or global Todo data is accessible."},"ITodoListTodo":{"type":"object","x-autobe-prisma-schema":"todo_list_todos","properties":{"id":{"type":"string","format":"uuid","description":"Primary key identifier for this Todo item. Assigned as a UUID string upon creation in the database. Required for unique identification and client operations referencing this Todo."},"todo_list_user_id":{"type":"string","format":"uuid","description":"The owner's user ID (foreign key), referencing the todo_list_users.id field. Restricts Todo item to its creator. Set by backend according to the authenticated user context and not modifiable via API."},"title":{"type":"string","minLength":1,"maxLength":100,"description":"Concise summary/title of the task. Required; must be 1-100 UTF-8 characters. Cannot be empty, blank, or whitespace-only. Business logic enforces this constraint at every create/update operation."},"description":{"oneOf":[{"type":"string","maxLength":500,"description":"Optional further details of the task (may be empty). Maximum 500 characters. Null or omitted if not provided; always validated for max length on create/update."},{"type":"null"}],"description":"Optional detailed description of the Todo item, or null if not provided. Maximum 500 characters. Never required."},"completed":{"type":"boolean","description":"Task completion status. false if incomplete, true if complete. All Todos are created with this value as false by default (system-enforced). May be toggled by user at any time."},"created_at":{"type":"string","format":"date-time","description":"Timestamp of Todo creation, in ISO8601 date-time format with timezone. Assigned by backend at creation and never updated."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of the last modification of this Todo (including completion toggle, title update, or description change). Updated automatically on every change."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the Todo was marked complete, in ISO8601 date-time format with timezone, or null if not completed. Automatically set when completed status flips to true, cleared when set back to false."}},"required":["id","todo_list_user_id","title","completed","created_at","updated_at"],"description":"Represents a single task/todo owned by a user. Each record contains its unique ID, creator (user) ID, title, optional description, completion state, timestamps for creation, update, and potential completion. All access, updates, and deletions are scoped to the owning user and enforced by business logic and schema constraints. No external references or system-generated fields (such as 'deleted_at') are present in this schema."},"ITodoListTodo.ICreate":{"type":"object","x-autobe-prisma-schema":"todo_list_todos","properties":{"title":{"type":"string","minLength":1,"maxLength":100,"description":"Concise summary of the task. Required. Must be between 1 and 100 characters. This field is validated for non-empty, meaningful content as described in the Business Rules. Upon creation, a Todo's title provides its primary identification. Directly corresponds to the 'title' column in the prisma schema for todo_list_todos."},"description":{"oneOf":[{"type":"string","maxLength":500},{"type":"null"}],"description":"Optional detailed description of the task, up to 500 characters. Can be null if not provided. Used to capture additional details about the Todo, but not required. Directly corresponds to the 'description' column in the prisma schema for todo_list_todos."}},"required":["title"],"description":"Create DTO for a Todo item. This schema defines the information required to register a new task in the Todo list system.\n\n- Only the fields present in the Prisma model are accepted.\n- 'title': required, validated as a non-empty string with maximum length enforcement.\n- 'description': optional, up to 500 characters, or omitted/null. Client should omit or send null if not used.\n- Ownership, status, and audit/timestamp fields are set by the system, not the client.\n\nThis schema corresponds to the Prisma table 'todo_list_todos', and is utilized in POST operations for creating new Todo items for an authenticated user."},"ITodoListTodo.IUpdate":{"type":"object","x-autobe-prisma-schema":"todo_list_todos","properties":{"title":{"type":"string","minLength":1,"maxLength":100,"description":"Updated concise summary of the task. If provided, must be between 1 and 100 characters; validated for content and length as in creation. This field is optional in update. Directly references the 'title' column in todo_list_todos."},"description":{"oneOf":[{"type":"string","maxLength":500},{"type":"null"}],"description":"Optional new description of the task. If provided, must not exceed 500 characters. Can be null to remove the description. Optional in updates. Directly maps to 'description' in todo_list_todos."},"completed":{"type":"boolean","description":"Updated completion status for the Todo item. If provided, must be a boolean value. Indicates whether the Todo is marked as done. Business rule: only the owner can toggle this status. Prisma column: 'completed'."}},"required":[],"description":"Update DTO for a Todo item. This interface is used for PATCH/PUT requests for an existing Todo belonging to the authenticated user.\n\n- All fields optional; if provided, must satisfy business validation (title: 1-100 chars, description: up to 500 chars, completed: boolean).\n- Fields not present in request are left unchanged.\n- Ownership, id, audit, and timestamps are not changeable via this DTO.\n\nDirectly references the corresponding Prisma schema 'todo_list_todos'. This type should be used in all update (PUT/PATCH) operations for a user's existing Todos."},"ITodoListTodo.ISummary":{"type":"object","x-autobe-prisma-schema":"todo_list_todos","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the Todo item. This field is the primary key in the todo_list_todos Prisma table. It allows for precise referencing, updating, and deletion of Todo records. The value is automatically generated as a UUID when the Todo is created and should never be modified by the client.\n\nBusiness context: Enables consistent, unambiguous identification of each Todo resource for authenticated users."},"title":{"type":"string","maxLength":100,"minLength":1,"description":"The concise summary or name of the Todo. As per the business requirements and Prisma schema, the title is required, must contain at least 1 character and no more than 100. It cannot be empty or whitespace. Used for quick identification and list display of Todos.\n\nValidation: Ensures all created and updated records meet length and non-empty constraints as mandated by business rules. The application must enforce UTF-8 string compliance."},"description":{"oneOf":[{"type":"string","maxLength":500,"description":"Optional extended details for the Todo item, up to 500 characters. This property is nullable and might not be provided. It is not required for basic Todo creation or update, but if supplied, must not exceed the maximum length constraint defined in the Prisma schema.\n\nIf null or omitted, the Todo appears as having no additional notes or comments."},{"type":"null"}],"description":"Optional extended details for the Todo item, up to 500 characters. This property is nullable and might not be provided. It is not required for basic Todo creation or update, but if supplied, must not exceed the maximum length constraint defined in the Prisma schema.\n\nIf null or omitted, the Todo appears as having no additional notes or comments."},"completed":{"type":"boolean","description":"Indicates whether the Todo has been marked complete by the user. A value of true means the task has been finished, while false means it is still active/incomplete. As defined in the Prisma schema, the default value is false upon creation, and can only be toggled by the Todo owner.\n\nBusiness rule: This is a strictly boolean field, never nullable, and is used for filtering, searching, and statistics functions."},"created_at":{"type":"string","format":"date-time","description":"Timestamp for when the Todo was initially created. This uses the ISO 8601 date-time format with timezone as defined by the Prisma schema. It is set by the system when the record is inserted and is never modified thereafter.\n\nPurpose: Used for list ordering (most recent first) and for audit/history features."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of the most recent update to this Todo record, including title/description changes or completion status toggles. Populated and maintained by the system, never by client. ISO 8601 format with timezone.\n\nSupports auditability and enables clients to refresh/update only changed items."},"completed_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp of when the Todo was completed, according to the Prisma schema (nullable field). If the item is incomplete, this should be null. If completed, this records the moment status switched to complete.\n\nDisplayed to the user where a completed/archived date is relevant."},{"type":"null"}],"description":"Timestamp of when the Todo was completed, according to the Prisma schema (nullable field). If the item is incomplete, this should be null. If completed, this records the moment status switched to complete.\n\nDisplayed to the user where a completed/archived date is relevant."}},"required":["id","title","completed","created_at","updated_at"],"description":"Minimal summary object for a Todo item, strictly conforming to the todo_list_todos Prisma model. Optimized for list views and search results. Contains only essential fields for UI display and action, omitting large or sensitive fields.\n\nIncludes id (UUID), title (required), optional description, completion status (boolean), and audit timestamps (created_at, updated_at, completed_at). All fields and business rules reference the todo_list_todos schema and application validation requirements.\n\nBusiness context: Serves as a safe, fast-to-render representation of a Todo for authenticated users' own data only."}}}},"missed":[],"created_at":"2025-10-07T15:41:50.505Z","completed_at":"2025-10-07T15:49:21.805Z","step":0},{"id":"0199bf5c-f8db-70ab-b9d1-50f7023919bb","type":"userMessage","contents":[{"type":"text","text":"Make the e2e test functions."}],"created_at":"2025-10-07T15:49:25.339Z"},{"type":"test","id":"0199bf62-d77f-75d0-b966-fbb436e40876","instruction":"Generate E2E test cases for the minimal Todo list API. Focus on validating core functionalities: creating, reading, updating, and deleting Todo items. Each test should verify correct API operation, proper data validation, and expected behavior for basic success and failure scenarios. Since this is a minimal application, do not cover advanced or edge-case features.","files":[{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Test the core user registration flow for the Todo List application. Verify that a new user can successfully register using a unique email and a valid password, and receives authentication tokens in the response. Ensure that account creation correctly sets created_at and updated_at, with last_login as null. Validate that registration cannot proceed with a duplicate email, enforcing uniqueness constraints. The scenario covers both successful and duplicate-registration attempt cases, focusing strictly on the minimal registration and uniqueness requirements. No authentication is required for this public operation.","functionName":"test_api_user_registration_basic_success","dependencies":[]},"location":"test/features/api/auth/test_api_user_registration_basic_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test the basic user registration process for the Todo List API.\n *\n * This test verifies two primary scenarios:\n *\n * 1. A new user can successfully register using a unique email (format-validated)\n *    and a password (8-72 chars), and receives a valid response with\n *    authentication tokens. The response structure and types are fully\n *    validated.\n * 2. Attempting to register again with the same email results in an error, as\n *    duplicate emails are not allowed (uniqueness constraint is enforced at\n *    API/DB level).\n *\n * Steps:\n *\n * 1. Generate a random, valid email and password.\n * 2. Make a POST request to /auth/user/join with these credentials and expect a\n *    successful authorized user response with tokens. Use typia.assert for\n *    schema correctness.\n * 3. Make a second POST to /auth/user/join with the exact same email and password,\n *    and expect an error (using TestValidator.error), confirming the API's\n *    duplicate registration prevention.\n */\nexport async function test_api_user_registration_basic_success(\n  connection: api.IConnection,\n) {\n  // Step 1: Generate random credentials (email and password)\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12); // length between 8 and 72\n\n  // Step 2: Register user\n  const authResponse = await api.functional.auth.user.join(connection, {\n    body: { email, password } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(authResponse); // Full DTO validation\n\n  // Step 3: Attempt duplicate registration, expect error\n  await TestValidator.error(\n    \"registering with duplicate email must fail\",\n    async () => {\n      await api.functional.auth.user.join(connection, {\n        body: { email, password } satisfies ITodoListUser.IJoin,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/refresh","method":"post"},"draft":"Test renewing authentication tokens using a valid refresh token after registration. The scenario covers a full workflow: registering a user, obtaining refresh token, and using it to get new tokens successfully. The test ensures a user can continue their session seamlessly by refreshing tokens without re-authenticating.","functionName":"test_api_refresh_token_success_path","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a new user to receive initial authentication and refresh tokens required for refresh endpoint."}]},"location":"test/features/api/auth/test_api_refresh_token_success_path.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test successful authentication token renewal using refresh token after user\n * registration.\n *\n * 1. Register a new minimal user (random, valid email and password).\n * 2. Assert the registration response and extract id and tokens.\n * 3. Call the /auth/user/refresh endpoint with the correct refresh token.\n * 4. Assert the refresh response and validate:\n *\n *    - User id remains the same.\n *    - The new token values (access, refresh) differ from the originals.\n *    - All response fields and types are valid.\n */\nexport async function test_api_refresh_token_success_path(\n  connection: api.IConnection,\n) {\n  // 1. Register new user\n  const joinInput = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(10),\n  } satisfies ITodoListUser.IJoin;\n  const original = await api.functional.auth.user.join(connection, {\n    body: joinInput,\n  });\n  typia.assert(original);\n\n  // 2. Prepare refresh body with correct token\n  const refreshBody = {\n    refresh_token: original.token.refresh,\n  } satisfies ITodoListUser.IRefresh;\n  const refreshed = await api.functional.auth.user.refresh(connection, {\n    body: refreshBody,\n  });\n  typia.assert(refreshed);\n\n  // 3. Validate that id is unchanged\n  TestValidator.equals(\n    \"user id remains consistent after refresh\",\n    refreshed.id,\n    original.id,\n  );\n  // 4. Validate new tokens are issued and not equal to originals\n  TestValidator.notEquals(\n    \"access token changes on refresh\",\n    refreshed.token.access,\n    original.token.access,\n  );\n  TestValidator.notEquals(\n    \"refresh token changes on refresh\",\n    refreshed.token.refresh,\n    original.token.refresh,\n  );\n  // 5. Assert the structure and types again explicitly\n  typia.assert(refreshed.token);\n  typia.assert(original.token);\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos","method":"patch"},"draft":"Test listing Todo items for an authenticated user. The workflow includes registering a user, creating several Todo items, and retrieving the paginated, filtered Todo list via this endpoint. It confirms only the authenticated user's own Todos are accessible and validates filtering, ordering, and pagination parameters in the search request body.","functionName":"test_api_index_todos_list_basic_workflow","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a new user and obtain authentication tokens to access endpoints requiring the user role."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create Todo item #1 for list retrieval test."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create Todo item #2 for list retrieval test."}]},"location":"test/features/api/todo_list_todo/test_api_index_todos_list_basic_workflow.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validates the listing of Todo items for an authenticated user.\n *\n * This test covers:\n *\n * 1. User registration and authentication\n * 2. Creating several user-owned Todo items\n * 3. Paginated, sorted, and filtered retrieval via the /todoList/user/todos\n *    endpoint (PATCH)\n * 4. Validation that only the authenticated user's Todos are listed\n * 5. Verification of result data, pagination fields, and correct filtering\n */\nexport async function test_api_index_todos_list_basic_workflow(\n  connection: api.IConnection,\n) {\n  // 1. Register new user\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12);\n  const auth: ITodoListUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: { email, password } satisfies ITodoListUser.IJoin,\n    },\n  );\n  typia.assert(auth);\n  TestValidator.predicate(\n    \"registered user id should be uuid\",\n    /[0-9a-f\\-]{36}/.test(auth.id),\n  );\n  TestValidator.predicate(\n    \"token must contain access\",\n    typeof auth.token.access === \"string\",\n  );\n\n  // 2. Create Todos for the user\n  const TODOS_COUNT = 5;\n  const todoSeeds = ArrayUtil.repeat(\n    TODOS_COUNT,\n    (i) =>\n      ({\n        title: `Test Todo ${i + 1}`,\n        description: `Description ${i + 1}`,\n      }) satisfies ITodoListTodo.ICreate,\n  );\n\n  const userTodos: ITodoListTodo[] = [];\n  for (const body of todoSeeds) {\n    const todo = await api.functional.todoList.user.todos.create(connection, {\n      body,\n    });\n    typia.assert(todo);\n    // All Todos must be incomplete (completed === false) at creation\n    TestValidator.equals(\n      `created todo ${todo.title} is not completed`,\n      todo.completed,\n      false,\n    );\n    userTodos.push(todo);\n  }\n\n  // 3. List Todos - default (no filters)\n  const pageResult: IPageITodoListTodo.ISummary =\n    await api.functional.todoList.user.todos.index(connection, {\n      body: {} satisfies ITodoListTodo.IRequest,\n    });\n  typia.assert(pageResult);\n  TestValidator.equals(\n    \"pagination limit positive\",\n    pageResult.pagination.limit > 0,\n    true,\n  );\n  TestValidator.equals(\n    \"pagination page is valid\",\n    pageResult.pagination.current >= 0,\n    true,\n  );\n  TestValidator.predicate(\n    \"data should not be empty\",\n    pageResult.data.length > 0,\n  );\n  // Confirm that only created Todos exist in the results\n  userTodos.forEach((todo) => {\n    TestValidator.predicate(\n      `todo with id ${todo.id} is listed`,\n      pageResult.data.some((row) => row.id === todo.id),\n    );\n  });\n\n  // 4. List Todos - filter by completed=false (all should be incomplete)\n  const pageResultIncomplete = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: { completed: false } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(pageResultIncomplete);\n  pageResultIncomplete.data.forEach((todo) => {\n    TestValidator.equals(\"todo is not completed\", todo.completed, false);\n  });\n\n  // 5. List Todos - filter by search (use a substring from title)\n  const searchTodo = userTodos[0];\n  const searchKeyword = searchTodo.title.substring(2, 7); // partial, to check search support\n  const searchResult = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: { search: searchKeyword } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(searchResult);\n  TestValidator.predicate(\n    \"search yields at least one match\",\n    searchResult.data.length > 0,\n  );\n  TestValidator.predicate(\n    \"at least one todo title/description matches search\",\n    searchResult.data.some(\n      (todo) =>\n        todo.title.includes(searchKeyword) ||\n        (todo.description ?? \"\").includes(searchKeyword),\n    ),\n  );\n\n  // 6. List Todos - ordering and pagination\n  const pageLimited = await api.functional.todoList.user.todos.index(\n    connection,\n    {\n      body: {\n        limit: 3,\n        page: 1,\n        sort_by: \"created_at\",\n        order: \"desc\",\n      } satisfies ITodoListTodo.IRequest,\n    },\n  );\n  typia.assert(pageLimited);\n  TestValidator.equals(\"page limit respected\", pageLimited.data.length, 3);\n  TestValidator.predicate(\n    \"all listed are user todos\",\n    pageLimited.data.every((row) => userTodos.some((t) => t.id === row.id)),\n  );\n  // Confirm ordering (created_at desc)\n  for (let i = 1; i < pageLimited.data.length; ++i) {\n    TestValidator.predicate(\n      `todos are sorted by created_at desc (idx ${i})`,\n      pageLimited.data[i - 1].created_at >= pageLimited.data[i].created_at,\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoList/user/todos/{todoId}"},"draft":"Test that an authenticated user can successfully update their own Todo item, modifying the title, optional description, and completion status. The workflow includes user registration, Todo creation, and then updating that Todo's fields. Validates that the updated fields are correctly persisted, the updated_at timestamp changes, and the completed status accurately reflects modifications.","functionName":"test_api_todo_update_successful_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register and authenticate user as owner of the Todo to provide required credentials for all further steps."},{"endpoint":{"method":"post","path":"/todoList/user/todos"},"purpose":"Create the Todo item to provide a valid todoId for the update test."}]},"location":"test/features/api/todo_list_todo/test_api_todo_update_successful_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validates that an authenticated user can update their own Todo item (title,\n * description, and completion status).\n *\n * Workflow:\n *\n * 1. Register and authenticate a new user\n * 2. Create a Todo item as the authenticated user\n * 3. Update the Todo's title, description, and completed status\n * 4. Validate that updates persisted, updated_at timestamp has changed, and that\n *    completed/completed_at are consistent\n */\nexport async function test_api_todo_update_successful_by_owner(\n  connection: api.IConnection,\n) {\n  // 1. Register user\n  const userBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n  } satisfies ITodoListUser.IJoin;\n  const auth: ITodoListUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    { body: userBody },\n  );\n  typia.assert(auth);\n\n  // 2. Create Todo\n  const createBody = {\n    title: RandomGenerator.paragraph({ sentences: 3 }),\n    description: RandomGenerator.paragraph({ sentences: 8 }),\n  } satisfies ITodoListTodo.ICreate;\n  const created: ITodoListTodo =\n    await api.functional.todoList.user.todos.create(connection, {\n      body: createBody,\n    });\n  typia.assert(created);\n\n  // 3. Update Todo\n  const updateBody = {\n    title: RandomGenerator.paragraph({ sentences: 2 }),\n    description: RandomGenerator.paragraph({ sentences: 4 }),\n    completed: !created.completed,\n  } satisfies ITodoListTodo.IUpdate;\n  const updated: ITodoListTodo =\n    await api.functional.todoList.user.todos.update(connection, {\n      todoId: created.id,\n      body: updateBody,\n    });\n  typia.assert(updated);\n\n  // 4. Assertions\n  TestValidator.equals(\"updated id matches original\", updated.id, created.id);\n  TestValidator.equals(\n    \"owner remains the same\",\n    updated.todo_list_user_id,\n    auth.id,\n  );\n  TestValidator.equals(\"title updated\", updated.title, updateBody.title);\n  TestValidator.equals(\n    \"description updated\",\n    updated.description,\n    updateBody.description,\n  );\n  TestValidator.equals(\n    \"completed status updated\",\n    updated.completed,\n    updateBody.completed,\n  );\n  TestValidator.notEquals(\n    \"updated_at timestamp advanced\",\n    updated.updated_at,\n    created.updated_at,\n  );\n  if (updated.completed)\n    TestValidator.predicate(\n      \"completed_at set when completed\",\n      updated.completed_at !== null && updated.completed_at !== undefined,\n    );\n  else\n    TestValidator.equals(\n      \"completed_at cleared when uncompleted\",\n      updated.completed_at,\n      null,\n    );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoList/user/todos/{todoId}"},"draft":"Test that an authenticated user can successfully delete one of their own Todo items. The workflow covers user registration, Todo creation, and deletion. Checks that the deleted Todo is no longer available after deletion and that repeat deletion attempts return the correct not-found error.","functionName":"test_api_todo_delete_successful_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Register and authenticate user as owner of the Todo to provide required credentials for all further steps."},{"endpoint":{"method":"post","path":"/todoList/user/todos"},"purpose":"Create the Todo item to provide a valid todoId for the deletion test."}]},"location":"test/features/api/todo_list_todo/test_api_todo_delete_successful_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate that a minimal Todo List user can successfully delete their own Todo\n * item.\n *\n * This test ensures that a typical user can follow the workflow of\n * registration, Todo creation, and then deletion, using only core required\n * fields and satisfying all DTO type and business logic constraints. It\n * verifies successful deletion and ensures that the same Todo cannot be deleted\n * twice (repeat delete yields an error). This covers the minimal success and\n * core failure scenario.\n *\n * Steps:\n *\n * 1. Register a new user (with unique email/password).\n * 2. Create a Todo as that user (valid title, no description required).\n * 3. Delete the Todo by id as the owner.\n * 4. Attempt to delete the Todo again and check for not-found error.\n */\nexport async function test_api_todo_delete_successful_by_owner(\n  connection: api.IConnection,\n) {\n  // 1. Register user for session\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(10);\n  const auth = await api.functional.auth.user.join(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(auth);\n\n  // 2. Create a Todo item as the user\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: {\n      title: RandomGenerator.paragraph({\n        sentences: 3,\n        wordMin: 3,\n        wordMax: 10,\n      }),\n      description: null,\n    } satisfies ITodoListTodo.ICreate,\n  });\n  typia.assert(todo);\n\n  // 3. Delete the Todo item\n  await api.functional.todoList.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // 4. Attempt to delete again and expect an error (not found)\n  await TestValidator.error(\n    \"repeat deletion returns not-found error\",\n    async () => {\n      await api.functional.todoList.user.todos.erase(connection, {\n        todoId: todo.id,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos/{todoId}","method":"get"},"draft":"Test that an authenticated user can retrieve detailed information about a Todo item they own. The flow should include registering a new user, authenticating the session, creating a Todo, and then requesting the details with the returned todoId. Validate that the response contains the full set of Todo fields as documented (id, title, description, completed status, timestamps), and that the ownership enforcement ensures only the creator can access the details.","functionName":"test_api_todo_detail_retrieval_by_owner","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a new user and obtain authentication tokens for further Todo operations."},{"endpoint":{"path":"/todoList/user/todos","method":"post"},"purpose":"Create a Todo item owned by this user to ensure there is a retrievable resource for the detail request."}]},"location":"test/features/api/todo_list/test_api_todo_detail_retrieval_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Validate detailed retrieval of a user's own Todo item.\n *\n * This test confirms that an authenticated user can register, create a Todo,\n * then retrieve the full details (including id, title, description, completed,\n * created_at, updated_at, completed_at, owner) of that Todo using the API. It\n * verifies that the response fields are present and correct, and that the Todo\n * is linked only to the authenticated creator. The flow is:\n *\n * 1. Register a new user with unique email and valid password.\n * 2. Create a Todo for that user (using title and description).\n * 3. Retrieve details for the created Todo by its id using the authenticated\n *    session.\n * 4. Validate that the entire Todo response matches expectations and ownership is\n *    enforced.\n */\nexport async function test_api_todo_detail_retrieval_by_owner(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const userJoin = await api.functional.auth.user.join(connection, {\n    body: {\n      email: typia.random<string & tags.Format<\"email\">>(),\n      password: RandomGenerator.alphaNumeric(12) as string &\n        tags.MinLength<8> &\n        tags.MaxLength<72>,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(userJoin);\n  // 2. Create a Todo as this user\n  const todoCreate = await api.functional.todoList.user.todos.create(\n    connection,\n    {\n      body: {\n        title: RandomGenerator.paragraph({\n          sentences: 3,\n          wordMin: 4,\n          wordMax: 16,\n        }) as string & tags.MinLength<1> & tags.MaxLength<100>,\n        description: RandomGenerator.paragraph({\n          sentences: 10,\n          wordMin: 2,\n          wordMax: 8,\n        }) as string & tags.MaxLength<500>,\n      } satisfies ITodoListTodo.ICreate,\n    },\n  );\n  typia.assert(todoCreate);\n  // 3. Retrieve detailed Todo by ID\n  const todoDetail = await api.functional.todoList.user.todos.at(connection, {\n    todoId: todoCreate.id,\n  });\n  typia.assert(todoDetail);\n  // 4. Validate all details and ownership\n  TestValidator.equals(\n    \"detail id matches created id\",\n    todoDetail.id,\n    todoCreate.id,\n  );\n  TestValidator.equals(\n    \"detail title is correct\",\n    todoDetail.title,\n    todoCreate.title,\n  );\n  TestValidator.equals(\n    \"detail description is correct\",\n    todoDetail.description ?? null,\n    todoCreate.description ?? null,\n  );\n  TestValidator.equals(\n    \"completed status is false by default\",\n    todoDetail.completed,\n    false,\n  );\n  TestValidator.equals(\n    \"owner is authenticated user\",\n    todoDetail.todo_list_user_id,\n    userJoin.id,\n  );\n  TestValidator.predicate(\n    \"created_at is ISO 8601\",\n    typeof todoDetail.created_at === \"string\" &&\n      !isNaN(Date.parse(todoDetail.created_at)),\n  );\n  TestValidator.predicate(\n    \"updated_at is ISO 8601\",\n    typeof todoDetail.updated_at === \"string\" &&\n      !isNaN(Date.parse(todoDetail.updated_at)),\n  );\n  TestValidator.equals(\n    \"completed_at null when incomplete\",\n    todoDetail.completed_at ?? null,\n    null,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test user login succeeds with valid credentials. First, register a new user account via the join endpoint. Then, attempt to log in using the same email and password. Verify that authentication tokens are returned and last_login is updated. Ensure proper handling of credential comparison without revealing unnecessary error details.","functionName":"test_api_user_login_with_valid_credentials","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a user account to be able to test login operation"}]},"location":"test/features/api/auth/test_api_user_login_with_valid_credentials.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test user login succeeds with valid credentials.\n *\n * 1. Register a new user with a unique email and valid password using the join\n *    endpoint.\n * 2. Attempt to login with the same credentials.\n * 3. Verify that authentication tokens and user ID are returned upon login.\n * 4. Ensure no unwanted details are exposed on successful login.\n */\nexport async function test_api_user_login_with_valid_credentials(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12);\n\n  const joinPayload = {\n    email,\n    password,\n  } satisfies ITodoListUser.IJoin;\n\n  const registerResult = await api.functional.auth.user.join(connection, {\n    body: joinPayload,\n  });\n  typia.assert(registerResult);\n\n  // 2. Login with the same credentials\n  const loginPayload = {\n    email,\n    password,\n  } satisfies ITodoListUser.ILogin;\n\n  const loginResult = await api.functional.auth.user.login(connection, {\n    body: loginPayload,\n  });\n  typia.assert(loginResult);\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test user login fails with invalid credentials. Register a user, then attempt login with incorrect password. Verify that the response is a generic error and does not reveal which field is incorrect for security reasons. Ensure that last_login is not updated for failed attempts.","functionName":"test_api_user_login_with_invalid_credentials","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Register a user account so invalid login can be tested against a real account"}]},"location":"test/features/api/auth/test_api_user_login_with_invalid_credentials.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test user login fails with invalid credentials.\n *\n * 1. Register a user with a valid random email and password via /auth/user/join\n * 2. Attempt login via /auth/user/login using the registered email but an\n *    incorrect password\n * 3. Assert that login fails with a generic error (no user info leakage)\n * 4. (Documented) Cannot check last_login not updated directly via public API, but\n *    this business logic is described here for test coverage\n */\nexport async function test_api_user_login_with_invalid_credentials(\n  connection: api.IConnection,\n) {\n  // 1. Register a user account\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12); // Valid length (8-72)\n  const joinBody = {\n    email,\n    password,\n  } satisfies ITodoListUser.IJoin;\n  const registered: ITodoListUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: joinBody });\n  typia.assert(registered);\n\n  // 2. Attempt login with incorrect password\n  const invalidLoginBody = {\n    email,\n    password: password + \"!\", // Wrong password\n  } satisfies ITodoListUser.ILogin;\n  await TestValidator.error(\n    \"login should fail with incorrect password\",\n    async () => {\n      await api.functional.auth.user.login(connection, {\n        body: invalidLoginBody,\n      });\n    },\n  );\n\n  // 3. (Cannot check server-side last_login update with current API)\n}\n"},{"scenario":{"endpoint":{"path":"/todoList/user/todos","method":"post"},"draft":"Test successful creation of a new Todo item by an authenticated user. Register a new user account, authenticate, and create a Todo with valid title and (optional) description. Verify the created Todo is attributed to the requesting user, has correct default completion status, and proper timestamps are set.","functionName":"test_api_todo_creation_by_user","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Establish a new authenticated user before creating a Todo item"}]},"location":"test/features/api/todo_list_todo/test_api_todo_creation_by_user.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport type { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\n\n/**\n * Test successful creation of a new Todo item by an authenticated user.\n *\n * 1. Register a new user via the join API.\n * 2. Ensure the returned user object contains a valid UUID and auth token.\n * 3. Prepare a Todo creation payload with valid title and (optional) description.\n * 4. Call the Todo creation endpoint as the authenticated user.\n * 5. Assert the Todo is attributed to the right user, is incomplete by default,\n *    and has required timestamps. Accept either null or undefined as correct\n *    for 'completed_at'.\n */\nexport async function test_api_todo_creation_by_user(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(10);\n  const registration = await api.functional.auth.user.join(connection, {\n    body: {\n      email,\n      password,\n    } satisfies ITodoListUser.IJoin,\n  });\n  typia.assert(registration);\n\n  // 2. Prepare Todo creation request\n  const createTodoPayload = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.paragraph({\n      sentences: 8,\n      wordMin: 3,\n      wordMax: 10,\n    }),\n  } satisfies ITodoListTodo.ICreate;\n\n  // 3. Create the Todo\n  const todo = await api.functional.todoList.user.todos.create(connection, {\n    body: createTodoPayload,\n  });\n  typia.assert(todo);\n\n  // 4. Validate Todo business correctness\n  TestValidator.equals(\n    \"todo is attributed to correct user\",\n    todo.todo_list_user_id,\n    registration.id,\n  );\n  TestValidator.equals(\n    \"default completion state is false\",\n    todo.completed,\n    false,\n  );\n  TestValidator.predicate(\n    \"todo title matches payload\",\n    todo.title === createTodoPayload.title,\n  );\n  TestValidator.predicate(\n    \"todo description matches\",\n    todo.description === createTodoPayload.description,\n  );\n  TestValidator.predicate(\n    \"completed_at should be null or undefined, as task is incomplete\",\n    todo.completed_at === null || todo.completed_at === undefined,\n  );\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-10-07T15:49:28.401Z","completed_at":"2025-10-07T15:55:50.015Z","step":0},{"id":"0199bf62-defa-756c-932c-5cded897030f","type":"userMessage","contents":[{"type":"text","text":"Implement API functions."}],"created_at":"2025-10-07T15:55:51.930Z"},{"type":"realize","id":"0199bf6a-be17-706b-b981-f1dd7ab8b192","instruction":"Implement the service logic for a minimal Todo list application. Ensure the code supports creating, reading, updating, and deleting Todo items, each with a title, optional description, completion status, and creation date. Focus only on the minimum business logic required for these basic CRUD operations, without adding advanced features or complex flows.","authorizations":[{"error_analysis":"No TypeScript errors found in userAuthorize or UserAuth, but compilation fails in src/MyGlobal.ts due to missing './MyConfiguration' module. This does not affect the authentication provider/decorator. Role/type naming is correct. Database table field and relationship are correct per Prisma schema.","solution_guidance":"Provider and decorator code are correct for the 'user' role: userAuthorize queries todo_list_users by id; UserAuth properly decorates controller parameters. The Prisma table and payload match; no code change needed. To fix overall build, restore or mock './MyConfiguration' import in src/MyGlobal.ts.","provider":{"name":"userAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { UserPayload } from \"../../decorators/payload/UserPayload\";\n\n/**\n * Authenticates and authorizes a registered user (todo_list_users).\n *\n * Verifies a valid JWT token, enforces the role type to be \"user\",\n * and confirms the user exists via the todo_list_users table\n * using the top-level user id. This function forms the core of\n * user-auth access control for todo management APIs.\n *\n * @param request Express request containing headers object\n * @returns The verified UserPayload if authorization is successful\n * @throws ForbiddenException if authorization fails\n */\nexport async function userAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<UserPayload> {\n  const payload: UserPayload = jwtAuthorize({ request }) as UserPayload;\n\n  if (payload.type !== \"user\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // payload.id is always the primary key of todo_list_users (top-level user)\n  const user = await MyGlobal.prisma.todo_list_users.findFirst({\n    where: {\n      id: payload.id,\n    },\n  });\n\n  if (user === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/userAuthorize.ts"},"decorator":{"name":"UserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { userAuthorize } from \"../providers/authorize/userAuthorize\";\n\n/**\n * Parameter decorator for authenticating a registered user (UserAuth).\n *\n * Injects the authorized UserPayload into controller methods and ensures\n * Swagger API docs are properly annotated for bearer authentication.\n */\nexport const UserAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return userAuthorize(request);\n  })(),\n);\n","location":"src/decorators/UserAuth.ts"},"payload":{"name":"UserPayload","location":"src/decorators/payload/UserPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * JWT payload interface for a regular user account.\n *\n * - Id: Always the top-level user id (todo_list_users.id; UUID)\n * - Type: \"user\" discriminator\n */\nexport interface UserPayload {\n  /** Top-level user table ID (the fundamental user identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the discriminated union type. */\n  type: \"user\";\n}\n"},"role":{"name":"user","description":"A registered user who can authenticate via API and manage their own Todo items, including creating, viewing, updating, and deleting their own tasks. Cannot access other users’ Todos or admin functions.","kind":"member"}}],"functions":[{"location":"src/providers/postTodoListUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function postTodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.ICreate;\n}): Promise<ITodoListTodo> {\n  const now = toISOStringSafe(new Date());\n  const created = await MyGlobal.prisma.todo_list_todos.create({\n    data: {\n      id: v4(),\n      todo_list_user_id: props.user.id,\n      title: props.body.title,\n      description:\n        props.body.description !== undefined ? props.body.description : null,\n      completed: false,\n      created_at: now,\n      updated_at: now,\n      completed_at: null,\n    },\n  });\n  return {\n    id: created.id,\n    todo_list_user_id: created.todo_list_user_id,\n    title: created.title,\n    ...(created.description !== undefined && {\n      description: created.description,\n    }),\n    completed: created.completed,\n    created_at: toISOStringSafe(created.created_at),\n    updated_at: toISOStringSafe(created.updated_at),\n    ...(created.completed_at !== undefined && {\n      completed_at:\n        created.completed_at !== null\n          ? toISOStringSafe(created.completed_at)\n          : created.completed_at,\n    }),\n  };\n}\n","endpoint":{"method":"post","path":"/todoList/user/todos"},"name":"postTodoListUserTodos"},{"location":"src/providers/postAuthUserJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserJoin(props: {\n  body: ITodoListUser.IJoin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { email, password } = props.body;\n\n  // 1. Enforce unique email\n  const existing = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { email },\n  });\n  if (existing) {\n    throw new HttpException(\"Email already registered\", 409);\n  }\n\n  // 2. Hash password\n  const password_hash = await PasswordUtil.hash(password);\n\n  // 3. Prepare id and timestamps\n  const now = toISOStringSafe(new Date());\n  // id must be uuid (schema requires manual id)\n  const id = v4();\n\n  // 4. Create user (last_login omitted - remains null)\n  const created = await MyGlobal.prisma.todo_list_users.create({\n    data: {\n      id,\n      email,\n      password_hash,\n      created_at: now,\n      updated_at: now,\n    },\n  });\n\n  // 5. JWT token generation and expiry calculations\n  const payload = { id: created.id, type: \"user\" };\n  const secret = MyGlobal.env.JWT_SECRET_KEY;\n\n  const accessExpiresAtMillis = Date.now() + 60 * 60 * 1000;\n  const refreshExpiresAtMillis = Date.now() + 7 * 24 * 60 * 60 * 1000;\n  const expired_at = toISOStringSafe(new Date(accessExpiresAtMillis));\n  const refreshable_until = toISOStringSafe(new Date(refreshExpiresAtMillis));\n\n  const access = jwt.sign(payload, secret, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(payload, secret, {\n    expiresIn: \"7d\",\n    issuer: \"autobe\",\n  });\n\n  return {\n    id: created.id,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/join"},"name":"postAuthUserJoin"},{"location":"src/providers/postAuthUserLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserLogin(props: {\n  body: ITodoListUser.ILogin;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { email, password } = props.body;\n  // Find user by email\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { email },\n  });\n  if (!user) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n  const valid = await PasswordUtil.verify(password, user.password_hash);\n  if (!valid) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n  // Update last_login (Date converted to ISO string)\n  const now = toISOStringSafe(new Date());\n  await MyGlobal.prisma.todo_list_users.update({\n    where: { id: user.id },\n    data: { last_login: now },\n  });\n\n  // JWT access/refresh tokens\n  const accessTokenExpiresInSeconds = 60 * 60; // 1 hour\n  const refreshTokenExpiresInSeconds = 60 * 60 * 24 * 7; // 7 days\n  const accessExpiredAt = toISOStringSafe(\n    new Date(Date.now() + accessTokenExpiresInSeconds * 1000),\n  );\n  const refreshExpiredAt = toISOStringSafe(\n    new Date(Date.now() + refreshTokenExpiresInSeconds * 1000),\n  );\n\n  const access = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: accessTokenExpiresInSeconds,\n      issuer: \"autobe\",\n    },\n  );\n  const refresh = jwt.sign(\n    { id: user.id, type: \"user\", token_type: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: refreshTokenExpiresInSeconds,\n      issuer: \"autobe\",\n    },\n  );\n\n  return {\n    id: user.id,\n    token: {\n      access,\n      refresh,\n      expired_at: accessExpiredAt,\n      refreshable_until: refreshExpiredAt,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/login"},"name":"postAuthUserLogin"},{"location":"src/providers/postAuthUserRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserRefresh(props: {\n  body: ITodoListUser.IRefresh;\n}): Promise<ITodoListUser.IAuthorized> {\n  const { refresh_token } = props.body;\n\n  let decoded;\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch (_err) {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n\n  // Payload validation: Must have id and type === \"user\"\n  if (\n    !decoded ||\n    typeof decoded !== \"object\" ||\n    !(\"id\" in decoded) ||\n    decoded.type !== \"user\"\n  ) {\n    throw new HttpException(\"Invalid refresh token payload\", 401);\n  }\n  const id = decoded.id;\n  if (typeof id !== \"string\") {\n    throw new HttpException(\"Invalid refresh token payload\", 401);\n  }\n\n  // Expect user to exist\n  const user = await MyGlobal.prisma.todo_list_users.findUnique({\n    where: { id },\n  });\n  if (!user) {\n    throw new HttpException(\"User not found for this refresh token\", 401);\n  }\n\n  // Issue new tokens\n  const nowEpoch = Date.now();\n  const accessExpiresAt = nowEpoch + 60 * 60 * 1000; // 1 hour\n  const refreshExpiresAt = nowEpoch + 30 * 24 * 60 * 60 * 1000; // 30 days\n\n  const payload = { id: user.id, type: \"user\" };\n  const access = jwt.sign(payload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n  const refresh = jwt.sign(payload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"30d\",\n    issuer: \"autobe\",\n  });\n\n  const expired_at = toISOStringSafe(new Date(accessExpiresAt));\n  const refreshable_until = toISOStringSafe(new Date(refreshExpiresAt));\n\n  return {\n    id: user.id,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/refresh"},"name":"postAuthUserRefresh"},{"location":"src/providers/patchTodoListUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListTodo\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function patchTodoListUserTodos(props: {\n  user: UserPayload;\n  body: ITodoListTodo.IRequest;\n}): Promise<IPageITodoListTodo.ISummary> {\n  const { user, body } = props;\n  const pageRaw = body.page ?? 1;\n  const limitRaw = body.limit ?? 20;\n  let page = pageRaw;\n  let limit = limitRaw;\n  // Enforce min/max for page/limit\n  if (limit < 1) limit = 1;\n  if (limit > 100) limit = 100;\n  if (page < 1) page = 1;\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where = {\n    todo_list_user_id: user.id,\n    ...(body.completed !== undefined && { completed: body.completed }),\n    ...(body.search !== undefined &&\n      body.search !== null &&\n      body.search.length > 0 && {\n        OR: [\n          { title: { contains: body.search } },\n          { description: { contains: body.search } },\n        ],\n      }),\n  };\n\n  // Sorting\n  const sortBy = body.sort_by ?? \"created_at\";\n  const order: \"asc\" | \"desc\" = body.order ?? \"desc\";\n\n  // Fetch todos and total count in parallel\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_todos.findMany({\n      where,\n      orderBy: { [sortBy]: order },\n      skip,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_todos.count({\n      where,\n    }),\n  ]);\n\n  // Map to API DTO\n  const data = rows.map((row) => ({\n    id: row.id,\n    title: row.title,\n    description: row.description ?? undefined,\n    completed: row.completed,\n    created_at: toISOStringSafe(row.created_at),\n    updated_at: toISOStringSafe(row.updated_at),\n    completed_at: row.completed_at\n      ? toISOStringSafe(row.completed_at)\n      : undefined,\n  }));\n\n  return {\n    pagination: {\n      current: page,\n      limit: limit,\n      records: total,\n      pages: Math.ceil(total / limit),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoList/user/todos"},"name":"patchTodoListUserTodos"},{"location":"src/providers/getTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function getTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListTodo> {\n  const { user, todoId } = props;\n\n  const todo = await MyGlobal.prisma.todo_list_todos.findFirst({\n    where: {\n      id: todoId,\n      todo_list_user_id: user.id,\n    },\n  });\n\n  if (!todo) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  return {\n    id: todo.id,\n    todo_list_user_id: todo.todo_list_user_id,\n    title: todo.title,\n    description: todo.description ?? undefined,\n    completed: todo.completed,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n    completed_at: todo.completed_at\n      ? toISOStringSafe(todo.completed_at)\n      : undefined,\n  };\n}\n","endpoint":{"method":"get","path":"/todoList/user/todos/{todoId}"},"name":"getTodoListUserTodosTodoId"},{"location":"src/providers/putTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function putTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoListTodo.IUpdate;\n}): Promise<ITodoListTodo> {\n  // Fetch and enforce ownership\n  const todo = await MyGlobal.prisma.todo_list_todos.findFirst({\n    where: {\n      id: props.todoId,\n      todo_list_user_id: props.user.id,\n    },\n  });\n  if (!todo) {\n    throw new HttpException(\"Todo not found or not authorized\", 404);\n  }\n\n  // Prepare logic for completed/completed_at handling\n  const now = toISOStringSafe(new Date());\n  let completedValue = todo.completed;\n  let completedAtValue: (string & tags.Format<\"date-time\">) | null | undefined =\n    todo.completed_at ? toISOStringSafe(todo.completed_at) : null;\n  if (props.body.completed !== undefined) {\n    if (props.body.completed === true && todo.completed === false) {\n      completedValue = true;\n      completedAtValue = now;\n    } else if (props.body.completed === false && todo.completed === true) {\n      completedValue = false;\n      completedAtValue = null;\n    } else {\n      completedValue = props.body.completed;\n      // completedAtValue unchanged\n    }\n  }\n\n  // Build update data object only with provided fields\n  await MyGlobal.prisma.todo_list_todos.update({\n    where: { id: props.todoId },\n    data: {\n      ...(props.body.title !== undefined ? { title: props.body.title } : {}),\n      ...(props.body.description !== undefined\n        ? { description: props.body.description }\n        : {}),\n      ...(props.body.completed !== undefined\n        ? { completed: completedValue }\n        : {}),\n      updated_at: now,\n      completed_at: completedAtValue,\n    },\n  });\n\n  // Retrieve the updated row (to fetch the actual state w/ conversions for all date fields)\n  const updated = await MyGlobal.prisma.todo_list_todos.findFirstOrThrow({\n    where: {\n      id: props.todoId,\n      todo_list_user_id: props.user.id,\n    },\n  });\n\n  return {\n    id: updated.id,\n    todo_list_user_id: updated.todo_list_user_id,\n    title: updated.title,\n    description: updated.description ?? undefined,\n    completed: updated.completed,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    completed_at: updated.completed_at\n      ? toISOStringSafe(updated.completed_at)\n      : null,\n  };\n}\n","endpoint":{"method":"put","path":"/todoList/user/todos/{todoId}"},"name":"putTodoListUserTodosTodoId"},{"location":"src/providers/deleteTodoListUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function deleteTodoListUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  // Find todo by id\n  const todo = await MyGlobal.prisma.todo_list_todos.findUnique({\n    where: { id: props.todoId },\n    select: { todo_list_user_id: true },\n  });\n  if (todo === null || todo.todo_list_user_id !== props.user.id) {\n    throw new HttpException(\"Todo not found\", 404);\n  }\n  await MyGlobal.prisma.todo_list_todos.delete({\n    where: { id: props.todoId },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoList/user/todos/{todoId}"},"name":"deleteTodoListUserTodosTodoId"}],"controllers":{"src/controllers/auth/user/AuthUserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthUserJoin } from \"../../../providers/postAuthUserJoin\";\nimport { postAuthUserLogin } from \"../../../providers/postAuthUserLogin\";\nimport { postAuthUserRefresh } from \"../../../providers/postAuthUserRefresh\";\n\nimport { ITodoListUser } from \"../../../api/structures/ITodoListUser\";\n\n@Controller(\"/auth/user\")\nexport class AuthUserController {\n  /**\n   * Register new user in todo_list_users (user role) and return authentication\n   * tokens.\n   *\n   * This endpoint registers a new user in the todo_list_users table by\n   * accepting an email and password. The Prisma schema ensures email is unique,\n   * and password_hash is used to securely store the credential. Upon creation,\n   * created_at and updated_at are stamped with the current time. last_login\n   * remains null. Registration is mandatory for all further Todo operations, as\n   * the application does not support guest or admin roles. Security is enforced\n   * by hashing the password and checking for duplicate emails. Only core\n   * authentication fields are supported; no extra user data is accepted. The\n   * endpoint is public and does not require authentication. Error handling\n   * includes clear feedback on email duplication and password requirements.\n   * Related authentication endpoints are provided for login and token refresh.\n   *\n   * @param connection\n   * @param body Email and password for user registration (used to create\n   *   todo_list_users entry).\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoListUser.IJoin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate user in todo_list_users (user role) and return authentication\n   * tokens.\n   *\n   * Authenticates a user by verifying email against a record in todo_list_users\n   * and matching password using password_hash. Updates last_login to timestamp\n   * of successful authentication. Only users with valid credentials can access\n   * the system; failed attempts return generic errors to avoid credential\n   * enumeration. Tokens issued allow access to CRUD Todo operations. Email and\n   * password are the only accepted inputs. Security and auditing rely on\n   * accurate maintenance of last_login and secure credential comparison.\n   * Account must have been created via join. Related endpoint: refresh for\n   * token renewal.\n   *\n   * @param connection\n   * @param body User email and password for login authentication.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoListUser.ILogin,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserLogin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh JWT tokens for authenticated user in todo_list_users (user role).\n   *\n   * Renews access/refresh tokens for authenticated user by validating the\n   * provided refresh token. Maps to todo_list_users, but only accepts a valid\n   * refresh token for an active user session. Does not change last_login (which\n   * is only updated on login). All further application actions require an\n   * active, valid token issued via this endpoint or login. Security policy\n   * limits refresh token lifetime and scope. Error handling is strict for\n   * expired or invalid tokens. Related endpoints: join, login. No other data\n   * required except the refresh token.\n   *\n   * @param connection\n   * @param body Refresh token to renew user session.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoListUser.IRefresh,\n  ): Promise<ITodoListUser.IAuthorized> {\n    try {\n      return await postAuthUserRefresh({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoList/user/todos/TodolistUserTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { postTodoListUserTodos } from \"../../../../providers/postTodoListUserTodos\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\nimport { patchTodoListUserTodos } from \"../../../../providers/patchTodoListUserTodos\";\nimport { getTodoListUserTodosTodoId } from \"../../../../providers/getTodoListUserTodosTodoId\";\nimport { putTodoListUserTodosTodoId } from \"../../../../providers/putTodoListUserTodosTodoId\";\nimport { deleteTodoListUserTodosTodoId } from \"../../../../providers/deleteTodoListUserTodosTodoId\";\n\nimport { ITodoListTodo } from \"../../../../api/structures/ITodoListTodo\";\nimport { IPageITodoListTodo } from \"../../../../api/structures/IPageITodoListTodo\";\n\n@Controller(\"/todoList/user/todos\")\nexport class TodolistUserTodosController {\n  /**\n   * Create a new Todo item owned by the authenticated user (todo_list_todos\n   * table).\n   *\n   * Allows an authenticated user to create a new Todo item to track a personal\n   * task. The title is required and must be meaningful, ranging from 1 to 100\n   * characters; a description is optional but, if provided, cannot exceed 500\n   * characters. When a Todo is created, the system sets the completion status\n   * to false and fills in current \"created_at\" and \"updated_at\" timestamps. The\n   * created Todo is associated with the requesting user for future ownership\n   * validation.\n   *\n   * Security checks require the user to be authenticated. The system uses the\n   * active user session for ownership linkage (todo_list_user_id). The backend\n   * enforces data validation as per the schema: empty or whitespace-only titles\n   * or overlength fields are not permitted. Description is optional but must\n   * respect the character limit when supplied.\n   *\n   * All fields not present in the Prisma schema (such as deleted_at,\n   * restored_at, etc.) are intentionally excluded; only the essential minimal\n   * fields (title, description, created_at, user-owned) are included. In case\n   * of validation failures or attempted creation without proper authentication,\n   * the system returns an error response without exposing internal details.\n   *\n   * @param connection\n   * @param body Information for creating a new Todo item, including title\n   *   (mandatory), optional description (up to 500 chars); completion is set to\n   *   false by default; all other fields default to system.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListTodo.ICreate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await postTodoListUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search and retrieve a paginated list of the authenticated user's Todo\n   * items.\n   *\n   * This operation enables an authenticated user to retrieve a filtered and\n   * paginated list of their Todo items from the system. The API allows\n   * searching by completion status (completed/incomplete/all), keyword\n   * filtering on the title and description, and supports ordering by creation\n   * date in descending order by default. The business logic strictly ensures\n   * that only Todos owned by the current user are included in the result, even\n   * if additional filter parameters are provided.\n   *\n   * Pagination parameters such as page number and size control the volume of\n   * results returned. Search and filtering operate only within the\n   * authenticated user's dataset; attempts to access other users' Todos are\n   * blocked at the business logic layer. The response contains summary details\n   * for each Todo, including its id, title, description (if any), completed\n   * status, and timestamps for creation, last update, and completed time where\n   * relevant.\n   *\n   * Security is enforced by requiring a valid user token, and all business\n   * logic prevents enumeration or disclosure of other users' data. Error\n   * scenarios include authentication failure (session/token missing or\n   * expired), invalid pagination/filter parameters, and unexpected server\n   * errors.\n   *\n   * Clients should use this endpoint to present Todo lists, filtered views, or\n   * search within the user's own tasks. Deeper details can be retrieved using\n   * the single-Todo endpoint if required.\n   *\n   * @param connection\n   * @param body Search criteria including optional completion status, text\n   *   keyword, and pagination options for filtering the user's Todos.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListTodo.IRequest,\n  ): Promise<IPageITodoListTodo.ISummary> {\n    try {\n      return await patchTodoListUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve the full details of a single Todo item owned by the authenticated\n   * user.\n   *\n   * This operation returns comprehensive details about a specified Todo item,\n   * but only if it is owned by the requesting (authenticated) user. The\n   * endpoint is designed for use cases where a client application needs to\n   * present all attributes of a selected Todo, including id, title, optional\n   * description, completion status, timestamps for creation, last update, and\n   * completion (if applicable).\n   *\n   * Authorization is strictly enforced: if the Todo does not exist or is not\n   * owned by the user, the operation returns a not-found or access denied error\n   * (without confirming the existence of others' Todos). This ensures privacy\n   * and data isolation in line with both business rules and security best\n   * practices. No modification occurs with this request. All fields correspond\n   * exactly to the todo_list_todos Prisma table definition, assuring that code\n   * and documentation stay in sync.\n   *\n   * Clients should use this operation when a user wishes to view all attributes\n   * of a Todo, such as on a detail page or before editing. Error handling\n   * includes authentication failure, nonexistent or non-owned resource, and\n   * generic internal errors.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the Todo item to retrieve. Must refer to\n   *   a Todo belonging to the authenticated user.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await getTodoListUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an existing Todo item, verifying ownership and field validation\n   * (todo_list_todos table).\n   *\n   * Allows the authenticated user to update the properties of an existing Todo\n   * item that they own. The user provides a new title (mandatory, 1-100 chars),\n   * an optional description (up to 500 chars), and/or a new completion status\n   * (boolean). The request is only validated and performed if the Todo exists\n   * and belongs to the requesting user. Upon successful update, the updated_at\n   * timestamp is refreshed to current time, and the completion state (and\n   * completed_at timestamp) is modified according to the change.\n   *\n   * All inputs are strictly validated: title cannot be empty or exceed the\n   * character limit; description is optional but must respect the 500 character\n   * restriction; completed must be boolean. Attempting to modify a Todo not\n   * owned by the user, or not in the database, results in a not found or\n   * forbidden error (no information about other users' data is leaked). Only\n   * the fields defined in the todo_list_todos schema are updatable; no hidden\n   * or system fields are present or updatable.\n   *\n   * Only authenticated users can call this operation. No batch or cross-user\n   * updates are supported. Any field provided must satisfy minimal field\n   * constraints. Error messages are business-contextual and avoid leaking\n   * privileged information.\n   *\n   * @param connection\n   * @param todoId Unique identifier (UUID) of the Todo item to update.\n   * @param body Fields to update in an owned Todo item: must include new title\n   *   (1-100 chars), optional description (up to 500 chars), and/or completion\n   *   status; updated_at is system-set.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListTodo.IUpdate,\n  ): Promise<ITodoListTodo> {\n    try {\n      return await putTodoListUserTodosTodoId({\n        user,\n        todoId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Permanently delete a Todo item from the user's list (todo_list_todos\n   * table).\n   *\n   * Permanently delete a specific Todo item from the system, ensuring that only\n   * the authenticated owner can remove their own Todo. The operation begins by\n   * confirming the user's authentication status and validating that the Todo\n   * exists and is owned by the requester.\n   *\n   * In compliance with the Prisma schema, each Todo is identified by a UUID,\n   * and deletion is allowed only if the requesting user's ID matches the\n   * todo_list_user_id foreign key of the target record. No soft-deletion or\n   * archival is performed; the Todo is removed from the database entirely.\n   *\n   * Error handling is strict—if the Todo does not exist, or if ownership\n   * validation fails, the operation returns a not-found response to avoid\n   * leaking any information about other users' Todos. The endpoint does not\n   * accept a request body, nor does it return a data payload on success.\n   * Operation is idempotent: repeated deletion requests for the same\n   * nonexistent Todo will always return the same error message.\n   *\n   * Security is enforced by requiring the \"user\" role. Appropriate audit\n   * logging for data deletion should be considered at the service provider\n   * layer, in accordance with non-functional requirements and business rules.\n   *\n   * @param connection\n   * @param todoId The unique identifier of the Todo item to be deleted (UUID\n   *   format)\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n"},"compiled":{"type":"success"},"created_at":"2025-10-07T15:55:53.951Z","completed_at":"2025-10-07T16:04:27.799Z","step":0}]