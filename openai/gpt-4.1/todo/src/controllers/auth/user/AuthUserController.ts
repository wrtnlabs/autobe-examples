import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthUserJoin } from "../../../providers/postAuthUserJoin";
import { postAuthUserLogin } from "../../../providers/postAuthUserLogin";
import { postAuthUserRefresh } from "../../../providers/postAuthUserRefresh";

import { ITodoListUser } from "../../../api/structures/ITodoListUser";

@Controller("/auth/user")
export class AuthUserController {
  /**
   * Register new user in todo_list_users (user role) and return authentication
   * tokens.
   *
   * This endpoint registers a new user in the todo_list_users table by
   * accepting an email and password. The Prisma schema ensures email is unique,
   * and password_hash is used to securely store the credential. Upon creation,
   * created_at and updated_at are stamped with the current time. last_login
   * remains null. Registration is mandatory for all further Todo operations, as
   * the application does not support guest or admin roles. Security is enforced
   * by hashing the password and checking for duplicate emails. Only core
   * authentication fields are supported; no extra user data is accepted. The
   * endpoint is public and does not require authentication. Error handling
   * includes clear feedback on email duplication and password requirements.
   * Related authentication endpoints are provided for login and token refresh.
   *
   * @param connection
   * @param body Email and password for user registration (used to create
   *   todo_list_users entry).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoListUser.IJoin,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate user in todo_list_users (user role) and return authentication
   * tokens.
   *
   * Authenticates a user by verifying email against a record in todo_list_users
   * and matching password using password_hash. Updates last_login to timestamp
   * of successful authentication. Only users with valid credentials can access
   * the system; failed attempts return generic errors to avoid credential
   * enumeration. Tokens issued allow access to CRUD Todo operations. Email and
   * password are the only accepted inputs. Security and auditing rely on
   * accurate maintenance of last_login and secure credential comparison.
   * Account must have been created via join. Related endpoint: refresh for
   * token renewal.
   *
   * @param connection
   * @param body User email and password for login authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ITodoListUser.ILogin,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for authenticated user in todo_list_users (user role).
   *
   * Renews access/refresh tokens for authenticated user by validating the
   * provided refresh token. Maps to todo_list_users, but only accepts a valid
   * refresh token for an active user session. Does not change last_login (which
   * is only updated on login). All further application actions require an
   * active, valid token issued via this endpoint or login. Security policy
   * limits refresh token lifetime and scope. Error handling is strict for
   * expired or invalid tokens. Related endpoints: join, login. No other data
   * required except the refresh token.
   *
   * @param connection
   * @param body Refresh token to renew user session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoListUser.IRefresh,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
