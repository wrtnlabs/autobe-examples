import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodo } from "../../../../structures/ITodoListTodo";
import { IPageITodoListTodo } from "../../../../structures/IPageITodoListTodo";

/**
 * Create a new Todo item owned by the authenticated user (todo_list_todos
 * table).
 *
 * Allows an authenticated user to create a new Todo item to track a personal
 * task. The title is required and must be meaningful, ranging from 1 to 100
 * characters; a description is optional but, if provided, cannot exceed 500
 * characters. When a Todo is created, the system sets the completion status to
 * false and fills in current "created_at" and "updated_at" timestamps. The
 * created Todo is associated with the requesting user for future ownership
 * validation.
 *
 * Security checks require the user to be authenticated. The system uses the
 * active user session for ownership linkage (todo_list_user_id). The backend
 * enforces data validation as per the schema: empty or whitespace-only titles
 * or overlength fields are not permitted. Description is optional but must
 * respect the character limit when supplied.
 *
 * All fields not present in the Prisma schema (such as deleted_at, restored_at,
 * etc.) are intentionally excluded; only the essential minimal fields (title,
 * description, created_at, user-owned) are included. In case of validation
 * failures or attempted creation without proper authentication, the system
 * returns an error response without exposing internal details.
 *
 * @param props.connection
 * @param props.body Information for creating a new Todo item, including title
 *   (mandatory), optional description (up to 500 chars); completion is set to
 *   false by default; all other fields default to system.
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information for creating a new Todo item, including title
     * (mandatory), optional description (up to 500 chars); completion is
     * set to false by default; all other fields default to system.
     */
    body: ITodoListTodo.ICreate;
  };
  export type Body = ITodoListTodo.ICreate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of the authenticated user's Todo items.
 *
 * This operation enables an authenticated user to retrieve a filtered and
 * paginated list of their Todo items from the system. The API allows searching
 * by completion status (completed/incomplete/all), keyword filtering on the
 * title and description, and supports ordering by creation date in descending
 * order by default. The business logic strictly ensures that only Todos owned
 * by the current user are included in the result, even if additional filter
 * parameters are provided.
 *
 * Pagination parameters such as page number and size control the volume of
 * results returned. Search and filtering operate only within the authenticated
 * user's dataset; attempts to access other users' Todos are blocked at the
 * business logic layer. The response contains summary details for each Todo,
 * including its id, title, description (if any), completed status, and
 * timestamps for creation, last update, and completed time where relevant.
 *
 * Security is enforced by requiring a valid user token, and all business logic
 * prevents enumeration or disclosure of other users' data. Error scenarios
 * include authentication failure (session/token missing or expired), invalid
 * pagination/filter parameters, and unexpected server errors.
 *
 * Clients should use this endpoint to present Todo lists, filtered views, or
 * search within the user's own tasks. Deeper details can be retrieved using the
 * single-Todo endpoint if required.
 *
 * @param props.connection
 * @param props.body Search criteria including optional completion status, text
 *   keyword, and pagination options for filtering the user's Todos.
 * @path /todoList/user/todos
 * @accessor api.functional.todoList.user.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria including optional completion status, text keyword,
     * and pagination options for filtering the user's Todos.
     */
    body: ITodoListTodo.IRequest;
  };
  export type Body = ITodoListTodo.IRequest;
  export type Response = IPageITodoListTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/user/todos";
  export const random = (): IPageITodoListTodo.ISummary =>
    typia.random<IPageITodoListTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the full details of a single Todo item owned by the authenticated
 * user.
 *
 * This operation returns comprehensive details about a specified Todo item, but
 * only if it is owned by the requesting (authenticated) user. The endpoint is
 * designed for use cases where a client application needs to present all
 * attributes of a selected Todo, including id, title, optional description,
 * completion status, timestamps for creation, last update, and completion (if
 * applicable).
 *
 * Authorization is strictly enforced: if the Todo does not exist or is not
 * owned by the user, the operation returns a not-found or access denied error
 * (without confirming the existence of others' Todos). This ensures privacy and
 * data isolation in line with both business rules and security best practices.
 * No modification occurs with this request. All fields correspond exactly to
 * the todo_list_todos Prisma table definition, assuring that code and
 * documentation stay in sync.
 *
 * Clients should use this operation when a user wishes to view all attributes
 * of a Todo, such as on a detail page or before editing. Error handling
 * includes authentication failure, nonexistent or non-owned resource, and
 * generic internal errors.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the Todo item to retrieve. Must
 *   refer to a Todo belonging to the authenticated user.
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the Todo item to retrieve. Must refer to a Todo
     * belonging to the authenticated user.
     */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing Todo item, verifying ownership and field validation
 * (todo_list_todos table).
 *
 * Allows the authenticated user to update the properties of an existing Todo
 * item that they own. The user provides a new title (mandatory, 1-100 chars),
 * an optional description (up to 500 chars), and/or a new completion status
 * (boolean). The request is only validated and performed if the Todo exists and
 * belongs to the requesting user. Upon successful update, the updated_at
 * timestamp is refreshed to current time, and the completion state (and
 * completed_at timestamp) is modified according to the change.
 *
 * All inputs are strictly validated: title cannot be empty or exceed the
 * character limit; description is optional but must respect the 500 character
 * restriction; completed must be boolean. Attempting to modify a Todo not owned
 * by the user, or not in the database, results in a not found or forbidden
 * error (no information about other users' data is leaked). Only the fields
 * defined in the todo_list_todos schema are updatable; no hidden or system
 * fields are present or updatable.
 *
 * Only authenticated users can call this operation. No batch or cross-user
 * updates are supported. Any field provided must satisfy minimal field
 * constraints. Error messages are business-contextual and avoid leaking
 * privileged information.
 *
 * @param props.connection
 * @param props.todoId Unique identifier (UUID) of the Todo item to update.
 * @param props.body Fields to update in an owned Todo item: must include new
 *   title (1-100 chars), optional description (up to 500 chars), and/or
 *   completion status; updated_at is system-set.
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the Todo item to update. */
    todoId: string & tags.Format<"uuid">;

    /**
     * Fields to update in an owned Todo item: must include new title (1-100
     * chars), optional description (up to 500 chars), and/or completion
     * status; updated_at is system-set.
     */
    body: ITodoListTodo.IUpdate;
  };
  export type Body = ITodoListTodo.IUpdate;
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoList/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a Todo item from the user's list (todo_list_todos table).
 *
 * Permanently delete a specific Todo item from the system, ensuring that only
 * the authenticated owner can remove their own Todo. The operation begins by
 * confirming the user's authentication status and validating that the Todo
 * exists and is owned by the requester.
 *
 * In compliance with the Prisma schema, each Todo is identified by a UUID, and
 * deletion is allowed only if the requesting user's ID matches the
 * todo_list_user_id foreign key of the target record. No soft-deletion or
 * archival is performed; the Todo is removed from the database entirely.
 *
 * Error handling is strictâ€”if the Todo does not exist, or if ownership
 * validation fails, the operation returns a not-found response to avoid leaking
 * any information about other users' Todos. The endpoint does not accept a
 * request body, nor does it return a data payload on success. Operation is
 * idempotent: repeated deletion requests for the same nonexistent Todo will
 * always return the same error message.
 *
 * Security is enforced by requiring the "user" role. Appropriate audit logging
 * for data deletion should be considered at the service provider layer, in
 * accordance with non-functional requirements and business rules.
 *
 * @param props.connection
 * @param props.todoId The unique identifier of the Todo item to be deleted
 *   (UUID format)
 * @path /todoList/user/todos/:todoId
 * @accessor api.functional.todoList.user.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the Todo item to be deleted (UUID format) */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
