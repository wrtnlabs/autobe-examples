import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthCustomerJoin } from "../../../providers/postAuthCustomerJoin";
import { postAuthCustomerLogin } from "../../../providers/postAuthCustomerLogin";
import { postAuthCustomerRefresh } from "../../../providers/postAuthCustomerRefresh";

import { IShoppingMallCustomer } from "../../../api/structures/IShoppingMallCustomer";

@Controller("/auth/customer")
export class AuthCustomerController {
  /**
   * Register new customer account (shopping_mall_customers) with JWT issuance.
   *
   * This endpoint supports new customer registration for the shoppingMall
   * platform. It creates a record in the shopping_mall_customers table,
   * requiring unique email, password (hashed), full name, and phone. The
   * implementation uses Prisma's model for shopping_mall_customers, referencing
   * fields such as email (unique, string), password_hash (string), full_name
   * (string), phone (string), status (string), email_verified (boolean),
   * created_at (datetime), and updated_at (datetime).
   *
   * Customers are not considered verified until completing the external email
   * verification workflow. Registration attempts are rejected if the email
   * already exists, and status is initially set to a pending state until
   * verification. Soft-deletion semantics use the deleted_at field, preventing
   * re-registration after account removal unless handled with explicit logic
   * (verifying deleted_at is null).
   *
   * The endpoint is public; no authentication is required for registration.
   * Upon success, the system issues a JWT and customer profile DTO using
   * IShoppingMallCustomer.IAuthorized, and triggers subsequent flows for
   * login/verification.
   *
   * Security is enforced at both API and DB schema levels. Throttling, spam
   * protection, and infrastructure-level input filtering are outside direct
   * scope but required in production. Related operations: login and refresh for
   * full authentication lifecycle. Account verification is triggered as a
   * necessary step before granting full access to platform features.
   *
   * Related operation references: /auth/customer/login, /auth/customer/refresh.
   *
   * @param connection
   * @param body New customer registration payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IShoppingMallCustomer.IJoin,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate customer (shopping_mall_customers) and issue tokens.
   *
   * This endpoint supports customer authentication by validating login
   * credentials. It uses the shopping_mall_customers table, where the client
   * provides email and password. The API checks email (unique, string),
   * compares the password to the stored password_hash (bcrypt), ensures the
   * account status is active, and verifies the email_verified flag.
   *
   * If authentication succeeds, an access and refresh token are issued and
   * returned as IShoppingMallCustomer.IAuthorized. Failed attempts are metered
   * and logged to mitigate brute-force risk (handled at the infra/auth
   * middleware level).
   *
   * The operation does not return detailed error cause on authentication
   * failure, complying with security best practices. The process is always
   * paired with registration and token refresh endpoints. Blocking removed
   * (deleted) or suspended accounts is enforced by checking the deleted_at and
   * status fields in the schema. The endpoint is public (no authentication
   * required).
   *
   * Related references: /auth/customer/join (registration),
   * /auth/customer/refresh (refresh token), shopping_mall_customers Prisma
   * definition.
   *
   * @param connection
   * @param body Customer login credentials (email, password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IShoppingMallCustomer.ILogin,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh customer JWT tokens (shopping_mall_user_sessions).
   *
   * This endpoint supports refreshing JWT tokens for customer sessions by
   * accepting a valid refresh token. It validates session state using
   * shopping_mall_user_sessions, checking refresh_token (unique, string), and
   * ensures the session is not expired or revoked via expires_at and revoked_at
   * fields.
   *
   * On success, a new access token is issued along with updated tokens,
   * following the authorized DTO IShoppingMallCustomer.IAuthorized. Invalid or
   * expired refresh tokens are rejected with generic error responses to prevent
   * information disclosure.
   *
   * The endpoint is unauthenticated but requires a valid refresh token for
   * operation. It is always paired with login and join for standard
   * authentication lifecycle management. Session integrity rules and maximum
   * concurrent session policies may be enforced at the DB or handler layer
   * (tracked via unique tokens and session records).
   *
   * All logic is based strictly on existing fields in
   * shopping_mall_user_sessions. Related references: Prisma schema, customer
   * session management flows across platform.
   *
   * @param connection
   * @param body Refresh token for acquiring new session tokens.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IShoppingMallCustomer.IRefresh,
  ): Promise<IShoppingMallCustomer.IAuthorized> {
    try {
      return await postAuthCustomerRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
