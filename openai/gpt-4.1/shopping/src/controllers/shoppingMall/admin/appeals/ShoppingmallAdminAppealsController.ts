import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchShoppingMallAdminAppeals } from "../../../../providers/patchShoppingMallAdminAppeals";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { getShoppingMallAdminAppealsAppealId } from "../../../../providers/getShoppingMallAdminAppealsAppealId";
import { putShoppingMallAdminAppealsAppealId } from "../../../../providers/putShoppingMallAdminAppealsAppealId";
import { deleteShoppingMallAdminAppealsAppealId } from "../../../../providers/deleteShoppingMallAdminAppealsAppealId";

import { IPageIShoppingMallAppeal } from "../../../../api/structures/IPageIShoppingMallAppeal";
import { IShoppingMallAppeal } from "../../../../api/structures/IShoppingMallAppeal";

@Controller("/shoppingMall/admin/appeals")
export class ShoppingmallAdminAppealsController {
  /**
   * Retrieve a paginated, filtered list of appeals (shopping_mall_appeals
   * table) for admin dashboard review.
   *
   * Fetch a filtered, paginated list of appeal records from the shoppingMall
   * platform. Appeals represent formal challenges to prior escalation case
   * decisions and are critical to transparent customer and seller service
   * workflows. This operation provides system admins with advanced search
   * capabilities over the shopping_mall_appeals schema, supporting filtering by
   * status (pending, under review, resolved, dismissed, etc.), appeal_type
   * (refund denied, policy review request, etc.), time windows, actor identity,
   * and outcome type.
   *
   * Results are returned in a paginated format for dashboard consumption and
   * can be sorted by creation/update time, status, or actor. The response
   * encapsulates complete metadata for each appeal, including escalation
   * linkage, actors, appeal/request type, status, outcome, resolution remarks,
   * and creation/update timestamps. Appropriate business logic must validate
   * admin authorization and prevent access leaks to non-admin users. Errors or
   * unsupported filter parameters are handled with clear error messages. This
   * API is intended for administrative dashboard use.
   *
   * @param connection
   * @param body Search and pagination criteria to filter appeals results
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAppeal.IRequest,
  ): Promise<IPageIShoppingMallAppeal> {
    try {
      return await patchShoppingMallAdminAppeals({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed information of a specific appeal by ID from
   * shopping_mall_appeals table.
   *
   * Retrieve detailed information about a specific customer or seller appeal
   * based on the provided appeal ID. This operation returns all relevant fields
   * of the appeal record as defined in the 'shopping_mall_appeals' schema,
   * including appellant identity, escalation reference, appeal type, status,
   * assigned reviewers, and resolution details.
   *
   * Security: The endpoint enforces role-based accessâ€”customers and sellers see
   * only their own appeals and admins have full platform-wide access. Sensitive
   * data is filtered out for roles without scope. Logging is performed for all
   * read access for audit purposes.
   *
   * Business logic ensures only appeals that have not been soft deleted
   * (deleted_at is null) are returned. Attempts to access non-existent or
   * unauthorized appeal IDs return a 404 or 403 error as appropriate.
   *
   * @param connection
   * @param appealId Unique identifier of the appeal to retrieve information
   *   for.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":appealId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("appealId")
    appealId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAppeal> {
    try {
      return await getShoppingMallAdminAppealsAppealId({
        admin,
        appealId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific appeal record's status, resolution, or comment in the
   * ShoppingMallAppeal table.
   *
   * Update an appeal entry to reflect admin decision or ongoing review status
   * in the context of customer service escalation. Appeals are created when a
   * customer or seller contests the outcome of a previous escalation, seeking
   * additional review or policy override. Admins reviewing an appeal must
   * document the outcome, status, and method of resolution, along with a
   * comment clarifying the decision and any remediation steps taken.
   *
   * This operation enforces platform business logic, including eligibility
   * checks (only open/in-review appeals can be updated), workflow controls
   * (status changes such as resolved, dismissed, or accepted), and
   * record-keeping for audit and compliance. Admins must ensure accurate
   * information is provided as changes here affect customer entitlements and
   * regulatory retention. All actions are time-stamped, actor logged, and
   * retrievable for later dispute or compliance analysis.
   *
   * @param connection
   * @param appealId Unique identifier of the target appeal to update.
   * @param body Object containing properties to update in the appeal, such as
   *   new status, resolution type, and admin comment explaining the outcome.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":appealId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("appealId")
    appealId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAppeal.IUpdate,
  ): Promise<IShoppingMallAppeal> {
    try {
      return await putShoppingMallAdminAppealsAppealId({
        admin,
        appealId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a specific appeal record from the ShoppingMallAppeal
   * table by its identifier.
   *
   * Permanently delete a specific appeal entry from the system, removing it
   * from the appeals queue and all customer/admin access. This action can only
   * be performed by authorized administrators and is intended for appeals
   * records that have fully completed their lifecycle or must be purged due to
   * data error or policy violation.
   *
   * The operation is subject to audit trail requirements: all deletion actions
   * are logged with timestamps and acting admin id for later compliance checks.
   * Attempts to delete appeals in active status (e.g., under review or
   * unresolved) must be rejected by business logic, returning an appropriate
   * error. Where regulatory or platform retention rules mandate, deleted
   * appeals are tracked in administrative action logs for historical reference
   * and reporting.
   *
   * @param connection
   * @param appealId Unique identifier of the appeal to be deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":appealId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("appealId")
    appealId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminAppealsAppealId({
        admin,
        appealId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
