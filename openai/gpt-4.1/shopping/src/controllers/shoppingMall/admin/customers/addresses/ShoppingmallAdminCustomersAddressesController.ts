import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchShoppingMallAdminCustomersCustomerIdAddresses } from "../../../../../providers/patchShoppingMallAdminCustomersCustomerIdAddresses";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { deleteShoppingMallAdminCustomersCustomerIdAddressesAddressId } from "../../../../../providers/deleteShoppingMallAdminCustomersCustomerIdAddressesAddressId";

import { IPageIShoppingMallCustomerAddress } from "../../../../../api/structures/IPageIShoppingMallCustomerAddress";
import { IShoppingMallCustomerAddress } from "../../../../../api/structures/IShoppingMallCustomerAddress";

@Controller("/shoppingMall/admin/customers/:customerId/addresses")
export class ShoppingmallAdminCustomersAddressesController {
  /**
   * Fetch a paginated list of addresses for a given customerId in
   * shopping_mall_customer_addresses.
   *
   * Retrieve a paginated and optionally filtered list of all addresses
   * registered by a specified customer. The API operates on the
   * shopping_mall_customer_addresses table, using customer_id as the foreign
   * key to retrieve addresses belonging to a single customer. All relevant
   * address fields—recipient_name, phone, region, postal_code, address lines,
   * is_default, and timestamps—are included per the Prisma column definitions.
   *
   * Customers must be authenticated to fetch their own address book;
   * authorization is enforced on customerId to ensure ownership. Advanced
   * features support filtering by region, postal_code, or searching for partial
   * address text, as well as sorting by created_at, updated_at, or is_default
   * flag.
   *
   * This endpoint is typically used in the account dashboard for browsing or
   * managing shipping information, as well as in checkout workflows for
   * selecting or updating delivery addresses. Security checks ensure that the
   * requesting token's user matches the customerId path parameter, or else
   * admin override is required. All data is returned in paginated form to
   * support users with many addresses.
   *
   * This operation is related to address creation, update, and deletion
   * endpoints, and is a primary part of customer self-service interfaces.
   * Errors are returned if customerId is not found or the user is not
   * authorized to view specified addresses.
   *
   * @param connection
   * @param customerId Unique identifier of the customer whose addresses should
   *   be fetched (UUID).
   * @param body Request body to specify search, filtering, sorting, and
   *   pagination options for fetching address list.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCustomerAddress.IRequest,
  ): Promise<IPageIShoppingMallCustomerAddress> {
    try {
      return await patchShoppingMallAdminCustomersCustomerIdAddresses({
        admin,
        customerId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a customer's address (shopping_mall_customer_addresses table)
   * with authorization and ownership checks.
   *
   * This operation provides a mechanism for customers to manage their own
   * address book by removing an address entry. When the customer requests to
   * delete an address, the system will verify that the address exists and is
   * owned by the currently authenticated user. Only the address owner or
   * administrators are permitted to invoke this operation, ensuring that
   * private address data is secured against unauthorized deletion.
   *
   * Upon successful validation, the address is permanently removed from the
   * shopping_mall_customer_addresses table. Since the column 'deleted_at'
   * exists, this operation should perform a soft delete, marking the deleted_at
   * timestamp instead of physically removing the row, in order to preserve
   * deletion history for audit trails. Any attempt to delete an address that
   * does not belong to the user should trigger a forbidden error.
   *
   * The system must check for business logic such as whether the address is
   * currently associated with pending orders or if it was the only or default
   * address on file. Appropriate validation or error handling must communicate
   * to the user if the address cannot be deleted due to these business
   * constraints. Related APIs for managing addresses (add, update, set as
   * default) should be referenced for complete address management flows.
   *
   * Error handling covers edge cases such as trying to delete non-existent
   * addresses, deleting another user's address, or attempting to remove the
   * only default address without providing an alternative.
   *
   * @param connection
   * @param customerId The unique identifier of the customer who owns the
   *   address being deleted.
   * @param addressId The unique identifier of the customer address to be
   *   deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":addressId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("addressId")
    addressId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminCustomersCustomerIdAddressesAddressId(
        {
          admin,
          customerId,
          addressId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
