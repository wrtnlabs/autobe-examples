import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminProductsProductIdSkus } from "../../../../../providers/postShoppingMallAdminProductsProductIdSkus";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminProductsProductIdSkus } from "../../../../../providers/patchShoppingMallAdminProductsProductIdSkus";
import { putShoppingMallAdminProductsProductIdSkusSkuId } from "../../../../../providers/putShoppingMallAdminProductsProductIdSkusSkuId";
import { deleteShoppingMallAdminProductsProductIdSkusSkuId } from "../../../../../providers/deleteShoppingMallAdminProductsProductIdSkusSkuId";

import { IShoppingMallProductSku } from "../../../../../api/structures/IShoppingMallProductSku";
import { IPageIShoppingMallProductSku } from "../../../../../api/structures/IPageIShoppingMallProductSku";

@Controller("/shoppingMall/admin/products/:productId/skus")
export class ShoppingmallAdminProductsSkusController {
  /**
   * Create a new SKU (shopping_mall_product_skus) under a product by productId.
   *
   * Create a new product SKU for an existing product under the specific
   * productId. This operation accepts a well-formed SKU creation structure
   * (including sku_code, name, price, status, low_stock_threshold, and option
   * value mapping) in the request body. The system checks that the productId
   * exists and belongs to the current seller or is accessible to admin, and
   * that the SKU meets all Prisma schema constraints (e.g., name, code
   * uniqueness, valid price, option configuration, and link to inventory
   * records).
   *
   * The operation is authorized for roles seller and admin (as enforced by
   * row-level and business validation). Attempts by unauthenticated or customer
   * users are rejected. Required fields and relationships are validated
   * strictly per the Prisma schema: SKU name and code must be unique within the
   * product; price must be positive as enforced by business rules; option
   * assignments must map to available option values; and an initial inventory
   * state is established on creation as required by inventory logic.
   *
   * Returned data is the complete SKU entity, with inventory and option state,
   * enabling follow-up actions on catalog management or integration into
   * purchase flows. Failed creation returns detailed errors, such as
   * duplication or invalid configuration, for correction by the caller.
   *
   * @param connection
   * @param productId Unique identifier for the product to which this SKU will
   *   be added.
   * @param body Creation payload for a new SKU under the given productId,
   *   following IShoppingMallProductSku.ICreate contract.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductSku.ICreate,
  ): Promise<IShoppingMallProductSku> {
    try {
      return await postShoppingMallAdminProductsProductIdSkus({
        admin,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve and paginate a filtered list of all SKUs/variants for a specific
   * product (shopping_mall_product_skus table).
   *
   * This API operation provides a seller or admin with the ability to search,
   * filter, and paginate over all SKUs (variants) associated with a given
   * product, identified by its productId. It is linked to the
   * shopping_mall_product_skus table, as well as related tables for product
   * options and SKU option values.
   *
   * A PATCH request enables advanced request body filtering: search by SKU
   * name, code, status (e.g., active/inactive/blocked), inventory status, price
   * range, and other SKU-level attributes as defined in the Prisma schema.
   * Results are paginated with full support for sorting by fields such as
   * creation date, price, or name. Filtering can include inventory status,
   * option selections (e.g., color/size), or activity ranges. This operation
   * powers catalog management screens, enables sellers to review all variant
   * SKUs efficiently, and supports administrative oversight for compliance,
   * moderation, or inventory audits.
   *
   * The response is a paginated list of detailed SKU entities, with optional
   * summaries or custom projections if required. Associated option/option-value
   * data is included for effective inventory and listing management. Only
   * authorized sellers (owning the product) or admins may utilize this advanced
   * search endpoint. Security controls ensure no leakage of SKU/catalog content
   * across vendors or unauthorized system actors. The implementation includes
   * robust input validation, error handling, and consistent pagination
   * metadata.
   *
   * @param connection
   * @param productId Unique identifier of the parent product for which SKUs are
   *   listed.
   * @param body Advanced search, filter, and sorting parameters for SKU variant
   *   listing.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductSku.IRequest,
  ): Promise<IPageIShoppingMallProductSku> {
    try {
      return await patchShoppingMallAdminProductsProductIdSkus({
        admin,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a product's SKU information in the shopping_mall_product_skus table,
   * reflecting changes to SKU name, price, status, image, or options.
   *
   * Update an existing SKU for a product by specifying the productId and skuId.
   * This operation supports modifications to SKU fields such as name, price,
   * status (active/inactive/blocked), low_stock_threshold, or main image URL.
   * Modification requests are validated for correct SKU ownership, business
   * rule compliance (SKU name uniqueness for the product, no updates that
   * violate inventory integrity or affect pending orders), and role-based
   * access (seller can only update their own SKUs; admin may update any).
   *
   * Each update is audited with a timestamp and user context recorded in
   * associated platform activity logs. If invalid values are supplied, such as
   * negative prices or duplicate SKU names, descriptive validation errors are
   * returned. If SKU cannot be found or does not belong to the specified
   * product, a not-found error is returned. Business logic ensures that SKU
   * option values and price updates are atomic and consistent.
   *
   * This endpoint is foundational for seller catalog maintenance and admin
   * interventions to resolve catalog errors or compliance issues. Related
   * endpoints include product listing retrieval, SKU creation, and
   * product-level updates.
   *
   * @param connection
   * @param productId Unique identifier for the parent product to which this SKU
   *   belongs.
   * @param skuId Unique identifier for the SKU (Stock Keeping Unit) to be
   *   updated within the product.
   * @param body Fields to update for the product SKU, such as name, price,
   *   status, image, and option values.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":skuId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("skuId")
    skuId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductSku.IUpdate,
  ): Promise<IShoppingMallProductSku> {
    try {
      return await putShoppingMallAdminProductsProductIdSkusSkuId({
        admin,
        productId,
        skuId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a specific SKU in shopping_mall_product_skus by marking
   * deleted_at, after verifying active order constraints and ownership.
   *
   * Soft-delete an existing SKU belonging to a product by specifying the
   * productId and skuId. The SKU must belong to the current seller or the
   * requester must be an admin. This operation marks the SKU as deleted by
   * setting its deleted_at timestamp, effectively removing it from catalog
   * search and purchase flows while preserving historical data for compliance.
   *
   * Before deletion, business logic checks ensure the SKU is not currently
   * associated with any active or pending orders. If the SKU is referenced in
   * pending transactions, the request is blocked and a clear, actionable error
   * is returned explaining why deletion cannot proceed. The deletion action is
   * audited for compliance. Related endpoints include listing SKUs for a
   * product and restoring or permanently erasing deleted SKUs if the business
   * supports such flows.
   *
   * No product-level data or related historical order data is deletedâ€”this
   * endpoint only marks the specific SKU as deleted for the purposes of catalog
   * management and inventory control.
   *
   * @param connection
   * @param productId Unique identifier for the parent product to which this SKU
   *   belongs.
   * @param skuId Unique identifier for the SKU (Stock Keeping Unit) to be
   *   deleted within the product.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":skuId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("skuId")
    skuId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminProductsProductIdSkusSkuId({
        admin,
        productId,
        skuId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
