import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getShoppingMallSellerAppealsAppealId } from "../../../../providers/getShoppingMallSellerAppealsAppealId";
import { SellerAuth } from "../../../../decorators/SellerAuth";
import { SellerPayload } from "../../../../decorators/payload/SellerPayload";
import { postShoppingMallSellerAppeals } from "../../../../providers/postShoppingMallSellerAppeals";

import { IShoppingMallAppeal } from "../../../../api/structures/IShoppingMallAppeal";

@Controller("/shoppingMall/seller/appeals")
export class ShoppingmallSellerAppealsController {
  /**
   * Retrieve detailed information of a specific appeal by ID from
   * shopping_mall_appeals table.
   *
   * Retrieve detailed information about a specific customer or seller appeal
   * based on the provided appeal ID. This operation returns all relevant fields
   * of the appeal record as defined in the 'shopping_mall_appeals' schema,
   * including appellant identity, escalation reference, appeal type, status,
   * assigned reviewers, and resolution details.
   *
   * Security: The endpoint enforces role-based access—customers and sellers see
   * only their own appeals and admins have full platform-wide access. Sensitive
   * data is filtered out for roles without scope. Logging is performed for all
   * read access for audit purposes.
   *
   * Business logic ensures only appeals that have not been soft deleted
   * (deleted_at is null) are returned. Attempts to access non-existent or
   * unauthorized appeal IDs return a 404 or 403 error as appropriate.
   *
   * @param connection
   * @param appealId Unique identifier of the appeal to retrieve information
   *   for.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":appealId")
  public async at(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("appealId")
    appealId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAppeal> {
    try {
      return await getShoppingMallSellerAppealsAppealId({
        seller,
        appealId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Create a new appeal record for customer service on the
   * shopping_mall_appeals table.
   *
   * Create a new appeal entry in the system for an escalation that has
   * occurred, such as disagreement with an order cancellation or refund
   * outcome. The request must include all mandatory fields from the appeal
   * creation DTO, which maps to the 'shopping_mall_appeals' schema
   * definition—referencing the escalation, the appellant (customer or seller),
   * appeal type and initial status, and optionally admin reviewer if assigned.
   *
   * Validation ensures the referenced escalation exists and that the client
   * initiating the appeal is authorized to do so (i.e., tied to the escalation
   * as a customer or seller). Soft-deleted appeals or escalations cannot be
   * used. On successful creation, the API returns the full appeal record as
   * confirmation. Audit trails are updated to ensure actions are logged for
   * compliance and follow-up.
   *
   * @param connection
   * @param body Information required to file a new appeal, referencing
   *   escalation, actor, and reason.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @SellerAuth()
    seller: SellerPayload,
    @TypedBody()
    body: IShoppingMallAppeal.ICreate,
  ): Promise<IShoppingMallAppeal> {
    try {
      return await postShoppingMallSellerAppeals({
        seller,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
