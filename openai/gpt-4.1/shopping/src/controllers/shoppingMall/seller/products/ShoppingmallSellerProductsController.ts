import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallSellerProducts } from "../../../../providers/postShoppingMallSellerProducts";
import { SellerAuth } from "../../../../decorators/SellerAuth";
import { SellerPayload } from "../../../../decorators/payload/SellerPayload";
import { putShoppingMallSellerProductsProductId } from "../../../../providers/putShoppingMallSellerProductsProductId";
import { deleteShoppingMallSellerProductsProductId } from "../../../../providers/deleteShoppingMallSellerProductsProductId";

import { IShoppingMallProduct } from "../../../../api/structures/IShoppingMallProduct";

@Controller("/shoppingMall/seller/products")
export class ShoppingmallSellerProductsController {
  /**
   * Create a new product for sale (shopping_mall_products table).
   *
   * This API endpoint facilitates the onboarding of new sellable products by
   * authorized sellers or platform admins. When invoked, it expects complete
   * product details such as product name, description, primary image URL,
   * seller ID (for attribution), and the category ID (which must correspond to
   * a leaf node in the categories hierarchy). The API validates that all
   * required fields are provided, the product's name is unique for the seller
   * within their product catalog, and that the category exists and is active.
   * Only sellers or admins can use this operation, with admins being able to
   * attribute listings to any seller while sellers may only list on their own
   * behalf.
   *
   * Once validated, the operation creates a new record in
   * shopping_mall_products and returns the resulting product entity, including
   * all its schema-defined fields. No SKU, options, or images are created at
   * this stage; these are handled in separate subsidiary operations. Security
   * measures ensure only authenticated seller or admin roles may execute this
   * action. The response includes the created product details and can be used
   * as the parent for downstream SKU or option creation, and for product
   * catalog listing displays. Error handling includes invalid or missing
   * attributes, duplicate product name for seller, invalid/disabled category
   * selection, and unauthorized access attempts.
   *
   * This operation directly relates to the shopping_mall_products entity. Any
   * subsequent product update, SKU setup, or category assignment relies on the
   * product record created here. It upholds all validations and business logic
   * encoded within the product creation business flow, integrates with catalog
   * indexers for product search functionality, and triggers cache or index
   * refresh on successful create. All access and creation events are logged for
   * product auditing as described in the requirements analysis.
   *
   * @param connection
   * @param body New product creation details, including name, description,
   *   seller attribution, category, status, and main image URL. Must comply
   *   with schema and business rule validations.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @SellerAuth()
    seller: SellerPayload,
    @TypedBody()
    body: IShoppingMallProduct.ICreate,
  ): Promise<IShoppingMallProduct> {
    try {
      return await postShoppingMallSellerProducts({
        seller,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update details of an existing product (shopping_mall_products table).
   *
   * This endpoint supports authorized sellers and platform administrators in
   * updating details of an existing product. Invoking this action requires
   * specifying the productId path parameter, which must correspond to a
   * persisted shopping_mall_products record that is accessible to the
   * requesting user (ownership or admin privileges enforced). The request body
   * may specify any writable field for products: name, description, main image,
   * activation status, or category association (category must exist and be
   * active/leaf).
   *
   * Business logic validates uniqueness of the product name within the seller's
   * assortment, prevents assignment to disabled or non-leaf categories, and
   * requires all field format constraints in the schema to be satisfied. The
   * operation does not affect SKUs, options, or inventory, which must be
   * managed through separate endpoints. Admins may reassign products or
   * forcibly update any product unless locked by compliance rules; sellers may
   * only update their own items. All changes trigger audit logging and search
   * index refresh if product name/category changes. Error handling includes
   * permission violations, non-existent product, duplicate product name,
   * invalid or inactive category, and field validation errors according to
   * platform policy.
   *
   * This update operation is an essential part of catalog maintenance,
   * rebranding, or correcting listing mistakes. Downstream operations (SKU
   * editing, inventory management) depend on the persistence and integrity of
   * product attributes defined and updated through this endpoint.
   *
   * @param connection
   * @param productId Unique identifier of the target product to update.
   * @param body Updated product attributes, such as name, description, active
   *   status, main image, or category re-association. Partial updates, but
   *   input must satisfy schema and business rules.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":productId")
  public async update(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProduct.IUpdate,
  ): Promise<IShoppingMallProduct> {
    try {
      return await putShoppingMallSellerProductsProductId({
        seller,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently remove a product and all its associated data by ID from the
   * platform catalog (shopping_mall_products table).
   *
   * This API operation enables an admin or authorized seller to permanently
   * remove a specific product from the platform catalog based on its unique
   * identifier (UUID). The request targets the product as defined in the
   * shopping_mall_products schema table.
   *
   * The permanent deletion process ensures that all direct and subsidiary
   * relations—including product SKUs, options, option values, product images,
   * and product-category links—are fully removed through cascade deletion
   * policies set at the database level. This operation must validate that there
   * are no active or open orders containing any SKU linked to this product. If
   * such orders exist, the operation will fail with a clear error explaining
   * that only products with no live order associations can be deleted,
   * consistent with domain business rules.
   *
   * Permanent product deletion is only permitted for products not in use by
   * ongoing order processing flows. Deleting an actively referenced product
   * would violate fulfillment integrity, impact customer order history, and
   * disrupt platform recordkeeping. This ensures compliance with catalog
   * management requirements and cohesive catalog navigation for all users.
   * Appropriate authorization (admin or the owning seller) is required to
   * execute this action.
   *
   * Response status confirms successful hard deletion. If a product is
   * referenced by any open order, an error is returned explaining the violation
   * of business logic. The operation’s implementation enforces database
   * referential integrity and robust error handling for edge cases.
   *
   * @param connection
   * @param productId Unique identifier of the product to be deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":productId")
  public async erase(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallSellerProductsProductId({
        seller,
        productId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
