import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchShoppingMallCustomerCustomersCustomerIdAddresses } from "../../../../../providers/patchShoppingMallCustomerCustomersCustomerIdAddresses";
import { CustomerAuth } from "../../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../../decorators/payload/CustomerPayload";
import { getShoppingMallCustomerCustomersCustomerIdAddressesAddressId } from "../../../../../providers/getShoppingMallCustomerCustomersCustomerIdAddressesAddressId";
import { putShoppingMallCustomerCustomersCustomerIdAddressesAddressId } from "../../../../../providers/putShoppingMallCustomerCustomersCustomerIdAddressesAddressId";
import { deleteShoppingMallCustomerCustomersCustomerIdAddressesAddressId } from "../../../../../providers/deleteShoppingMallCustomerCustomersCustomerIdAddressesAddressId";

import { IPageIShoppingMallCustomerAddress } from "../../../../../api/structures/IPageIShoppingMallCustomerAddress";
import { IShoppingMallCustomerAddress } from "../../../../../api/structures/IShoppingMallCustomerAddress";

@Controller("/shoppingMall/customer/customers/:customerId/addresses")
export class ShoppingmallCustomerCustomersAddressesController {
  /**
   * Fetch a paginated list of addresses for a given customerId in
   * shopping_mall_customer_addresses.
   *
   * Retrieve a paginated and optionally filtered list of all addresses
   * registered by a specified customer. The API operates on the
   * shopping_mall_customer_addresses table, using customer_id as the foreign
   * key to retrieve addresses belonging to a single customer. All relevant
   * address fields—recipient_name, phone, region, postal_code, address lines,
   * is_default, and timestamps—are included per the Prisma column definitions.
   *
   * Customers must be authenticated to fetch their own address book;
   * authorization is enforced on customerId to ensure ownership. Advanced
   * features support filtering by region, postal_code, or searching for partial
   * address text, as well as sorting by created_at, updated_at, or is_default
   * flag.
   *
   * This endpoint is typically used in the account dashboard for browsing or
   * managing shipping information, as well as in checkout workflows for
   * selecting or updating delivery addresses. Security checks ensure that the
   * requesting token's user matches the customerId path parameter, or else
   * admin override is required. All data is returned in paginated form to
   * support users with many addresses.
   *
   * This operation is related to address creation, update, and deletion
   * endpoints, and is a primary part of customer self-service interfaces.
   * Errors are returned if customerId is not found or the user is not
   * authorized to view specified addresses.
   *
   * @param connection
   * @param customerId Unique identifier of the customer whose addresses should
   *   be fetched (UUID).
   * @param body Request body to specify search, filtering, sorting, and
   *   pagination options for fetching address list.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCustomerAddress.IRequest,
  ): Promise<IPageIShoppingMallCustomerAddress> {
    try {
      return await patchShoppingMallCustomerCustomersCustomerIdAddresses({
        customer,
        customerId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific customer address by customerId and addressId
   * (shopping_mall_customer_addresses table).
   *
   * This operation enables an authenticated customer to retrieve the full
   * details of a single address from their address book, identified by the
   * specified addressId and customerId. It covers fields such as recipient
   * name, phone number, region, postal code, address_line1 and address_line2,
   * is_default flag, creation and updated timestamps, and soft-deletion status
   * (address is ignored if deleted_at is not null).
   *
   * Security is enforced by ensuring only the owning customer (customerId) is
   * allowed to view their own addresses; cross-customer access is forbidden.
   * The operation returns a single address as defined in the
   * shopping_mall_customer_addresses Prisma model, with all available fields.
   * Any attempt to access an address not belonging to the customer, or a
   * soft-deleted address, should return an appropriate error (not found or
   * forbidden).
   *
   * This operation is essential for the customer profile management flow, order
   * checkout pre-fill, and address editing. It directly references the
   * shopping_mall_customer_addresses table in the Prisma DB. Related API
   * operations include updating (PUT) or deleting an address, as well as
   * listing all addresses for a customer. Implementers must validate both the
   * path parameters and apply authorization logic matching the business rule:
   * only the address owner can view the address detail.
   *
   * @param connection
   * @param customerId Unique identifier (UUID) of the customer who owns the
   *   address.
   * @param addressId Unique identifier (UUID) of the address to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":addressId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("addressId")
    addressId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallCustomerAddress> {
    try {
      return await getShoppingMallCustomerCustomersCustomerIdAddressesAddressId(
        {
          customer,
          customerId,
          addressId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing customer address for a customer
   * (shopping_mall_customer_addresses table).
   *
   * This operation allows an authenticated customer to update the information
   * for a specific address in their address book, referenced by customerId and
   * addressId. Supports updates to recipient_name, phone, region, postal_code,
   * address_line1, address_line2, and is_default flag. The operation ensures
   * only addresses belonging to the specified customer may be edited, and only
   * if the address is not soft-deleted. Business logic enforces that if
   * is_default is set to true, any previous default address for this customer
   * is updated to is_default=false so that at most one default address exists
   * per customer.
   *
   * Security is critical: only the owning customer is allowed to perform
   * updates, and attempts to edit non-owned or deleted addresses are forbidden.
   * The request body must match the IShoppingMallCustomerAddress.IUpdate type,
   * referencing all updatable fields. Accurate timestamping and audit logging
   * for compliance are required.
   *
   * This relates directly to shopping_mall_customer_addresses in the Prisma
   * schema. Related operations include get (GET) and delete (DELETE) address,
   * and the update method must respect uniqueness and referential integrity for
   * customerId/addressId. Proper error handling must distinguish between not
   * found, forbidden, and validation errors.
   *
   * @param connection
   * @param customerId Unique identifier (UUID) of the customer who owns the
   *   address.
   * @param addressId Unique identifier (UUID) of the address to update.
   * @param body Fields for updating the customer address as defined in
   *   IShoppingMallCustomerAddress.IUpdate. Includes recipient name, phone,
   *   region, postal code, address lines, optional is_default flag, etc.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":addressId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("addressId")
    addressId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCustomerAddress.IUpdate,
  ): Promise<IShoppingMallCustomerAddress> {
    try {
      return await putShoppingMallCustomerCustomersCustomerIdAddressesAddressId(
        {
          customer,
          customerId,
          addressId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a customer's address (shopping_mall_customer_addresses table)
   * with authorization and ownership checks.
   *
   * This operation provides a mechanism for customers to manage their own
   * address book by removing an address entry. When the customer requests to
   * delete an address, the system will verify that the address exists and is
   * owned by the currently authenticated user. Only the address owner or
   * administrators are permitted to invoke this operation, ensuring that
   * private address data is secured against unauthorized deletion.
   *
   * Upon successful validation, the address is permanently removed from the
   * shopping_mall_customer_addresses table. Since the column 'deleted_at'
   * exists, this operation should perform a soft delete, marking the deleted_at
   * timestamp instead of physically removing the row, in order to preserve
   * deletion history for audit trails. Any attempt to delete an address that
   * does not belong to the user should trigger a forbidden error.
   *
   * The system must check for business logic such as whether the address is
   * currently associated with pending orders or if it was the only or default
   * address on file. Appropriate validation or error handling must communicate
   * to the user if the address cannot be deleted due to these business
   * constraints. Related APIs for managing addresses (add, update, set as
   * default) should be referenced for complete address management flows.
   *
   * Error handling covers edge cases such as trying to delete non-existent
   * addresses, deleting another user's address, or attempting to remove the
   * only default address without providing an alternative.
   *
   * @param connection
   * @param customerId The unique identifier of the customer who owns the
   *   address being deleted.
   * @param addressId The unique identifier of the customer address to be
   *   deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":addressId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("addressId")
    addressId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallCustomerCustomersCustomerIdAddressesAddressId(
        {
          customer,
          customerId,
          addressId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
