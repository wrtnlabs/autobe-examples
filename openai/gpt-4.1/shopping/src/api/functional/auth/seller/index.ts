import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSeller } from "../../../structures/IShoppingMallSeller";

/**
 * Register a new seller and issue first JWT tokens (shopping_mall_sellers
 * table).
 *
 * This API allows a new seller to register for an account on the e-commerce
 * platform by providing all legally required business information and
 * credentials. It interacts directly with the shopping_mall_sellers table to
 * create a new seller record and initializes the email_verified field to false
 * until verification is completed.
 *
 * After inserting the new record, the system generates a pending account
 * requiring email verification by sending a verification record (referencing
 * the user's new id) to shopping_mall_email_verifications, which is not exposed
 * by this endpoint. The approval_status is set to 'pending', and KYC document
 * upload is optional at registration. Passwords are securely hashed using
 * BCrypt and only the hash is stored, with the response masking all sensitive
 * values and tokens.
 *
 * This operation never allows registration if the seller email or business
 * registration number are already present in the database, enforcing unique
 * constraints for both. Any validation errors produce clear error responses,
 * and rate limiting can be enforced as a security precaution for abuse
 * prevention.
 *
 * The response never includes the password_hash, kyc_document_uri, or
 * approval_status. Upon successful registration, a JWT is issued in the
 * response of type IShoppingMallSeller.IAuthorized. This token incorporates
 * user id, role, permissions array, and expiry as required by the requirements
 * and reflected in the schema.
 *
 * Security and business compliance are strictly enforced by only referencing
 * fields that exist in the shopping_mall_sellers schema, and integration with
 * the shopping_mall_email_verifications table for subsequent flows. Related
 * API: email verification endpoint (external to this interface), login,
 * refresh.
 *
 * This endpoint provides the initial step in the seller authentication
 * workflow. To obtain tokens after email verification, use the login endpoint.
 *
 * @param props.connection
 * @param props.body Seller registration form, including all legal business
 *   details and credentials.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/join
 * @accessor api.functional.auth.seller.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Seller registration form, including all legal business details and
     * credentials.
     */
    body: IShoppingMallSeller.IJoin;
  };
  export type Body = IShoppingMallSeller.IJoin;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/join";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a seller by email/password and issue session JWT tokens
 * (shopping_mall_sellers table).
 *
 * Authenticates a seller by checking the email/password combination against the
 * shopping_mall_sellers schema. The endpoint requires the provided email to
 * match an existing seller with email_verified true and approval_status
 * 'approved'. The seller's password is checked using a secure BCrypt comparison
 * with the stored password_hash, and no sensitive credential data is ever
 * returned.
 *
 * If authentication is successful, the system creates a new record in the
 * shopping_mall_user_sessions table, generating a new pair of JWT tokens
 * (access + refresh) as per platform session policy. The response consists of
 * these tokens inside the IShoppingMallSeller.IAuthorized response body, which
 * encodes the seller's id, their role, permissions, and expiry in JWT claims.
 *
 * The API strictly enforces business and security rules: rejected or suspended
 * seller accounts, unverified emails, or pending admin approval status all
 * prevent authentication. Any failed login attempt is recorded for brute-force
 * detection and rate-limited as necessary. The tokens are securely formed and
 * never expose underlying user or session secrets.
 *
 * This API does not return profile or business details, only the authentication
 * envelope. For session refresh, use the dedicated refresh endpoint with a
 * valid refresh token. This is the core login operation for authorized sessions
 * of sellers.
 *
 * @param props.connection
 * @param props.body Seller credential (login) form with email and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/login
 * @accessor api.functional.auth.seller.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Seller credential (login) form with email and password. */
    body: IShoppingMallSeller.ILogin;
  };
  export type Body = IShoppingMallSeller.ILogin;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/login";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Exchange a seller's refresh token for a new access token
 * (shopping_mall_user_sessions table).
 *
 * Refreshes the authentication token for a seller given a valid refresh token.
 * The endpoint validates the provided refresh token by checking it against the
 * shopping_mall_user_sessions table, ensuring the token is active, not expired,
 * and not revoked. Only matching tokens granted to approved and fully verified
 * seller accounts are permitted to be refreshed.
 *
 * If validation succeeds, a new access and refresh token are issued and
 * returned using the IShoppingMallSeller.IAuthorized DTO, encoding the seller's
 * id, role, and updated JWT expiry in the payload. No business or sensitive
 * profile information is returned.
 *
 * Any invalid, expired, or revoked refresh tokens trigger an explicit error
 * response. Tokens are securely rotated and blacklisted as necessary, per
 * shopping_mall_user_sessions logic. The session's device_info, if present, may
 * be used for additional security validations but is not exposed via this
 * endpoint.
 *
 * The refresh endpoint is a key part of the seller authentication lifecycle,
 * providing seamless session extension while enforcing security and compliance.
 * For registration and initial login, use the /auth/seller/join and
 * /auth/seller/login endpoints respectively, as required by business rules.
 *
 * @param props.connection
 * @param props.body Refresh token envelope for sellers. Must include valid
 *   refresh_token.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/refresh
 * @accessor api.functional.auth.seller.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token envelope for sellers. Must include valid refresh_token. */
    body: IShoppingMallSeller.IRefresh;
  };
  export type Body = IShoppingMallSeller.IRefresh;
  export type Response = IShoppingMallSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/refresh";
  export const random = (): IShoppingMallSeller.IAuthorized =>
    typia.random<IShoppingMallSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
