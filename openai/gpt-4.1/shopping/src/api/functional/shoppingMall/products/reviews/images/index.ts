import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIShoppingMallReviewImage } from "../../../../../structures/IPageIShoppingMallReviewImage";
import { IShoppingMallReviewImage } from "../../../../../structures/IShoppingMallReviewImage";

/**
 * Retrieve all images for a given product review (shopping_mall_review_images).
 *
 * This endpoint allows any user (including guests) to retrieve the complete set
 * of images linked to a specific review on a product. The images serve as
 * supplementary content to review text, enhancing authenticity and transparency
 * for other customers considering a purchase. Each image is stored as a URI
 * reference and includes metadata such as display order and alt text for
 * accessibility.
 *
 * Images are filtered to exclude any that are soft-deleted (indicated by a
 * non-null deleted_at in the shopping_mall_review_images schema) and are sorted
 * by display order. The operation pulls all image records matching the given
 * reviewId, ensuring only images visible to the public are returned. This
 * incorporates detailed comments from the shopping_mall_review_images Prisma
 * model, emphasizing its role as a subsidiary entity and part of broader review
 * content management.
 *
 * No authentication or authorization is required, as review images are public.
 * However, implementation should consider safe handling of image URIs,
 * prevention of information leakage through deleted/hidden content, and
 * consistency with platform-wide content moderation rules.
 *
 * @param props.connection
 * @param props.productId Target product's unique identifier (UUID) for which
 *   the review belongs
 * @param props.reviewId Unique identifier (UUID) of the target review whose
 *   images are being retrieved
 * @path /shoppingMall/products/:productId/reviews/:reviewId/images
 * @accessor api.functional.shoppingMall.products.reviews.images.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Target product's unique identifier (UUID) for which the review
     * belongs
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier (UUID) of the target review whose images are being
     * retrieved
     */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIShoppingMallReviewImage;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/products/:productId/reviews/:reviewId/images",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}/images`;
  export const random = (): IPageIShoppingMallReviewImage =>
    typia.random<IPageIShoppingMallReviewImage>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single review image by its ID (shopping_mall_review_images).
 *
 * This endpoint fetches the details for a single image associated with a
 * particular review of a product. The imageId parameter uniquely identifies the
 * image entry within the context of the referenced review and product. Returned
 * payload includes the URI (URL) to the uploaded image, optional alt text for
 * accessibility, display ordering, and any other non-deleted metadata from the
 * shopping_mall_review_images Prisma model.
 *
 * The system validates that the imageId is attached to the specified reviewId
 * and productId, ensuring no data leak or mismatched context. If the image is
 * soft-deleted (deleted_at not null), it will not be returned and appropriate
 * not-found or access-denied behavior is expected. The operation is public;
 * access control is generally not required unless hosting sensitive review
 * images (in which case additional filtering/sanitization logic may be added).
 *
 * This endpoint is closely related to the list/retrieve operation for review
 * images and is expected to be used in scenarios such as gallery lightbox
 * previews or programmatic access for generating product pages.
 *
 * @param props.connection
 * @param props.productId UUID of the product to which the review and image
 *   belong
 * @param props.reviewId UUID of the parent review record that owns the image
 * @param props.imageId UUID for the review image to be retrieved
 * @path /shoppingMall/products/:productId/reviews/:reviewId/images/:imageId
 * @accessor api.functional.shoppingMall.products.reviews.images.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the product to which the review and image belong */
    productId: string & tags.Format<"uuid">;

    /** UUID of the parent review record that owns the image */
    reviewId: string & tags.Format<"uuid">;

    /** UUID for the review image to be retrieved */
    imageId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallReviewImage;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/products/:productId/reviews/:reviewId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IShoppingMallReviewImage =>
    typia.random<IShoppingMallReviewImage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
