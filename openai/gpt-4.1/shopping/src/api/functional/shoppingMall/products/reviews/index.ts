import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReview } from "../../../../structures/IShoppingMallReview";
import { IPageIShoppingMallReview } from "../../../../structures/IPageIShoppingMallReview";
export * as images from "./images/index";
export * as replies from "./replies/index";

/**
 * Search and paginate product reviews for a given product
 * (shopping_mall_reviews table).
 *
 * Retrieve a filtered and paginated list of customer product reviews for a
 * given product by specifying the productId path parameter. This highly
 * flexible endpoint supports searching reviews by status (e.g., approved,
 * pending, rejected), star rating (1–5), creation and update timestamps, and
 * provides rich pagination and sorting options to support large review
 * volumes.
 *
 * The operation is available to all roles: customers (for public/approved
 * reviews), sellers (for their own product reviews with moderation data), and
 * admins (for moderation, audit, and platform management). The response
 * provides summaries with review rating, text snippet, author, creation date,
 * moderation status, and attached media previews. Complex filtering supports
 * large catalogs, abusive content moderation, and user-experience workflows
 * such as filtering by rating, recency, or status.
 *
 * Business logic enforces review status visibility based on role and product
 * ownership—sellers are restricted to their own products' reviews, while admins
 * can search and filter across all statuses. Customers can only access
 * public/approved reviews for products. Edge cases include empty result sets,
 * out-of-bounds pages, or inappropriate filter criteria, which should be
 * gracefully handled with clear error messages.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose reviews are
 *   being searched and retrieved
 * @param props.body Advanced search and filter criteria for locating product
 *   reviews, including status, star rating, creation range, sorting, and
 *   pagination parameters
 * @path /shoppingMall/products/:productId/reviews
 * @accessor api.functional.shoppingMall.products.reviews.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the product whose reviews are being searched and
     * retrieved
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Advanced search and filter criteria for locating product reviews,
     * including status, star rating, creation range, sorting, and
     * pagination parameters
     */
    body: IShoppingMallReview.IRequest;
  };
  export type Body = IShoppingMallReview.IRequest;
  export type Response = IPageIShoppingMallReview.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/products/:productId/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/reviews`;
  export const random = (): IPageIShoppingMallReview.ISummary =>
    typia.random<IPageIShoppingMallReview.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific product review by product and review ID from
 * shopping_mall_reviews.
 *
 * Retrieve the detailed information of a specific product review. This API
 * endpoint serves to fetch all core fields of a review, such as the review
 * text, star rating, status (pending, approved, rejected, or hidden), author,
 * and audit timestamps. Product reviews in the shopping_mall_reviews table are
 * uniquely identified by composite (product_id, review_id) and are always
 * linked to a product and a customer for validation.
 *
 * The operation requires both product and review identifiers as path parameters
 * to ensure strict scoping—this prevents leaking reviews across unrelated
 * products and supports auditability. Only reviews which exist and are related
 * to the specified product are retrievable. Appropriate error handling is
 * enforced for not found, mismatches, or unauthorized access cases.
 *
 * Security is generally public for product review retrieval, but if reviews are
 * pending moderation or marked hidden, additional permission checks may be
 * imposed by the provider logic. The underlying Prisma schema ensures one
 * review per (customer, product, order). Responses are aligned with the
 * IShoppingMallReview DTO, which includes all essential review and relationship
 * fields for application consumption.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the product whose review is
 *   being requested.
 * @param props.reviewId The unique identifier of the review to retrieve.
 * @path /shoppingMall/products/:productId/reviews/:reviewId
 * @accessor api.functional.shoppingMall.products.reviews.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier of the product whose review is being requested. */
    productId: string & tags.Format<"uuid">;

    /** The unique identifier of the review to retrieve. */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/products/:productId/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
