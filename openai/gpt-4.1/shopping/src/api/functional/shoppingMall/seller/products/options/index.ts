import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductOption } from "../../../../../structures/IShoppingMallProductOption";
export * as values from "./values/index";

/**
 * Create a product option for a given product in shopping_mall_product_options
 * table.
 *
 * Allows the authenticated seller of a product, or an admin, to define a new
 * product option within an existing product for variant management. This
 * operation is functionally tied to the shopping_mall_product_options table in
 * the Prisma schema, which contains fields for the option's parent product,
 * display name, display order, and timestamps for audit.
 *
 * The operation imposes business validation such that only an authenticated
 * seller who owns the product or an admin may create product options. Duplicate
 * option names for the same product are not allowed, and all option names must
 * comply with business naming conventions. The creation also timestamps audit
 * information for later review.
 *
 * This operation presumes that options are essential for generating all valid
 * SKU combinations for a product. API consumers should be aware that creating
 * an option does not automatically generate SKUs but allows subsequent
 * composition of product variants. If the same option name exists for the
 * targeted product, the server returns a conflict error. Related APIs include
 * product option value management and SKU creation endpoints.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product to which the
 *   option will be added.
 * @param props.body Parameters for creating a product option, such as name and
 *   display order.
 * @path /shoppingMall/seller/products/:productId/options
 * @accessor api.functional.shoppingMall.seller.products.options.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the parent product to which the option will be
     * added.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Parameters for creating a product option, such as name and display
     * order.
     */
    body: IShoppingMallProductOption.ICreate;
  };
  export type Body = IShoppingMallProductOption.ICreate;
  export type Response = IShoppingMallProductOption;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products/:productId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options`;
  export const random = (): IShoppingMallProductOption =>
    typia.random<IShoppingMallProductOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a product option for a specific product in
 * shopping_mall_product_options table.
 *
 * Enables the seller of a product or an admin user to modify an existing
 * product option. This is applied to records in the
 * shopping_mall_product_options table which stores information on options like
 * size, color, and other configurable fields relevant for SKU generation.
 *
 * The operation strictly checks that only the product's owning seller or an
 * admin can update the option, enforcing correct authorization and preventing
 * cross-product editing. Business rules forbid duplicate option names for a
 * given product and require the option name to conform to platform validation
 * rules (length, prohibited characters, etc). Update timestamps are maintained
 * for auditing purposes.
 *
 * If the specified product or option ID does not exist, or if the user attempts
 * to assign a duplicate name, the operation returns an error. This API is
 * typically called as part of catalog management interfaces for sellers and
 * admin dashboards. Related endpoints include option creation, deletion, and
 * SKU management APIs.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product to which the
 *   option belongs.
 * @param props.optionId Unique identifier of the product option to be updated.
 * @param props.body Information required to update a product option, including
 *   updated name or display order.
 * @path /shoppingMall/seller/products/:productId/options/:optionId
 * @accessor api.functional.shoppingMall.seller.products.options.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the parent product to which the option belongs. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the product option to be updated. */
    optionId: string & tags.Format<"uuid">;

    /**
     * Information required to update a product option, including updated
     * name or display order.
     */
    body: IShoppingMallProductOption.IUpdate;
  };
  export type Body = IShoppingMallProductOption.IUpdate;
  export type Response = IShoppingMallProductOption;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/options/:optionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallProductOption =>
    typia.random<IShoppingMallProductOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific product option from a product
 * (shopping_mall_product_options) if not used by SKUs.
 *
 * This API endpoint enables sellers or administrators to permanently delete a
 * specific option (such as 'Color' or 'Size') from a given product in the
 * catalog. Deletion is allowed only if the option belongs to the targeted
 * product and the requesting user is authorized. The system enforces business
 * rules such that if any SKU is currently configured to use this option,
 * deletion is strictly blocked. The client receives an informative error if
 * attempting to delete an option that is still referenced in product variants.
 *
 * Security is enforced such that only the product's owning seller or an admin
 * can execute this operation. Audit logs are maintained for compliance and
 * transparency. The product option removal updates all related database
 * references and supports real-time cache or indexing triggers, if any, to
 * ensure product listings remain accurate.
 *
 * This operation is crucial for catalog maintenance, variant management, and
 * keeping product metadata clean, as enforced by catalog management business
 * logic.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the product to which the
 *   option belongs.
 * @param props.optionId The unique identifier of the product option to delete.
 * @path /shoppingMall/seller/products/:productId/options/:optionId
 * @accessor api.functional.shoppingMall.seller.products.options.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the product to which the option belongs. */
    productId: string & tags.Format<"uuid">;

    /** The unique identifier of the product option to delete. */
    optionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId/options/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
