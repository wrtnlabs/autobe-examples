import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductSku } from "../../../../../structures/IShoppingMallProductSku";
import { IPageIShoppingMallProductSku } from "../../../../../structures/IPageIShoppingMallProductSku";
export * as images from "./images/index";
export * as inventory from "./inventory/index";

/**
 * Create a new SKU (shopping_mall_product_skus) under a product by productId.
 *
 * Create a new product SKU for an existing product under the specific
 * productId. This operation accepts a well-formed SKU creation structure
 * (including sku_code, name, price, status, low_stock_threshold, and option
 * value mapping) in the request body. The system checks that the productId
 * exists and belongs to the current seller or is accessible to admin, and that
 * the SKU meets all Prisma schema constraints (e.g., name, code uniqueness,
 * valid price, option configuration, and link to inventory records).
 *
 * The operation is authorized for roles seller and admin (as enforced by
 * row-level and business validation). Attempts by unauthenticated or customer
 * users are rejected. Required fields and relationships are validated strictly
 * per the Prisma schema: SKU name and code must be unique within the product;
 * price must be positive as enforced by business rules; option assignments must
 * map to available option values; and an initial inventory state is established
 * on creation as required by inventory logic.
 *
 * Returned data is the complete SKU entity, with inventory and option state,
 * enabling follow-up actions on catalog management or integration into purchase
 * flows. Failed creation returns detailed errors, such as duplication or
 * invalid configuration, for correction by the caller.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to which this SKU
 *   will be added.
 * @param props.body Creation payload for a new SKU under the given productId,
 *   following IShoppingMallProductSku.ICreate contract.
 * @path /shoppingMall/seller/products/:productId/skus
 * @accessor api.functional.shoppingMall.seller.products.skus.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier for the product to which this SKU will be added. */
    productId: string & tags.Format<"uuid">;

    /**
     * Creation payload for a new SKU under the given productId, following
     * IShoppingMallProductSku.ICreate contract.
     */
    body: IShoppingMallProductSku.ICreate;
  };
  export type Body = IShoppingMallProductSku.ICreate;
  export type Response = IShoppingMallProductSku;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products/:productId/skus",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IShoppingMallProductSku =>
    typia.random<IShoppingMallProductSku>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve and paginate a filtered list of all SKUs/variants for a specific
 * product (shopping_mall_product_skus table).
 *
 * This API operation provides a seller or admin with the ability to search,
 * filter, and paginate over all SKUs (variants) associated with a given
 * product, identified by its productId. It is linked to the
 * shopping_mall_product_skus table, as well as related tables for product
 * options and SKU option values.
 *
 * A PATCH request enables advanced request body filtering: search by SKU name,
 * code, status (e.g., active/inactive/blocked), inventory status, price range,
 * and other SKU-level attributes as defined in the Prisma schema. Results are
 * paginated with full support for sorting by fields such as creation date,
 * price, or name. Filtering can include inventory status, option selections
 * (e.g., color/size), or activity ranges. This operation powers catalog
 * management screens, enables sellers to review all variant SKUs efficiently,
 * and supports administrative oversight for compliance, moderation, or
 * inventory audits.
 *
 * The response is a paginated list of detailed SKU entities, with optional
 * summaries or custom projections if required. Associated option/option-value
 * data is included for effective inventory and listing management. Only
 * authorized sellers (owning the product) or admins may utilize this advanced
 * search endpoint. Security controls ensure no leakage of SKU/catalog content
 * across vendors or unauthorized system actors. The implementation includes
 * robust input validation, error handling, and consistent pagination metadata.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product for which SKUs
 *   are listed.
 * @param props.body Advanced search, filter, and sorting parameters for SKU
 *   variant listing.
 * @path /shoppingMall/seller/products/:productId/skus
 * @accessor api.functional.shoppingMall.seller.products.skus.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the parent product for which SKUs are listed. */
    productId: string & tags.Format<"uuid">;

    /**
     * Advanced search, filter, and sorting parameters for SKU variant
     * listing.
     */
    body: IShoppingMallProductSku.IRequest;
  };
  export type Body = IShoppingMallProductSku.IRequest;
  export type Response = IPageIShoppingMallProductSku;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/seller/products/:productId/skus",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus`;
  export const random = (): IPageIShoppingMallProductSku =>
    typia.random<IPageIShoppingMallProductSku>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a product's SKU information in the shopping_mall_product_skus table,
 * reflecting changes to SKU name, price, status, image, or options.
 *
 * Update an existing SKU for a product by specifying the productId and skuId.
 * This operation supports modifications to SKU fields such as name, price,
 * status (active/inactive/blocked), low_stock_threshold, or main image URL.
 * Modification requests are validated for correct SKU ownership, business rule
 * compliance (SKU name uniqueness for the product, no updates that violate
 * inventory integrity or affect pending orders), and role-based access (seller
 * can only update their own SKUs; admin may update any).
 *
 * Each update is audited with a timestamp and user context recorded in
 * associated platform activity logs. If invalid values are supplied, such as
 * negative prices or duplicate SKU names, descriptive validation errors are
 * returned. If SKU cannot be found or does not belong to the specified product,
 * a not-found error is returned. Business logic ensures that SKU option values
 * and price updates are atomic and consistent.
 *
 * This endpoint is foundational for seller catalog maintenance and admin
 * interventions to resolve catalog errors or compliance issues. Related
 * endpoints include product listing retrieval, SKU creation, and product-level
 * updates.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the parent product to which this
 *   SKU belongs.
 * @param props.skuId Unique identifier for the SKU (Stock Keeping Unit) to be
 *   updated within the product.
 * @param props.body Fields to update for the product SKU, such as name, price,
 *   status, image, and option values.
 * @path /shoppingMall/seller/products/:productId/skus/:skuId
 * @accessor api.functional.shoppingMall.seller.products.skus.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the parent product to which this SKU belongs. */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the SKU (Stock Keeping Unit) to be updated
     * within the product.
     */
    skuId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the product SKU, such as name, price, status,
     * image, and option values.
     */
    body: IShoppingMallProductSku.IUpdate;
  };
  export type Body = IShoppingMallProductSku.IUpdate;
  export type Response = IShoppingMallProductSku;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/skus/:skuId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): IShoppingMallProductSku =>
    typia.random<IShoppingMallProductSku>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a specific SKU in shopping_mall_product_skus by marking
 * deleted_at, after verifying active order constraints and ownership.
 *
 * Soft-delete an existing SKU belonging to a product by specifying the
 * productId and skuId. The SKU must belong to the current seller or the
 * requester must be an admin. This operation marks the SKU as deleted by
 * setting its deleted_at timestamp, effectively removing it from catalog search
 * and purchase flows while preserving historical data for compliance.
 *
 * Before deletion, business logic checks ensure the SKU is not currently
 * associated with any active or pending orders. If the SKU is referenced in
 * pending transactions, the request is blocked and a clear, actionable error is
 * returned explaining why deletion cannot proceed. The deletion action is
 * audited for compliance. Related endpoints include listing SKUs for a product
 * and restoring or permanently erasing deleted SKUs if the business supports
 * such flows.
 *
 * No product-level data or related historical order data is deleted—this
 * endpoint only marks the specific SKU as deleted for the purposes of catalog
 * management and inventory control.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the parent product to which this
 *   SKU belongs.
 * @param props.skuId Unique identifier for the SKU (Stock Keeping Unit) to be
 *   deleted within the product.
 * @path /shoppingMall/seller/products/:productId/skus/:skuId
 * @accessor api.functional.shoppingMall.seller.products.skus.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the parent product to which this SKU belongs. */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the SKU (Stock Keeping Unit) to be deleted
     * within the product.
     */
    skuId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId/skus/:skuId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/skus/${encodeURIComponent(props.skuId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("skuId")(() => typia.assert(props.skuId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
