import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrder } from "../../../../structures/IShoppingMallOrder";
import { IPageIShoppingMallOrder } from "../../../../structures/IPageIShoppingMallOrder";
export * as items from "./items/index";
export * as shipments from "./shipments/index";
export * as statusHistory from "./statusHistory/index";
export * as payments from "./payments/index";
export * as cancellations from "./cancellations/index";
export * as refunds from "./refunds/index";

/**
 * Search and list paginated orders with advanced filters
 * (shopping_mall_orders).
 *
 * This endpoint provides a filtered, paginated list of orders in the shopping
 * mall platform. The operation queries the shopping_mall_orders entity, which
 * is the core table for storing order information including links to the
 * customer, optional seller reference (for split-orders), payment and shipping
 * addresses, and order items.
 *
 * The search supports advanced filtering (by order status, placed date,
 * customer or seller, order number, payment state), multi-field sorting, and
 * pagination for efficient access to potentially large datasets. Admin users
 * can access all orders; sellers may only access orders relevant to their
 * products. The structure of each result includes summary-level information:
 * order number, current status, order total, timestamp fields, main customer
 * reference, and, optionally, payment status/fulfillment data. This endpoint
 * also supports searching by keyword and filter combinations as defined in the
 * business requirement.
 *
 * Security is enforced by role constraints: admins have platform-wide access,
 * while sellers are strictly limited to their own orders. Customer-facing order
 * history may use a different, customer-restricted endpoint. Error handling
 * includes filters for non-existing search combinations and validation of
 * pagination parameters. This operation does not return full order details; for
 * that, the order detail endpoint should be used.
 *
 * @param props.connection
 * @param props.body Search and pagination criteria for retrieving filtered
 *   orders.
 * @path /shoppingMall/seller/orders
 * @accessor api.functional.shoppingMall.seller.orders.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and pagination criteria for retrieving filtered orders. */
    body: IShoppingMallOrder.IRequest;
  };
  export type Body = IShoppingMallOrder.IRequest;
  export type Response = IPageIShoppingMallOrder.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/seller/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/seller/orders";
  export const random = (): IPageIShoppingMallOrder.ISummary =>
    typia.random<IPageIShoppingMallOrder.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full detail of a single order from shopping_mall_orders by orderId.
 *
 * Retrieve the complete detail view of a single order as referenced by the
 * provided orderId. The operation fully exposes all attributes defined in
 * shopping_mall_orders, including customer and (where applicable) seller
 * association, shipping address snapshot, payment method snapshot, order line
 * items, shipment data, and full audit fields (created_at, updated_at,
 * deleted_at).
 *
 * From a security and access control perspective, only the owning customer, the
 * fulfilling seller (if present), and platform admins are allowed to view order
 * details. The endpoint must enforce this in implementation, ensuring customers
 * cannot access orders that do not belong to them, and sellers can only view
 * orders related to their products.
 *
 * All relationships (order items, status history, shipments, cancellations,
 * refunds) are framed as per the database design. Order data is provided
 * according to the schema structure and reflects the point-in-time state at
 * query, with full timeline context (placed_at, paid_at, fulfilled_at) and
 * business state if present. Expected errors include 404 for not found or 403
 * for unauthorized access.
 *
 * Related APIs include order search by customer, order listing for
 * seller/admin, and historic/timeline views for auditing. This endpoint is a
 * read-only accessor and does not modify data.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to retrieve (UUID from
 *   shopping_mall_orders.id).
 * @path /shoppingMall/seller/orders/:orderId
 * @accessor api.functional.shoppingMall.seller.orders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the order to retrieve (UUID from
     * shopping_mall_orders.id).
     */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing orderâ€™s details in the shoppingMall_orders table.
 *
 * This API operation permits the modification of a placed order's details
 * within the shoppingMall_orders entity. The purpose is to enable key actors
 * (customer, seller, admin) to update an order based on workflow stage and
 * permissions.
 *
 * Customers may request updates to shipping address, contact details, or cancel
 * orders that are still pending or processing. Sellers may update shipping
 * status, input shipment tracking numbers, or add operational comments if the
 * order is in the fulfillment stage. Admins retain global rights to override
 * any field in exceptional scenarios (e.g., fraud, user disputes, compliance).
 *
 * Security is strictly enforced via role-based authentication and order
 * ownership checks. Path parameter validation is required to ensure only the
 * intended order is modified. Attempting to update a finalized, cancelled, or
 * delivered order as a non-admin returns a validation error. All updates
 * trigger entry in the shopping_mall_admin_action_logs table for traceability.
 *
 * Business logic includes validation of eligibility for each update request
 * type: shipping address modification is only permitted before shipment, status
 * transitions follow defined state machines, and pricing/payment changes are
 * only processed by admin.
 *
 * This operation integrates with related schemas, including
 * shopping_mall_order_addresses (address snapshot),
 * shopping_mall_order_status_history (order audit), and
 * shopping_mall_admin_action_logs (event tracking). Error handling covers
 * invalid state transitions, unauthorized access, and data integrity issues.
 * Commonly related operations include placing new orders, viewing order
 * status/history, and handling order cancellation/refunds.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the order to be updated.
 * @param props.body Order update payload with only the fields eligible for
 *   modification based on business rules, such as status, shipping address, or
 *   remarks.
 * @path /shoppingMall/seller/orders/:orderId
 * @accessor api.functional.shoppingMall.seller.orders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the order to be updated. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Order update payload with only the fields eligible for modification
     * based on business rules, such as status, shipping address, or
     * remarks.
     */
    body: IShoppingMallOrder.IUpdate;
  };
  export type Body = IShoppingMallOrder.IUpdate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
