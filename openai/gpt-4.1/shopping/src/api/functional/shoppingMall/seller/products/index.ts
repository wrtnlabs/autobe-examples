import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProduct } from "../../../../structures/IShoppingMallProduct";
export * as skus from "./skus/index";
export * as options from "./options/index";
export * as images from "./images/index";
export * as reviews from "./reviews/index";

/**
 * Create a new product for sale (shopping_mall_products table).
 *
 * This API endpoint facilitates the onboarding of new sellable products by
 * authorized sellers or platform admins. When invoked, it expects complete
 * product details such as product name, description, primary image URL, seller
 * ID (for attribution), and the category ID (which must correspond to a leaf
 * node in the categories hierarchy). The API validates that all required fields
 * are provided, the product's name is unique for the seller within their
 * product catalog, and that the category exists and is active. Only sellers or
 * admins can use this operation, with admins being able to attribute listings
 * to any seller while sellers may only list on their own behalf.
 *
 * Once validated, the operation creates a new record in shopping_mall_products
 * and returns the resulting product entity, including all its schema-defined
 * fields. No SKU, options, or images are created at this stage; these are
 * handled in separate subsidiary operations. Security measures ensure only
 * authenticated seller or admin roles may execute this action. The response
 * includes the created product details and can be used as the parent for
 * downstream SKU or option creation, and for product catalog listing displays.
 * Error handling includes invalid or missing attributes, duplicate product name
 * for seller, invalid/disabled category selection, and unauthorized access
 * attempts.
 *
 * This operation directly relates to the shopping_mall_products entity. Any
 * subsequent product update, SKU setup, or category assignment relies on the
 * product record created here. It upholds all validations and business logic
 * encoded within the product creation business flow, integrates with catalog
 * indexers for product search functionality, and triggers cache or index
 * refresh on successful create. All access and creation events are logged for
 * product auditing as described in the requirements analysis.
 *
 * @param props.connection
 * @param props.body New product creation details, including name, description,
 *   seller attribution, category, status, and main image URL. Must comply with
 *   schema and business rule validations.
 * @path /shoppingMall/seller/products
 * @accessor api.functional.shoppingMall.seller.products.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * New product creation details, including name, description, seller
     * attribution, category, status, and main image URL. Must comply with
     * schema and business rule validations.
     */
    body: IShoppingMallProduct.ICreate;
  };
  export type Body = IShoppingMallProduct.ICreate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/seller/products";
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of an existing product (shopping_mall_products table).
 *
 * This endpoint supports authorized sellers and platform administrators in
 * updating details of an existing product. Invoking this action requires
 * specifying the productId path parameter, which must correspond to a persisted
 * shopping_mall_products record that is accessible to the requesting user
 * (ownership or admin privileges enforced). The request body may specify any
 * writable field for products: name, description, main image, activation
 * status, or category association (category must exist and be active/leaf).
 *
 * Business logic validates uniqueness of the product name within the seller's
 * assortment, prevents assignment to disabled or non-leaf categories, and
 * requires all field format constraints in the schema to be satisfied. The
 * operation does not affect SKUs, options, or inventory, which must be managed
 * through separate endpoints. Admins may reassign products or forcibly update
 * any product unless locked by compliance rules; sellers may only update their
 * own items. All changes trigger audit logging and search index refresh if
 * product name/category changes. Error handling includes permission violations,
 * non-existent product, duplicate product name, invalid or inactive category,
 * and field validation errors according to platform policy.
 *
 * This update operation is an essential part of catalog maintenance,
 * rebranding, or correcting listing mistakes. Downstream operations (SKU
 * editing, inventory management) depend on the persistence and integrity of
 * product attributes defined and updated through this endpoint.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the target product to update.
 * @param props.body Updated product attributes, such as name, description,
 *   active status, main image, or category re-association. Partial updates, but
 *   input must satisfy schema and business rules.
 * @path /shoppingMall/seller/products/:productId
 * @accessor api.functional.shoppingMall.seller.products.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target product to update. */
    productId: string & tags.Format<"uuid">;

    /**
     * Updated product attributes, such as name, description, active status,
     * main image, or category re-association. Partial updates, but input
     * must satisfy schema and business rules.
     */
    body: IShoppingMallProduct.IUpdate;
  };
  export type Body = IShoppingMallProduct.IUpdate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a product and all its associated data by ID from the
 * platform catalog (shopping_mall_products table).
 *
 * This API operation enables an admin or authorized seller to permanently
 * remove a specific product from the platform catalog based on its unique
 * identifier (UUID). The request targets the product as defined in the
 * shopping_mall_products schema table.
 *
 * The permanent deletion process ensures that all direct and subsidiary
 * relations—including product SKUs, options, option values, product images, and
 * product-category links—are fully removed through cascade deletion policies
 * set at the database level. This operation must validate that there are no
 * active or open orders containing any SKU linked to this product. If such
 * orders exist, the operation will fail with a clear error explaining that only
 * products with no live order associations can be deleted, consistent with
 * domain business rules.
 *
 * Permanent product deletion is only permitted for products not in use by
 * ongoing order processing flows. Deleting an actively referenced product would
 * violate fulfillment integrity, impact customer order history, and disrupt
 * platform recordkeeping. This ensures compliance with catalog management
 * requirements and cohesive catalog navigation for all users. Appropriate
 * authorization (admin or the owning seller) is required to execute this
 * action.
 *
 * Response status confirms successful hard deletion. If a product is referenced
 * by any open order, an error is returned explaining the violation of business
 * logic. The operation’s implementation enforces database referential integrity
 * and robust error handling for edge cases.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to be deleted.
 * @path /shoppingMall/seller/products/:productId
 * @accessor api.functional.shoppingMall.seller.products.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the product to be deleted. */
    productId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
