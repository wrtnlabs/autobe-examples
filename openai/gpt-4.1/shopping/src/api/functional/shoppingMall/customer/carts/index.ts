import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCart } from "../../../../structures/IShoppingMallCart";
import { IShoppingMallCartItem } from "../../../../structures/IShoppingMallCartItem";
import { IPageIShoppingMallCartItem } from "../../../../structures/IPageIShoppingMallCartItem";
export * as cartItems from "./cartItems/index";

/**
 * Create a new shopping cart for an authenticated customer and return the cart
 * information.
 *
 * Create a new shopping cart for the currently authenticated customer. This
 * writes a new entry into the shopping_mall_carts table, setting the owner and
 * default creation state. If the customer already has a cart, system logic may
 * choose to restore or merge with an abandoned/previous cart rather than create
 * a second one; business logic will enforce this uniqueness.
 *
 * Only an authenticated customer may use this endpoint. The system enforces
 * that no more than one cart exists per customer, returning the current cart
 * state if a cart already exists. Cart creation is typically handled
 * automatically upon user registration or login if no active cart exists, but
 * this API enables explicit cart creation when needed in the front-end flow.
 *
 * Related operations include cart retrieval, adding items, and cart
 * modification. Error handling addresses the case of duplicate cart creation
 * attempts or violation of unique-per-customer constraints.
 *
 * @param props.connection
 * @param props.body Parameters for creating a new shopping cart for the
 *   customer. Typically empty, but can be extended (e.g., for paying guest
 *   migration or cart merge instructions).
 * @path /shoppingMall/customer/carts
 * @accessor api.functional.shoppingMall.customer.carts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Parameters for creating a new shopping cart for the customer.
     * Typically empty, but can be extended (e.g., for paying guest
     * migration or cart merge instructions).
     */
    body: IShoppingMallCart.ICreate;
  };
  export type Body = IShoppingMallCart.ICreate;
  export type Response = IShoppingMallCart;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/carts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/carts";
  export const random = (): IShoppingMallCart =>
    typia.random<IShoppingMallCart>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated search and retrieval of items in a customer's shopping cart
 * (shopping_mall_carts, shopping_mall_cart_items).
 *
 * Retrieve a filtered and paginated list of shopping cart items for the
 * authenticated customer. This operation returns all SKUs held in the cart,
 * supporting search criteria such as product/SKU name, summary view, and
 * advanced sorting.
 *
 * This API integrates data from both the shopping_mall_carts and
 * shopping_mall_cart_items entities, returning each item's SKU, product detail
 * snapshot, unit price, added quantity, and last update time. The operation
 * supports pagination and sorting, allowing customers to efficiently manage
 * large or long-standing shopping carts.
 *
 * Authorization is strictly enforced: customers may only access their own carts
 * and cannot view or modify cart data of others. If no active cart is found,
 * the operation returns an empty result set. All returned data accurately
 * reflects the current state of the cart and its items in the
 * shopping_mall_carts and shopping_mall_cart_items tables.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination parameters for cart item
 *   retrieval.
 * @path /shoppingMall/customer/carts
 * @accessor api.functional.shoppingMall.customer.carts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filtering, and pagination parameters for cart item retrieval. */
    body: IShoppingMallCartItem.IRequest;
  };
  export type Body = IShoppingMallCartItem.IRequest;
  export type Response = IPageIShoppingMallCartItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/carts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/carts";
  export const random = (): IPageIShoppingMallCartItem =>
    typia.random<IPageIShoppingMallCartItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information of a shopping cart by cartId, including all
 * line items.
 *
 * Retrieve the details of a specific shopping cart, allowing a customer to view
 * the products, SKUs, and current quantities in their cart. This operation
 * references the shopping_mall_carts and shopping_mall_cart_items tables,
 * incorporating all cart structure, creation and update timestamps, and links
 * to associated user and SKUs according to the schema.
 *
 * Security enforces that only the owner of the cart (authenticated customer)
 * can access the cart, preventing unauthorized viewing by others. Admin users
 * may also have access to view any cart for customer service or troubleshooting
 * purposes. Attempts to access a non-existent or unauthorized cart will result
 * in clear error responses.
 *
 * Related business logic for price and inventory validation may be triggered
 * here to ensure displayed information is up-to-date. This operation is
 * frequently paired with cart modification and checkout processes in the
 * customer journey.
 *
 * @param props.connection
 * @param props.cartId Unique identifier (UUID) of the shopping cart to
 *   retrieve.
 * @path /shoppingMall/customer/carts/:cartId
 * @accessor api.functional.shoppingMall.customer.carts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the shopping cart to retrieve. */
    cartId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCart;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): IShoppingMallCart =>
    typia.random<IShoppingMallCart>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the existing shopping cart for the authenticated customer.
 *
 * This API endpoint enables a customer to update the contents or attributes of
 * their shopping cart. The cart is uniquely identified by the cartId path
 * parameter, which corresponds to the primary key in the shopping_mall_carts
 * table.
 *
 * Customers can use this operation to update their cart's items, such as
 * changing quantities or removing entire items. The update logic ensures that
 * changes are only applied to the authorized user's own cart, verifying cart
 * ownership and data integrity. The request body must include the updated data
 * as specified by the IShoppingMallCart.IUpdate schema, which reflects all
 * allowable modifications defined in the shopping_mall_carts schema, including
 * updated_at timestamp. Validation checks are performed to enforce business
 * rules such as maximum allowed cart items, quantity per SKU, and stock
 * availability.
 *
 * If the cart does not exist, or if the user attempts to update a cart not
 * owned by them, the operation returns an appropriate error message. Business
 * logic handles scenarios such as updating to a quantity greater than available
 * stock or attempting modifications when the cart has already been converted to
 * an order. Related operations include retrieving cart details or
 * adding/removing items individually. All updates are time-stamped for audit
 * and customer experience tracking.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the shopping cart to be updated
 * @param props.body Updated information for the customer's shopping cart
 * @path /shoppingMall/customer/carts/:cartId
 * @accessor api.functional.shoppingMall.customer.carts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the shopping cart to be updated */
    cartId: string & tags.Format<"uuid">;

    /** Updated information for the customer's shopping cart */
    body: IShoppingMallCart.IUpdate;
  };
  export type Body = IShoppingMallCart.IUpdate;
  export type Response = IShoppingMallCart;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/carts/:cartId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): IShoppingMallCart =>
    typia.random<IShoppingMallCart>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a shopping cart owned by the authenticated customer.
 *
 * This API endpoint allows an authenticated customer to permanently delete
 * their shopping cart. The cart is specified by the cartId path parameter,
 * which directly maps to the primary key in the shopping_mall_carts table.
 *
 * Upon receiving the delete request, the system validates that the cart exists
 * and belongs to the authenticated user. Successful deletion results in the
 * removal of the cart record and all related cart items; the operation performs
 * a hard delete as there is no soft delete column in shopping_mall_carts. This
 * ensures that abandoned or unwanted carts are purged, supporting clean state
 * management for customers.
 *
 * If a customer attempts to delete a cart not owned by them, the system returns
 * an authorization error. Attempts to delete non-existent or already
 * checked-out carts also trigger appropriate error messages, ensuring
 * consistent business logic. Deleting a cart cannot be undone and requires the
 * customer to recreate a cart for further shopping activities. Related
 * operations include updating or retrieving cart details. All deletes are
 * audited for compliance and troubleshooting.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the shopping cart to be deleted
 * @path /shoppingMall/customer/carts/:cartId
 * @accessor api.functional.shoppingMall.customer.carts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the shopping cart to be deleted */
    cartId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
