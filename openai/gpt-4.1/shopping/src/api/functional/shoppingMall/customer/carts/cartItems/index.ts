import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCartItem } from "../../../../../structures/IShoppingMallCartItem";
import { IPageIShoppingMallCartItem } from "../../../../../structures/IPageIShoppingMallCartItem";

/**
 * Add a product SKU as a new item to an active customer's shopping cart
 * (shopping_mall_cart_items).
 *
 * This endpoint enables a customer to add a product SKU as a new item in their
 * shopping cart. When invoked, the system verifies the specified cart exists,
 * belongs to the authenticated customer, and is in an active state. It checks
 * that the SKU is valid, the requested quantity is at least one, does not
 * exceed system-configured per-SKU limits, and that available inventory is
 * sufficient at time of insertion.
 *
 * Upon successful validation, the item is added to the cart with the price
 * captured as a snapshot for historical pricing integrity. If the item already
 * exists, a validation error will be returned: use the update endpoint instead
 * to change quantity. The operation enforces platform-level rules (maximum 50
 * unique items in cart, max 20 per SKU by default) and returns a detailed error
 * object if limits are violated.
 *
 * Only authenticated customers can add items to their own cart. This API
 * corresponds to a transactional addition in shopping_mall_cart_items and is
 * used in conjunction with cart management endpoints. Upon addition, the latest
 * cart item details, including SKU info, quantity, and unit price, are
 * returned.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the active shopping cart owned by
 *   the customer
 * @param props.body Details of the SKU and quantity to add to the cart.
 * @path /shoppingMall/customer/carts/:cartId/cartItems
 * @accessor api.functional.shoppingMall.customer.carts.cartItems.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the active shopping cart owned by the customer */
    cartId: string & tags.Format<"uuid">;

    /** Details of the SKU and quantity to add to the cart. */
    body: IShoppingMallCartItem.ICreate;
  };
  export type Body = IShoppingMallCartItem.ICreate;
  export type Response = IShoppingMallCartItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/carts/:cartId/cartItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}/cartItems`;
  export const random = (): IShoppingMallCartItem =>
    typia.random<IShoppingMallCartItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated, filterable list of shopping cart items for a customer's
 * cart (shopping_mall_cart_items).
 *
 * This operation is used to retrieve a paginated list of items currently
 * contained in a specific customer's shopping cart. It references the
 * shopping_mall_cart_items table, enabling customers to see which product SKUs,
 * quantities, and pricing apply to their cart prior to checkout.
 *
 * Security considerations are addressed by verifying that the requesting user
 * owns the cart in question. Only customers may access their own cart, and
 * sensitive item details are never exposed to unauthorized users. Filtering and
 * sorting options are provided so customers can see the latest changes (e.g.,
 * price, availability) before finalizing their purchase.
 *
 * As part of the shopping experience, the response integrates product and
 * SKU-level details such as name, image, price at addition, and item quantity,
 * mapped against current inventory status. The operation returns paginated
 * results and supports business rules for enforcing cart size, per-SKU limits,
 * and warnings for out-of-stock items.
 *
 * Related operations include modifying cart contents, adding new items, and
 * proceeding to order placement. If the cart contains SKUs that have become
 * unavailable or prices that have changed, this will be reflected in the
 * results to prompt the customer to review accordingly. Error handling covers
 * permissions, non-existent cart IDs, and attempts to access others' carts.
 *
 * @param props.connection
 * @param props.cartId Unique identifier of the customer's cart to retrieve
 *   items for.
 * @param props.body Filtering, sorting, and pagination parameters for searching
 *   cart items.
 * @path /shoppingMall/customer/carts/:cartId/cartItems
 * @accessor api.functional.shoppingMall.customer.carts.cartItems.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the customer's cart to retrieve items for. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination parameters for searching cart
     * items.
     */
    body: IShoppingMallCartItem.IRequest;
  };
  export type Body = IShoppingMallCartItem.IRequest;
  export type Response = IPageIShoppingMallCartItem.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/carts/:cartId/cartItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}/cartItems`;
  export const random = (): IPageIShoppingMallCartItem.ISummary =>
    typia.random<IPageIShoppingMallCartItem.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single cart item with details for a specific customer's cart
 * (shopping_mall_cart_items).
 *
 * This operation allows the customer to retrieve complete details for an
 * individual cart item within their shopping cart. It is based on the
 * shopping_mall_cart_items table and provides full context about the product
 * SKU, name, corresponding unit price snapshot, and the selected quantity.
 *
 * Only the customer who owns the cart has authorization to view this
 * information. This ensures privacy and proper enforcement of data access
 * rules. The data returned can be used for displaying detailed cart lines prior
 * to checkout, reviewing price changes, or before taking actions such as
 * updating or removing the item from the cart.
 *
 * The path parameters strictly correspond to the specific cart and item
 * combination, which is matched for both existence and ownership before any
 * data is returned. Any attempt to access non-existent or unauthorized items
 * results in clear errors. Relevant business rules, such as enforcing the
 * maximum allowable quantity or showing up-to-date availability, are
 * considered. The operation is used in conjunction with cart item update and
 * removal APIs for complete cart management.
 *
 * @param props.connection
 * @param props.cartId Identifier of the customer's cart containing the item.
 * @param props.cartItemId Identifier of the specific cart item to retrieve.
 * @path /shoppingMall/customer/carts/:cartId/cartItems/:cartItemId
 * @accessor api.functional.shoppingMall.customer.carts.cartItems.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the customer's cart containing the item. */
    cartId: string & tags.Format<"uuid">;

    /** Identifier of the specific cart item to retrieve. */
    cartItemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCartItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/carts/:cartId/cartItems/:cartItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): IShoppingMallCartItem =>
    typia.random<IShoppingMallCartItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the quantity or details of a specific cart item in an active
 * customer's shopping cart (shopping_mall_cart_items).
 *
 * This endpoint allows a customer to update the quantity of a specific SKU item
 * already present in their active shopping cart. The system verifies that the
 * referenced cart exists, belongs to the authenticated requester, and the item
 * is active/valid. Any update checks the inventory to ensure the new quantity
 * does not exceed available stock or global per-SKU/cart maximums defined by
 * platform business logic.
 *
 * If the quantity is set to zero, the system will remove the item from the cart
 * entirely. Price snapshot may be updated if required by policy (e.g., price
 * change notification). This operation corresponds to in-place modification of
 * a row in shopping_mall_cart_items. Validation errors are returned for
 * attempts to update another user's cart, use an invalid or non-active SKU, or
 * attempt to reserve more than allowed amount.
 *
 * Only the owning customer may perform updates to their cart. This operation is
 * used in concert with other cart management APIs to maintain cart integrity
 * throughout the user journey. On success, the full updated cart item is
 * provided as the response body.
 *
 * @param props.connection
 * @param props.cartId Unique identifier for the customer's active shopping cart
 * @param props.cartItemId Unique identifier for the cart item (SKU line item)
 *   being updated
 * @param props.body Update details for the cart item, typically only the
 *   quantity field.
 * @path /shoppingMall/customer/carts/:cartId/cartItems/:cartItemId
 * @accessor api.functional.shoppingMall.customer.carts.cartItems.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the customer's active shopping cart */
    cartId: string & tags.Format<"uuid">;

    /** Unique identifier for the cart item (SKU line item) being updated */
    cartItemId: string & tags.Format<"uuid">;

    /** Update details for the cart item, typically only the quantity field. */
    body: IShoppingMallCartItem.IUpdate;
  };
  export type Body = IShoppingMallCartItem.IUpdate;
  export type Response = IShoppingMallCartItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/carts/:cartId/cartItems/:cartItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): IShoppingMallCartItem =>
    typia.random<IShoppingMallCartItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a specific cart item from a shopping cart (shopping_mall_cart_items).
 *
 * This API endpoint enables authenticated customers to remove a specific cart
 * item, referenced by its unique cartItemId, from their current shopping cart
 * (referenced as cartId). The endpoint ensures that only the cart owner can
 * remove items from their own cart. Deleting an item updates the parent cart's
 * modification timestamp and may impact the total number of unique items or the
 * overall price summary presented to the customer during checkout.
 *
 * The API enforces business rules by verifying that the target cart and item
 * exist and that the cart belongs to the current customer. Attempting to remove
 * a cart item from another customer's cart will result in an authorization
 * error. If the item specified does not exist, the system will return a clear,
 * actionable error message and leave the cart unchanged.
 *
 * This operation reflects user-initiated updates and has no side effects on
 * inventory reservation or order history. Once removed, the product SKU is no
 * longer referenced for this cart in subsequent order placements. No soft
 * delete is used for cart items—removal is a permanent operation, and the
 * underlying row is erased from the shopping_mall_cart_items table.
 *
 * @param props.connection
 * @param props.cartId Unique identifier (UUID) of the customer's shopping cart.
 * @param props.cartItemId Unique identifier (UUID) of the cart item to be
 *   removed from the cart.
 * @path /shoppingMall/customer/carts/:cartId/cartItems/:cartItemId
 * @accessor api.functional.shoppingMall.customer.carts.cartItems.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the customer's shopping cart. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Unique identifier (UUID) of the cart item to be removed from the
     * cart.
     */
    cartItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/carts/:cartId/cartItems/:cartItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/carts/${encodeURIComponent(props.cartId ?? "null")}/cartItems/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
