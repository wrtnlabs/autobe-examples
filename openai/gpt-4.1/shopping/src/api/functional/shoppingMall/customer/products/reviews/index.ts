import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReview } from "../../../../../structures/IShoppingMallReview";
export * as images from "./images/index";
export * as flags from "./flags/index";

/**
 * Create a new review for a product in shopping_mall_reviews
 * (customer-authored).
 *
 * Allows a customer to submit a product review and rating after a completed
 * purchase. This endpoint validates that the customer has purchased the product
 * and has not already reviewed this item for this order, enforcing the business
 * rule of one review per (customer, product, order) triplet. The review
 * includes a mandatory rating (integer 1-5), body text, and can optionally
 * include attached image URIs.
 *
 * Upon submission, the review is stored in the shopping_mall_reviews table with
 * status defaulting to pending or auto-approved per policy. Automated content
 * moderation is applied before publication; reviews flagged for issues or
 * policy violation are routed for admin review before appearing in the
 * product's aggregate rating.
 *
 * Proper authentication is required (customer role). Error handling covers
 * duplicate reviews, policy violations, and purchase verification failures. The
 * IShoppingMallReview.ICreate DTO describes the expected payload; the response
 * includes the created review in normalized form for immediate display or
 * further moderation.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the product being reviewed.
 * @param props.body New review submission, including rating, review body,
 *   optional images, and order reference.
 * @path /shoppingMall/customer/products/:productId/reviews
 * @accessor api.functional.shoppingMall.customer.products.reviews.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** The unique identifier of the product being reviewed. */
    productId: string & tags.Format<"uuid">;

    /**
     * New review submission, including rating, review body, optional
     * images, and order reference.
     */
    body: IShoppingMallReview.ICreate;
  };
  export type Body = IShoppingMallReview.ICreate;
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/products/:productId/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/products/${encodeURIComponent(props.productId ?? "null")}/reviews`;
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a customer's review for a specific product (shopping_mall_reviews
 * table).
 *
 * Edit a previously posted product review. The operation is designed for
 * customers who wish to update their feedback on products they have purchased.
 * Each review is uniquely identified by its productId and reviewId, ensuring
 * only the original author (reviewing customer) can edit their review.
 *
 * The API operation first verifies the customer's authorship to enforce that
 * only the initial submitter can edit their own review. If the review is not
 * found, deleted, or does not belong to the authenticated user, an error is
 * thrown with explanation. Review update input includes rating (1-5, integer),
 * review body (10-2000 characters, string), and optional adjustment of review
 * images (up to system limit, typically 5 images per review, each â‰¤4MB).
 *
 * Any modification to the rating or body resets moderation status to "pending"
 * if an auto-moderation workflow applies; an email or in-app notification may
 * inform the reviewer of status changing. Changes are logged for admin review.
 * If a review is under forced moderation lock or was previously permanently
 * rejected/hidden by admin, this operation is blocked with a suitable
 * client-facing error code. The response includes the full updated review
 * object including status, moderation state, and timestamps. Success or
 * validation errors are returned with clear messaging.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product being reviewed
 * @param props.reviewId Unique identifier of the review to update
 * @param props.body New review data: updated rating, body text, and optional
 *   image URIs. Only body/rating/images may be changed; authorship and order
 *   are immutable.
 * @path /shoppingMall/customer/products/:productId/reviews/:reviewId
 * @accessor api.functional.shoppingMall.customer.products.reviews.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the product being reviewed */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the review to update */
    reviewId: string & tags.Format<"uuid">;

    /**
     * New review data: updated rating, body text, and optional image URIs.
     * Only body/rating/images may be changed; authorship and order are
     * immutable.
     */
    body: IShoppingMallReview.IUpdate;
  };
  export type Body = IShoppingMallReview.IUpdate;
  export type Response = IShoppingMallReview;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/products/:productId/reviews/:reviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IShoppingMallReview =>
    typia.random<IShoppingMallReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (soft-delete) a customer's product review for compliance and storefront
 * removal (shopping_mall_reviews table).
 *
 * Completely remove (soft delete) a product review previously authored by the
 * authenticated customer. This API operation deactivates the review by setting
 * the deleted_at flag, making it invisible on the storefront and excluded from
 * all rating calculations and product detail listings, but retaining a record
 * for compliance audit and potential admin moderation review.
 *
 * Authorization is tightly enforced: only the original review author (customer)
 * can perform this erase action. The endpoint checks the review's existence,
 * ownership, and current moderation status. If the review was already deleted,
 * an error is returned with an informative message. Attempts to delete reviews
 * under admin moderation lock, or belonging to another customer, are denied
 * with a clear error response. All erase operations are audit-logged for future
 * reference.
 *
 * No response body is returned on success; an HTTP 204 (No Content) is
 * expected. This operation is critical for customer self-service controls over
 * their feedback and aligns with best practice data retention policies for
 * online marketplaces.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose review is being
 *   deleted
 * @param props.reviewId Unique identifier of the review to erase (soft delete)
 * @path /shoppingMall/customer/products/:productId/reviews/:reviewId
 * @accessor api.functional.shoppingMall.customer.products.reviews.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the product whose review is being deleted */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the review to erase (soft delete) */
    reviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/products/:productId/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
