import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../structures/IShoppingMallCustomer";
export * as addresses from "./addresses/index";

/**
 * Retrieve a specific customer account's detailed profile information
 * (shopping_mall_customers table).
 *
 * This API endpoint provides detailed profile information for a specific
 * customer, referencing the shopping_mall_customers table from the database
 * schema. This includes core user data such as email, hashed password (NOT
 * returned), legal name, contact phone, status
 * (active/suspended/pending_verification), and email verification flag.
 *
 * Sensitive information, such as email and phone, must only be returned to
 * either the account owner (when authenticated) or to admin users with the
 * right permissions. Unauthorized access should be denied, and attempts to
 * access non-existent accounts must result in clear error reporting.
 *
 * The operation is read-only and does not expose password hashes or sensitive
 * authentication data. Timestamps for account creation and last update are
 * included for audit purposes. Soft-deletion markers (deleted_at) are available
 * for admin review, but not for end-users. This API is closely tied to profile
 * management, admin support tools, and customer authentication workflows. It is
 * often followed by update or delete operations for profile lifecycle
 * management.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose information
 *   is to be retrieved.
 * @path /shoppingMall/customer/customers/:customerId
 * @accessor api.functional.shoppingMall.customer.customers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the customer whose information is to be
     * retrieved.
     */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the profile information of a specific customer account
 * (shopping_mall_customers table).
 *
 * This API endpoint updates the properties of a single customer account,
 * referencing the shopping_mall_customers entity in the Prisma schema. Only
 * fields that are explicitly updatable by end-users or admins are accepted:
 * full_name, phone, status, and email verification flag can be modified,
 * subject to validation. Email address may also be changed if business logic
 * requires it, but must ensure uniqueness across accounts.
 *
 * Direct updates to security-sensitive fields such as password_hash are not
 * allowed hereâ€”users must use dedicated password reset flows. The API validates
 * the authenticity of the user or administrative privileges before applying any
 * changes. Unauthorized or invalid update attempts must be cleanly rejected,
 * with error codes explaining the failure. All field changes are tracked with
 * updated_at timestamp for audit purposes.
 *
 * This operation supports core customer profile update flows (address and order
 * associations update separately) and integrates into admin dashboards to
 * enable account corrections, suspension/reactivation, and more advanced
 * customer service. The operation references all business rules and validation
 * logic specified in the shopping_mall_customers table comments.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose profile is
 *   being updated.
 * @param props.body Updated customer profile information to be applied; all
 *   fields subject to validation and business rules.
 * @path /shoppingMall/customer/customers/:customerId
 * @accessor api.functional.shoppingMall.customer.customers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the customer whose profile is being updated. */
    customerId: string & tags.Format<"uuid">;

    /**
     * Updated customer profile information to be applied; all fields
     * subject to validation and business rules.
     */
    body: IShoppingMallCustomer.IUpdate;
  };
  export type Body = IShoppingMallCustomer.IUpdate;
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
