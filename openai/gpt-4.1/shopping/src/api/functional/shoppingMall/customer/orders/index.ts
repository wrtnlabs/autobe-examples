import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrder } from "../../../../structures/IShoppingMallOrder";
export * as items from "./items/index";
export * as shipments from "./shipments/index";
export * as statusHistory from "./statusHistory/index";
export * as payments from "./payments/index";
export * as cancellations from "./cancellations/index";
export * as refunds from "./refunds/index";

/**
 * Retrieve full detail of a single order from shopping_mall_orders by orderId.
 *
 * Retrieve the complete detail view of a single order as referenced by the
 * provided orderId. The operation fully exposes all attributes defined in
 * shopping_mall_orders, including customer and (where applicable) seller
 * association, shipping address snapshot, payment method snapshot, order line
 * items, shipment data, and full audit fields (created_at, updated_at,
 * deleted_at).
 *
 * From a security and access control perspective, only the owning customer, the
 * fulfilling seller (if present), and platform admins are allowed to view order
 * details. The endpoint must enforce this in implementation, ensuring customers
 * cannot access orders that do not belong to them, and sellers can only view
 * orders related to their products.
 *
 * All relationships (order items, status history, shipments, cancellations,
 * refunds) are framed as per the database design. Order data is provided
 * according to the schema structure and reflects the point-in-time state at
 * query, with full timeline context (placed_at, paid_at, fulfilled_at) and
 * business state if present. Expected errors include 404 for not found or 403
 * for unauthorized access.
 *
 * Related APIs include order search by customer, order listing for
 * seller/admin, and historic/timeline views for auditing. This endpoint is a
 * read-only accessor and does not modify data.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to retrieve (UUID from
 *   shopping_mall_orders.id).
 * @path /shoppingMall/customer/orders/:orderId
 * @accessor api.functional.shoppingMall.customer.orders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the order to retrieve (UUID from
     * shopping_mall_orders.id).
     */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing orderâ€™s details in the shoppingMall_orders table.
 *
 * This API operation permits the modification of a placed order's details
 * within the shoppingMall_orders entity. The purpose is to enable key actors
 * (customer, seller, admin) to update an order based on workflow stage and
 * permissions.
 *
 * Customers may request updates to shipping address, contact details, or cancel
 * orders that are still pending or processing. Sellers may update shipping
 * status, input shipment tracking numbers, or add operational comments if the
 * order is in the fulfillment stage. Admins retain global rights to override
 * any field in exceptional scenarios (e.g., fraud, user disputes, compliance).
 *
 * Security is strictly enforced via role-based authentication and order
 * ownership checks. Path parameter validation is required to ensure only the
 * intended order is modified. Attempting to update a finalized, cancelled, or
 * delivered order as a non-admin returns a validation error. All updates
 * trigger entry in the shopping_mall_admin_action_logs table for traceability.
 *
 * Business logic includes validation of eligibility for each update request
 * type: shipping address modification is only permitted before shipment, status
 * transitions follow defined state machines, and pricing/payment changes are
 * only processed by admin.
 *
 * This operation integrates with related schemas, including
 * shopping_mall_order_addresses (address snapshot),
 * shopping_mall_order_status_history (order audit), and
 * shopping_mall_admin_action_logs (event tracking). Error handling covers
 * invalid state transitions, unauthorized access, and data integrity issues.
 * Commonly related operations include placing new orders, viewing order
 * status/history, and handling order cancellation/refunds.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the order to be updated.
 * @param props.body Order update payload with only the fields eligible for
 *   modification based on business rules, such as status, shipping address, or
 *   remarks.
 * @path /shoppingMall/customer/orders/:orderId
 * @accessor api.functional.shoppingMall.customer.orders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the order to be updated. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Order update payload with only the fields eligible for modification
     * based on business rules, such as status, shipping address, or
     * remarks.
     */
    body: IShoppingMallOrder.IUpdate;
  };
  export type Body = IShoppingMallOrder.IUpdate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new order entry from customer cart, writing shopping_mall_orders and
 * child records.
 *
 * Create and commit a new order from a validated customer's cart. This endpoint
 * is designed for customer checkout, handling order creation only after
 * thorough cart validation steps have been performed in prior flows. The
 * submitted payload must conform to the IShoppingMallOrder.ICreate schema:
 * containing the customer's UUID, the approved list of SKUs and quantities,
 * selected shipping address details, payment method selection (with method
 * data), and any required business logic data.
 *
 * All order creation logic strictly validates requested items for availability,
 * quantity, and price against the live product/SKU/inventory tables as of the
 * transaction time; order creation is atomic to prevent double-purchase and
 * over-selling. On success, a complete order entry is written including all
 * audit and timeline fields. The newly created order object is returned in the
 * response, matching the structure of a full order read.
 *
 * Security: Only authenticated customers can create orders. Sellers and admins
 * cannot use this general order creation endpoint. Implementation must block
 * attempts by unauthorized actors. Typical business errors returned include
 * insufficient stock, price mismatch, invalid shipping/payment information, and
 * authorization failures.
 *
 * Related endpoints include cart validation, payment gateways, and order
 * history lookups. This endpoint does not handle payment capture itself but
 * records the intent and metadata for payment initiation.
 *
 * @param props.connection
 * @param props.body Order creation information including cart items, shipping
 *   address snapshot, payment method choice, as per IShoppingMallOrder.ICreate
 *   specification.
 * @path /shoppingMall/customer/orders
 * @accessor api.functional.shoppingMall.customer.orders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Order creation information including cart items, shipping address
     * snapshot, payment method choice, as per IShoppingMallOrder.ICreate
     * specification.
     */
    body: IShoppingMallOrder.ICreate;
  };
  export type Body = IShoppingMallOrder.ICreate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/orders";
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
