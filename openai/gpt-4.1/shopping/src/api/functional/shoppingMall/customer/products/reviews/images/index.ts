import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReviewImage } from "../../../../../../structures/IShoppingMallReviewImage";

/**
 * Attach new image(s) to an existing product review as review author
 * (shopping_mall_review_images table).
 *
 * Allows a customer to attach new image(s) to an existing product review for
 * visual enhancement. The operation ensures that only the review's original
 * author can upload images, with access restricted by the review's status
 * (e.g., active, not deleted, not rejected by moderation).
 *
 * It references the shopping_mall_review_images entity in the Prisma schema,
 * supporting up to 5 images per review by system policy. Uploaded images are
 * validated for file type, size, and content guidelines before association.
 * Business logic prevents uploading more images than permitted, and all new
 * images are subject to automatic and/or manual content moderation as per
 * platform rules.
 *
 * Security controls ensure that the image is attached only to a review authored
 * by the requesting customer. Any attempt by a non-author or for a non-existent
 * review triggers an error. The operation also ensures that moderation or
 * locked reviews cannot receive new images.
 *
 * Error scenarios include exceeding the maximum allowed images, uploading
 * disallowed content types, or failing moderation checks. Related operations
 * include image deletion and complete review retrieval for management of
 * attached images.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the product being reviewed.
 * @param props.reviewId The unique identifier of the product review to which
 *   images will be added.
 * @param props.body Image upload and metadata for a new review image
 *   attachment.
 * @path /shoppingMall/customer/products/:productId/reviews/:reviewId/images
 * @accessor api.functional.shoppingMall.customer.products.reviews.images.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** The unique identifier of the product being reviewed. */
    productId: string & tags.Format<"uuid">;

    /**
     * The unique identifier of the product review to which images will be
     * added.
     */
    reviewId: string & tags.Format<"uuid">;

    /** Image upload and metadata for a new review image attachment. */
    body: IShoppingMallReviewImage.ICreate;
  };
  export type Body = IShoppingMallReviewImage.ICreate;
  export type Response = IShoppingMallReviewImage;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/products/:productId/reviews/:reviewId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}/images`;
  export const random = (): IShoppingMallReviewImage =>
    typia.random<IShoppingMallReviewImage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific image uploaded to a product review by the review's author
 * (shopping_mall_review_images table).
 *
 * Enables the review author to permanently remove a previously attached image
 * from a product review. This action deletes the image reference from the
 * shopping_mall_review_images table and, if applicable, removes the image asset
 * from storage/CDN.
 *
 * Access control restricts this operation to the review's author; admins may
 * override only in moderation or policy violation cases as per business rules.
 * The operation verifies the existence of the image and its linkage to the
 * review and user before deletion. It disallows deletion for locked/restricted
 * reviews or images already subject to moderation procedure.
 *
 * The operation accepts productId, reviewId, and imageId as path parameters to
 * specifically identify the target image. Business logic and schema constraints
 * ensure that deletion does not violate any retention or moderation policies.
 * Error conditions include unauthorized attempts, not found images, or trying
 * to remove images from non-editable reviews. Deletion actions are audit-logged
 * for platform compliance.
 *
 * This endpoint complements review image upload and detail retrieval APIs to
 * provide full review image lifecycle management for users.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the product being reviewed.
 * @param props.reviewId The unique identifier of the product review associated
 *   with the image.
 * @param props.imageId The unique identifier of the image to be deleted from
 *   the review.
 * @path /shoppingMall/customer/products/:productId/reviews/:reviewId/images/:imageId
 * @accessor api.functional.shoppingMall.customer.products.reviews.images.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the product being reviewed. */
    productId: string & tags.Format<"uuid">;

    /**
     * The unique identifier of the product review associated with the
     * image.
     */
    reviewId: string & tags.Format<"uuid">;

    /** The unique identifier of the image to be deleted from the review. */
    imageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/products/:productId/reviews/:reviewId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/products/${encodeURIComponent(props.productId ?? "null")}/reviews/${encodeURIComponent(props.reviewId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
