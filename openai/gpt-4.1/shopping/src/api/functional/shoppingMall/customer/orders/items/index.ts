import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrderItem } from "../../../../../structures/IShoppingMallOrderItem";
import { IPageIShoppingMallOrderItem } from "../../../../../structures/IPageIShoppingMallOrderItem";

/**
 * Retrieve and filter the list of items for a specific order from
 * shoppingMall_orders.
 *
 * Retrieve a detailed list of all itemized SKUs included in a specific order.
 * This includes information such as item name, SKU code, quantity, unit price,
 * total price, currency, and item-specific refund or cancellation statuses.
 *
 * The endpoint supports filtering and pagination to efficiently review orders
 * with many line items. Sensitive fields and access are scoped according to
 * user roles: customers can view their own orders, sellers can view items from
 * orders they are responsible for, and admins can view all items. Security
 * checks enforce access control to ensure only authorized users access the
 * order's item details.
 *
 * Built upon the shopping_mall_order_items table, joined to
 * shopping_mall_orders for permission enforcement, this operation enables
 * robust audit and accountability for inventory, fulfillment, returns, and
 * analytics across roles. Validation ensures the order exists and the user role
 * is permitted to view items for this order, and errors are returned if the
 * order is invalid or access is denied.
 *
 * This operation is commonly paired with order detail retrieval, item-level
 * refund initiation endpoints, and shipment tracking features for high-fidelity
 * order monitoring by both buyers and sellers.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order whose items will be
 *   listed.
 * @param props.body Request parameters for filtering and paginating the list of
 *   items within the specified order.
 * @path /shoppingMall/customer/orders/:orderId/items
 * @accessor api.functional.shoppingMall.customer.orders.items.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the order whose items will be listed. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Request parameters for filtering and paginating the list of items
     * within the specified order.
     */
    body: IShoppingMallOrderItem.IRequest;
  };
  export type Body = IShoppingMallOrderItem.IRequest;
  export type Response = IPageIShoppingMallOrderItem.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/orders/:orderId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallOrderItem.ISummary =>
    typia.random<IPageIShoppingMallOrderItem.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details of a single order item (line SKU) by itemId and
 * orderId.
 *
 * Fetch the full detail of a single order item (SKU line) belonging to the
 * specified order. The operation returns key attributes: item display name, SKU
 * code, purchased quantity, unit price, total price, currency, and current
 * refund or cancellation state for the line item.
 *
 * Access to this endpoint is controlled so only the customer who placed the
 * order, the seller responsible for the SKU, or an admin can view the item
 * details. Security validation ensures neither sensitive nor unrelated line
 * items are exposed to unauthorized actors.
 *
 * The implementation relies on the shopping_mall_order_items table and
 * validates the provided identifiers (orderId, itemId) exist and match
 * permission scopes. If the item or order is not found, or access is denied,
 * standard error responses are triggered.
 *
 * This endpoint is useful for item-level customer service (refunds,
 * cancellations), warehouse or shipping review, and detailed
 * analytical/reporting use cases.
 *
 * @param props.connection
 * @param props.orderId Unique order identifier containing the item.
 * @param props.itemId Unique identifier of the specific order item (SKU line)
 *   to retrieve.
 * @path /shoppingMall/customer/orders/:orderId/items/:itemId
 * @accessor api.functional.shoppingMall.customer.orders.items.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique order identifier containing the item. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific order item (SKU line) to retrieve. */
    itemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific item from an order (shopping_mall_order_items table).
 *
 * Delete an item from a specific order using its unique order ID and item ID.
 * This operation targets the shopping_mall_order_items table and ensures that
 * only items actually included in the given order may be removed, complying
 * with all referential and business integrity rules. The main use cases include
 * customer-requested cancellations prior to shipment, administrative
 * corrections, or seller-directed modifications before fulfillment.
 *
 * Authorization is strictly enforced: customers can only modify their own
 * orders and only under certain states (e.g., pending, processing). Sellers can
 * act on their own products before shipment, and admins have full override
 * capability in accordance with business policies. Each attempted deletion
 * checks item/order status for eligibility, blocks removal if the item is
 * already shipped, delivered, refunded, or under dispute, and provides a
 * suitable error if the operation cannot proceed.
 *
 * Related updates such as refund of reserved funds, adjustment of inventory,
 * and timeline notifications are triggered as per business rules. This
 * operation links to core flows documented in order management, cancellation,
 * refund, and customer service requirements, and should be coordinated with
 * those API calls where intricate business processes are involved.
 *
 * Error cases are handled with explicit status returns, such as 'not found',
 * 'unauthorized', 'item not removable', or 'order ineligible for
 * modification'.
 *
 * @param props.connection
 * @param props.orderId ID of the target order containing the item to be
 *   deleted.
 * @param props.itemId ID of the order item (order item record) to be deleted.
 * @path /shoppingMall/customer/orders/:orderId/items/:itemId
 * @accessor api.functional.shoppingMall.customer.orders.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the target order containing the item to be deleted. */
    orderId: string & tags.Format<"uuid">;

    /** ID of the order item (order item record) to be deleted. */
    itemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
