import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallWishlistItem } from "../../../../../structures/IShoppingMallWishlistItem";
import { IPageIShoppingMallWishlistItem } from "../../../../../structures/IPageIShoppingMallWishlistItem";

/**
 * Add a product to a customer's wishlist (shopping_mall_wishlist_items table).
 *
 * This operation enables a customer to add a product to an existing wishlist.
 * The endpoint requires the wishlistId path parameter, referencing the target
 * wishlist belonging to the authenticated customer. The request body must
 * include the product to add, and the underlying logic will create a row in
 * shopping_mall_wishlist_items if not present for this (wishlistId, productId)
 * pair.
 *
 * Authorization is enforced so only the owner of the wishlist can add products,
 * and a business rule restricts duplicate product entries per wishlist.
 *
 * If the product is already present, the API may respond with a suitable
 * message or a conflict error. Error handling also covers cases where the
 * referenced wishlist does not exist or does not belong to the caller.
 *
 * The wishlist item entity links the wishlist to a product (not a SKU), and
 * persists the relationship for quick wishlist retrieval and display.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist to modify (must be
 *   owned by the authenticated customer)
 * @param props.body New wishlist item data specifying the product to add.
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the wishlist to modify (must be owned by the
     * authenticated customer)
     */
    wishlistId: string & tags.Format<"uuid">;

    /** New wishlist item data specifying the product to add. */
    body: IShoppingMallWishlistItem.ICreate;
  };
  export type Body = IShoppingMallWishlistItem.ICreate;
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve all wishlist items for a given customer's wishlist from the
 * shopping_mall_wishlist_items table.
 *
 * Retrieve all wishlist items belonging to a particular customer's wishlist by
 * specifying the wishlist ID. This operation enables customers to see all
 * products they have saved for later consideration or purchase. The returned
 * information includes references to the associated products, timestamps for
 * when items were added or updated, and can be configured to provide paginated
 * results.
 *
 * Customers may apply search or filtering parameters (for instance, to display
 * only products matching certain criteria or to sort by the date added). The
 * response will include all relevant details for wishlist display but will hide
 * internal system fields not intended for customers.
 *
 * Security is enforced so only the wishlist owner (authenticated customer) can
 * access their wishlist items. Requests by unauthorized users to access or
 * enumerate another customer's wishlist will be blocked. The operation is
 * tightly coupled to the shopping_mall_wishlist_items and
 * shopping_mall_products entities as defined in the Prisma schema.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist to retrieve items
 *   from.
 * @param props.body Advanced search, filtering, and pagination criteria for
 *   wishlist item retrieval.
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the wishlist to retrieve items from. */
    wishlistId: string & tags.Format<"uuid">;

    /**
     * Advanced search, filtering, and pagination criteria for wishlist item
     * retrieval.
     */
    body: IShoppingMallWishlistItem.IRequest;
  };
  export type Body = IShoppingMallWishlistItem.IRequest;
  export type Response = IPageIShoppingMallWishlistItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems`;
  export const random = (): IPageIShoppingMallWishlistItem =>
    typia.random<IPageIShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific wishlist item identified by
 * wishlistId and wishlistItemId.
 *
 * Retrieve a specific wishlist item by its unique identifier, within the
 * context of a parent wishlist. Only the wishlist owner (authenticated
 * customer) is permitted to access this data. The response includes all details
 * allowed for customer viewing, such as the referenced product information, the
 * time the item was added or updated, and the relationship to the associated
 * wishlist.
 *
 * Attempting to access a wishlist item not belonging to the authenticated
 * customer will result in access denial. This operation is crucial for
 * supporting UI features that display detailed information about a product in
 * the customer's wishlist or facilitate actions like switching an item to the
 * cart.
 *
 * The operation relies on accurate mapping between the path parameter IDs and
 * the shopping_mall_wishlist_items entity structure as defined in the Prisma
 * schema. Security best practices are enforced such that only the relevant
 * customer can retrieve this data by verifying both the wishlist and item
 * ownership.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist containing the
 *   item.
 * @param props.wishlistItemId Unique identifier of the wishlist item to
 *   retrieve.
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the wishlist containing the item. */
    wishlistId: string & tags.Format<"uuid">;

    /** Unique identifier of the wishlist item to retrieve. */
    wishlistItemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a wishlist item in a customer's wishlist (shopping_mall_wishlist_items
 * table).
 *
 * This operation lets a customer update an existing wishlist item. Only the
 * owner of the wishlist may perform this operation, and only wishlist items
 * belonging to that wishlist can be updated.
 *
 * Business logic ensures the specified wishlist and wishlist item exist and are
 * associated, and that only supported fields may be updated (such as notes or
 * tags, if present in the entity). Error scenarios include attempts to update
 * non-existent or unauthorized items.
 *
 * The API will check that the combination of wishlistId and wishlistItemId is
 * valid and refers to a record owned by the authenticated customer.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist that contains the
 *   wishlist item.
 * @param props.wishlistItemId Unique identifier of the wishlist item to update.
 * @param props.body Data to update for the wishlist item, such as notes or
 *   display fields (fields subject to schema support).
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the wishlist that contains the wishlist item. */
    wishlistId: string & tags.Format<"uuid">;

    /** Unique identifier of the wishlist item to update. */
    wishlistItemId: string & tags.Format<"uuid">;

    /**
     * Data to update for the wishlist item, such as notes or display fields
     * (fields subject to schema support).
     */
    body: IShoppingMallWishlistItem.IUpdate;
  };
  export type Body = IShoppingMallWishlistItem.IUpdate;
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific product from a customer's wishlist
 * (shopping_mall_wishlist_items).
 *
 * This endpoint deletes a specific product from a customer's wishlist. The
 * operation targets the shopping_mall_wishlist_items entity, which is a join
 * table linking a customer's wishlist to the products they are interested in.
 *
 * Deleting a wishlist item is a permanent action; the wishlist item record is
 * removed from the database, and the product will no longer appear in the
 * customer's wishlist. Customers can only delete items from their own
 * wishlists. The system must confirm that the authenticated user owns the
 * wishlist before permitting the deletion. Attempts to delete wishlist items
 * from another user's wishlist shall be rejected with an appropriate error
 * message.
 *
 * Wishlist management forms part of the customer personalization suite.
 * Associated APIs include adding products to the wishlist, viewing all wishlist
 * items, and removing the entire wishlist, if supported. This hard delete
 * operation is irreversible. If the referenced wishlist or wishlist item does
 * not exist, the system returns a not-found error. No response body is returned
 * for successful completion.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist owning the wishlist
 *   item.
 * @param props.wishlistItemId Unique identifier of the wishlist item to delete.
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the wishlist owning the wishlist item. */
    wishlistId: string & tags.Format<"uuid">;

    /** Unique identifier of the wishlist item to delete. */
    wishlistItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
