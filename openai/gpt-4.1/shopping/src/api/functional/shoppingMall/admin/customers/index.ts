import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../structures/IShoppingMallCustomer";
import { IPageIShoppingMallCustomer } from "../../../../structures/IPageIShoppingMallCustomer";
export * as addresses from "./addresses/index";

/**
 * Search and retrieve a paginated, filterable list of all registered customers
 * for admin management purposes.
 *
 * Retrieve a paginated, filterable list of all registered customers on the
 * platform. This operation supports advanced search use-cases, including
 * filtering by registration date, status (active, suspended,
 * pending_verification), name, and email. Designed for admin dashboard usage,
 * it provides UI-ready pagination, sorting, and search fields.
 *
 * The Prisma shopping_mall_customers table provides the data model, including
 * profile fields, email verification state, and account activity status.
 * Response records allow navigation to customer detail, order summaries, and
 * address management. Query complexity accommodates both bulk admin operations
 * and contextual search (e.g., find all new users for the last 30 days).
 *
 * Security wise, only users with admin privileges can access this endpoint to
 * ensure customer personal data (email, phone, full_name, status) privacy. The
 * system enforces strict access control and logs queries performed. This
 * endpoint is intended to be paired with single-customer detail, create,
 * update, or erase operations for full admin management coverage.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, and pagination/sorting parameters
 *   for customer search.
 * @path /shoppingMall/admin/customers
 * @accessor api.functional.shoppingMall.admin.customers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, and pagination/sorting parameters for
     * customer search.
     */
    body: IShoppingMallCustomer.IRequest;
  };
  export type Body = IShoppingMallCustomer.IRequest;
  export type Response = IPageIShoppingMallCustomer.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/customers";
  export const random = (): IPageIShoppingMallCustomer.ISummary =>
    typia.random<IPageIShoppingMallCustomer.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific customer account's detailed profile information
 * (shopping_mall_customers table).
 *
 * This API endpoint provides detailed profile information for a specific
 * customer, referencing the shopping_mall_customers table from the database
 * schema. This includes core user data such as email, hashed password (NOT
 * returned), legal name, contact phone, status
 * (active/suspended/pending_verification), and email verification flag.
 *
 * Sensitive information, such as email and phone, must only be returned to
 * either the account owner (when authenticated) or to admin users with the
 * right permissions. Unauthorized access should be denied, and attempts to
 * access non-existent accounts must result in clear error reporting.
 *
 * The operation is read-only and does not expose password hashes or sensitive
 * authentication data. Timestamps for account creation and last update are
 * included for audit purposes. Soft-deletion markers (deleted_at) are available
 * for admin review, but not for end-users. This API is closely tied to profile
 * management, admin support tools, and customer authentication workflows. It is
 * often followed by update or delete operations for profile lifecycle
 * management.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose information
 *   is to be retrieved.
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the customer whose information is to be
     * retrieved.
     */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the profile information of a specific customer account
 * (shopping_mall_customers table).
 *
 * This API endpoint updates the properties of a single customer account,
 * referencing the shopping_mall_customers entity in the Prisma schema. Only
 * fields that are explicitly updatable by end-users or admins are accepted:
 * full_name, phone, status, and email verification flag can be modified,
 * subject to validation. Email address may also be changed if business logic
 * requires it, but must ensure uniqueness across accounts.
 *
 * Direct updates to security-sensitive fields such as password_hash are not
 * allowed here—users must use dedicated password reset flows. The API validates
 * the authenticity of the user or administrative privileges before applying any
 * changes. Unauthorized or invalid update attempts must be cleanly rejected,
 * with error codes explaining the failure. All field changes are tracked with
 * updated_at timestamp for audit purposes.
 *
 * This operation supports core customer profile update flows (address and order
 * associations update separately) and integrates into admin dashboards to
 * enable account corrections, suspension/reactivation, and more advanced
 * customer service. The operation references all business rules and validation
 * logic specified in the shopping_mall_customers table comments.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose profile is
 *   being updated.
 * @param props.body Updated customer profile information to be applied; all
 *   fields subject to validation and business rules.
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the customer whose profile is being updated. */
    customerId: string & tags.Format<"uuid">;

    /**
     * Updated customer profile information to be applied; all fields
     * subject to validation and business rules.
     */
    body: IShoppingMallCustomer.IUpdate;
  };
  export type Body = IShoppingMallCustomer.IUpdate;
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a shopping mall customer account (shopping_mall_customers table)
 * by customerId.
 *
 * Permanently erase a shopping mall customer account based on the provided
 * customerId. This API operation is typically used by administrative actors to
 * enforce compliance, policy violations, GDPR/account erasure requests, or
 * permanent account withdrawal. The operation targets the
 * shopping_mall_customers table, referencing the id primary key column defined
 * in the Prisma schema.
 *
 * All related records that reference this customer, such as addresses
 * (shopping_mall_customer_addresses), carts (shopping_mall_carts), wishlists,
 * orders, and reviews, are subject to cascading deletion or orphan retention
 * according to the Prisma relations and ON DELETE behavior. This hard delete
 * operation sets the deleted_at column for audit but also physically removes
 * data where compliance or security requires complete erasure.
 *
 * Security is critical—this erase operation is restricted to admin users.
 * Authorization via JWT with role validation is mandatory. The operation
 * validates that the customerId is well-formed, exists, and has no dependent
 * compliance holds before proceeding. In cases where the customer cannot be
 * deleted due to unresolved orders, refunds, or legal holds, an error
 * describing the blocking condition is returned.
 *
 * This operation is related to the creation, updating, and retrieval APIs for
 * customer data, forming the DELETE operation in the REST lifecycle. It must be
 * used with caution and is logged in system audit tables for compliance and
 * traceability. This operation does not implement a soft-delete pattern but
 * will set deleted_at for audit/tombstone if present in schema.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to be permanently
 *   removed (UUID).
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer to be permanently removed (UUID). */
    customerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
