import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallSystemConfig } from "../../../../structures/IShoppingMallSystemConfig";
import { IPageIShoppingMallSystemConfig } from "../../../../structures/IPageIShoppingMallSystemConfig";

/**
 * Create a new system configuration entry in shopping_mall_system_configs.
 *
 * Create a new system configuration setting in the shopping_mall_system_configs
 * table. This operation is available exclusively to platform administrators for
 * defining runtime flags, feature switches, maximum limits, external service
 * credentials, or other advanced platform settings.
 *
 * The configuration requires a unique combination of config_key and
 * config_scope, identification of the intended value_type (string, int,
 * boolean, double, or json), and the typing of one of the value fields
 * accordingly. If a value is specified in an incompatible field (e.g., string
 * value for int type), validation errors will be returned.
 *
 * Security is enforced for admin access only. The service checks for duplicate
 * config keys within the same scope, rejecting if non-unique. Audit fields
 * record time and identity of creation for compliance. The endpoint's response
 * returns the created configuration entry, including all metadata and value
 * fields.
 *
 * This operation implements complex business logic related to platform-wide
 * runtime configurability, supports admin dashboard use cases, and ensures
 * traceability through auditing.
 *
 * @param props.connection
 * @param props.body The configuration data required for creation, including
 *   key, scope, value type, and the appropriate typed value field.
 * @path /shoppingMall/admin/systemConfigs
 * @accessor api.functional.shoppingMall.admin.systemConfigs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * The configuration data required for creation, including key, scope,
     * value type, and the appropriate typed value field.
     */
    body: IShoppingMallSystemConfig.ICreate;
  };
  export type Body = IShoppingMallSystemConfig.ICreate;
  export type Response = IShoppingMallSystemConfig;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/systemConfigs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/systemConfigs";
  export const random = (): IShoppingMallSystemConfig =>
    typia.random<IShoppingMallSystemConfig>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter system configuration settings in the
 * 'shopping_mall_system_configs' table (admin only).
 *
 * This endpoint retrieves a paginated and filterable list of system
 * configuration settings from the 'shopping_mall_system_configs' table,
 * supporting admin maintenance, diagnostics, and feature management. Admins can
 * filter results by config key, configuration scope (e.g., 'global', 'payment',
 * 'product'), value type, or specific value fields, ensuring rapid access to
 * targeted settings during routine platform operations or incident response.
 *
 * Search requests support partial match by key, scope, and value, and advanced
 * queries using structured search DTOs. Pagination and sorting are fully
 * supported, with configurable page size and ordering. Access is strictly
 * limited to admins, and all access to configuration data is logged for audit
 * compliance.
 *
 * This operation is typically used together with create, update, and
 * detail/retrieval endpoints for system configuration, and forms the backbone
 * of platform feature toggling, runtime operational adjustments, and
 * infrastructure credentials management.
 *
 * @param props.connection
 * @param props.body Structured search/filter parameters and pagination/sorting
 *   instructions for admin config retrieval.
 * @path /shoppingMall/admin/systemConfigs
 * @accessor api.functional.shoppingMall.admin.systemConfigs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Structured search/filter parameters and pagination/sorting
     * instructions for admin config retrieval.
     */
    body: IShoppingMallSystemConfig.IRequest;
  };
  export type Body = IShoppingMallSystemConfig.IRequest;
  export type Response = IPageIShoppingMallSystemConfig;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/systemConfigs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/systemConfigs";
  export const random = (): IPageIShoppingMallSystemConfig =>
    typia.random<IPageIShoppingMallSystemConfig>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific system configuration entry by ID from
 * shopping_mall_system_configs.
 *
 * Fetch a single system configuration object by its unique ID from the
 * shopping_mall_system_configs table. This endpoint enables platform
 * administrators to inspect or audit details of a specific configuration, such
 * as feature toggles, rate limits, third-party credentials, or operational
 * switches.
 *
 * Security is enforced by restricting access to the admin role. The operation
 * returns all attributes of the configuration record, including value type,
 * scope, and typed values (string/int/boolean/double/json), as well as audit
 * timestamps such as creation and last update. Entries marked as soft-deleted
 * via deleted_at will not be returned in results.
 *
 * Parameters must specify the correct system configuration ID as a UUID. This
 * operation references the shopping_mall_system_configs Prisma model and is
 * related to configuration dashboard and system diagnostics flows. Error
 * handling includes not-found for non-existent or deleted records, and
 * forbidden for non-admin users.
 *
 * @param props.connection
 * @param props.systemConfigId The unique identifier (UUID) of the target system
 *   configuration entry to retrieve.
 * @path /shoppingMall/admin/systemConfigs/:systemConfigId
 * @accessor api.functional.shoppingMall.admin.systemConfigs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique identifier (UUID) of the target system configuration entry
     * to retrieve.
     */
    systemConfigId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallSystemConfig;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/systemConfigs/:systemConfigId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/systemConfigs/${encodeURIComponent(props.systemConfigId ?? "null")}`;
  export const random = (): IShoppingMallSystemConfig =>
    typia.random<IShoppingMallSystemConfig>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemConfigId")(() => typia.assert(props.systemConfigId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a platform system configuration entry by its unique systemConfigId.
 *
 * Update a system configuration entry in the shopping_mall_system_configs
 * table. The operation allows an administrator to modify any attributes of a
 * system config, such as changing feature flags, limit values, or JSON
 * structures controlling platform behavior.
 *
 * Security requirements strictly limit access to admin users. The operation
 * checks that the specified systemConfigId exists; if not, it returns an
 * appropriate error. Upon a valid update request, the value type must be
 * consistent with the selected key's expected type (e.g., integer value when
 * value_type is "int").
 *
 * All updates trigger audit logging of the admin actor, old and new values, and
 * the update timestamp. System-wide cache invalidation or runtime refresh may
 * also occur following core config updates. Editable fields include all value
 * columns (string, int, double, boolean, json) and meta attributes. Operation
 * is aligned with the business imperative of feature flexibility and runtime
 * control from the admin dashboard.
 *
 * @param props.connection
 * @param props.systemConfigId Unique identifier of the system configuration to
 *   update.
 * @param props.body New configuration values to update for the specified
 *   systemConfigId.
 * @path /shoppingMall/admin/systemConfigs/:systemConfigId
 * @accessor api.functional.shoppingMall.admin.systemConfigs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the system configuration to update. */
    systemConfigId: string & tags.Format<"uuid">;

    /** New configuration values to update for the specified systemConfigId. */
    body: IShoppingMallSystemConfig.IUpdate;
  };
  export type Body = IShoppingMallSystemConfig.IUpdate;
  export type Response = IShoppingMallSystemConfig;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/systemConfigs/:systemConfigId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/systemConfigs/${encodeURIComponent(props.systemConfigId ?? "null")}`;
  export const random = (): IShoppingMallSystemConfig =>
    typia.random<IShoppingMallSystemConfig>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemConfigId")(() => typia.assert(props.systemConfigId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a platform system configuration entry by its unique systemConfigId.
 *
 * Delete a system configuration entry by its unique identifier systemConfigId
 * from the shopping_mall_system_configs table. Only platform admin users have
 * permission to perform this operation due to the potential system-wide impact
 * of removing feature toggles or critical settings.
 *
 * The operation checks that the systemConfigId exists and is not a protected
 * configuration (e.g., essential bootstrapping settings are protected against
 * deletion by business logic). If deletion is permitted, the configuration is
 * removed from the database and will not be referenced by any system process or
 * client read. Actions are logged, and system contexts referencing the setting
 * will detect removal and react accordingly (reload, fallback, or error as
 * defined by business rules).
 *
 * This operation is considered a hard delete: the record is completely removed
 * from the table and cannot be recovered except by external backup or
 * administrator intervention. All deletions are audit-trailed, including the
 * acting admin and timestamp.
 *
 * @param props.connection
 * @param props.systemConfigId Unique identifier of the system configuration to
 *   delete.
 * @path /shoppingMall/admin/systemConfigs/:systemConfigId
 * @accessor api.functional.shoppingMall.admin.systemConfigs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the system configuration to delete. */
    systemConfigId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/systemConfigs/:systemConfigId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/systemConfigs/${encodeURIComponent(props.systemConfigId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemConfigId")(() => typia.assert(props.systemConfigId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
