import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallModerationEventLog } from "../../../../structures/IShoppingMallModerationEventLog";
import { IPageIShoppingMallModerationEventLog } from "../../../../structures/IPageIShoppingMallModerationEventLog";

/**
 * Create a new moderation event log entry (shopping_mall_moderation_event_logs
 * table).
 *
 * Create a moderation event log entry for tracking actions performed by
 * platform administrators on marketplace entities. The moderation event log
 * captures detailed information about moderation interventions such as policy
 * enforcement, abuse takedown, exception handling, and other events that
 * require transparent logging. Each log entry contains the acting admin ID,
 * optional references to affected sellers, products, reviews, or orders, the
 * event type (such as flag, removal, approval, annotation, warning, escalation,
 * etc.), a moderation message that explains the action, and a timestamp.
 *
 * Security is paramount for this operation; only platform administrators who
 * are properly authenticated and authorized may invoke this endpoint. The
 * action will be fully auditable for regulatory and business review. Changes
 * made through this operation are used to maintain accountability and support
 * post-incident investigation flows. Details provided within the log entry must
 * comply with business requirements for classification and completeness. The
 * moderation event log is tightly integrated with the
 * shopping_mall_moderation_event_logs table as described in the database
 * schema, and additional custom business logic applies for linking moderation
 * events to relevant domain entities.
 *
 * The operation requires all mandatory fields including acting admin, event
 * type, and moderation message, and will return the created log entry on
 * success. Error responses detail validation issues if required properties are
 * missing or permissions are insufficient. Related operations include updating
 * existing moderation event logs and retrieving moderation event history for
 * audit review.
 *
 * @param props.connection
 * @param props.body New moderation event log including admin, event type,
 *   moderation message, and affected entity references.
 * @path /shoppingMall/admin/moderationEventLogs
 * @accessor api.functional.shoppingMall.admin.moderationEventLogs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * New moderation event log including admin, event type, moderation
     * message, and affected entity references.
     */
    body: IShoppingMallModerationEventLog.ICreate;
  };
  export type Body = IShoppingMallModerationEventLog.ICreate;
  export type Response = IShoppingMallModerationEventLog;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/moderationEventLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/moderationEventLogs";
  export const random = (): IShoppingMallModerationEventLog =>
    typia.random<IShoppingMallModerationEventLog>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of moderation event logs
 * (shopping_mall_moderation_event_logs table).
 *
 * Retrieve a filtered and paginated list of moderation event logs. This API is
 * primarily used by platform administrators to monitor, audit, and review all
 * moderation or exception actions recorded on products, reviews, sellers, and
 * orders. Each log references the acting admin, the affected entity (by foreign
 * key), the event type, moderation message, and timestamp.
 *
 * The endpoint enables advanced filtering including by admin, entity type,
 * event type (flag, removal, approval, escalation, warning), and date range. It
 * offers pagination support to facilitate navigation through extensive
 * moderation history. All queries operate on the moderation event log entity as
 * per the Prisma schema, which contains complete action contexts for
 * compliance.
 *
 * Service security is critical: only authenticated admins can access this
 * endpoint. Unauthorized access must return an appropriate error.
 * Implementation should enforce comprehensive logging and query performance
 * optimizations for large search spaces. Related APIs may include detailed
 * moderation event retrieval and admin audit log endpoints.
 *
 * Any business critical operation (deletion, banning, flagging, escalation,
 * unblocking, etc.) with moderation impact should be discoverable via this
 * listing for complete administrative oversight. In case of query or data
 * issues, return a meaningful error response including information for
 * debugging and request traceability.
 *
 * @param props.connection
 * @param props.body Search and filter parameters for pagination, including
 *   event type, status, acting admin, affected entity reference, and optional
 *   date ranges.
 * @path /shoppingMall/admin/moderationEventLogs
 * @accessor api.functional.shoppingMall.admin.moderationEventLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter parameters for pagination, including event type,
     * status, acting admin, affected entity reference, and optional date
     * ranges.
     */
    body: IShoppingMallModerationEventLog.IRequest;
  };
  export type Body = IShoppingMallModerationEventLog.IRequest;
  export type Response = IPageIShoppingMallModerationEventLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/moderationEventLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/moderationEventLogs";
  export const random = (): IPageIShoppingMallModerationEventLog.ISummary =>
    typia.random<IPageIShoppingMallModerationEventLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve complete detail for a single moderation event log entry by its ID
 * (shopping_mall_moderation_event_logs table).
 *
 * Retrieve detailed information about a single moderation event log by its
 * unique ID. This API is used by platform administrators to access the complete
 * audit trail and context of specific moderation or exception events. The
 * moderation_event_log_id path parameter must be a valid UUID referencing an
 * existing moderation event log entry.
 *
 * The returned resource includes the acting admin's identifier, affected entity
 * foreign keys (seller, product, review, order), event type (such as flag,
 * removal, approval, escalation, warning), moderation message, and creation
 * timestamp. It operates strictly on the moderation event logs table as
 * described in the Prisma schema, providing all available details for
 * compliance and investigatory needs.
 *
 * Permissions: Only authenticated admins can access this endpoint. Any
 * unauthorized request must return an error. Invalid or unfound IDs should also
 * return proper error messages. This operation is complementary to search/list
 * endpoints for moderation logs and may be used together for deeper
 * investigations or operational auditing. Error handling includes validation on
 * UUID format and resource existence.
 *
 * @param props.connection
 * @param props.moderationEventLogId Unique identifier of the moderation event
 *   log entry to retrieve (UUID).
 * @path /shoppingMall/admin/moderationEventLogs/:moderationEventLogId
 * @accessor api.functional.shoppingMall.admin.moderationEventLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the moderation event log entry to retrieve
     * (UUID).
     */
    moderationEventLogId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallModerationEventLog;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/moderationEventLogs/:moderationEventLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/moderationEventLogs/${encodeURIComponent(props.moderationEventLogId ?? "null")}`;
  export const random = (): IShoppingMallModerationEventLog =>
    typia.random<IShoppingMallModerationEventLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationEventLogId")(() =>
        typia.assert(props.moderationEventLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a moderation event log entry by log ID
 * (shopping_mall_moderation_event_logs table).
 *
 * Update an existing moderation event log entry to correct errors, supplement
 * details, or provide additional annotation on moderation actions performed by
 * platform administrators. This operation targets the
 * shopping_mall_moderation_event_logs table, and is invoked via the
 * moderationEventLogId path parameter, identifying the record to mutate.
 * Typical use cases include updating the event type after further review,
 * clarifying the moderation message, or adding further references to affected
 * marketplace entities (such as products, reviews, sellers, or orders) to
 * provide improved traceability for regulatory or investigative purposes.
 *
 * Only authenticated admin users can perform this update. Security
 * considerations ensure that only users with proper administrative role and
 * access rights may change audit log data, preventing tampering or unauthorized
 * modification. The business logic ensures only permissible fields are updated
 * (change type, moderation message, affected entity references), records the
 * updater’s identity, and logs the timestamp of the change for full audit
 * transparency.
 *
 * The response returns the updated log entry, and errors are raised if the
 * provided moderationEventLogId does not exist, if the admin lacks permission,
 * or if required update fields are missing. Related operations include creation
 * of new moderation event logs and listing of all moderation actions for audit
 * history.
 *
 * @param props.connection
 * @param props.moderationEventLogId The unique identifier of the moderation
 *   event log entry to be updated.
 * @param props.body Updated moderation event log parameters. May include new
 *   moderation message, event type, and affected entity references.
 * @path /shoppingMall/admin/moderationEventLogs/:moderationEventLogId
 * @accessor api.functional.shoppingMall.admin.moderationEventLogs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * The unique identifier of the moderation event log entry to be
     * updated.
     */
    moderationEventLogId: string & tags.Format<"uuid">;

    /**
     * Updated moderation event log parameters. May include new moderation
     * message, event type, and affected entity references.
     */
    body: IShoppingMallModerationEventLog.IUpdate;
  };
  export type Body = IShoppingMallModerationEventLog.IUpdate;
  export type Response = IShoppingMallModerationEventLog;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/moderationEventLogs/:moderationEventLogId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/moderationEventLogs/${encodeURIComponent(props.moderationEventLogId ?? "null")}`;
  export const random = (): IShoppingMallModerationEventLog =>
    typia.random<IShoppingMallModerationEventLog>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationEventLogId")(() =>
        typia.assert(props.moderationEventLogId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a moderation event log
 * (shopping_mall_moderation_event_logs table) by ID.
 *
 * This endpoint handles the permanent deletion of a specific moderation event
 * log. It is directly tied to the shopping_mall_moderation_event_logs table
 * which maintains records of all moderation and exception actions (e.g.,
 * product flagging, review removal, seller warnings) performed by
 * administrative users on platform entities.
 *
 * Deleting a moderation event log removes evidence of moderation actions and
 * should only take place for events that are no longer required for compliance,
 * investigation, or audit. This operation is available exclusively to
 * administrators to ensure security and proper oversight; attempts by
 * unauthorized users are logged and rejected.
 *
 * The deletion action is irreversible—once a moderation event log is deleted,
 * it cannot be recovered. The API expects the unique moderationEventLogId as a
 * path parameter, referencing the primary key in the schema. Hard delete
 * behavior is enforced, and the operation does not return any content on
 * successful execution. Failure is signaled if the event does not exist or if
 * the caller lacks admin privileges. Related endpoints allow for moderation
 * event log review and search prior to deletion for risk mitigation.
 *
 * @param props.connection
 * @param props.moderationEventLogId Unique identifier of the moderation event
 *   log to be deleted.
 * @path /shoppingMall/admin/moderationEventLogs/:moderationEventLogId
 * @accessor api.functional.shoppingMall.admin.moderationEventLogs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the moderation event log to be deleted. */
    moderationEventLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/moderationEventLogs/:moderationEventLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/moderationEventLogs/${encodeURIComponent(props.moderationEventLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationEventLogId")(() =>
        typia.assert(props.moderationEventLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
