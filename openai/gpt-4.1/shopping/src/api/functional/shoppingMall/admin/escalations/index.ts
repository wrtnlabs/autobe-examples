import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallEscalation } from "../../../../structures/IShoppingMallEscalation";
import { IPageIShoppingMallEscalation } from "../../../../structures/IPageIShoppingMallEscalation";

/**
 * Retrieve a paginated and filterable list of escalation cases (disputes,
 * escalated customer service) from the shopping mall platform.
 *
 * This endpoint provides a comprehensive, filtered, and paginated list of
 * escalation cases present in the shopping mall system. Escalations represent
 * customer, seller, or admin-raised service requests that could not be resolved
 * through regular workflows (e.g., disputes, complaints, major refunds,
 * investigation cases). Escalations may include information on the order,
 * actors involved, escalation type and status, and assigned admin.
 *
 * Access to this endpoint is typically restricted to admin users and authorized
 * customer service agents as it may contain sensitive case and account
 * information. Permissions must be enforced in business logic to restrict
 * access to escalation cases relevant to the requesting user's role or scope.
 *
 * Each escalation in the result includes meta-information like creation
 * timestamp, status, type, current handler, and optionally linked events. The
 * query supports filters on type, status, assigned admin, date range, and
 * keyword search. The paginated response ensures scalable handling even as the
 * number of open/closed cases grows.
 *
 * Related endpoints include single escalation detail loading (GET
 * /escalations/{escalationId}), status/action change APIs, and escalation
 * creation through customer/seller dispute flows. Error cases handled include
 * excessive page size, invalid search terms, or unauthorized access.
 *
 * @param props.connection
 * @param props.body Request body for filtering, searching, and paginating
 *   escalation cases. Supports filters on type, status, assigned admin,
 *   initiator, date range, and keyword search.
 * @path /shoppingMall/admin/escalations
 * @accessor api.functional.shoppingMall.admin.escalations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Request body for filtering, searching, and paginating escalation
     * cases. Supports filters on type, status, assigned admin, initiator,
     * date range, and keyword search.
     */
    body: IShoppingMallEscalation.IRequest;
  };
  export type Body = IShoppingMallEscalation.IRequest;
  export type Response = IPageIShoppingMallEscalation.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/escalations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/escalations";
  export const random = (): IPageIShoppingMallEscalation.ISummary =>
    typia.random<IPageIShoppingMallEscalation.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a single escalation (dispute, customer
 * service case) by escalationId from the shopping mall platform.
 *
 * This endpoint loads the detailed information for a specific
 * escalation/dispute case given its unique escalationId. Escalations represent
 * complex customer service or complaint situations (such as refunds, disputes,
 * or major delivery issues) that require manual handling by admin or customer
 * service staff. The response includes case state, type, related order and
 * actors, audit trail fields, status, escalation reason/type, resolution
 * status, and assignment details.
 *
 * Authorization is required and typically limited to admin users or designated
 * customer service staff, as escalation cases may contain sensitive or private
 * information regarding users, orders, and disputes. The endpoint will validate
 * that the requesting user is authorized to view escalation details, returning
 * a not-found or unauthorized error otherwise.
 *
 * This operation references the 'shopping_mall_escalations' table and draws
 * from its relationships with orders, customers, sellers, and admins to present
 * a complete view of the given escalation. Use cases include escalation
 * handling, resolution processes, audit, and customer history investigation.
 * Error scenarios include non-existent, deleted, or unauthorized escalationId
 * references.
 *
 * @param props.connection
 * @param props.escalationId Unique identifier of the escalation case to fetch
 *   details for.
 * @path /shoppingMall/admin/escalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.escalations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the escalation case to fetch details for. */
    escalationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallEscalation;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/escalations/:escalationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/escalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): IShoppingMallEscalation =>
    typia.random<IShoppingMallEscalation>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("escalationId")(() => typia.assert(props.escalationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing escalation case (shopping_mall_escalations) by ID.
 *
 * Update the properties of an existing escalation record, such as its status,
 * escalation type, or resolution outcomes. Only authorized users—such as the
 * initiator (customer or seller) or an assigned admin—may perform updates to an
 * escalation. Typical updates include status transitions (e.g., 'in-review',
 * 'resolved', 'closed'), adding or updating comments, or assigning the case to
 * a specific admin.
 *
 * The endpoint strictly checks access permissions: customers can only update
 * their own escalations, sellers for their orders, and admins for any case.
 * Updates are tracked with audit logs, including who made the change, the prior
 * and new status, and timestamps for compliance and traceability. Validation
 * ensures status transitions are legal (e.g., cannot resolve a closed case,
 * must provide a resolution reason when closing, etc.) and that escalation
 * content remains consistent with business rules.
 *
 * This operation interacts with the shopping_mall_escalations record identified
 * by escalationId. Potential errors are returned on unauthorized updates,
 * invalid status transitions, or missing required fields in the update request.
 * Related flows include dashboard visibility of escalation status for
 * customers, sellers, and admins; customer service event tracking; and
 * downstream effects such as notifications or associated appeals.
 *
 * @param props.connection
 * @param props.escalationId Unique identifier for the escalation to update.
 * @param props.body Updated escalation fields, such as status change,
 *   assignment, resolution, or commentary.
 * @path /shoppingMall/admin/escalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.escalations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the escalation to update. */
    escalationId: string & tags.Format<"uuid">;

    /**
     * Updated escalation fields, such as status change, assignment,
     * resolution, or commentary.
     */
    body: IShoppingMallEscalation.IUpdate;
  };
  export type Body = IShoppingMallEscalation.IUpdate;
  export type Response = IShoppingMallEscalation;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/escalations/:escalationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/escalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): IShoppingMallEscalation =>
    typia.random<IShoppingMallEscalation>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("escalationId")(() => typia.assert(props.escalationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an escalation (shopping_mall_escalations table) and all
 * related records by escalationId.
 *
 * Permanently remove an escalation case and all its associated records from the
 * shoppingMall platform. This operation should only be performed by an admin
 * with full permissions, as escalation records may relate to disputes,
 * order-related complaints, or serious customer/vendor issues. The operation
 * relies on the Prisma model shopping_mall_escalations, which contains complete
 * details about the escalation type, status, actors (customer, seller, and
 * assigned admin), and timestamps.
 *
 * To maintain audit integrity, all deletions trigger cascaded removal of
 * subsidiary customer service events, related appeals, and any associated
 * comments. Regulatory and business policy may require reason tracking and
 * audit of such deletions, which should be implemented in the system's backend
 * logic. Attempting to delete a non-existent escalation should yield a clear
 * business error response. This operation should NOT be exposed to non-admin
 * actors, and misuse could impact compliance or incident audit trails.
 *
 * @param props.connection
 * @param props.escalationId Unique identifier of the escalation to delete
 * @path /shoppingMall/admin/escalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.escalations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the escalation to delete */
    escalationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/escalations/:escalationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/escalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("escalationId")(() => typia.assert(props.escalationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
