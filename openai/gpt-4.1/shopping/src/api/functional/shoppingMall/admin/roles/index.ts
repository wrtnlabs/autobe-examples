import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallRole } from "../../../../structures/IShoppingMallRole";
import { IPageIShoppingMallRole } from "../../../../structures/IPageIShoppingMallRole";

/**
 * Create a new system role in shopping_mall_roles (admin only).
 *
 * This API allows platform administrators to define and create new system roles
 * for RBAC (role-based access control) scenarios. It inserts a role record with
 * a unique name and descriptive documentation. The operation validates for
 * uniqueness on roleName and requires both the roleName and description fields
 * as input.
 *
 * Role creation affects user management, permission matrix, and must propagate
 * to all RBAC subsystems. All create operations are audited for compliance and
 * traceability. The endpoint is strictly limited to admins; unauthorized access
 * is denied with auditing.
 *
 * No soft-delete is performed on creation; the role is inserted and becomes
 * available for assignment to new or existing users immediately after
 * creation.
 *
 * @param props.connection
 * @param props.body Information required for creating a new role, including
 *   roleName and description.
 * @path /shoppingMall/admin/roles
 * @accessor api.functional.shoppingMall.admin.roles.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required for creating a new role, including roleName and
     * description.
     */
    body: IShoppingMallRole.ICreate;
  };
  export type Body = IShoppingMallRole.ICreate;
  export type Response = IShoppingMallRole;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/roles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/roles";
  export const random = (): IShoppingMallRole =>
    typia.random<IShoppingMallRole>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated, filtered role definitions from
 * shopping_mall_roles.
 *
 * This API retrieves a joined, paginated list of roles configured in the
 * system, referencing the shopping_mall_roles table from the Prisma schema. The
 * roles table provides role_name (unique) and description fields, supporting
 * search by name/description and filtering for permission management
 * workflows.
 *
 * The platform uses roles to assign user capabilities (e.g., CUSTOMER, ADMIN,
 * SELLER), shaping access control and dashboard views. This endpoint allows
 * privileged users (typically admins) to view and filter all current role
 * definitions, with support for search keywords (with GIN/Trigram indexes),
 * sort by creation/update date, and custom pagination (page size, offset).
 *
 * Returned results provide complete role metadata for client-side permission
 * matrix rendering, internal audits, and user administration screens. Errors
 * and edge cases (e.g., empty results, malformed queries) will trigger standard
 * platform error responses.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for querying role
 *   definitions
 * @path /shoppingMall/admin/roles
 * @accessor api.functional.shoppingMall.admin.roles.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, and pagination parameters for querying role
     * definitions
     */
    body: IShoppingMallRole.IRequest;
  };
  export type Body = IShoppingMallRole.IRequest;
  export type Response = IPageIShoppingMallRole;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/roles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/roles";
  export const random = (): IPageIShoppingMallRole =>
    typia.random<IPageIShoppingMallRole>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific system role by roleId (shopping_mall_roles).
 *
 * Fetch complete information about a platform role (e.g., CUSTOMER, SELLER,
 * ADMIN) using the role's unique identifier from the shopping_mall_roles table.
 * The operation is essential for admin dashboards, auditing, or any UI that
 * enumerates or manages roles.
 *
 * This API is intended for admin or system use to allow determination and
 * explanation of user permissions, not for direct customer interaction. The
 * detailed response includes roleName, description, and metadata fields for
 * audit. Unauthorized or non-existent roleId queries will return an error
 * according to business rules.
 *
 * Only admin-level users should have direct access to this endpoint. All
 * requests are audited. This operation has no requestBody since all parameters
 * are in the path.
 *
 * @param props.connection
 * @param props.roleId Unique identifier for the target role (UUID).
 * @path /shoppingMall/admin/roles/:roleId
 * @accessor api.functional.shoppingMall.admin.roles.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target role (UUID). */
    roleId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallRole;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/roles/:roleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/roles/${encodeURIComponent(props.roleId ?? "null")}`;
  export const random = (): IShoppingMallRole =>
    typia.random<IShoppingMallRole>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("roleId")(() => typia.assert(props.roleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing platform role (shopping_mall_roles table) by its ID.
 *
 * Update the information for a specific system role by its role ID. This
 * operation is core to the administration of access control on the e-commerce
 * platform. Only platform administrators are authorized to execute this
 * operation, as improper role modifications could jeopardize platform security
 * or user access.
 *
 * When called, it updates attributes on the 'shopping_mall_roles' table, such
 * as 'role_name' (e.g., CUSTOMER, SELLER, ADMIN), and 'description' (permission
 * explanation). It enforces uniqueness of the 'role_name' property, and
 * validation ensures the updated role definition does not conflict with
 * existing assignments or violate platform invariants. Changes are immediately
 * reflected across all permission checks, and all updates are logged for audit
 * purposes.
 *
 * This API provides transactional guarantees for role editing: if the update
 * would violate uniqueness or referential constraints, an error is returned.
 * Role updates are critical for responding to evolving business requirements,
 * regulatory needs, or new features that impact permission matrices.
 *
 * @param props.connection
 * @param props.roleId Unique identifier for the role to be updated.
 * @param props.body Information to update the target role. Includes fields such
 *   as role_name and description.
 * @path /shoppingMall/admin/roles/:roleId
 * @accessor api.functional.shoppingMall.admin.roles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the role to be updated. */
    roleId: string & tags.Format<"uuid">;

    /**
     * Information to update the target role. Includes fields such as
     * role_name and description.
     */
    body: IShoppingMallRole.IUpdate;
  };
  export type Body = IShoppingMallRole.IUpdate;
  export type Response = IShoppingMallRole;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/roles/:roleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/roles/${encodeURIComponent(props.roleId ?? "null")}`;
  export const random = (): IShoppingMallRole =>
    typia.random<IShoppingMallRole>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("roleId")(() => typia.assert(props.roleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a platform role (shopping_mall_roles table) by its ID.
 *
 * Delete an existing system role from the platform's role registry by its
 * unique ID. This action is restricted to platform administrators due to its
 * impact on access control and permission matrices.
 *
 * On invocation, this operation checks referential integrity: if any users or
 * entities are still assigned the role, the operation is blocked and an error
 * is returned. The delete is a hard removal based on the absence of a
 * soft-delete field in the 'shopping_mall_roles' table. All deletions are
 * logged for audit and compliance. Removing a role cannot be undone and could
 * have system-wide effects if the role was used in access decisions.
 *
 * Appropriate error checks, validation of constraints, and confirmation of
 * non-assignment of users are critical for successful execution of this
 * operation. Documentation and approval flows should be in place before
 * attempting to delete a role. Attempts to delete system-critical roles should
 * be guarded by additional business policy checks.
 *
 * @param props.connection
 * @param props.roleId Unique identifier for the role to be deleted.
 * @path /shoppingMall/admin/roles/:roleId
 * @accessor api.functional.shoppingMall.admin.roles.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the role to be deleted. */
    roleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/roles/:roleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/roles/${encodeURIComponent(props.roleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("roleId")(() => typia.assert(props.roleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
