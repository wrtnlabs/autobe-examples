import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdminActionLog } from "../../../../structures/IShoppingMallAdminActionLog";
import { IPageIShoppingMallAdminActionLog } from "../../../../structures/IPageIShoppingMallAdminActionLog";

/**
 * Create a new administrative action log entry (shopping_mall_admin_action_logs
 * table).
 *
 * This API endpoint allows an authenticated admin to create a new action log
 * describing a significant administrative event, such as approvals, bans,
 * suspensions, overrides, or edits, which impact platform data or user states.
 * Upon submission, essential details such as the acting admin, affected
 * entities (using corresponding IDs), the type and reason for the action, as
 * well as the affected domain, are recorded. Optionally, structured details can
 * be attached in JSON format for trace analysis.
 *
 * The operation ensures that all actions are auditable for future
 * investigations or compliance reviews required by regulatory policies. Only
 * users with the 'admin' role can invoke this endpoint. It directly references
 * the shopping_mall_admin_action_logs table, contributing to the system's
 * immutable administrative action trail.
 *
 * If required fields are missing or IDs do not correspond to existing entities,
 * the endpoint returns a validation error. All successful logs are timestamped
 * at creation.
 *
 * @param props.connection
 * @param props.body Information about the admin action to log, including acting
 *   admin, affected entity, action type/reason, and any context details.
 * @path /shoppingMall/admin/adminActionLogs
 * @accessor api.functional.shoppingMall.admin.adminActionLogs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information about the admin action to log, including acting admin,
     * affected entity, action type/reason, and any context details.
     */
    body: IShoppingMallAdminActionLog.ICreate;
  };
  export type Body = IShoppingMallAdminActionLog.ICreate;
  export type Response = IShoppingMallAdminActionLog;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/adminActionLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/adminActionLogs";
  export const random = (): IShoppingMallAdminActionLog =>
    typia.random<IShoppingMallAdminActionLog>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve and search the list of administrative action logs from
 * shopping_mall_admin_action_logs table.
 *
 * This endpoint allows an administrator to search through the history of
 * administrative actions recorded in the shopping_mall_admin_action_logs
 * schema. Each log entry documents an action taken by a platform admin
 * (approval, ban, update, deletion, override, etc.) and contains references to
 * affected users, products, orders, or reviews, the domain context, the reason
 * for the action, a timestamp, and detailed structured context as JSON if
 * available.
 *
 * Security is paramount: only admin users should be granted access, as these
 * logs may contain sensitive operational or user data, including reasons for
 * disciplinary actions or platform changes. All access to this endpoint itself
 * should be recorded for compliance and monitoring purposes. Data returned
 * should mask or filter PII if the requesting admin does not have full
 * privileges.
 *
 * The operation supports sophisticated filtering queries, such as actions by a
 * particular admin, within a date/time range, or on a given domain type
 * (product, user, order, etc.). Pagination parameters help navigate large log
 * datasets, and results are sorted by creation timestamp descending by default.
 * Failures should return clear, actionable messages, and backend errors must
 * not leak sensitive information.
 *
 * @param props.connection
 * @param props.body Query parameters for filtering, searching, and paginating
 *   admin action logs. Filters may include admin ID, action type, affected
 *   entity/domain, and timestamp range.
 * @path /shoppingMall/admin/adminActionLogs
 * @accessor api.functional.shoppingMall.admin.adminActionLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query parameters for filtering, searching, and paginating admin
     * action logs. Filters may include admin ID, action type, affected
     * entity/domain, and timestamp range.
     */
    body: IShoppingMallAdminActionLog.IRequest;
  };
  export type Body = IShoppingMallAdminActionLog.IRequest;
  export type Response = IPageIShoppingMallAdminActionLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/adminActionLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/adminActionLogs";
  export const random = (): IPageIShoppingMallAdminActionLog.ISummary =>
    typia.random<IPageIShoppingMallAdminActionLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific administrative action log entry
 * from shopping_mall_admin_action_logs.
 *
 * This endpoint enables the retrieval of fully detailed information about a
 * specific administrative action log, identified by the adminActionLogId path
 * parameter and referencing the shopping_mall_admin_action_logs schema entity.
 * The log entry contains structured information about which admin performed the
 * action, the type and domain of the action (e.g., approval, ban, edit), which
 * entity was affected, the reason for the action, a JSON context dump, and an
 * audit-compliant timestamp.
 *
 * Security is strict: Only authenticated admin users may access this endpoint,
 * and all access must be recorded. The returned record provides all relevant
 * metadata including acting admin information, linked
 * customer/seller/product/order/review (if any), the rationale for the action,
 * and full structured context for root cause analysis or compliance
 * investigation. If the log entry does not exist or the admin lacks sufficient
 * privileges, the API returns a clear, appropriate error.
 *
 * This operation is a critical building block for platform accountability,
 * incident post-mortems, and regulatory reviews. It should be integrated with
 * role-based visibility controls and full access audit trails.
 *
 * @param props.connection
 * @param props.adminActionLogId Unique identifier of the admin action log entry
 *   to retrieve.
 * @path /shoppingMall/admin/adminActionLogs/:adminActionLogId
 * @accessor api.functional.shoppingMall.admin.adminActionLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the admin action log entry to retrieve. */
    adminActionLogId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdminActionLog;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/adminActionLogs/:adminActionLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/adminActionLogs/${encodeURIComponent(props.adminActionLogId ?? "null")}`;
  export const random = (): IShoppingMallAdminActionLog =>
    typia.random<IShoppingMallAdminActionLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminActionLogId")(() =>
        typia.assert(props.adminActionLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing admin action log entry by ID
 * (shopping_mall_admin_action_logs table).
 *
 * This API allows an authenticated admin to update fields of an existing admin
 * action log, typically to correct previous input, append clarifications, or
 * supply additional audit context. The key fields that may be modified include
 * the action reason and the details_json property, enabling admins to document
 * post-event information relevant for future traceability or compliance
 * checks.
 *
 * This operation cross-verifies that the log entry with the given identifier
 * exists and has not been soft-deleted before making any modification. Only
 * users with the 'admin' role can perform updates, and any changes are
 * timestamped and reflected in the audit system. Attempts to modify a
 * non-existent or deleted log record will result in an appropriate error
 * response.
 *
 * Partial updates are allowed; unchanged fields may be omitted from the
 * payload. Administration of immutable fields (such as acting_admin or
 * affected_entity identifiers) is generally NOT permitted via this endpoint to
 * preserve historical accuracy.
 *
 * @param props.connection
 * @param props.adminActionLogId Unique identifier of the admin action log to
 *   update
 * @param props.body Fields to update in the admin action log record (typically
 *   action_reason or details_json); other fields may not be updatable.
 * @path /shoppingMall/admin/adminActionLogs/:adminActionLogId
 * @accessor api.functional.shoppingMall.admin.adminActionLogs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the admin action log to update */
    adminActionLogId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the admin action log record (typically
     * action_reason or details_json); other fields may not be updatable.
     */
    body: IShoppingMallAdminActionLog.IUpdate;
  };
  export type Body = IShoppingMallAdminActionLog.IUpdate;
  export type Response = IShoppingMallAdminActionLog;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/adminActionLogs/:adminActionLogId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/adminActionLogs/${encodeURIComponent(props.adminActionLogId ?? "null")}`;
  export const random = (): IShoppingMallAdminActionLog =>
    typia.random<IShoppingMallAdminActionLog>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminActionLogId")(() =>
        typia.assert(props.adminActionLogId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific admin action log entry (soft delete if supported) from
 * shopping_mall_admin_action_logs table.
 *
 * This DELETE operation is focused on the admin action log management for the
 * shopping mall platform. Each record in shopping_mall_admin_action_logs tracks
 * actions performed by platform admins, including the acting admin, affected
 * entity, action type, reason, and timestamp.
 *
 * The operation is restricted to administrators to support compliance with data
 * privacy, legal retention, and operational policies. When an administrator
 * issues this deletion, the system will remove the admin action log record
 * identified by 'adminActionLogId' from the database entirely. Given that the
 * model includes a nullable 'deleted_at' field, this operation should perform a
 * soft deletion by updating the 'deleted_at' timestamp unless permanent
 * deletion is explicitly mandated by business rules or configuration.
 *
 * Special care must be taken to ensure that accidental or unauthorized
 * deletions do not occur, and a full audit trail should be maintained for
 * deletion activities. Related references in audit, investigation, or reporting
 * flows should be updated or handled as per platform policy. Error handling
 * should clearly report if the ID does not exist or if deletion is restricted
 * by compliance holds.
 *
 * @param props.connection
 * @param props.adminActionLogId The unique identifier of the admin action log
 *   entry to be deleted.
 * @path /shoppingMall/admin/adminActionLogs/:adminActionLogId
 * @accessor api.functional.shoppingMall.admin.adminActionLogs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the admin action log entry to be deleted. */
    adminActionLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/adminActionLogs/:adminActionLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/adminActionLogs/${encodeURIComponent(props.adminActionLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminActionLogId")(() =>
        typia.assert(props.adminActionLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
