import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCatalogImage } from "../../../../../structures/IShoppingMallCatalogImage";

/**
 * Add a new image to a specific product (shopping_mall_products table).
 *
 * This API endpoint receives a request to upload a new image for an existing
 * product. The target product is identified by the 'productId' path parameter
 * and must already exist in the product catalog. Sellers can use this to expand
 * the product gallery, or admins can use it for moderation or compliance
 * requirements.
 *
 * Request validation includes the following: the image file must be properly
 * uploaded and accessible via a URI; metadata such as optional alt text and
 * display order may be supplied; and the user must have the necessary
 * authorization to modify this product's catalog content. The system will
 * enforce maximum image count per product, allowable image file formats, and
 * size limits as per current platform configuration. If the image violates
 * policy, an error code and descriptive message will be provided.
 *
 * Security considerations: Only sellers assigned to the product and admins can
 * add images to products. Attempts by unauthorized users will be denied. Image
 * uploads may be subject to further background moderation (automated or manual)
 * before being publicly displayed.
 *
 * Related APIs: GET /products/{productId}/images (for viewing all images), PUT
 * /products/{productId}/images/{imageId} (for modifying an existing image),
 * DELETE /products/{productId}/images/{imageId} (for removing an image). Each
 * modification triggers update to product cache and business audit logs.
 * Failure cases (invalid productId, unauthorized action, invalid image, or
 * storage errors) result in appropriate error responses and do not affect
 * existing images.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to which the new
 *   image will be added.
 * @param props.body Details for the image to be uploaded, including the storage
 *   URI, optional alt text, and display order within the product gallery.
 * @path /shoppingMall/admin/products/:productId/images
 * @accessor api.functional.shoppingMall.admin.products.images.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the product to which the new image will be
     * added.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Details for the image to be uploaded, including the storage URI,
     * optional alt text, and display order within the product gallery.
     */
    body: IShoppingMallCatalogImage.ICreate;
  };
  export type Body = IShoppingMallCatalogImage.ICreate;
  export type Response = IShoppingMallCatalogImage;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/products/:productId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/images`;
  export const random = (): IShoppingMallCatalogImage =>
    typia.random<IShoppingMallCatalogImage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an image's metadata for a specific product (shopping_mall_products,
 * shopping_mall_catalog_images).
 *
 * This API endpoint receives a request to update image metadata for a specific
 * image belonging to a product. It supports changing properties such as alt
 * text (for accessibility), display order (for gallery sorting), or image URI
 * (for replacing the visual asset).
 *
 * Only authorized users, specifically the seller assigned to the product or
 * designated admins, may perform this operation. The endpoint validates both
 * the existence of the referenced image and the user's permission to modify it.
 * The business logic layer ensures that updates are consistent with product
 * limits (e.g., ordering within the current product image set) and enforces
 * audit logging for accountability.
 *
 * If the operation is successful, the response includes the newly updated image
 * object with all applied changes. Failure modes include invalid product or
 * image IDs, permission denials, invalid input data, or attempts to update
 * images not belonging to the specified product. Related endpoints are POST
 * /products/{productId}/images for creation and DELETE
 * /products/{productId}/images/{imageId} for removal. All modifications affect
 * product cache and may trigger UI gallery reorder.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose image is to be
 *   updated.
 * @param props.imageId Unique identifier of the image to update within the
 *   product's gallery.
 * @param props.body New image metadata or reference to apply to this product
 *   image record.
 * @path /shoppingMall/admin/products/:productId/images/:imageId
 * @accessor api.functional.shoppingMall.admin.products.images.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the product whose image is to be updated. */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the image to update within the product's
     * gallery.
     */
    imageId: string & tags.Format<"uuid">;

    /**
     * New image metadata or reference to apply to this product image
     * record.
     */
    body: IShoppingMallCatalogImage.IUpdate;
  };
  export type Body = IShoppingMallCatalogImage.IUpdate;
  export type Response = IShoppingMallCatalogImage;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/products/:productId/images/:imageId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IShoppingMallCatalogImage =>
    typia.random<IShoppingMallCatalogImage>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("imageId")(() => typia.assert(props.imageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an image from a product in shopping_mall_catalog_images by imageId.
 *
 * The main purpose of this API operation is to enable sellers or administrators
 * to remove an individual image associated with a given product. The deletion
 * process ensures that the specified image record is permanently deleted from
 * the shopping_mall_catalog_images table: the system removes the image by its
 * unique imageId and verifies that the requesting user is the seller of the
 * product or an authorized admin.
 *
 * Security rules require strict authorization so that only the product's owner
 * (seller) or platform admins are permitted to perform this operation. The
 * relationship to the shopping_mall_products and shopping_mall_catalog_images
 * tables is crucial since images are referenced by productId and are displayed
 * in product galleries throughout the marketplace. Additionally, the operation
 * respects any logical or business constraints, such as ensuring at least one
 * product image remains if a business rule requires it, and denies deletion
 * otherwise.
 *
 * Business logic for validation includes checking that the product and image
 * exist and that the image is indeed associated with the given productId. If
 * the image being deleted is the product's primary image, the system may
 * trigger fallback behavior to another available image or flag the product as
 * lacking a main image; error handling must inform the caller of such states
 * and enforce consistent catalog appearance. This operation is related to the
 * PATCH /products/{productId}/images endpoint for retrieving or updating
 * product images and should be documented together for product management
 * workflows.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose image will be
 *   deleted.
 * @param props.imageId Unique identifier of the image to be deleted from the
 *   specified product.
 * @path /shoppingMall/admin/products/:productId/images/:imageId
 * @accessor api.functional.shoppingMall.admin.products.images.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the product whose image will be deleted. */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the image to be deleted from the specified
     * product.
     */
    imageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/products/:productId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
