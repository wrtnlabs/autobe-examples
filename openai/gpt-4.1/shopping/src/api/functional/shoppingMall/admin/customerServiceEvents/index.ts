import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomerServiceEvent } from "../../../../structures/IShoppingMallCustomerServiceEvent";
import { IPageIShoppingMallCustomerServiceEvent } from "../../../../structures/IPageIShoppingMallCustomerServiceEvent";

/**
 * Admin-only, paginated search for customer service events in
 * shopping_mall_customer_service_events.
 *
 * Search and filter customer service events across all orders and escalations.
 * This API performs advanced queries on the
 * shopping_mall_customer_service_events table, enabling admins to audit,
 * review, and respond to customer service case progression. Supported filters
 * include event_type, event_status, order_history_id, actor information
 * (customer/seller/admin), escalation_id, appeal_id, and date ranges. The
 * result is a paginated view of events.
 *
 * Only admin users can access this operation, ensuring that sensitive customer
 * service interactions are secured. Security and audit requirements dictate
 * strict logging of access to these logs.
 *
 * Business logic may enforce maximum page sizes for performance reasons. The
 * operation is typically used alongside APIs for order histories, escalations,
 * and appeals to present a complete investigative timeline for cases involving
 * orders, complaints, refunds, or appeals.
 *
 * Error handling covers invalid filters or unauthorized access attempts, which
 * result in access denied or validation error responses.
 *
 * @param props.connection
 * @param props.body Search/request parameters for filtering and sorting
 *   customer service events. Accepts IShoppingMallCustomerServiceEvent.IRequest
 *   body.
 * @path /shoppingMall/admin/customerServiceEvents
 * @accessor api.functional.shoppingMall.admin.customerServiceEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search/request parameters for filtering and sorting customer service
     * events. Accepts IShoppingMallCustomerServiceEvent.IRequest body.
     */
    body: IShoppingMallCustomerServiceEvent.IRequest;
  };
  export type Body = IShoppingMallCustomerServiceEvent.IRequest;
  export type Response = IPageIShoppingMallCustomerServiceEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/customerServiceEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/customerServiceEvents";
  export const random = (): IPageIShoppingMallCustomerServiceEvent =>
    typia.random<IPageIShoppingMallCustomerServiceEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a customer service event's details by eventId
 * (shopping_mall_customer_service_events table).
 *
 * This API retrieves a customer service event identified by its unique eventId
 * from the shopping_mall_customer_service_events table. The customer service
 * event logs actions performed by customers, sellers, admins, or the system for
 * order service cases, escalations, or appeals. The log captures the associated
 * order history, escalation, or appeal context, as well as all relevant actor
 * information (customer, seller, admin).
 *
 * Access control is vital: customers may only retrieve events they are directly
 * involved in, sellers may only see events tied to orders/products they are
 * responsible for, and admins can view all cases for oversight or investigation
 * purposes. Sensitive/comment fields require masking or omission for users
 * lacking appropriate permissions.
 *
 * This retrieval operation is critical for customer support timelines, audit
 * trails, and case histories. Error handling includes returning not found for
 * nonexistent IDs, or forbidden for unauthorized access. Related endpoints
 * include searching service events by order or filtering logs by context.
 *
 * @param props.connection
 * @param props.eventId Unique identifier of the target customer service event
 *   record (UUID format).
 * @path /shoppingMall/admin/customerServiceEvents/:eventId
 * @accessor api.functional.shoppingMall.admin.customerServiceEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the target customer service event record (UUID
     * format).
     */
    eventId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomerServiceEvent;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/customerServiceEvents/:eventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customerServiceEvents/${encodeURIComponent(props.eventId ?? "null")}`;
  export const random = (): IShoppingMallCustomerServiceEvent =>
    typia.random<IShoppingMallCustomerServiceEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("eventId")(() => typia.assert(props.eventId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of a customer service event record by eventId
 * (shopping_mall_customer_service_events table).
 *
 * This API allows updating certain allowed fields of an existing customer
 * service event record identified by eventId. The
 * shopping_mall_customer_service_events table provides an audit trail of
 * customer service actions spanning case escalation, investigation, messaging,
 * admin resolution, or appeal. Permitted fields to update may include
 * event_status, event_comment, or actor assignment but never audit or
 * created_at details.
 *
 * Authorization is strictly enforced: typically only admins or specifically
 * assigned actors to the event (e.g., as part of an escalation case) can change
 * status, annotate, or append a comment. Attempts to update fields outside of
 * permission scope or immutable fields (created_at, actor references, order
 * linkage) will be rejected with validation or forbidden errors.
 *
 * The operation incorporates business logic to ensure customer service process
 * integrity, supporting only those field changes reflecting real workflow steps
 * (e.g., review, resolution, annotation), and rigorously logs each update for
 * audit compliance. Related APIs include retrieving event details, listing all
 * events per escalation/appeal, or escalating to admin for further review.
 *
 * @param props.connection
 * @param props.eventId Unique identifier of the customer service event to
 *   update (UUID format).
 * @param props.body Modifiable fields for updating customer service event
 *   (event_status, event_comment, etc.) in accordance with assigned roles and
 *   business workflow.
 * @path /shoppingMall/admin/customerServiceEvents/:eventId
 * @accessor api.functional.shoppingMall.admin.customerServiceEvents.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the customer service event to update (UUID
     * format).
     */
    eventId: string & tags.Format<"uuid">;

    /**
     * Modifiable fields for updating customer service event (event_status,
     * event_comment, etc.) in accordance with assigned roles and business
     * workflow.
     */
    body: IShoppingMallCustomerServiceEvent.IUpdate;
  };
  export type Body = IShoppingMallCustomerServiceEvent.IUpdate;
  export type Response = IShoppingMallCustomerServiceEvent;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/customerServiceEvents/:eventId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customerServiceEvents/${encodeURIComponent(props.eventId ?? "null")}`;
  export const random = (): IShoppingMallCustomerServiceEvent =>
    typia.random<IShoppingMallCustomerServiceEvent>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("eventId")(() => typia.assert(props.eventId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
