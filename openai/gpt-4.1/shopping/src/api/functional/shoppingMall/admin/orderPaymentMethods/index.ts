import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrderPaymentMethod } from "../../../../structures/IShoppingMallOrderPaymentMethod";
import { IPageIShoppingMallOrderPaymentMethod } from "../../../../structures/IPageIShoppingMallOrderPaymentMethod";

/**
 * Create a new payment method snapshot for an order
 * (shopping_mall_order_payment_methods).
 *
 * This API operation creates a new snapshot of an order payment method for
 * recording and auditing transactional payments. Payment method snapshots are
 * required to be created for each order at checkout to store relevant data as
 * it was at the time of purchase.
 *
 * The snapshot includes the type of payment method (e.g., card, bank_transfer,
 * PayPal), method data required for reconciliation, and a display name suitable
 * for UI display or customer receipt. This operation does not create or update
 * actual third-party payment tokens; it simply records a static snapshot in the
 * database for compliance, auditing, and for use in later order and payment
 * history queries.
 *
 * This operation references the shopping_mall_order_payment_methods table,
 * ensuring all required fields (payment_method_type, method_data, display_name)
 * are provided and validated. Only administrators and internal platform
 * components are allowed to call this endpoint directly, as customers and
 * sellers typically interact with payment methods through guided UI flows
 * during checkout. Error handling includes validation of required fields and
 * compliance with method-specific data formats. This operation may be paired
 * with order/payment creation APIs for a complete order processing flow.
 *
 * @param props.connection
 * @param props.body Information to capture a payment method snapshot for an
 *   order, including type, method data, and display name.
 * @path /shoppingMall/admin/orderPaymentMethods
 * @accessor api.functional.shoppingMall.admin.orderPaymentMethods.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information to capture a payment method snapshot for an order,
     * including type, method data, and display name.
     */
    body: IShoppingMallOrderPaymentMethod.ICreate;
  };
  export type Body = IShoppingMallOrderPaymentMethod.ICreate;
  export type Response = IShoppingMallOrderPaymentMethod;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/orderPaymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/orderPaymentMethods";
  export const random = (): IShoppingMallOrderPaymentMethod =>
    typia.random<IShoppingMallOrderPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated and filterable index/search of order payment methods (audit
 * records) in the system, reflecting shopping_mall_order_payment_methods
 * table.
 *
 * This operation allows administrators or platform operators to retrieve a
 * filtered and paginated list of all order payment methods stored in the
 * e-commerce system. It operates on the shopping_mall_order_payment_methods
 * table, supporting queries by payment method type, masked card/bank name, and
 * creation date.
 *
 * This endpoint can be used for administrative, auditing, or customer service
 * use cases where reference to historical payment methods is necessary, such as
 * payment reconciliations or issue resolution. Sensitive payment information is
 * never exposed; rather, a safe display name and method metadata is provided.
 *
 * Authorization checks should ensure only admin users (or authorized support
 * staff) have access.
 *
 * Pagination, sorting, and advanced filtering are available. Typical search
 * fields include payment_method_type (e.g., card, bank_transfer), display_name,
 * and timeframe. This operation does not allow exposure or enumeration of
 * credentials and is strictly for metadata review or troubleshooting.
 *
 * Related endpoints include single payment method retrieval for detailed
 * inspection. Error conditions include invalid filter criteria, requesting a
 * page beyond result set, or insufficient permissions.
 *
 * @param props.connection
 * @param props.body Query parameters for filtering, sorting, and paginating the
 *   search of order payment methods.
 * @path /shoppingMall/admin/orderPaymentMethods
 * @accessor api.functional.shoppingMall.admin.orderPaymentMethods.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query parameters for filtering, sorting, and paginating the search of
     * order payment methods.
     */
    body: IShoppingMallOrderPaymentMethod.IRequest;
  };
  export type Body = IShoppingMallOrderPaymentMethod.IRequest;
  export type Response = IPageIShoppingMallOrderPaymentMethod.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orderPaymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/orderPaymentMethods";
  export const random = (): IPageIShoppingMallOrderPaymentMethod.ISummary =>
    typia.random<IPageIShoppingMallOrderPaymentMethod.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details for a specific order payment method snapshot by ID
 * (shopping_mall_order_payment_methods table).
 *
 * This operation returns comprehensive details for a single order payment
 * method record, uniquely identified by orderPaymentMethodId. It draws from the
 * shopping_mall_order_payment_methods Prisma model, which stores a snapshot of
 * the payment method (including payment_method_type, display_name, method_data,
 * and timestamps) for every created order.
 *
 * The endpoint is intended for admin or support staff, supporting granular
 * investigations for order issues, payment disputes, or customer service needs
 * where reference to historical method information is required. This data is
 * immutable post-order and represents the state at time of purchase, ensuring
 * audit and trace compliance.
 *
 * Only admin-level users are authorized to access this information as it could
 * be linked to sensitive business or user audit trails (though display data is
 * masked for privacy). Related endpoints include listing all payment methods,
 * and order-level payment investigation or dispute workflow APIs.
 *
 * Validation checks include confirming the orderPaymentMethodId exists and
 * belongs to a valid database record. Missing or unauthorized requests return a
 * 404 or 403 as appropriate.
 *
 * @param props.connection
 * @param props.orderPaymentMethodId Unique identifier (UUID) of the target
 *   order payment method record to be retrieved.
 * @path /shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId
 * @accessor api.functional.shoppingMall.admin.orderPaymentMethods.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) of the target order payment method record to
     * be retrieved.
     */
    orderPaymentMethodId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrderPaymentMethod;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orderPaymentMethods/${encodeURIComponent(props.orderPaymentMethodId ?? "null")}`;
  export const random = (): IShoppingMallOrderPaymentMethod =>
    typia.random<IShoppingMallOrderPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderPaymentMethodId")(() =>
        typia.assert(props.orderPaymentMethodId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing order payment method snapshot
 * (shopping_mall_order_payment_methods).
 *
 * This API operation allows updating of a previously captured payment method
 * snapshot for a specific order. The update is referenced by the unique
 * orderPaymentMethodId path parameter, which corresponds to a record in
 * shopping_mall_order_payment_methods.
 *
 * The operation replaces (or amends) the type, data, or display-friendly label
 * for the payment method, which may be required if administrative corrections
 * are needed after order placement, or if UI reconciliation data needs to be
 * adjusted for audit or compliance.
 *
 * Security considerations ensure that only admin users or privileged internal
 * systems have access to this endpoint. The update strictly affects only the
 * snapshot record—no changes are made to actual payment tokens or live
 * third-party details. The response returns the complete, updated payment
 * method snapshot record for further use. Input errors (such as an invalid ID,
 * missing fields, or schema violations) are handled with clear, actionable
 * error messages. Related APIs include the creation and retrieval of order
 * payment method snapshots for audit and reconciliation flows.
 *
 * @param props.connection
 * @param props.orderPaymentMethodId Unique identifier of the payment method
 *   snapshot to update.
 * @param props.body Updated data for the order payment method snapshot,
 *   including method type, method data, and display name.
 * @path /shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId
 * @accessor api.functional.shoppingMall.admin.orderPaymentMethods.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the payment method snapshot to update. */
    orderPaymentMethodId: string & tags.Format<"uuid">;

    /**
     * Updated data for the order payment method snapshot, including method
     * type, method data, and display name.
     */
    body: IShoppingMallOrderPaymentMethod.IUpdate;
  };
  export type Body = IShoppingMallOrderPaymentMethod.IUpdate;
  export type Response = IShoppingMallOrderPaymentMethod;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orderPaymentMethods/${encodeURIComponent(props.orderPaymentMethodId ?? "null")}`;
  export const random = (): IShoppingMallOrderPaymentMethod =>
    typia.random<IShoppingMallOrderPaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderPaymentMethodId")(() =>
        typia.assert(props.orderPaymentMethodId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific order payment method snapshot by its ID
 * (shopping_mall_order_payment_methods table).
 *
 * Permanently remove a single order payment method snapshot record by
 * specifying its unique identifier. This table stores the historical payment
 * method data associated with an order at the time of order placement, so
 * erasing a record should only be done in exceptional circumstances—such as
 * regulatory compliance, error correction, or full order removal by platform
 * administration.
 *
 * Only system administrators with the highest privileges are permitted to
 * execute this operation. Before executing, the system must validate that the
 * order payment method is not referenced by any active orders or payment
 * records, as required by foreign key constraints to maintain referential
 * integrity.
 *
 * This is a hard delete operation: the target payment method record will be
 * entirely deleted from the shopping_mall_order_payment_methods table and
 * cannot be recovered. Careful event logging and audit trails must be
 * maintained to ensure compliance and transparency in all administrative data
 * deletion.
 *
 * Related APIs include order payment method retrieval, order viewing, and any
 * administrative audit logging endpoints. Any deletion errors, such as
 * constraint violations, should be reported with actionable error messages and
 * administrative notifications.
 *
 * @param props.connection
 * @param props.orderPaymentMethodId Unique identifier of the order payment
 *   method record to be permanently deleted
 * @path /shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId
 * @accessor api.functional.shoppingMall.admin.orderPaymentMethods.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the order payment method record to be
     * permanently deleted
     */
    orderPaymentMethodId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/orderPaymentMethods/:orderPaymentMethodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orderPaymentMethods/${encodeURIComponent(props.orderPaymentMethodId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderPaymentMethodId")(() =>
        typia.assert(props.orderPaymentMethodId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
