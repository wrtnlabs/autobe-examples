import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrderItem } from "../../../../../structures/IShoppingMallOrderItem";
import { IPageIShoppingMallOrderItem } from "../../../../../structures/IPageIShoppingMallOrderItem";

/**
 * Add a new item (SKU) to an existing e-commerce order
 * (shopping_mall_order_items table).
 *
 * Adds a new item (SKU) to an existing order by creating an order item record
 * and associating it with the parent order. This is not a standard
 * customer-facing API, but is used in exceptional business situations, such as
 * admin intervention or pre-shipment order modifications, where an additional
 * item must be included before fulfillment.
 *
 * Security is paramount—only admins should be authorized to perform this
 * action, and changes must be tracked in audit trails. This endpoint should
 * only permit adding items to orders in 'pending' or 'processing' status;
 * fulfilled or cancelled orders are locked against modifications. Before
 * adding, SKU existence and inventory sufficiency are validated, and duplicate
 * SKUs in the same order are rejected. Business rules in the schema—such as
 * ensuring one line item per unique SKU per order—are strictly enforced.
 *
 * If the specified SKU does not exist, is not available, or insufficient
 * inventory remains, the operation returns a business error and no item is
 * added. Successful additions automatically update the order's financial totals
 * and shipment plans, and a corresponding audit log entry is created for
 * compliance. The operation's request and response strictly mirror the schema
 * fields, and any related updates to parent records (order summary, audit logs)
 * are handled atomically. Related endpoints may include order modification,
 * cancellation, and status history APIs.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to which a new item is
 *   being added.
 * @param props.body Details for the new order item to be added, including SKU,
 *   qty, price, and related fields.
 * @path /shoppingMall/admin/orders/:orderId/items
 * @accessor api.functional.shoppingMall.admin.orders.items.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the order to which a new item is being added. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Details for the new order item to be added, including SKU, qty,
     * price, and related fields.
     */
    body: IShoppingMallOrderItem.ICreate;
  };
  export type Body = IShoppingMallOrderItem.ICreate;
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/orders/:orderId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve and filter the list of items for a specific order from
 * shoppingMall_orders.
 *
 * Retrieve a detailed list of all itemized SKUs included in a specific order.
 * This includes information such as item name, SKU code, quantity, unit price,
 * total price, currency, and item-specific refund or cancellation statuses.
 *
 * The endpoint supports filtering and pagination to efficiently review orders
 * with many line items. Sensitive fields and access are scoped according to
 * user roles: customers can view their own orders, sellers can view items from
 * orders they are responsible for, and admins can view all items. Security
 * checks enforce access control to ensure only authorized users access the
 * order's item details.
 *
 * Built upon the shopping_mall_order_items table, joined to
 * shopping_mall_orders for permission enforcement, this operation enables
 * robust audit and accountability for inventory, fulfillment, returns, and
 * analytics across roles. Validation ensures the order exists and the user role
 * is permitted to view items for this order, and errors are returned if the
 * order is invalid or access is denied.
 *
 * This operation is commonly paired with order detail retrieval, item-level
 * refund initiation endpoints, and shipment tracking features for high-fidelity
 * order monitoring by both buyers and sellers.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order whose items will be
 *   listed.
 * @param props.body Request parameters for filtering and paginating the list of
 *   items within the specified order.
 * @path /shoppingMall/admin/orders/:orderId/items
 * @accessor api.functional.shoppingMall.admin.orders.items.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the order whose items will be listed. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Request parameters for filtering and paginating the list of items
     * within the specified order.
     */
    body: IShoppingMallOrderItem.IRequest;
  };
  export type Body = IShoppingMallOrderItem.IRequest;
  export type Response = IPageIShoppingMallOrderItem.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orders/:orderId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallOrderItem.ISummary =>
    typia.random<IPageIShoppingMallOrderItem.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details of a single order item (line SKU) by itemId and
 * orderId.
 *
 * Fetch the full detail of a single order item (SKU line) belonging to the
 * specified order. The operation returns key attributes: item display name, SKU
 * code, purchased quantity, unit price, total price, currency, and current
 * refund or cancellation state for the line item.
 *
 * Access to this endpoint is controlled so only the customer who placed the
 * order, the seller responsible for the SKU, or an admin can view the item
 * details. Security validation ensures neither sensitive nor unrelated line
 * items are exposed to unauthorized actors.
 *
 * The implementation relies on the shopping_mall_order_items table and
 * validates the provided identifiers (orderId, itemId) exist and match
 * permission scopes. If the item or order is not found, or access is denied,
 * standard error responses are triggered.
 *
 * This endpoint is useful for item-level customer service (refunds,
 * cancellations), warehouse or shipping review, and detailed
 * analytical/reporting use cases.
 *
 * @param props.connection
 * @param props.orderId Unique order identifier containing the item.
 * @param props.itemId Unique identifier of the specific order item (SKU line)
 *   to retrieve.
 * @path /shoppingMall/admin/orders/:orderId/items/:itemId
 * @accessor api.functional.shoppingMall.admin.orders.items.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique order identifier containing the item. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific order item (SKU line) to retrieve. */
    itemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing order item (line) for a given order
 * (shopping_mall_order_items table).
 *
 * Modifies the details (e.g., quantity, price) of a specific order item within
 * an order prior to fulfillment. This is used in support situations or admin
 * workflows, not for regular customer modification.
 *
 * Security enforcement restricts access to authorized administrators. The
 * operation first checks that both order and order item exist and are not
 * locked by fulfillment, refund, or cancellation status. If the order item has
 * already been shipped, refunded, or cancelled, no updates are permitted.
 * Quantity must be positive and not exceed available SKU stock; price changes
 * must comply with business rules and pricing constraints for the order. Any
 * update recalculates order summaries and triggers audit trail records.
 *
 * Error scenarios include requests for non-existent order/items, attempts to
 * change items in locked orders, or violations of business validation rules.
 * Success returns the updated, fully detailed item record after changes.
 * Related operations include adding/removing order items, order cancellation,
 * and status history tracking APIs.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the parent order for the order
 *   item.
 * @param props.itemId Unique identifier of the order item being updated.
 * @param props.body Updated values for the order item, such as quantity or
 *   price, as defined by the order item's updatable schema fields.
 * @path /shoppingMall/admin/orders/:orderId/items/:itemId
 * @accessor api.functional.shoppingMall.admin.orders.items.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the parent order for the order item. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the order item being updated. */
    itemId: string & tags.Format<"uuid">;

    /**
     * Updated values for the order item, such as quantity or price, as
     * defined by the order item's updatable schema fields.
     */
    body: IShoppingMallOrderItem.IUpdate;
  };
  export type Body = IShoppingMallOrderItem.IUpdate;
  export type Response = IShoppingMallOrderItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/orders/:orderId/items/:itemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): IShoppingMallOrderItem =>
    typia.random<IShoppingMallOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific item from an order (shopping_mall_order_items table).
 *
 * Delete an item from a specific order using its unique order ID and item ID.
 * This operation targets the shopping_mall_order_items table and ensures that
 * only items actually included in the given order may be removed, complying
 * with all referential and business integrity rules. The main use cases include
 * customer-requested cancellations prior to shipment, administrative
 * corrections, or seller-directed modifications before fulfillment.
 *
 * Authorization is strictly enforced: customers can only modify their own
 * orders and only under certain states (e.g., pending, processing). Sellers can
 * act on their own products before shipment, and admins have full override
 * capability in accordance with business policies. Each attempted deletion
 * checks item/order status for eligibility, blocks removal if the item is
 * already shipped, delivered, refunded, or under dispute, and provides a
 * suitable error if the operation cannot proceed.
 *
 * Related updates such as refund of reserved funds, adjustment of inventory,
 * and timeline notifications are triggered as per business rules. This
 * operation links to core flows documented in order management, cancellation,
 * refund, and customer service requirements, and should be coordinated with
 * those API calls where intricate business processes are involved.
 *
 * Error cases are handled with explicit status returns, such as 'not found',
 * 'unauthorized', 'item not removable', or 'order ineligible for
 * modification'.
 *
 * @param props.connection
 * @param props.orderId ID of the target order containing the item to be
 *   deleted.
 * @param props.itemId ID of the order item (order item record) to be deleted.
 * @path /shoppingMall/admin/orders/:orderId/items/:itemId
 * @accessor api.functional.shoppingMall.admin.orders.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the target order containing the item to be deleted. */
    orderId: string & tags.Format<"uuid">;

    /** ID of the order item (order item record) to be deleted. */
    itemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
