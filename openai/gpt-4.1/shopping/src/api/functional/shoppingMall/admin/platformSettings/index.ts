import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallPlatformSettings } from "../../../../structures/IShoppingMallPlatformSettings";
import { IShoppingMallPlatformSetting } from "../../../../structures/IShoppingMallPlatformSetting";
import { IPageIShoppingMallPlatformSetting } from "../../../../structures/IPageIShoppingMallPlatformSetting";

/**
 * Create new e-commerce platform-wide settings
 * (shopping_mall_platform_settings).
 *
 * Create a new set of site-wide platform settings for the e-commerce shopping
 * mall. Administrators use this endpoint to specify information such as
 * localized site titles and descriptions, support contact details, branding
 * assets (logo URI), and legal document links (privacy policy and terms of
 * service URIs).
 *
 * This operation is restricted to admin users to maintain security and
 * compliance. The platform settings table is intended for infrequent updates by
 * authorized operators, as changes propagate immediately to UI and SEO/metadata
 * references across the platform.
 *
 * Care is required to ensure that provided URIs and contact information meet
 * business policy and legal requirements. All fields must be filled according
 * to platform standards described in business requirements. Error handling must
 * guard against duplicate settings or attempts to create more than one active
 * configuration when the table is intended as a singleton.
 *
 * @param props.connection
 * @param props.body Payload for new platform settings creation, including site
 *   titles, descriptions, contact, branding, and policy URIs.
 * @path /shoppingMall/admin/platformSettings
 * @accessor api.functional.shoppingMall.admin.platformSettings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Payload for new platform settings creation, including site titles,
     * descriptions, contact, branding, and policy URIs.
     */
    body: IShoppingMallPlatformSettings.ICreate;
  };
  export type Body = IShoppingMallPlatformSettings.ICreate;
  export type Response = IShoppingMallPlatformSettings;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/platformSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/platformSettings";
  export const random = (): IShoppingMallPlatformSettings =>
    typia.random<IShoppingMallPlatformSettings>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated and filterable list of shopping mall platform settings
 * from shopping_mall_platform_settings.
 *
 * Retrieve a filtered and paginated list of platform settings used across the
 * shopping mall platform. This operation supports advanced search and sort
 * capabilities for administrators managing global system configuration,
 * SEO/branding details, legal reference URIs, and support information.
 * Administrators can filter by site title, status, or creation/update date, and
 * paginate results to efficiently review or update settings as needed.
 *
 * The operation enforces platform-wide administrative access control, ensuring
 * only authorized admins may view or modify platform-wide settings. This
 * endpoint interacts directly with the shopping_mall_platform_settings table,
 * referencing its schema comment and column definitions. The list may include
 * settings in both Korean and English localizations for full
 * internationalization support.
 *
 * Errors may be returned if access permissions are insufficient, filters are
 * malformed, or if there is an issue with platform settings retrieval from the
 * database. Related settings update and single-platform-setting retrieval
 * operations are typically used in conjunction with this endpoint.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination specifications for
 *   retrieving platform settings.
 * @path /shoppingMall/admin/platformSettings
 * @accessor api.functional.shoppingMall.admin.platformSettings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, search, and pagination specifications for retrieving platform
     * settings.
     */
    body: IShoppingMallPlatformSetting.IRequest;
  };
  export type Body = IShoppingMallPlatformSetting.IRequest;
  export type Response = IPageIShoppingMallPlatformSetting.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/platformSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/platformSettings";
  export const random = (): IPageIShoppingMallPlatformSetting.ISummary =>
    typia.random<IPageIShoppingMallPlatformSetting.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single shopping mall platform setting by ID from
 * shopping_mall_platform_settings.
 *
 * Retrieve the detailed information of a single platform setting record by its
 * unique platformSettingId. This operation is restricted to admin users and
 * includes all configuration and branding fields, such as Korean and English
 * site titles, descriptions, support contacts, logo/image URIs, and links to
 * privacy policy and terms of service documents as persisted in the
 * shopping_mall_platform_settings table.
 *
 * This endpoint allows administrative review and editing preparation for
 * settings, supports error feedback for request failures (e.g., not found,
 * unauthorized access), and integrates tightly with the platform's
 * configuration dashboard. Path parameter enforcement ensures that the provided
 * platformSettingId is a valid UUID matching an existing settings record.
 *
 * Detailed inspection of this record is typically used for further update or
 * administrative actions, and error handling covers missing, deleted, or
 * permission-denied records.
 *
 * @param props.connection
 * @param props.platformSettingId Unique identifier of the target platform
 *   setting (UUID).
 * @path /shoppingMall/admin/platformSettings/:platformSettingId
 * @accessor api.functional.shoppingMall.admin.platformSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target platform setting (UUID). */
    platformSettingId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallPlatformSetting;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/platformSettings/:platformSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/platformSettings/${encodeURIComponent(props.platformSettingId ?? "null")}`;
  export const random = (): IShoppingMallPlatformSetting =>
    typia.random<IShoppingMallPlatformSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("platformSettingId")(() =>
        typia.assert(props.platformSettingId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing e-commerce platform settings record
 * (shopping_mall_platform_settings) by ID.
 *
 * Update an existing platform-wide settings record, referenced by its unique
 * ID. This operation is restricted to admin users and is used to revise core
 * metadata for the entire site, including localized titles and descriptions,
 * customer support details, branding logos, and legal document links.
 *
 * Security is paramount; only properly authenticated admin users may perform
 * this action. The operation must validate the existence of the referenced
 * settings record, ensure appropriate formatting and completeness of updated
 * fields, and propagate updated settings to relevant caches and displays.
 *
 * Attempting to update a non-existent or deleted platform setting record must
 * result in a clear error response. Business logic must prevent unauthorized
 * changes and maintain detailed audit logs as per platform requirements.
 *
 * @param props.connection
 * @param props.platformSettingId Target platform settings record's unique ID
 *   (UUID) for update.
 * @param props.body Fields and values to update the platform settings record,
 *   including site titles, descriptions, support contacts, branding, and
 *   policies.
 * @path /shoppingMall/admin/platformSettings/:platformSettingId
 * @accessor api.functional.shoppingMall.admin.platformSettings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target platform settings record's unique ID (UUID) for update. */
    platformSettingId: string & tags.Format<"uuid">;

    /**
     * Fields and values to update the platform settings record, including
     * site titles, descriptions, support contacts, branding, and policies.
     */
    body: IShoppingMallPlatformSettings.IUpdate;
  };
  export type Body = IShoppingMallPlatformSettings.IUpdate;
  export type Response = IShoppingMallPlatformSettings;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/platformSettings/:platformSettingId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/platformSettings/${encodeURIComponent(props.platformSettingId ?? "null")}`;
  export const random = (): IShoppingMallPlatformSettings =>
    typia.random<IShoppingMallPlatformSettings>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("platformSettingId")(() =>
        typia.assert(props.platformSettingId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific platform-wide editable setting using its unique identifier
 * (soft delete if supported).
 *
 * This API operation allows a platform administrator to delete a global
 * platform setting entry identified by the specified 'platformSettingId'. These
 * settings manage editable site metadata including branding, descriptions,
 * support contacts, and legal policy URIs. When invoked, the system sets the
 * 'deleted_at' timestamp for a soft delete, preserving the historical data for
 * recovery and audit purposes.
 *
 * The operation checks the acting user's role to confirm they have 'admin'
 * privileges. It enforces that only precisely the record matching the provided
 * ID is affected. The response is empty on success. Audit trails of the action
 * are maintained through shopping_mall_admin_action_logs, linking the acting
 * admin and affected setting. All relevant caches are invalidated to prevent
 * stale UI or logic references to the deleted setting.
 *
 * The operation expects a valid UUID in the 'platformSettingId' path parameter.
 * If the specified ID does not exist or is already deleted, an explicit not
 * found or idempotency response is returned. Attempts by non-admin users are
 * denied with an error. Related API operations include creation and update
 * endpoints for platform settings management.
 *
 * @param props.connection
 * @param props.platformSettingId Unique identifier of the platform setting to
 *   delete.
 * @path /shoppingMall/admin/platformSettings/:platformSettingId
 * @accessor api.functional.shoppingMall.admin.platformSettings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the platform setting to delete. */
    platformSettingId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/platformSettings/:platformSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/platformSettings/${encodeURIComponent(props.platformSettingId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("platformSettingId")(() =>
        typia.assert(props.platformSettingId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
