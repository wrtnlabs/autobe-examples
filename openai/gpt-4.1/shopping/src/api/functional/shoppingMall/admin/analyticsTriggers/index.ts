import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAnalyticsTrigger } from "../../../../structures/IShoppingMallAnalyticsTrigger";
import { IPageIShoppingMallAnalyticsTrigger } from "../../../../structures/IPageIShoppingMallAnalyticsTrigger";

/**
 * Create a new analytics trigger configuration
 * (shopping_mall_analytics_triggers table).
 *
 * This API endpoint allows platform administrators to establish new analytics
 * triggers for the scheduled execution of platform analytics jobs, dashboard
 * report generation, or export jobs. According to the Prisma schema, each
 * trigger is stored in the shopping_mall_analytics_triggers table with fields
 * including trigger_type, schedule_config_json, status, and admin linkage.
 *
 * The operation requires all business and schedule parameters to be specified
 * in the request body. The trigger_type controls what type of analytics or data
 * export the job is. The schedule_config_json defines recurring schedule or
 * one-time execution, and status field sets the job as pending for future
 * execution by the analytics engine. Only administrative users (admins) have
 * authorization to create or manage platform triggers as defined by system
 * policy.
 *
 * All created analytics triggers can subsequently be managed or updated using
 * the corresponding update endpoints, and the platform will maintain a full
 * audit trail of all such jobs for compliance and diagnostic review. Proper
 * error responses are returned for invalid or incomplete configurations and for
 * any authorization failure.
 *
 * @param props.connection
 * @param props.body Properties and configuration data for creating a new
 *   analytics trigger.
 * @path /shoppingMall/admin/analyticsTriggers
 * @accessor api.functional.shoppingMall.admin.analyticsTriggers.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Properties and configuration data for creating a new analytics
     * trigger.
     */
    body: IShoppingMallAnalyticsTrigger.ICreate;
  };
  export type Body = IShoppingMallAnalyticsTrigger.ICreate;
  export type Response = IShoppingMallAnalyticsTrigger;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/analyticsTriggers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/analyticsTriggers";
  export const random = (): IShoppingMallAnalyticsTrigger =>
    typia.random<IShoppingMallAnalyticsTrigger>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated/filterable list of analytics triggers for the
 * shopping mall platform (shopping_mall_analytics_triggers table).
 *
 * Retrieve a filtered and paginated list of analytics triggers and scheduled
 * reporting jobs configured for the shoppingMall platform. The operation
 * enables authorized admins to explore all analytics triggers, including their
 * type (dashboard update, report export, data rebuild), status (pending,
 * running, success, failed, cancelled), scheduling configuration, admin
 * ownership, and outcome logs.
 *
 * This operation supports advanced searching via request body, including
 * filtering by status, trigger type, admin ID, date ranges, and additional
 * config properties. It is primarily intended for use in the admin dashboard as
 * part of analytics and platform diagnostics.
 *
 * The Prisma model shopping_mall_analytics_triggers includes all scheduled and
 * executed analytics trigger jobs, with references to scheduling admin,
 * schedule configuration, job status, outcome logs, timestamps, and deletion
 * status. Pagination, sorting, and filter validation are enforced at the API
 * and database level for security and performance.
 *
 * Only platform admins authorized for platform diagnostics and analytics
 * management may access this API. Role-based access control and search rate
 * limiting apply.
 *
 * Typical errors include invalid query parameters, insufficient permissions, or
 * database connectivity problems. The API returns paginated trigger summaries
 * along with total counts for result set navigation. This operation does NOT
 * manipulate or create analytics triggers, and only provides a read/search
 * interface.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination criteria for analytics
 *   trigger retrieval.
 * @path /shoppingMall/admin/analyticsTriggers
 * @accessor api.functional.shoppingMall.admin.analyticsTriggers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filtering, and pagination criteria for analytics trigger
     * retrieval.
     */
    body: IShoppingMallAnalyticsTrigger.IRequest;
  };
  export type Body = IShoppingMallAnalyticsTrigger.IRequest;
  export type Response = IPageIShoppingMallAnalyticsTrigger.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/analyticsTriggers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/analyticsTriggers";
  export const random = (): IPageIShoppingMallAnalyticsTrigger.ISummary =>
    typia.random<IPageIShoppingMallAnalyticsTrigger.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail for a specific shopping mall analytics trigger job by ID
 * (shopping_mall_analytics_triggers table).
 *
 * Fetch a detailed record for a single analytics trigger (scheduled reporting,
 * analytics, or dashboard update task) using its unique analyticsTriggerId. The
 * operation enables authorized platform admins to view full trigger details,
 * including trigger type, scheduling configuration, job status, run logs, admin
 * assignment, and timestamps.
 *
 * This operation corresponds to the shopping_mall_analytics_triggers table
 * within the Prisma schema and is essential for admin review, job diagnostics,
 * and platform monitoring in the admin dashboard.
 *
 * Permissions: Only authenticated platform admins with analytics management
 * rights may call this API. Ownership and platform security are strictly
 * enforced via role-based access control.
 *
 * Validation is performed on the provided analyticsTriggerId to ensure it is a
 * valid UUID and refers to an existing analytics trigger record. Typical error
 * cases include invalid analyticsTriggerId, insufficient privileges, or if the
 * record was soft deleted or purged from the database.
 *
 * @param props.connection
 * @param props.analyticsTriggerId Unique identifier (UUID) of the analytics
 *   trigger record to retrieve.
 * @path /shoppingMall/admin/analyticsTriggers/:analyticsTriggerId
 * @accessor api.functional.shoppingMall.admin.analyticsTriggers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the analytics trigger record to retrieve. */
    analyticsTriggerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAnalyticsTrigger;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/analyticsTriggers/:analyticsTriggerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/analyticsTriggers/${encodeURIComponent(props.analyticsTriggerId ?? "null")}`;
  export const random = (): IShoppingMallAnalyticsTrigger =>
    typia.random<IShoppingMallAnalyticsTrigger>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsTriggerId")(() =>
        typia.assert(props.analyticsTriggerId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing analytics trigger configuration
 * (shopping_mall_analytics_triggers table).
 *
 * This API endpoint allows platform administrators to update or modify an
 * existing analytics trigger definition, which schedules analytics reporting or
 * dashboard jobs for the shopping mall platform. The analytics triggers table
 * (shopping_mall_analytics_triggers) includes all configuration for recurring
 * or one-off jobs, including the trigger type (dashboard_update, report_export,
 * etc), schedule configuration, run status, and additional job metadata.
 *
 * The operation requires the unique analyticsTriggerId as a path parameter for
 * targeting the existing record, and a valid update configuration in the
 * request body. Only admins have permission to perform this operation, as it
 * affects platform-level analytics and reporting. All updates are recorded for
 * compliance and operational debugging, with the updated trigger configuration
 * being returned on success.
 *
 * Common use cases include changing the schedule of a dashboard refresh,
 * disabling/enabling analytics exports, or correcting configuration errors
 * before a job is due to run. Error responses cover invalid triggers,
 * authorization failures, and invalid data in payloads.
 *
 * @param props.connection
 * @param props.analyticsTriggerId Unique identifier (UUID) of the analytics
 *   trigger to update.
 * @param props.body Properties and configuration data for updating an analytics
 *   trigger.
 * @path /shoppingMall/admin/analyticsTriggers/:analyticsTriggerId
 * @accessor api.functional.shoppingMall.admin.analyticsTriggers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the analytics trigger to update. */
    analyticsTriggerId: string & tags.Format<"uuid">;

    /** Properties and configuration data for updating an analytics trigger. */
    body: IShoppingMallAnalyticsTrigger.IUpdate;
  };
  export type Body = IShoppingMallAnalyticsTrigger.IUpdate;
  export type Response = IShoppingMallAnalyticsTrigger;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/analyticsTriggers/:analyticsTriggerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/analyticsTriggers/${encodeURIComponent(props.analyticsTriggerId ?? "null")}`;
  export const random = (): IShoppingMallAnalyticsTrigger =>
    typia.random<IShoppingMallAnalyticsTrigger>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsTriggerId")(() =>
        typia.assert(props.analyticsTriggerId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently erase an analytics trigger from the
 * shopping_mall_analytics_triggers table by ID.
 *
 * This operation permanently deletes an analytics trigger identified by
 * analyticsTriggerId from the shopping_mall_analytics_triggers table. The
 * analytics triggers table stores details about scheduled or executed platform
 * analytics/report jobs, including scheduling configuration, status, and
 * outcome logs.
 *
 * This API is designed for administrative use and access is restricted to users
 * with the 'admin' role. Erased analytics triggers are removed from the system
 * and cannot be recovered. The deletion is logged in the
 * shopping_mall_admin_action_logs table for audit trail and compliance.
 * Triggers that are pending, running, or failed will also be removed and will
 * not run in the future. After deletion, any references to the erased trigger
 * should be cleaned from dependent systems or UIs.
 *
 * Status and error handling follow standard platform patterns: if the specified
 * analyticsTriggerId does not exist, a clear error is returned. The operation
 * performs a hard delete because there is a deleted_at field for soft deletion,
 * but erase is designed for permanent removal only available to admins, and
 * deleted triggers will not appear in future queries.
 *
 * @param props.connection
 * @param props.analyticsTriggerId Unique identifier for the analytics trigger
 *   to permanently erase.
 * @path /shoppingMall/admin/analyticsTriggers/:analyticsTriggerId
 * @accessor api.functional.shoppingMall.admin.analyticsTriggers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the analytics trigger to permanently erase. */
    analyticsTriggerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/analyticsTriggers/:analyticsTriggerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/analyticsTriggers/${encodeURIComponent(props.analyticsTriggerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("analyticsTriggerId")(() =>
        typia.assert(props.analyticsTriggerId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
