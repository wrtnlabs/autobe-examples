import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdminAuditLog } from "../../../../structures/IShoppingMallAdminAuditLog";
import { IPageIShoppingMallAdminAuditLog } from "../../../../structures/IPageIShoppingMallAdminAuditLog";
import { IShoppingMallAdminActionLog } from "../../../../structures/IShoppingMallAdminActionLog";

/**
 * Create a new admin audit log entry (shopping_mall_admin_audit_logs table).
 *
 * This endpoint allows the explicit insertion of a new admin audit log record
 * into the shopping_mall_admin_audit_logs table. The primary use case is for
 * platform internal systems, background jobs, or integrations that must create
 * their own audit records as part of business-critical or compliance workflows.
 * While admin audit logs are usually produced automatically by sensitive
 * operations (such as changing user permissions, deleting products, or
 * modifying configuration), the API permits direct creation when needed.
 *
 * All required fields, such as the acting admin's ID, action type, action
 * reason, affected entity IDs (customer, seller, product, order, or review as
 * applicable), domain, and timestamp, must be provided. Default values are not
 * assumed for critical fields. Only system-level admin or internal service
 * accounts should have access to this endpoint. Audit log creation should be
 * validated for completeness and correctness, ensuring referential integrity to
 * affected entities where relevant.
 *
 * Related API operations include retrieval of admin audit logs for governance
 * or review, and listing/filtering across audit log records for incident
 * response. If required fields are missing, malformed, or referential integrity
 * cannot be verified, the system returns appropriate validation errors. Logical
 * deletion is not supported for these records, per audit trail governance
 * rules.
 *
 * @param props.connection
 * @param props.body Information for creating a new admin audit log entry,
 *   including all mandatory attributes as specified by the
 *   shopping_mall_admin_audit_logs schema.
 * @path /shoppingMall/admin/adminAuditLogs
 * @accessor api.functional.shoppingMall.admin.adminAuditLogs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information for creating a new admin audit log entry, including all
     * mandatory attributes as specified by the
     * shopping_mall_admin_audit_logs schema.
     */
    body: IShoppingMallAdminAuditLog.ICreate;
  };
  export type Body = IShoppingMallAdminAuditLog.ICreate;
  export type Response = IShoppingMallAdminAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/adminAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/adminAuditLogs";
  export const random = (): IShoppingMallAdminAuditLog =>
    typia.random<IShoppingMallAdminAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of admin audit logs from
 * shopping_mall_admin_audit_logs table.
 *
 * This PATCH operation enables authorized platform administrators to search,
 * filter, and retrieve historical audit log entries related to all critical
 * administrative actions, including logins, permission changes, settings
 * modifications, and system activities. Each log in
 * shopping_mall_admin_audit_logs contains the acting admin ID, audit event
 * type, domain, serialised event context, log level, and timestamp.
 *
 * The request body uses a standardized search DTO for flexible filtering,
 * supporting criteria such as admin identifier, event type, domain, log level,
 * time range, and keyword full text queries. Pagination controls (page,
 * pageSize) are also provided in the request body to support efficient
 * navigation through high-volume data. Sorting options should be accepted
 * (e.g., by created_at descending for most recent activity first).
 *
 * Important security controls are in place to ensure only authorized admins can
 * access this audit history. The operation may exclude sensitive event context
 * fields based on the requesting adminâ€™s permissions. Error cases such as
 * invalid search criteria, lack of results, or permission denials should be
 * clearly reported.
 *
 * The response returns a paginated list of matching audit log summary records,
 * with metadata about pagination, total results, and applied filters for UI
 * display and export.
 *
 * @param props.connection
 * @param props.body Criteria, filters, and pagination parameters for searching
 *   admin audit logs.
 * @path /shoppingMall/admin/adminAuditLogs
 * @accessor api.functional.shoppingMall.admin.adminAuditLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Criteria, filters, and pagination parameters for searching admin
     * audit logs.
     */
    body: IShoppingMallAdminAuditLog.IRequest;
  };
  export type Body = IShoppingMallAdminAuditLog.IRequest;
  export type Response = IPageIShoppingMallAdminAuditLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/adminAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/adminAuditLogs";
  export const random = (): IPageIShoppingMallAdminAuditLog.ISummary =>
    typia.random<IPageIShoppingMallAdminAuditLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single admin audit log by unique identifier
 * (shopping_mall_admin_audit_logs table).
 *
 * This endpoint retrieves the full set of data for a single admin audit log
 * entry from the shopping_mall_admin_audit_logs table in the e-commerce
 * platform's database. The admin audit log table tracks all critical
 * platform-wide administrative actions and events, including logins, permission
 * changes, system settings modifications, and explicit admin actions that are
 * relevant for compliance and legal review.
 *
 * Authorization is typically restricted to high-privilege admin users, as audit
 * logs may contain sensitive platform or user information. Requesters must have
 * system-level admin privileges or equivalent secure credentials. The endpoint
 * expects the adminAuditLogId, which should be a valid UUID, as a path
 * parameter. On success, the system returns all log details including acting
 * admin identity, event type, event context, associated domain, log level, and
 * timestamp data.
 *
 * This API is closely related to general auditing, admin action log review, and
 * security incident response workflows. Error scenarios include invalid/missing
 * UUID or unauthorized access attempts, for which suitable error messages
 * should be returned. No Personally Identifiable Information (PII) is exposed
 * except as required in the audit context, and only to properly authorized
 * requesters.
 *
 * @param props.connection
 * @param props.adminAuditLogId Unique identifier of the targeted admin audit
 *   log entry.
 * @path /shoppingMall/admin/adminAuditLogs/:adminAuditLogId
 * @accessor api.functional.shoppingMall.admin.adminAuditLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the targeted admin audit log entry. */
    adminAuditLogId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdminAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/adminAuditLogs/:adminAuditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/adminAuditLogs/${encodeURIComponent(props.adminAuditLogId ?? "null")}`;
  export const random = (): IShoppingMallAdminAuditLog =>
    typia.random<IShoppingMallAdminAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminAuditLogId")(() =>
        typia.assert(props.adminAuditLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific admin audit log entry in the admin action log table.
 *
 * This API endpoint enables updating of a specific admin audit log entry in
 * shopping mall admin log records. Administrators may modify the action type,
 * action reason, domain, or JSON context for the log. The operation is
 * restricted to administrators; all changes are tracked with timestamps for
 * history and compliance review.
 *
 * The admin audit log is used for platform-wide administrative action recording
 * such as approvals, rejections, bans, restoration actions, and compliance
 * logs. Updates to log entries are permitted to correct or annotate previous
 * actions, but all original data is maintained for audit trail purposes.
 *
 * Error cases include missing log entry for the specified adminAuditLogId or
 * attempts to update with invalid data (such as violating unique constraints or
 * schema validations). Appropriate error messages are returned on validation
 * failure or unauthorized access attempts.
 *
 * @param props.connection
 * @param props.adminAuditLogId The unique identifier of the admin audit log
 *   entry to update.
 * @param props.body The information to update on the admin audit log entry.
 * @path /shoppingMall/admin/adminAuditLogs/:adminAuditLogId
 * @accessor api.functional.shoppingMall.admin.adminAuditLogs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the admin audit log entry to update. */
    adminAuditLogId: string & tags.Format<"uuid">;

    /** The information to update on the admin audit log entry. */
    body: IShoppingMallAdminActionLog.IUpdate;
  };
  export type Body = IShoppingMallAdminActionLog.IUpdate;
  export type Response = IShoppingMallAdminActionLog;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/adminAuditLogs/:adminAuditLogId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/adminAuditLogs/${encodeURIComponent(props.adminAuditLogId ?? "null")}`;
  export const random = (): IShoppingMallAdminActionLog =>
    typia.random<IShoppingMallAdminActionLog>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminAuditLogId")(() =>
        typia.assert(props.adminAuditLogId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a specific admin audit log entry from the system.
 *
 * This API endpoint irreversibly deletes an admin audit log entry as identified
 * by its adminAuditLogId field. Only administrators with adequate permissions
 * can access this operation; the action removes the record directly from the
 * shopping_mall_admin_action_logs table.
 *
 * Once executed, this operation permanently erases the log entry and all
 * associated data. The deletion is immediate and cannot be undone; as the admin
 * audit log table does not retain a soft deletion marker for erased entries,
 * the record will no longer appear in audit trails or compliance reports.
 *
 * Permission to perform deletion is limited to platform administrators to
 * ensure both operational security and data retention compliance. Normal error
 * handling applies for attempts to remove entries that do not exist or when the
 * user lacks required authorization.
 *
 * @param props.connection
 * @param props.adminAuditLogId The unique identifier of the admin audit log
 *   entry to delete.
 * @path /shoppingMall/admin/adminAuditLogs/:adminAuditLogId
 * @accessor api.functional.shoppingMall.admin.adminAuditLogs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the admin audit log entry to delete. */
    adminAuditLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/adminAuditLogs/:adminAuditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/adminAuditLogs/${encodeURIComponent(props.adminAuditLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminAuditLogId")(() =>
        typia.assert(props.adminAuditLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
