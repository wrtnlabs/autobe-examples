import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdmin } from "../../../../structures/IShoppingMallAdmin";
import { IPageIShoppingMallAdmin } from "../../../../structures/IPageIShoppingMallAdmin";

/**
 * List and search shopping_mall_admins with filtering and pagination for
 * dashboard monitoring.
 *
 * This API operation allows platform-level administrators to retrieve a list of
 * all admin user accounts, with advanced filtering and pagination support.
 * Operating on the shopping_mall_admins entity, it is intended for
 * administrative dashboard tooling and compliance reporting, not general user
 * or seller access. The operation supports powerful search capabilities over
 * fields such as account status, admin name, and account creation date,
 * enabling the supervision of multiple admin accounts across the platform.
 *
 * Returned results exclude sensitive information such as password hashes,
 * two-factor secrets, and other confidential fields to ensure compliance with
 * security best practices. The implementation is required to audit all access
 * to this endpoint for compliance purposes. Only users with the admin role are
 * permitted to use this endpoint; all other users must receive a clear
 * unauthorized error response. This endpoint is foundational for operational
 * security and audit oversight in the shoppingMall system.
 *
 * @param props.connection
 * @param props.body Filter criteria and pagination options for searching admin
 *   users.
 * @path /shoppingMall/admin/admins
 * @accessor api.functional.shoppingMall.admin.admins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter criteria and pagination options for searching admin users. */
    body: IShoppingMallAdmin.IRequest;
  };
  export type Body = IShoppingMallAdmin.IRequest;
  export type Response = IPageIShoppingMallAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/admins";
  export const random = (): IPageIShoppingMallAdmin.ISummary =>
    typia.random<IPageIShoppingMallAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the full detail for a given administrator (shopping_mall_admins) by
 * adminId.
 *
 * This API operation returns detailed information about the administrator
 * account identified by the adminId parameter. Its core function is to provide
 * full visibility into the selected admin's core profile fields (such as email,
 * full name, status, 2FA setup) and critical audit timestamps. It incorporates
 * all security attributes, including account status (active, disabled,
 * suspended), email address, last login timestamp, and optional two-factor
 * authentication secret.
 *
 * Security considerations are critical. This endpoint should be restricted
 * strictly to users with appropriate admin privileges, require authentication,
 * and never expose the password hash to client-side consumers. Relationship to
 * underlying database is one-to-one with the shopping_mall_admins schema table,
 * guaranteeing synchronous reflection of all profile and audit changes.
 *
 * Any attempt to access a non-existent or logically deleted administrator
 * should result in a clear not-found error. The operation supports integration
 * with admin audit or action log views. Related endpoints include update,
 * erase, or authentication operations for administrator accounts. Output never
 * includes related logs or tokensâ€”only core admin table columns. Error handling
 * ensures proper messaging for authorization failures or invalid admin IDs.
 *
 * @param props.connection
 * @param props.adminId Unique identifier for the target administrator
 *   (shopping_mall_admins.id).
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the target administrator
     * (shopping_mall_admins.id).
     */
    adminId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdmin;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IShoppingMallAdmin =>
    typia.random<IShoppingMallAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update administrator profile and security attributes by adminId
 * (shopping_mall_admins).
 *
 * This API operation allows authorized admin users to modify the attributes of
 * an existing administrator account, identified by adminId. Updatable fields
 * may include full name, account status (active, suspended, disabled), email
 * address, and two-factor authentication settings, while the password is
 * typically managed through a separate reset/change flow.
 *
 * Security is paramount: only users with verified admin role can update admin
 * accounts, and audit trails must be written for every update for compliance
 * with platform requirements. Validations are enforced to prevent duplicate
 * emails, improper status transitions, or loss of audit data. The
 * shopping_mall_admins model is updated atomically, with timestamp columns
 * updated according to business logic.
 *
 * Upon successful update, the operation returns the newly updated administrator
 * entity as a response. Errors are handled elegantly with messages for not
 * found, duplicate, or invalid input. This operation is closely related to
 * admin creation, deletion, and detail/retrieve operations, and strongly relies
 * on the Prisma schema comments for administrative security logic.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin to be updated
 *   (shopping_mall_admins.id).
 * @param props.body Administrator update fields for profile, status, email, or
 *   2FA. See IShoppingMallAdmin.IUpdate for permitted properties.
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the admin to be updated
     * (shopping_mall_admins.id).
     */
    adminId: string & tags.Format<"uuid">;

    /**
     * Administrator update fields for profile, status, email, or 2FA. See
     * IShoppingMallAdmin.IUpdate for permitted properties.
     */
    body: IShoppingMallAdmin.IUpdate;
  };
  export type Body = IShoppingMallAdmin.IUpdate;
  export type Response = IShoppingMallAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/admins/:adminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): IShoppingMallAdmin =>
    typia.random<IShoppingMallAdmin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a system admin account (shopping_mall_admins table) by ID.
 *
 * This API operation is used to permanently remove an administrator account
 * from the system. It references the shopping_mall_admins table in the Prisma
 * schema, deleting the account and all associated authentication information,
 * two-factor secrets, and audit references.
 *
 * This action can only be performed by a user with sufficient privileges (e.g.,
 * super-admin or system operator) and is restricted to scenarios where account
 * removal is necessary for compliance, offboarding, or platform security.
 *
 * Upon execution, the admin record is fully removed from the database rather
 * than being soft-deleted, as the deleted_at column will be set if logical
 * deletion is implemented, but if hard delete is specified, the record is
 * physically removed and cannot be restored. Related logs or entities
 * referencing the removed admin remain for audit trail integrity, but this user
 * will lose all access rights immediately.
 *
 * Appropriate role checks and operation blocking are enforced at the business
 * logic level to prevent accidental or unauthorized deletions. Any failed
 * attempts (e.g., due to lack of permission or invalid adminId) return clear
 * error messages for troubleshooting.
 *
 * Operation is expected to return no response body. Errors are handled per
 * platform conventions for authorization/validation failures.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the administrator account to
 *   permanently delete (shopping_mall_admins.id)
 * @path /shoppingMall/admin/admins/:adminId
 * @accessor api.functional.shoppingMall.admin.admins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the administrator account to permanently delete
     * (shopping_mall_admins.id)
     */
    adminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
