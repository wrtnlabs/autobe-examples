import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallNotificationJob } from "../../../../structures/IShoppingMallNotificationJob";

/**
 * Get detailed information for a scheduled or executed notification job by job
 * ID (shopping_mall_notification_jobs).
 *
 * Retrieve and display full details of a single notification job by its unique
 * identifier. The response includes all configuration parameters, notification
 * type (email, push, etc.), job status, all targeting information, configured
 * templates, result status for each recipient or group, error logs, and related
 * audit data relevant to platform administrators. This enables the admin to
 * audit notification effectiveness, trace communication deliveries, and review
 * any failures or partial successes.
 *
 * Security: Only users with the 'admin' role are permitted to access this
 * endpoint. Access is strictly logged and sensitive details such as recipient
 * lists are provided only to authenticated admins.
 *
 * The operation integrates directly with the shopping_mall_notification_jobs
 * table, referencing fields such as job_type, job_status, target_json,
 * config_json, and result_json. The endpoint must enforce strict access
 * controls to prevent unauthorized data leaks. If the specified notification
 * job does not exist or has been deleted, an appropriate error and record of
 * access attempt must be logged in admin action log.
 *
 * Related operations include listing/searching past notification jobs and
 * creating new jobs, which admins can use to analyze past campaigns or to rerun
 * failed communication tasks.
 *
 * @param props.connection
 * @param props.notificationJobId Unique identifier (UUID) of the notification
 *   job to retrieve.
 * @path /shoppingMall/admin/notificationJobs/:notificationJobId
 * @accessor api.functional.shoppingMall.admin.notificationJobs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the notification job to retrieve. */
    notificationJobId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallNotificationJob;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/notificationJobs/:notificationJobId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/notificationJobs/${encodeURIComponent(props.notificationJobId ?? "null")}`;
  export const random = (): IShoppingMallNotificationJob =>
    typia.random<IShoppingMallNotificationJob>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationJobId")(() =>
        typia.assert(props.notificationJobId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a scheduled notification job (shopping_mall_notification_jobs table)
 * by ID as admin.
 *
 * Update a platform notification job's configuration, targeting, status, or
 * results within the shopping_mall_notification_jobs table. Typical usages
 * include adjusting targeting for scheduled platforms notifications, modifying
 * delivery configuration, or updating status (e.g., retry, cancel, mark as
 * failed/success). Admin control is required—only platform administrators can
 * perform updates.
 *
 * Audit logging is enforced for all edits, supporting compliance and
 * investigations. Edits should only occur when job status allows (not already
 * deleted or in a terminal state like 'success' or 'failed'), and downstream
 * notification systems must be updated accordingly. Errors such as attempting
 * to update a finalized or deleted job return clear error statuses and reasons.
 * This corresponds to business requirements for platform-wide notification
 * management, status tracking, and reliability/recovery. Soft delete is
 * available (deleted_at).
 *
 * @param props.connection
 * @param props.notificationJobId Unique identifier of the notification job to
 *   update.
 * @param props.body Update object for notification job (configuration, status,
 *   targeting, or results).
 * @path /shoppingMall/admin/notificationJobs/:notificationJobId
 * @accessor api.functional.shoppingMall.admin.notificationJobs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the notification job to update. */
    notificationJobId: string & tags.Format<"uuid">;

    /**
     * Update object for notification job (configuration, status, targeting,
     * or results).
     */
    body: IShoppingMallNotificationJob.IUpdate;
  };
  export type Body = IShoppingMallNotificationJob.IUpdate;
  export type Response = IShoppingMallNotificationJob;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/notificationJobs/:notificationJobId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/notificationJobs/${encodeURIComponent(props.notificationJobId ?? "null")}`;
  export const random = (): IShoppingMallNotificationJob =>
    typia.random<IShoppingMallNotificationJob>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationJobId")(() =>
        typia.assert(props.notificationJobId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a notification job by ID (shopping_mall_notification_jobs table,
 * admin only).
 *
 * Soft-delete a notification job by ID, marking the deleted_at field on the
 * shopping_mall_notification_jobs row rather than removing the record. This
 * aligns with audit, compliance, and operational retention requirements—deleted
 * jobs are retained for investigation and reporting, but are excluded from
 * operational display and cannot be executed or updated further.
 *
 * The operation is only available to platform administrators, and all actions
 * are logged as admin events for future auditability. If the target
 * notification job does not exist or is already deleted, the operation returns
 * a clear error message. This matches regulatory and business requirements for
 * notification/event/job management across the admin dashboard and reporting
 * tools.
 *
 * @param props.connection
 * @param props.notificationJobId Unique identifier of the notification job to
 *   delete (soft-delete).
 * @path /shoppingMall/admin/notificationJobs/:notificationJobId
 * @accessor api.functional.shoppingMall.admin.notificationJobs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the notification job to delete (soft-delete). */
    notificationJobId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/notificationJobs/:notificationJobId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/notificationJobs/${encodeURIComponent(props.notificationJobId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationJobId")(() =>
        typia.assert(props.notificationJobId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create and schedule a new notification job for admin-initiated user, group,
 * or segment communication (shopping_mall_notification_jobs).
 *
 * Create and schedule a new notification job for bulk or targeted communication
 * from admins to platform users or groups. The API accepts a payload including
 * all job details: type (email, push, SMS, in-app), recipient targeting options
 * (user lists, groups, or segments encoded in JSON), configuration for content
 * templates, scheduling or immediate execution, and optional re-delivery/retry
 * instructions. Upon creation, the job status is set to pending or running
 * depending on execution time, and the job is visible in the admin dashboard
 * for status, progress, and delivery outcome monitoring.
 *
 * Security: Only authenticated admins are permitted to create notification
 * jobs, and the requested operation is logged for auditing. The system
 * validates all inputs including recipient targeting, template references, and
 * job type. Attempts to schedule duplicate or unsupported jobs are rejected
 * with clear errors.
 *
 * This endpoint directly corresponds to the shopping_mall_notification_jobs
 * entity; on job creation, all fields such as job_type, job_status,
 * target_json, config_json, and result_json are created or initialized. Admins
 * can inspect outcomes by using the single-job query or job list endpoints.
 *
 * If scheduling options are invalid (e.g., in the past, malformed JSON),
 * appropriate validation errors are returned and creation is aborted. Job
 * creation also adds to the admin action log for traceability.
 *
 * @param props.connection
 * @param props.body Data required to create a new notification job including
 *   job type, recipient targeting, config options, template, schedule, and
 *   execution parameters.
 * @path /shoppingMall/admin/notificationJobs
 * @accessor api.functional.shoppingMall.admin.notificationJobs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data required to create a new notification job including job type,
     * recipient targeting, config options, template, schedule, and
     * execution parameters.
     */
    body: IShoppingMallNotificationJob.ICreate;
  };
  export type Body = IShoppingMallNotificationJob.ICreate;
  export type Response = IShoppingMallNotificationJob;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/notificationJobs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/notificationJobs";
  export const random = (): IShoppingMallNotificationJob =>
    typia.random<IShoppingMallNotificationJob>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
