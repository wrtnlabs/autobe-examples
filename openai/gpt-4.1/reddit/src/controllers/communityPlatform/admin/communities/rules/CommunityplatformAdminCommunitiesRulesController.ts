import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPlatformAdminCommunitiesCommunityIdRules } from "../../../../../providers/postCommunityPlatformAdminCommunitiesCommunityIdRules";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { putCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId } from "../../../../../providers/putCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId";
import { deleteCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId } from "../../../../../providers/deleteCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId";

import { ICommunityPlatformCommunityRule } from "../../../../../api/structures/ICommunityPlatformCommunityRule";

@Controller("/communityPlatform/admin/communities/:communityId/rules")
export class CommunityplatformAdminCommunitiesRulesController {
  /**
   * Create a new community-specific rules document for a given community
   * (community_platform_community_rules).
   *
   * Create a new set of rules for a specific community by providing rule body
   * content and required metadata.
   *
   * This operation uses the community_platform_community_rules table in the
   * database, which contains fields for body (the full Markdown rule text),
   * version (integer, incremented on edits, used for audit/version control),
   * community_id (the community to which rules apply), and timestamps for
   * published, created, and updated dates.
   *
   * Security: Only authenticated users with moderator or admin privileges for
   * the specified community are permitted to create new rules. The request must
   * reference a community (by UUID), and checks should confirm the actor's
   * authorization. If an unauthorized or unauthenticated user calls this
   * endpoint, an error is returned.
   *
   * Business logic: Validation enforces length and formatting for the rule
   * body, ensures no duplicate version number for the same community, and sets
   * published and created timestamps. On creation, the rules are active for the
   * given community until replaced by a higher version. Error handling covers
   * invalid community references, overly long rule text, redundant version, or
   * permission errors.
   *
   * Related Operations: For updating existing rules, use the update operation
   * on /communities/{communityId}/rules/{ruleId} with PUT. For retrieving
   * rules, use GET endpoints not included here.
   *
   * Edge Cases: If moderation rules change rapidly or concurrent edits occur,
   * the system may require last-write-wins or version increment logic.
   * Timestamps are auto-assigned by the backend.
   *
   * @param connection
   * @param communityId Unique identifier of the target community for which the
   *   rules are being created.
   * @param body New community rules content, version, and publication metadata.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityRule.ICreate,
  ): Promise<ICommunityPlatformCommunityRule> {
    try {
      return await postCommunityPlatformAdminCommunitiesCommunityIdRules({
        admin,
        communityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing community rules document by community and rule ID
   * (community_platform_community_rules).
   *
   * Update an existing rules document for a given community. This operation
   * requires both the community UUID (communityId) and the unique identifier of
   * the rule document (ruleId).
   *
   * The operation operates on the community_platform_community_rules table,
   * which tracks community_id, body (Markdown), version, published_at,
   * created_at, and updated_at. The system validates that only authorized
   * moderators or administrators for the target community may update its rules.
   * Versioning logic must ensure that edits are tracked and that the version
   * field strictly increases with each update for auditability. Edits are
   * reflected in the updated_at timestamp, while the published_at timestamp may
   * also be updated if the rule is officially republished.
   *
   * Authorization is strictly enforced at the endpoint: only assigned
   * moderators or platform admins may update rules for a given community.
   * Validation checks for version increment, Markdown length/format, and
   * association with the correct community. Errors include permission denied,
   * invalid or non-existent rule/community identifiers, conflicting version
   * numbers, or text exceeding 50,000 characters.
   *
   * Related Operations: To create new rules, use the POST
   * /communities/{communityId}/rules endpoint. For removal, only permitted via
   * archival or soft delete as determined by business needs (not covered
   * here).
   *
   * Concurrency: The system must ensure that updates do not allow version
   * regression or data loss due to simultaneous edits; the last-write or
   * explicit version check strategy should be considered.
   *
   * @param connection
   * @param communityId Unique identifier of the target community for which the
   *   rules are to be updated.
   * @param ruleId Unique identifier of the rule document being updated.
   * @param body Editable fields for rules document update, including body,
   *   version, and publication details.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":ruleId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("ruleId")
    ruleId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityRule.IUpdate,
  ): Promise<ICommunityPlatformCommunityRule> {
    try {
      return await putCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId({
        admin,
        communityId,
        ruleId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a specific rule from a community
   * (community_platform_community_rules table).
   *
   * This API endpoint serves to delete a specific community rule from the
   * platform, referencing the community_platform_community_rules table in the
   * Prisma schema. Each rule pertains to a particular community and version,
   * providing customized governance for posting, commenting, and moderation.
   *
   * To execute this operation, the client must supply both the parent
   * community's unique identifier (communityId) and the rule's unique
   * identifier (ruleId) as path parameters. Both identifiers are UUIDs. Only
   * users with appropriate moderator or admin privileges for the target
   * community may call this endpoint; unauthorized attempts should be blocked
   * with a clear error response.
   *
   * Upon successful invocation, the rule is permanently removed from the
   * database. There are no soft delete fields on the schema, so this is a hard
   * delete operation. Once deletion is performed, the rule cannot be recovered.
   * All deletion actions should be recorded in the audit log for regulatory and
   * governance transparency. This operation is typically used during
   * moderation, restructuring, or when a community's policy has become
   * obsolete.
   *
   * Related operations include the creation and updating of rules, as well as
   * retrieval of existing rules. In combination, these enable full lifecycle
   * management of community governance policies.
   *
   * @param connection
   * @param communityId The unique identifier of the target community which the
   *   rule belongs to.
   * @param ruleId The unique identifier of the rule to permanently delete from
   *   the community.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":ruleId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("ruleId")
    ruleId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPlatformAdminCommunitiesCommunityIdRulesRuleId(
        {
          admin,
          communityId,
          ruleId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
