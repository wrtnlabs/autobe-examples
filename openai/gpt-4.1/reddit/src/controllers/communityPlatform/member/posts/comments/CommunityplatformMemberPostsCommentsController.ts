import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPlatformMemberPostsPostIdComments } from "../../../../../providers/postCommunityPlatformMemberPostsPostIdComments";
import { MemberAuth } from "../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../decorators/payload/MemberPayload";
import { putCommunityPlatformMemberPostsPostIdCommentsCommentId } from "../../../../../providers/putCommunityPlatformMemberPostsPostIdCommentsCommentId";
import { deleteCommunityPlatformMemberPostsPostIdCommentsCommentId } from "../../../../../providers/deleteCommunityPlatformMemberPostsPostIdCommentsCommentId";

import { ICommunityPlatformComment } from "../../../../../api/structures/ICommunityPlatformComment";

@Controller("/communityPlatform/member/posts/:postId/comments")
export class CommunityplatformMemberPostsCommentsController {
  /**
   * Create a new comment on a specific post (community_platform_comments).
   *
   * This endpoint enables authenticated and verified members to submit a new
   * comment on a post. It references the community_platform_comments Prisma
   * model, capturing details such as the comment body, author (member), post
   * association, optional parent comment for replies, nesting level, and
   * moderation/publication status.
   *
   * Input validation occurs to enforce maximum comment length, non-empty
   * bodies, reply depth restrictions, and content rules (including banned
   * words, formatting, and moderation policies) as described in the Prisma
   * schema and business requirements. Additionally, posting frequency and
   * member/community ban state are checked. Attempting to comment beyond
   * allowed nesting levels or while under restriction yields an appropriate
   * error.
   *
   * When invoked, the system will link the comment to its parent post (and
   * optionally to another comment for threading), ensure it is properly nested,
   * set moderation and status flags (e.g., published, mod_queued), and record
   * creation timestamps. The response will return the complete comment object
   * as recorded in the database, ready for rendering or client confirmation.
   *
   * Frontend clients should display any server-supplied error messages
   * indicating validation, permission, or moderation issues. Related endpoints
   * provide update, delete, and retrieval actions for comments and their
   * threads.
   *
   * @param connection
   * @param postId Unique identifier (UUID) of the post to which the comment
   *   will be attached.
   * @param body Information required to create a new comment as a reply to a
   *   post or to an existing comment.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformComment.ICreate,
  ): Promise<ICommunityPlatformComment> {
    try {
      return await postCommunityPlatformMemberPostsPostIdComments({
        member,
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing comment in a post (community_platform_comments).
   *
   * This endpoint allows a verified member (original author) or an authorized
   * moderator/admin to update a comment attached to a specific post. It acts on
   * the community_platform_comments Prisma model, supporting comment text
   * edits, moderation status changes, and historical edit tracking via related
   * tables.
   *
   * Business logic enforces required validation: edited bodies must be within
   * allowed length, pass forbidden/banned word filters, and not exceed
   * permitted depth. If outside the author-editing time window, only
   * moderators/admins may edit the comment, and all edits are logged for audit
   * purposes (see comment edit history model). Unauthorized edit attempts are
   * rejected with a clear error.
   *
   * The request path requires both the unique postId and the target commentId.
   * The request body contains the updated text content. Response returns the
   * modified comment with all relevant status and metadata, such as timestamps,
   * author, and moderation state. Associated endpoints are available for
   * deleting or retrieving threaded comments in the same context.
   *
   * @param connection
   * @param postId Unique identifier (UUID) of the post containing the comment
   *   to update.
   * @param commentId Unique identifier (UUID) of the comment to be updated.
   * @param body Updated comment body and applicable fields for comment edit (as
   *   allowed by business rules and permission model).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":commentId")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformComment.IUpdate,
  ): Promise<ICommunityPlatformComment> {
    try {
      return await putCommunityPlatformMemberPostsPostIdCommentsCommentId({
        member,
        postId,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently remove (soft delete) a comment from a post, restricted to
   * author, moderators, or admins as per permissions
   * (community_platform_comments).
   *
   * This DELETE operation enables end-users (authors), community moderators, or
   * admins to delete individual comments within a post. According to the Prisma
   * schema, each comment is identified by 'id' and may be nested (using
   * parent_id). Comments include a soft delete field, allowing the comment to
   * be marked as deleted rather than physically removed, supporting both user
   * privacy and retention/audit requirements.
   *
   * Authorization checks ensure that only the author, a community moderator (as
   * identified via moderator assignments), or a platform admin may perform the
   * deletion. The API must verify the acting user's role and permissions before
   * marking the comment as deleted. Soft deletion is performed by setting the
   * 'deleted_at' timestamp, hiding the comment from normal views, and
   * optionally displaying a placeholder if policy requires.
   *
   * If the deleted comment is a parent in a threaded discussion, application
   * logic must determine whether to recursively mark all child comments as
   * deleted or to orphan/reparent them at the nearest allowed level, according
   * to platform business logic. This action triggers audit logging, as required
   * for traceability and policy compliance. Deletion cascades to associated
   * votes and reports per business rules.
   *
   * Error conditions include attempts by unauthorized users, conflicts with
   * moderation policies (e.g., trying to delete an already-removed comment),
   * and deletion of non-existent comments. Related safeguards ensure proper
   * notification and fallback.
   *
   * Related operations include comment creation (POST), editing (PUT), and
   * moderation workflows for comment enforcement.
   *
   * @param connection
   * @param postId Unique identifier of the parent post containing the comment
   *   targeted for deletion.
   * @param commentId Unique identifier of the comment to be deleted within the
   *   post.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":commentId")
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPlatformMemberPostsPostIdCommentsCommentId({
        member,
        postId,
        commentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
