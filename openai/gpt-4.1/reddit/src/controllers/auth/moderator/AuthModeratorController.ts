import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthModeratorJoin } from "../../../providers/postAuthModeratorJoin";
import { postAuthModeratorLogin } from "../../../providers/postAuthModeratorLogin";
import { postAuthModeratorRefresh } from "../../../providers/postAuthModeratorRefresh";

import { ICommunityPlatformModerator } from "../../../api/structures/ICommunityPlatformModerator";

@Controller("/auth/moderator")
export class AuthModeratorController {
  /**
   * Register a new moderator (community_platform_moderators) account and issue
   * authorization tokens.
   *
   * This API operation enables the creation and registration of a new moderator
   * account on the platform, as defined by the 'community_platform_moderators'
   * table. It requires a unique email address—which is also verified at the
   * member layer—and a secure password. Community assignment and linkage to the
   * corresponding 'community_platform_members' record are enforced, validating
   * that the registering user qualifies as a member before they can become a
   * moderator. Upon successful creation, the moderator receives an initial
   * authorization token that allows them to access moderator-specific
   * functions, but only within their assigned communities.
   *
   * Implementation enforces email uniqueness, ensures linkage to both the
   * member and target community, and creates audit timestamps for registration
   * and any updates. The 'password_hash' is generated server-side from the
   * provided password using a secure hashing algorithm (e.g., bcrypt). The
   * operation enforces business rules confirming the user was previously
   * verified as a member.
   *
   * By restricting the operation to the moderator table and required
   * relationships, the API integrates seamlessly into the platform's role and
   * permissions structure. After registration, moderators are granted
   * heightened credentials and authorization to perform moderation actions
   * within their respective communities.
   *
   * Security is ensured by validating prior member status, unique email
   * assignment, and by securely handling password storage as specified in the
   * schema. All sensitive operations—such as creation and update—are logged for
   * audit purposes. Workflow ensures that no moderator account can be
   * provisioned without first passing membership requirements, preventing
   * unauthorized privilege escalation.
   *
   * Related operations include member registration, email verification, and
   * login. Upon successful registration, follow-up authentication and
   * privileged session management are expected to be performed according to the
   * platform's authorization flows.
   *
   * @param connection
   * @param body Moderator registration information (email, password, community
   *   assignment).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformModerator.IJoin,
  ): Promise<ICommunityPlatformModerator.IAuthorized> {
    try {
      return await postAuthModeratorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an existing moderator account and issue new JWT tokens.
   *
   * This operation enables a moderator to authenticate using their email and
   * password, as referenced by the 'community_platform_moderators' table.
   * Success requires the moderator's status to be 'active' and linked to a
   * valid, verified member account. The supplied password is checked against
   * the stored server-side 'password_hash'. On valid authentication, the API
   * issues JWT access and refresh tokens, including role and permission scopes
   * specific to the moderator's assigned communities.
   *
   * The system checks for suspension, resignations, or deletions using the
   * 'status' and 'deleted_at' fields before allowing login or session creation,
   * denying access if any restrict the account. Accurate audit logs are
   * mandatory for all login attempts, successful or failed, to ensure
   * traceability and security compliance.
   *
   * Session management integrates with platform-wide authorization enforcement.
   * On login, the API returns a structured authentication DTO including current
   * moderator identity, session information, and role scope, as specified by
   * the authentication operation pattern.
   *
   * Security measures include rate limiting, secure comparison of stored and
   * entered passwords, and plain-language error reporting that avoids leaking
   * sensitive account states (e.g., distinguishing between non-existent email
   * and wrong password is not allowed in responses).
   *
   * Related flows: registration (join), token refresh, and logout. The login
   * outcome is prerequisite for any subsequent privileged moderator operations
   * within the platform.
   *
   * @param connection
   * @param body Moderator login information (email and password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformModerator.ILogin,
  ): Promise<ICommunityPlatformModerator.IAuthorized> {
    try {
      return await postAuthModeratorLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh a moderator's JWT tokens using a valid refresh token
   * (community_platform_moderators).
   *
   * This API operation issues a fresh pair of JWT tokens for a moderator user,
   * provided that a valid, unexpired refresh token is supplied. The
   * 'community_platform_moderators' schema stores all credentials and status
   * flags necessary to determine the account's validity. The operation confirms
   * both the integrity of the refresh token and that the account has not been
   * suspended or deleted ('status', 'deleted_at'), preventing any privilege
   * escalation or reactivation of removed users.
   *
   * Tokens are generated based on the platform's security policy, such as
   * including moderator's unique ID, assigned community scope, the role
   * 'moderator', and explicit permissions in the JWT payload. This promotes
   * precise session scoping and execution of moderator-only platform
   * operations.
   *
   * Security practices require all refresh attempts to be logged for auditing.
   * The endpoint must handle errors gracefully, never revealing whether
   * failures are due to an invalid token or an account restriction (to avoid
   * information leakage about moderator existence or status).
   *
   * After successful refresh, the returned DTO provides updated session and
   * authorization details. This operation is related to the moderator's initial
   * login, logout, and any privileged moderator workflow.
   *
   * @param connection
   * @param body Moderator refresh token submission for obtaining new JWT
   *   tokens.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformModerator.IRefresh,
  ): Promise<ICommunityPlatformModerator.IAuthorized> {
    try {
      return await postAuthModeratorRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
