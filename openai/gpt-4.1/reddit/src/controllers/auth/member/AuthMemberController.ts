import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthMemberJoin } from "../../../providers/postAuthMemberJoin";
import { postAuthMemberLogin } from "../../../providers/postAuthMemberLogin";
import { postAuthMemberRefresh } from "../../../providers/postAuthMemberRefresh";

import { ICommunityPlatformMember } from "../../../api/structures/ICommunityPlatformMember";

@Controller("/auth/member")
export class AuthMemberController {
  /**
   * Register a new platform member (community_platform_members table).
   *
   * This endpoint enables an unauthenticated user to register a new member
   * account in the Reddit-like community platform. The
   * 'community_platform_members' table is referenced, which has key fields:
   * 'email' (must be unique and valid for identification and contact),
   * 'password_hash' (only password hashes are stored for security),
   * 'email_verified' (initially set to false), and 'status' (such as 'active'
   * after verification).
   *
   * Upon receiving registration details, the platform will validate the email's
   * uniqueness—enforcing a one-user-per-email policy at the DB level to block
   * duplicates—and will require a password meeting policy. Passwords are hashed
   * (per the 'password_hash' field; plaintext passwords are never stored or
   * returned). The user's 'email_verified' is false after registration,
   * preventing all member-only actions until a separate verification operation
   * completes.
   *
   * Post-registration, a verification email workflow is triggered, and the
   * created member receives a verification link. Until verified, feature access
   * is restricted in accordance with the 'email_verified' boolean field and
   * business requirement. The 'status' field in the schema allows for
   * additional workflow enforcement if 'blocked' or 'pending' during specific
   * business cases.
   *
   * This registration ('join') endpoint is a prerequisite for all subsequent
   * authentication flows (login, refresh, etc.) and is referenced by business
   * policies for onboarding and security enforcement.
   *
   * Related security endpoints include login, refresh, email verification, and
   * password management, each using the base member schema for logic
   * enforcement.
   *
   * @param connection
   * @param body Payload for member registration (requires unique email and
   *   password hash)
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformMember.ICreate,
  ): Promise<ICommunityPlatformMember.IAuthorized> {
    try {
      return await postAuthMemberJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an existing platform member and issue authorization tokens
   * (community_platform_members table).
   *
   * This operation enables an existing platform member to log in by submitting
   * their registered email and password. The 'community_platform_members' table
   * schema is used, relying on these key fields: 'email' (to lookup user),
   * 'password_hash' (to securely verify the supplied password against the
   * hash), 'email_verified' (must be true for login), and 'status' (must be
   * 'active' for session establishment).
   *
   * Upon receiving credentials, the operation validates the email exists,
   * compares the provided password (after hashing) with the stored
   * 'password_hash', and checks the member's status and verification flag. If
   * all checks pass, the operation issues a JWT access token for immediate
   * platform activity and a refresh token (issued as per business session
   * rules) so clients can maintain authenticated state across sessions.
   *
   * If credentials do not match, the account is unverified, or 'status' is not
   * 'active', the login fails with appropriate error handling as per business
   * policy (including rate limiting on repeated failures, reference 'status'
   * field for blocks/suspensions). All tokens are generated using platform best
   * practices. Related authentication operations include registration ('join'),
   * token refresh, email verification, logout, and password recovery, all using
   * the 'community_platform_members' schema for logic enforcement.
   *
   * @param connection
   * @param body Payload for member login (email and password required)
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformMember.ILogin,
  ): Promise<ICommunityPlatformMember.IAuthorized> {
    try {
      return await postAuthMemberLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Renew member authentication tokens using valid refresh token
   * (community_platform_members table).
   *
   * This endpoint enables authenticated platform members to renew their session
   * tokens by presenting a valid refresh token. The operation works within the
   * security boundaries described by the 'community_platform_members' table,
   * referencing the member via session context, ensuring the 'status' field is
   * 'active' and the refresh token is valid, not expired, and not revoked (if
   * revocation logic is implemented outside the schema).
   *
   * If the refresh token is valid and the member's account status is
   * acceptable, the server issues a new JWT access token and a new refresh
   * token, ensuring ongoing authenticated platform interaction without repeated
   * full logins. If the operation detects a revoked/expired refresh token, or
   * if the member is blocked or deleted, it rejects the request and requires
   * manual re-authentication.
   *
   * The refresh endpoint is central for maintaining seamless authenticated user
   * flows, reducing friction from session expiration and increasing security.
   * It is referenced by all client session management logic and expected to
   * comply with session expiry, device tracking, and revocation business
   * rules.
   *
   * All session logic is governed by platform-wide security policy but
   * fundamentally relies on the ongoing existence and status value of the
   * 'community_platform_members' schema for enforcement.
   *
   * @param connection
   * @param body Payload containing the refresh token for session continuation
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformMember.IRefresh,
  ): Promise<ICommunityPlatformMember.IAuthorized> {
    try {
      return await postAuthMemberRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
