import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityModeratorAssignment } from "../../../../../structures/ICommunityPlatformCommunityModeratorAssignment";
import { IPageICommunityPlatformCommunityModeratorAssignment } from "../../../../../structures/IPageICommunityPlatformCommunityModeratorAssignment";

/**
 * Create a new moderator assignment record for a specific community in the
 * community_platform_community_moderator_assignments table.
 *
 * Create a new moderator assignment for a community. The operation requires the
 * caller to be an admin or a current community moderator with sufficient
 * privileges. It references the
 * community_platform_community_moderator_assignments table in the schema, which
 * tracks moderator assignments per community, and includes assignment rationale
 * and auditing information.
 *
 * The request body should provide all necessary assignment details (target
 * community, member to be assigned, role, assigner, start time, and any notes).
 * The system ensures that the member exists, is not already assigned as a
 * moderator with the same role, and is eligible for moderation duties. It
 * checks assignment quotas, avoids duplicates, and ensures compliance with
 * business rules described in requirements analysis (moderator assignment by
 * admins or owner-moderators, per audit/compliance control).
 *
 * Security controls require all assignment actions to be logged. If a community
 * is archived or does not exist, or the actor is not authorized, an appropriate
 * error is returned. The response includes the full assignment entity created,
 * for immediate use (such as interface update or audit view).
 *
 * Related APIs include updating assignments, deleting moderator assignments, or
 * listing all current assignments for a community.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community for which
 *   moderator assignment is being created.
 * @param props.body Moderator assignment creation information including
 *   assigned member, role, assigner ID, and assignment timing.
 * @path /communityPlatform/admin/communities/:communityId/moderatorAssignments
 * @accessor api.functional.communityPlatform.admin.communities.moderatorAssignments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the target community for which moderator
     * assignment is being created.
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Moderator assignment creation information including assigned member,
     * role, assigner ID, and assignment timing.
     */
    body: ICommunityPlatformCommunityModeratorAssignment.ICreate;
  };
  export type Body = ICommunityPlatformCommunityModeratorAssignment.ICreate;
  export type Response = ICommunityPlatformCommunityModeratorAssignment;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/communities/:communityId/moderatorAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderatorAssignments`;
  export const random = (): ICommunityPlatformCommunityModeratorAssignment =>
    typia.random<ICommunityPlatformCommunityModeratorAssignment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List all moderator assignments for a community
 * (community_platform_community_moderator_assignments).
 *
 * Retrieve a filtered and paginated list of all moderator assignments for a
 * specified community. Each assignment indicates a member assigned as
 * moderator, their moderator role, start/end dates, assigner, and notes. This
 * endpoint enables transparency and control for community owners and platform
 * admins to review current and past moderator staff, and to ensure proper
 * governance.
 *
 * Security and permissions: This operation is restricted to authenticated users
 * with sufficient rights within the context of the community, typically
 * community owners, assigned moderators, or admins. Data returned is limited to
 * the specified community.
 *
 * The operation directly references the
 * community_platform_community_moderator_assignments table, incorporating its
 * fields and join relations with the communities and members table. Filtering
 * may include moderator role, assignment status (active, ended), or search by
 * member. Pagination reduces result set size for efficient client handling.
 *
 * Related operations: assignment retrieval by id, creating new assignments,
 * updating existing assignments, or removing assignments. Error handling
 * includes invalid communityId, insufficient permissions, or excessive result
 * size.
 *
 * @param props.connection
 * @param props.communityId Unique identifier for the target community
 * @param props.body Filtering, sorting, and pagination parameters for
 *   retrieving moderator assignments
 * @path /communityPlatform/admin/communities/:communityId/moderatorAssignments
 * @accessor api.functional.communityPlatform.admin.communities.moderatorAssignments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the target community */
    communityId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination parameters for retrieving
     * moderator assignments
     */
    body: ICommunityPlatformCommunityModeratorAssignment.IRequest;
  };
  export type Body = ICommunityPlatformCommunityModeratorAssignment.IRequest;
  export type Response =
    IPageICommunityPlatformCommunityModeratorAssignment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/communities/:communityId/moderatorAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderatorAssignments`;
  export const random =
    (): IPageICommunityPlatformCommunityModeratorAssignment.ISummary =>
      typia.random<IPageICommunityPlatformCommunityModeratorAssignment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a moderator assignment by id
 * (community_platform_community_moderator_assignments).
 *
 * Retrieve detailed information about a specific moderator assignment within a
 * community. This information includes the assigned member, their role,
 * assignment effective dates, who assigned the role, and contextual notes for
 * the assignment or removal.
 *
 * Permissions: This endpoint is accessible to authenticated users with
 * appropriate rights within the community context (owner, moderator, or admin).
 * The system ensures the assignmentId belongs to the specified community
 * (communityId) and enforces access boundaries.
 *
 * The underlying data comes from the
 * community_platform_community_moderator_assignments table, joined as needed to
 * member and community details. Typical use cases are in moderator dashboards,
 * admin review, or audit workflows. Error handling covers missing/invalid ids,
 * mismatched community/assignment, or insufficient permissions.
 *
 * @param props.connection
 * @param props.communityId Unique identifier for the target community
 * @param props.assignmentId Unique identifier for the moderator assignment to
 *   retrieve
 * @path /communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId
 * @accessor api.functional.communityPlatform.admin.communities.moderatorAssignments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target community */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier for the moderator assignment to retrieve */
    assignmentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityModeratorAssignment;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderatorAssignments/${encodeURIComponent(props.assignmentId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityModeratorAssignment =>
    typia.random<ICommunityPlatformCommunityModeratorAssignment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("assignmentId")(() => typia.assert(props.assignmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing moderator assignment record for a community in the
 * community_platform_community_moderator_assignments table.
 *
 * Update an existing moderator assignment for a specific community. The
 * operation requires the assigning actor to be an admin or an authorized
 * owner-moderator of the target community, in accordance with permission logic.
 * This operation references the
 * community_platform_community_moderator_assignments schema table, which stores
 * each assignment's details including assignment role, note, and assignment
 * time periods.
 *
 * The request body must contain all changes to apply, which may include
 * moderator role, start/end dates, and assignment notes or reasons. The
 * operation verifies that the target assignment and community exist, that the
 * actor is permitted to make changes, and that the changes comply with business
 * rules (no orphaning of a community without an owner, limits on moderator
 * assignments, etc.).
 *
 * The update action is logged for audit and traceability. The response returns
 * the updated assignment record. Errors can result from unauthorized actors,
 * invalid IDs, or violating assignment constraints (such as trying to remove
 * the last 'owner' of a community).
 *
 * Related APIs include assignment creation, deletion, and retrieval/listing
 * APIs for moderator assignments.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community for which the
 *   moderator assignment is being updated.
 * @param props.assignmentId Unique identifier of the moderator assignment to be
 *   updated.
 * @param props.body Updated moderator assignment details, including new role,
 *   note, or start/end times, and assigning actor ID.
 * @path /communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId
 * @accessor api.functional.communityPlatform.admin.communities.moderatorAssignments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the community for which the moderator assignment
     * is being updated.
     */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the moderator assignment to be updated. */
    assignmentId: string & tags.Format<"uuid">;

    /**
     * Updated moderator assignment details, including new role, note, or
     * start/end times, and assigning actor ID.
     */
    body: ICommunityPlatformCommunityModeratorAssignment.IUpdate;
  };
  export type Body = ICommunityPlatformCommunityModeratorAssignment.IUpdate;
  export type Response = ICommunityPlatformCommunityModeratorAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderatorAssignments/${encodeURIComponent(props.assignmentId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityModeratorAssignment =>
    typia.random<ICommunityPlatformCommunityModeratorAssignment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("assignmentId")(() => typia.assert(props.assignmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a moderator assignment from a community
 * (community_platform_community_moderator_assignments table).
 *
 * This endpoint is designed to allow administrative-level users to remove an
 * existing moderator assignment and thus revoke moderation privileges from an
 * assigned member within a specific community.
 *
 * Removing a moderator assignment impacts community governance and security, so
 * this operation should be audited and restricted. It references the
 * community_platform_community_moderator_assignments table (which hosts the
 * mapping between communities and assigned moderators) and deletes or marks as
 * ended the specified assignment record. Deletion should ensure that any open
 * moderation tasks or escalation queue items for this moderator are also
 * reassigned or resolved as per business workflows.
 *
 * Permission to perform this action should be limited to platform admins or
 * community owners/founders, and all removals must be logged for compliance and
 * traceability. Attempting to delete a non-existent or already ended assignment
 * should result in an idempotent response or a specific error. This is a hard
 * delete because the deleted_at column is present in the schema.
 *
 * Related operations that might be used together include listing all moderator
 * assignments for a community or assigning a new moderator. Error handling must
 * ensure that trying to remove an assignment that does not exist, or for which
 * the caller lacks permission, will return a clear error.
 *
 * @param props.connection
 * @param props.communityId Target community's unique identifier where the
 *   moderator assignment exists.
 * @param props.assignmentId Unique identifier of the moderator assignment to be
 *   removed.
 * @path /communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId
 * @accessor api.functional.communityPlatform.admin.communities.moderatorAssignments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Target community's unique identifier where the moderator assignment
     * exists.
     */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the moderator assignment to be removed. */
    assignmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/communities/:communityId/moderatorAssignments/:assignmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/moderatorAssignments/${encodeURIComponent(props.assignmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("assignmentId")(() => typia.assert(props.assignmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
