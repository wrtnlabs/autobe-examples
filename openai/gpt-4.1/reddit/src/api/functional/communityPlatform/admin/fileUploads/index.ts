import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformFileUpload } from "../../../../structures/ICommunityPlatformFileUpload";
import { IPageICommunityPlatformFileUpload } from "../../../../structures/IPageICommunityPlatformFileUpload";

/**
 * Search, filter, and paginate file uploads in the platform
 * (community_platform_file_uploads).
 *
 * This operation allows authorized users to search, filter, and retrieve a
 * paginated list of files that have been uploaded to the platform. File upload
 * records may represent images, documents, attachments to posts or comments,
 * banners, or avatars, as recorded in the community_platform_file_uploads
 * table. Filtering can be performed by uploader member, file type (MIME),
 * status (active, deleted, archived), date ranges, or filename.
 *
 * Permissions should restrict non-admin/moderator users from retrieving files
 * they do not own or are not allowed to view. Sensitive metadata, such as
 * storage keys or file URLs, are handled according to platform privacy policy,
 * only surfaced if access is warranted by the user's role (such as moderator or
 * admin). Records reflect the Prisma schema's design, including the use of soft
 * delete via the deleted_at field, which supports both active and archived
 * asset queries. The operation validates complex filter input and handles
 * errors for out-of-bounds page/sort specifications.
 *
 * Administrators can use this endpoint for management review, abuse
 * investigations, or media inventory, while users may access it for reviewing
 * their own uploads or download history. Any soft-deleted files should be
 * explicitly labeled in the result set when returned. Related business logic
 * for audit logging or asset cleanup can reference this operation for evidence
 * gathering and compliance checks.
 *
 * @param props.connection
 * @param props.body Filter, search, sorting, and pagination options for finding
 *   file uploads
 * @path /communityPlatform/admin/fileUploads
 * @accessor api.functional.communityPlatform.admin.fileUploads.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, search, sorting, and pagination options for finding file
     * uploads
     */
    body: ICommunityPlatformFileUpload.IRequest;
  };
  export type Body = ICommunityPlatformFileUpload.IRequest;
  export type Response = IPageICommunityPlatformFileUpload.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/fileUploads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/fileUploads";
  export const random = (): IPageICommunityPlatformFileUpload.ISummary =>
    typia.random<IPageICommunityPlatformFileUpload.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve metadata for a specific file upload entry
 * (community_platform_file_uploads).
 *
 * This endpoint returns comprehensive metadata describing a single file upload,
 * as stored in the community_platform_file_uploads table. The result includes
 * uploader information, file storage and access details, MIME type, size,
 * status, and life cycle timestamps.
 *
 * Authorization rules require that only the uploading member, a moderator with
 * asset permissions, or an administrator may view all metadata fields or file
 * URLs. Unauthorized users are blocked from accessing sensitive storage
 * information. The result set adheres strictly to the actual database schema
 * fields, never exposing extraneous details, and making soft-deleted
 * (deleted_at != null) status explicit where appropriate.
 *
 * Typical use cases include allowing users to manage or re-download their own
 * uploads, admin/media audits, compliance review, or resolving moderation
 * actions regarding uploaded files. Non-downloadable and deleted files are
 * clearly labeled to preclude user confusion or broken links.
 *
 * @param props.connection
 * @param props.fileUploadId Unique identifier of the file upload record to
 *   retrieve
 * @path /communityPlatform/admin/fileUploads/:fileUploadId
 * @accessor api.functional.communityPlatform.admin.fileUploads.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the file upload record to retrieve */
    fileUploadId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformFileUpload;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/fileUploads/:fileUploadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/fileUploads/${encodeURIComponent(props.fileUploadId ?? "null")}`;
  export const random = (): ICommunityPlatformFileUpload =>
    typia.random<ICommunityPlatformFileUpload>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("fileUploadId")(() => typia.assert(props.fileUploadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata or logical status of an existing file upload in
 * community_platform_file_uploads.
 *
 * Authenticated members, moderators, or admins use this endpoint to update
 * non-binary metadata for a previously uploaded file. Allowed updates may
 * include renaming the file, updating the status ('active', 'deleted',
 * 'archived'), or changing the associated public URL when the file is moved in
 * storage. The file upload record is uniquely identified by fileUploadId
 * (UUID).
 *
 * This operation enforces strict permission checks: a member may only update
 * their own uploads; moderators and admins may update any file within their
 * scope. Attempting to update the status to 'deleted' marks the file as
 * soft-deleted and prevents further display/association but does not physically
 * remove stored content (to preserve integrity and audit). Updated file uploads
 * retain all prior relationships to posts, comments, communities, or profiles
 * unless deleted.
 *
 * Security requirements and audit protocols are enforced at every update,
 * ensuring the action is logged with member or role details. Related APIs
 * include endpoints for deleting file associations from posts or communities
 * and for retrieving file metadata by id.
 *
 * @param props.connection
 * @param props.fileUploadId Unique identifier of the file upload to update.
 * @param props.body Fields to update within the file upload metadata such as
 *   filename, status, or URL. Only non-binary changes allowed; actual
 *   storage/move/removal is out-of-band.
 * @path /communityPlatform/admin/fileUploads/:fileUploadId
 * @accessor api.functional.communityPlatform.admin.fileUploads.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the file upload to update. */
    fileUploadId: string & tags.Format<"uuid">;

    /**
     * Fields to update within the file upload metadata such as filename,
     * status, or URL. Only non-binary changes allowed; actual
     * storage/move/removal is out-of-band.
     */
    body: ICommunityPlatformFileUpload.IUpdate;
  };
  export type Body = ICommunityPlatformFileUpload.IUpdate;
  export type Response = ICommunityPlatformFileUpload;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/fileUploads/:fileUploadId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/fileUploads/${encodeURIComponent(props.fileUploadId ?? "null")}`;
  export const random = (): ICommunityPlatformFileUpload =>
    typia.random<ICommunityPlatformFileUpload>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("fileUploadId")(() => typia.assert(props.fileUploadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently erase a file upload record from the platform database
 * (community_platform_file_uploads).
 *
 * The purpose of this operation is to delete a file upload entry from the
 * community_platform_file_uploads table, which tracks all files users have
 * uploaded to the platform (e.g., profile pictures, post images, community
 * banners/icons). The operation takes a fileUploadId as a path parameter and
 * will remove the associated row. This includes enforcing referential
 * integrity, meaning files used in banners, post images, or community images
 * are also removed if they lose their reference, according to onDelete:
 * Cascade.
 *
 * File records contain metadata for file location (storage_key, url), ownership
 * (uploaded_by_member_id), MIME type, and status (active, deleted). The field
 * 'deleted_at' is updated to the current timestamp when a soft deletion occurs;
 * for hard delete, the row is removed entirely. Deleting an upload is a
 * privileged action: only a moderator or admin may erase a file. The operation
 * ensures audit logging and may trigger further cleanups in related image or
 * post tables.
 *
 * Related operations include uploading a new file (POST), restoring (undelete)
 * a soft-deleted file, and listing files for a user or community. Validation
 * includes ensuring the fileUploadId exists, the user has correct role and
 * ownership or admin rights, and that the file is not currently required for
 * non-deletable key entities. Errors include attempting to delete files still
 * referenced as essential in the schema (e.g., a current banner image), lack of
 * permission, or not found (404).
 *
 * @param props.connection
 * @param props.fileUploadId Unique identifier for the file upload record to be
 *   deleted, must be UUID format.
 * @path /communityPlatform/admin/fileUploads/:fileUploadId
 * @accessor api.functional.communityPlatform.admin.fileUploads.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the file upload record to be deleted, must be
     * UUID format.
     */
    fileUploadId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/fileUploads/:fileUploadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/fileUploads/${encodeURIComponent(props.fileUploadId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("fileUploadId")(() => typia.assert(props.fileUploadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
