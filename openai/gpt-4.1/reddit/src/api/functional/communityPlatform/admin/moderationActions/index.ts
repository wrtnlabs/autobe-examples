import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformModerationAction } from "../../../../structures/ICommunityPlatformModerationAction";
import { IPageICommunityPlatformModerationAction } from "../../../../structures/IPageICommunityPlatformModerationAction";

/**
 * Create a new moderation action record
 * (community_platform_moderation_actions).
 *
 * This API operation enables authorized moderators or platform administrators
 * to document actions taken in response to moderation needs, such as the
 * removal of posts or comments, issuing warnings or bans, or performing
 * escalations. Each moderation action includes metadata specifying the actor's
 * identity, the nature of the moderation action, links to the affected content,
 * and a reference to the related report if one exists.
 *
 * Security for this operation is critical, as only users with moderator or
 * admin privileges are permitted to perform moderation actions. Access control
 * must tightly restrict use, with every successful action recorded for
 * compliance and later review. Sensitive audit trails are maintained, and
 * inputs are validated to ensure the legitimacy and appropriateness of each
 * moderation action.
 *
 * This operation is fundamental to the moderation process, supporting the
 * enforcement of platform and community standards, user safety, and content
 * policy. Error scenarios include invalid permissions, references to
 * nonexistent reports or content, or improperly formatted action types, all of
 * which result in clear validation errors.
 *
 * @param props.connection
 * @param props.body Details of the moderation action to record, including
 *   actor, target post or comment, action type, and associated report if any.
 * @path /communityPlatform/admin/moderationActions
 * @accessor api.functional.communityPlatform.admin.moderationActions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Details of the moderation action to record, including actor, target
     * post or comment, action type, and associated report if any.
     */
    body: ICommunityPlatformModerationAction.ICreate;
  };
  export type Body = ICommunityPlatformModerationAction.ICreate;
  export type Response = ICommunityPlatformModerationAction;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/moderationActions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/moderationActions";
  export const random = (): ICommunityPlatformModerationAction =>
    typia.random<ICommunityPlatformModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of moderation actions from the moderation
 * log table.
 *
 * Fetch a filtered and paginated list of moderation actions performed by
 * moderators and admins as recorded in the
 * community_platform_moderation_actions table. Each action record includes
 * references to the actor (moderator or admin), action type, targeted post or
 * comment, related report (if any), a description, and the creation timestamp,
 * supporting a comprehensive moderation audit process.
 *
 * This operation is restricted to admin and moderator roles due to the
 * potentially sensitive nature of moderation actions and audit data. By
 * default, it supports advanced filtering for action_type, actor_id,
 * target_post_id, target_comment_id, report_id, date ranges, and description
 * keywords, in order to allow for effective incident review, analytics, and
 * compliance checks.
 *
 * Pagination and sorting options follow platform standards and are required for
 * large datasets. Sensitive information, such as moderator notes or private
 * user references within descriptions, is filtered or redacted according to the
 * authorization role of the requester.
 *
 * Related operations include fetching detail for a single moderation action,
 * exporting logs (admin only), and reviewing associated reports or escalations.
 * Errors are returned for insufficient permissions, invalid filters, or
 * excessive pagination requests.
 *
 * Field references, query capabilities, and privacy enforcement are strictly
 * matched to the structure and comments of the
 * community_platform_moderation_actions Prisma model.
 *
 * @param props.connection
 * @param props.body Filtering criteria and pagination/sorting parameters for
 *   moderation action search and log review.
 * @path /communityPlatform/admin/moderationActions
 * @accessor api.functional.communityPlatform.admin.moderationActions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering criteria and pagination/sorting parameters for moderation
     * action search and log review.
     */
    body: ICommunityPlatformModerationAction.IRequest;
  };
  export type Body = ICommunityPlatformModerationAction.IRequest;
  export type Response = IPageICommunityPlatformModerationAction.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/moderationActions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/moderationActions";
  export const random = (): IPageICommunityPlatformModerationAction.ISummary =>
    typia.random<IPageICommunityPlatformModerationAction.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full detail for a specific moderation action by its unique identifier.
 *
 * Retrieve complete detail for a single moderation action event from the
 * moderation log as stored in the community_platform_moderation_actions table.
 * This API allows admins or moderators to audit, review, or debug specific
 * moderation interventions, including actor identity, moderation action type,
 * affected post or comment (with IDs), any linked report, descriptive notes,
 * and the creation timestamp.
 *
 * Access to this endpoint is limited to admin and moderator roles, as the data
 * may contain sensitive references or information about moderation rationale,
 * actions on specific users, or report content. The returned detail is subject
 * to privacy controls and may redact or mask fields for non-superuser
 * moderators as per company privacy and security standards.
 *
 * Expected usage includes post-incident reviews, handling appeals, compliance
 * checks, and system audits. Related API operations include listing all
 * moderation actions with advanced filtering, exporting audit logs, and
 * reviewing escalation chains. Error responses are provided for unauthorized
 * access or if the specified action ID does not exist.
 *
 * All returned fields, error handling, and traceability requirements strictly
 * match the structure and documentation of the
 * community_platform_moderation_actions Prisma schema.
 *
 * @param props.connection
 * @param props.moderationActionId Unique identifier (UUID) of the moderation
 *   action log entry to retrieve, as stored in the
 *   community_platform_moderation_actions table.
 * @path /communityPlatform/admin/moderationActions/:moderationActionId
 * @accessor api.functional.communityPlatform.admin.moderationActions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) of the moderation action log entry to
     * retrieve, as stored in the community_platform_moderation_actions
     * table.
     */
    moderationActionId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformModerationAction;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/moderationActions/:moderationActionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): ICommunityPlatformModerationAction =>
    typia.random<ICommunityPlatformModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing moderation action record
 * (community_platform_moderation_actions).
 *
 * This operation supports moderation workflows where additional details or
 * outcome updates need to be recorded for previously performed moderation
 * actions. Only authorized moderators or admins can invoke this operation.
 * Modifications may include updating the description, clarifying reasons, or
 * amending metadata, but should never overwrite the nature or subject of the
 * original intervention.
 *
 * For integrity, all updates are timestamped and associated with the updating
 * actor. Security checks ensure that only the appropriate roles may modify
 * records, and all changes are logged for subsequent compliance review.
 * Business logic enforces that only allowed fields are updatable after a
 * moderation action is logged, and changes are subject to validation against
 * platform policy.
 *
 * This endpoint is commonly paired with the moderation action creation endpoint
 * and supports full moderation lifecycles, including documentation of appeals,
 * clarifications, or policy-driven record amendments. Potential errors include
 * reference to nonexistent actions, unauthorized modification attempts, or
 * updates attempting to override protected fields.
 *
 * @param props.connection
 * @param props.moderationActionId Unique identifier of the moderation action to
 *   update.
 * @param props.body Updated details for the moderation action, allowing changes
 *   to description or metadata, respecting audit and policy constraints.
 * @path /communityPlatform/admin/moderationActions/:moderationActionId
 * @accessor api.functional.communityPlatform.admin.moderationActions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the moderation action to update. */
    moderationActionId: string & tags.Format<"uuid">;

    /**
     * Updated details for the moderation action, allowing changes to
     * description or metadata, respecting audit and policy constraints.
     */
    body: ICommunityPlatformModerationAction.IUpdate;
  };
  export type Body = ICommunityPlatformModerationAction.IUpdate;
  export type Response = ICommunityPlatformModerationAction;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/moderationActions/:moderationActionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): ICommunityPlatformModerationAction =>
    typia.random<ICommunityPlatformModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a moderation action (admin only) from the
 * moderation_actions table.
 *
 * This endpoint is responsible for permanently deleting a specified moderation
 * action from the 'community_platform_moderation_actions' table. Moderation
 * actions record essential audit data each time a moderator or admin takes
 * action (such as removing a post or comment, warning a user, or escalating
 * content) on the platform. By deleting the record, all information about the
 * action—such as who performed it, the target content, the associated reason,
 * and timestamps—is erased from the system.
 *
 * Due to the sensitive nature of this operation and its impact on the integrity
 * of platform audit trails, it must only be accessible by administrators.
 * Appropriate permission checks are required to ensure that only users with the
 * 'admin' role can invoke this operation. As there is no soft-delete field
 * present in the schema, the action constitutes a full hard delete.
 * Administrators should exercise caution, as all details of the moderation
 * action, including its relationship to moderation, reporting, or escalation
 * workflows, will be lost.
 *
 * Error scenarios include attempting to delete a moderation action that does
 * not exist or one already removed, in which case the system should return an
 * appropriate error message indicating the absence of the record. All delete
 * attempts must be logged for compliance purposes, including unsuccessful
 * ones.
 *
 * @param props.connection
 * @param props.moderationActionId Unique identifier of the moderation action to
 *   be deleted.
 * @path /communityPlatform/admin/moderationActions/:moderationActionId
 * @accessor api.functional.communityPlatform.admin.moderationActions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the moderation action to be deleted. */
    moderationActionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/moderationActions/:moderationActionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
